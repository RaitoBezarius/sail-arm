theory "Armv9_instrs32" 

imports
  "Armv9_instrs64"

begin 

\<comment> \<open>\<open>val execute_aarch32_instrs_ADC_i_Op_A_txt : integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADC_i_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADC_i_Op_A_txt d imm32 n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__0 imm32(ProcState_C   w__1)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__5 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADC_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADC_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADC_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:68.29-68.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_ADC_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADC_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADC_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADC_i_T1enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADC_i_Op_A_txt d imm32 n setflags)))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADC_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADC_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADC_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:122.54-122.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__2 shifted(ProcState_C   w__3)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADC_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADC_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADC_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:144.29-144.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADC_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADC_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADC_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADC_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADC_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADC_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADC_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADC_r_T2enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADC_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADC_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADC_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADC_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__3 shifted(ProcState_C   w__4)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__7 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__8 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () ))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADC_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADC_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADC_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:253.29-253.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADC_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADD_i_OpA_A_txt : integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADD_i_OpA_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADD_i_OpA_A_txt d imm32 n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__0 imm32 ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:307.29-307.30'') \<then>
     (if ((((((Rn = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''ADR''))
      else return () )) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''ADD (SP plus immediate)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_ADD_i_OpA_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADD_i_OpT_A_txt : integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADD_i_OpT_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__0 imm32 ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_i_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_i_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_i_T1enc_A_txt imm3 Rn Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (imm32 :: 32 bits) = ((zero_extend imm3 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "imm3"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_i_T2enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_i_T2enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_i_T2enc_A_txt Rdn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "Rdn"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_i_T3enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_i_T3enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMN (immediate)''))
      else return () ) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''ADD (SP plus immediate)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if (((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_i_T4enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_i_T4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_i_T4enc_A_txt i Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''ADR''))
      else return () ) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''ADD (SP plus immediate)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags)))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADD_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADD_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:461.54-461.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__2 shifted ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__6 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:483.29-483.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''ADD (SP plus register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_r_T1enc_A_txt Rm Rn Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_r_T2enc_A_txt DN Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((concat_vec DN Rdn  ::  4 Word.word)) = ( 0xD ::  4 Word.word)))) \<or> (((Rm = ( 0xD ::  4 Word.word))))))) then
        throw (Error_See (''ADD (SP plus register)''))
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec DN Rdn  ::  4 Word.word))) in
     (let n = d in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if ((((((n = (( 15 :: int)::ii)))) \<and> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM (and_boolM (return (((d = (( 15 :: int)::ii))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "DN"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_r_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_r_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_r_T3enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     ((if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMN (register)''))
      else return () ) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''ADD (SP plus register)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADD_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADD_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADD_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__3 shifted ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () ))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:634.29-634.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADD_SP_i_Op_A_txt : integer -> mword ty32 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADD_SP_i_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (SP_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__0 imm32 ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_i_A1enc_A_txt cond S Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:687.29-687.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_i_T1enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_i_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_i_T1enc_A_txt Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags)))
   else return () )))\<close> 
  for  "Rd"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_i_T2enc_A_txt : mword ty7 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_i_T2enc_A_txt  :: \<open>(7)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_i_T2enc_A_txt imm7 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = ((( 13 :: int)::ii)) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm7 (( 0 :: int)::ii) (( 7 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags)))
   else return () )))\<close> 
  for  "imm7"  :: "(7)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_i_T3enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_i_T3enc_A_txt i S imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMN (immediate)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if ((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags)))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_i_T4enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_i_T4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_i_T4enc_A_txt i imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags)))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADD_SP_r_Op_A_txt : integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADD_SP_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:801.54-801.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (SP_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__2 shifted ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__6 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_r_A1enc_A_txt cond S Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:823.29-823.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_r_T1enc_A_txt : mword ty1 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_r_T1enc_A_txt DM Rdm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint ((concat_vec DM Rdm  ::  4 Word.word))) in
     (let m = (Word.uint ((concat_vec DM Rdm  ::  4 Word.word))) in
     (let (setflags :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     and_boolM (and_boolM (return (((d = (( 15 :: int)::ii))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t))))))))))))))))
   else return () )))\<close> 
  for  "DM"  :: "(1)Word.word " 
  and  "Rdm"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_r_T2enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_r_T2enc_A_txt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rm = ( 0xD ::  4 Word.word)))) then throw (Error_See (''encoding T1''))
      else return () ) \<then>
     ((let d = ((( 13 :: int)::ii)) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADD_SP_r_T3enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADD_SP_r_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADD_SP_r_T3enc_A_txt S imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMN (register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ADR_Op_A_txt : bool -> integer -> mword ty32 -> M unit\<close>\<close>

definition execute_aarch32_instrs_ADR_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ADR_Op_A_txt add d imm32 = (
   (if add then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((add_vec w__1 imm32  ::  32 Word.word))))))
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (Align w__2 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 imm32  ::  32 Word.word))))))) \<bind> ((\<lambda> (result :: 32 bits) . 
   if (((d = (( 15 :: int)::ii)))) then ALUWritePC result
   else R_set d result)))\<close> 
  for  "add"  :: " bool " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADR_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADR_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADR_A1enc_A_txt cond Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:954.29-954.30'') \<then>
     ((let d = (Word.uint Rd) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let (add :: bool) = True in
     execute_aarch32_instrs_ADR_Op_A_txt add d imm32)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADR_A2enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADR_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADR_A2enc_A_txt cond Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:975.29-975.30'') \<then>
     ((let d = (Word.uint Rd) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let (add :: bool) = False in
     execute_aarch32_instrs_ADR_Op_A_txt add d imm32)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADR_T1enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADR_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADR_T1enc_A_txt Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = True in
     execute_aarch32_instrs_ADR_Op_A_txt add d imm32)))
   else return () )))\<close> 
  for  "Rd"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADR_T2enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADR_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADR_T2enc_A_txt i imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (let (add :: bool) = False in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADR_Op_A_txt add d imm32)))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ADR_T3enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ADR_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ADR_T3enc_A_txt i imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (let (add :: bool) = True in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ADR_Op_A_txt add d imm32)))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_AND_i_Op_A_txt : mword ty1 -> integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_AND_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_AND_i_Op_A_txt carry d imm32 n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__0 imm32  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg PSTATE_ref ( w__2 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_C := carry |))))))))
   else return () )))))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_AND_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AND_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AND_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1086.29-1086.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_AND_i_Op_A_txt carry d imm32 n setflags))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_AND_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AND_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AND_i_T1enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''TST (immediate)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_AND_i_Op_A_txt carry d imm32 n setflags)))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_AND_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_AND_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_AND_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:1147.54-1147.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__3 shifted  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_AND_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AND_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AND_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1171.29-1171.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_AND_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_AND_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AND_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AND_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_AND_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_AND_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AND_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AND_r_T2enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''TST (register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_AND_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_AND_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_AND_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_AND_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__4 shifted  ::  32 Word.word)) in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg PSTATE_ref ( w__6 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg PSTATE_ref ( w__7 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_AND_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AND_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AND_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1283.29-1283.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_AND_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ASR_i_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_ASR_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ASR_i_Op_A_txt d m setflags shift_n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:1317.54-1317.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 SRType_ASR shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg PSTATE_ref ( w__4 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_ASR_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ASR_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ASR_i_T1enc_A_txt imm5 Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     DecodeImmShift ( 0b10 ::  2 Word.word) imm5 \<bind> ((\<lambda> varstup .  (let (_, (tup_10 :: ii)) = varstup in
     (let (shift_n :: ii) = tup_10 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ASR_i_Op_A_txt d m setflags shift_n))))))))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ASR_r_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ASR_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ASR_r_Op_A_txt d m n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 SRType_ASR shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ASR_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ASR_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ASR_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     execute_aarch32_instrs_ASR_r_Op_A_txt d m n setflags))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_B_Op_A_txt : mword ty32 -> M unit\<close>\<close>

definition execute_aarch32_instrs_B_Op_A_txt  :: \<open>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_B_Op_A_txt imm32 = (
   (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   BranchWritePC ((add_vec w__0 imm32  ::  32 Word.word)) BranchType_DIR)))\<close> 
  for  "imm32"  :: "(32)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_B_A1enc_A_txt : mword ty4 -> mword ty24 -> M unit\<close>\<close>

definition decode_aarch32_instrs_B_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_B_A1enc_A_txt cond imm24 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1406.29-1406.30'') \<then>
     ((let (imm32 :: 32 bits) =
       ((sign_extend ((concat_vec imm24 ( 0b00 ::  2 Word.word)  ::  26 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_B_Op_A_txt imm32))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm24"  :: "(24)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_B_T1enc_A_txt : mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_B_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_B_T1enc_A_txt cond imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1424.29-1424.30'') \<then>
     (if (((cond = ( 0xE ::  4 Word.word)))) then throw (Error_See (''UDF''))
      else return () )) \<then>
     (if (((cond = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SVC''))
      else return () )) \<then>
     ((let (imm32 :: 32 bits) =
       ((sign_extend ((concat_vec imm8 ( 0b0 ::  1 Word.word)  ::  9 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_B_Op_A_txt imm32))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_B_T2enc_A_txt : mword ty11 -> M unit\<close>\<close>

definition decode_aarch32_instrs_B_T2enc_A_txt  :: \<open>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_B_T2enc_A_txt imm11 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (imm32 :: 32 bits) =
       ((sign_extend ((concat_vec imm11 ( 0b0 ::  1 Word.word)  ::  12 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_B_Op_A_txt imm32)))
   else return () )))\<close> 
  for  "imm11"  :: "(11)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_B_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty6 -> mword ty1 -> mword ty1 -> mword ty11 -> M unit\<close>\<close>

definition decode_aarch32_instrs_B_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_B_T3enc_A_txt S cond imm6 J1 J2 imm11 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1470.29-1470.30'') \<then>
     (if (((((subrange_vec_dec cond (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     ((let (imm32 :: 32 bits) =
       ((sign_extend
          ((concat_vec
              ((concat_vec
                  ((concat_vec ((concat_vec ((concat_vec S J2  ::  2 Word.word)) J1  ::  3 Word.word)) imm6
                     ::  9 Word.word)) imm11
                 ::  20 Word.word)) ( 0b0 ::  1 Word.word)
             ::  21 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_B_Op_A_txt imm32))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "cond"  :: "(4)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "J1"  :: "(1)Word.word " 
  and  "J2"  :: "(1)Word.word " 
  and  "imm11"  :: "(11)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_B_T4enc_A_txt : mword ty1 -> mword ty10 -> mword ty1 -> mword ty1 -> mword ty11 -> M unit\<close>\<close>

definition decode_aarch32_instrs_B_T4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(10)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_B_T4enc_A_txt S imm10 J1 J2 imm11 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (I1 :: 1 bits) = ((not_vec ((xor_vec J1 S  ::  1 Word.word))  ::  1 Word.word)) in
     (let (I2 :: 1 bits) = ((not_vec ((xor_vec J2 S  ::  1 Word.word))  ::  1 Word.word)) in
     (let (imm32 :: 32 bits) =
       ((sign_extend
          ((concat_vec
              ((concat_vec
                  ((concat_vec ((concat_vec ((concat_vec S I1  ::  2 Word.word)) I2  ::  3 Word.word)) imm10
                     ::  13 Word.word)) imm11
                 ::  24 Word.word)) ( 0b0 ::  1 Word.word)
             ::  25 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_B_Op_A_txt imm32)))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "imm10"  :: "(10)Word.word " 
  and  "J1"  :: "(1)Word.word " 
  and  "J2"  :: "(1)Word.word " 
  and  "imm11"  :: "(11)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BFC_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_BFC_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BFC_Op_A_txt d lsbit msbit = (
   if ((msbit \<ge> lsbit)) then
     (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     R_set d ((set_subrange_zeros (( 32 :: int)::ii) w__0 msbit lsbit  ::  32 Word.word))))
   else throw (Error_Unpredictable () ))\<close> 
  for  "d"  :: " int " 
  and  "lsbit"  :: " int " 
  and  "msbit"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_BFC_A1enc_A_txt : mword ty4 -> mword ty5 -> mword ty4 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BFC_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BFC_A1enc_A_txt cond msb1 Rd lsb1 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1535.29-1535.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let msbit = (Word.uint msb1) in
     (let lsbit = (Word.uint lsb1) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BFC_Op_A_txt d lsbit msbit))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "msb1"  :: "(5)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "lsb1"  :: "(5)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BFC_T1enc_A_txt : mword ty3 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BFC_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BFC_T1enc_A_txt imm3 Rd imm2 msb1 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let msbit = (Word.uint msb1) in
     (let lsbit = (Word.uint ((concat_vec imm3 imm2  ::  5 Word.word))) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BFC_Op_A_txt d lsbit msbit)))
   else return () )))\<close> 
  for  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "msb1"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BFI_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_BFI_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BFI_Op_A_txt d lsbit msbit n = (
   if ((msbit \<ge> lsbit)) then
     (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     R_set d
       ((vector_update_subrange_from_subrange (( 32 :: int)::ii) w__0 msbit lsbit w__1
           ((msbit - lsbit)) (( 0 :: int)::ii)
          ::  32 Word.word))))))
   else throw (Error_Unpredictable () ))\<close> 
  for  "d"  :: " int " 
  and  "lsbit"  :: " int " 
  and  "msbit"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_BFI_A1enc_A_txt : mword ty4 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BFI_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BFI_A1enc_A_txt cond msb1 Rd lsb1 Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1600.29-1600.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''BFC''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let msbit = (Word.uint msb1) in
     (let lsbit = (Word.uint lsb1) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BFI_Op_A_txt d lsbit msbit n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "msb1"  :: "(5)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "lsb1"  :: "(5)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BFI_T1enc_A_txt : mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BFI_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BFI_T1enc_A_txt Rn imm3 Rd imm2 msb1 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''BFC''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let msbit = (Word.uint msb1) in
     (let lsbit = (Word.uint ((concat_vec imm3 imm2  ::  5 Word.word))) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BFI_Op_A_txt d lsbit msbit n)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "msb1"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BIC_i_Op_A_txt : mword ty1 -> integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_BIC_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BIC_i_Op_A_txt carry d imm32 n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__0 ((not_vec imm32  ::  32 Word.word))  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg PSTATE_ref ( w__2 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_C := carry |))))))))
   else return () )))))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_BIC_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BIC_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BIC_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1686.29-1686.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_BIC_i_Op_A_txt carry d imm32 n setflags))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BIC_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BIC_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BIC_i_T1enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let carry = carry in
     execute_aarch32_instrs_BIC_i_Op_A_txt carry d imm32 n setflags)))))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BIC_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_BIC_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BIC_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:1746.54-1746.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__3 ((not_vec shifted  ::  32 Word.word))  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_BIC_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BIC_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BIC_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1770.29-1770.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_BIC_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BIC_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BIC_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BIC_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_BIC_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BIC_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BIC_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BIC_r_T2enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_BIC_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BIC_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_BIC_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BIC_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__4 ((not_vec shifted  ::  32 Word.word))  ::  32 Word.word)) in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg PSTATE_ref ( w__6 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg PSTATE_ref ( w__7 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_BIC_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BIC_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BIC_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1881.29-1881.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BIC_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BKPT_Op_A_txt : mword ty16 -> M unit\<close>\<close>

definition execute_aarch32_instrs_BKPT_Op_A_txt  :: \<open>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BKPT_Op_A_txt imm16 = ( AArch32_SoftwareBreakpoint imm16 )\<close> 
  for  "imm16"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BKPT_A1enc_A_txt : mword ty4 -> mword ty12 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BKPT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BKPT_A1enc_A_txt cond imm12 imm4 = (
   assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1917.25-1917.26'') \<then>
   ((let (imm16 :: 16 bits) = ((concat_vec imm12 imm4  ::  16 Word.word)) in
   (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_BKPT_Op_A_txt imm16)))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BKPT_T1enc_A_txt : mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BKPT_T1enc_A_txt  :: \<open>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BKPT_T1enc_A_txt imm8 = (
   (let (imm16 :: 16 bits) = ((zero_extend imm8 (( 16 :: int)::ii)  ::  16 Word.word)) in
   execute_aarch32_instrs_BKPT_Op_A_txt imm16))\<close> 
  for  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BL_i_Op_A_txt : mword ty32 -> InstrSet -> M unit\<close>\<close>

definition execute_aarch32_instrs_BL_i_Op_A_txt  :: \<open>(32)Word.word \<Rightarrow> InstrSet \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet = (
   CurrentInstrSet ()  \<bind> ((\<lambda> (w__0 :: InstrSet) . 
   ((if (((w__0 = InstrSet_A32))) then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      LR_write ((sub_vec_int w__1 (( 4 :: int)::ii)  ::  32 Word.word))))
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      LR_write
        ((concat_vec ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 1 :: int)::ii)  ::  31 Word.word)) ( 0b1 ::  1 Word.word)
           ::  32 Word.word))))) \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (targetAddress :: 32 bits) . 
   (if (((targetInstrSet = InstrSet_A32))) then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      (Align w__3 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      (let targetAddress = ((add_vec w__4 imm32  ::  32 Word.word)) in
      return targetAddress)))))
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      (let targetAddress = ((add_vec w__5 imm32  ::  32 Word.word)) in
      return targetAddress)))) \<bind> ((\<lambda> (targetAddress ::  32 Word.word) . 
   SelectInstrSet targetInstrSet \<then> BranchWritePC targetAddress BranchType_DIRCALL)))))))\<close> 
  for  "imm32"  :: "(32)Word.word " 
  and  "targetInstrSet"  :: " InstrSet "


\<comment> \<open>\<open>val decode_aarch32_instrs_BL_i_A1enc_A_txt : mword ty4 -> mword ty24 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BL_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BL_i_A1enc_A_txt cond imm24 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:1968.29-1968.30'') \<then>
     ((let (imm32 :: 32 bits) =
       ((sign_extend ((concat_vec imm24 ( 0b00 ::  2 Word.word)  ::  26 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (targetInstrSet :: InstrSet) = InstrSet_A32 in
     execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm24"  :: "(24)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BL_i_A2enc_A_txt : mword ty1 -> mword ty24 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BL_i_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BL_i_A2enc_A_txt H imm24 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (imm32 :: 32 bits) =
       ((sign_extend
          ((concat_vec ((concat_vec imm24 H  ::  25 Word.word)) ( 0b0 ::  1 Word.word)  ::  26 Word.word))
          (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (let (targetInstrSet :: InstrSet) = InstrSet_T32 in
     execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet))
   else return () )))\<close> 
  for  "H"  :: "(1)Word.word " 
  and  "imm24"  :: "(24)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BL_i_T1enc_A_txt : mword ty1 -> mword ty10 -> mword ty1 -> mword ty1 -> mword ty11 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BL_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(10)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BL_i_T1enc_A_txt S imm10 J1 J2 imm11 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (I1 :: 1 bits) = ((not_vec ((xor_vec J1 S  ::  1 Word.word))  ::  1 Word.word)) in
     (let (I2 :: 1 bits) = ((not_vec ((xor_vec J2 S  ::  1 Word.word))  ::  1 Word.word)) in
     (let (imm32 :: 32 bits) =
       ((sign_extend
          ((concat_vec
              ((concat_vec
                  ((concat_vec ((concat_vec ((concat_vec S I1  ::  2 Word.word)) I2  ::  3 Word.word)) imm10
                     ::  13 Word.word)) imm11
                 ::  24 Word.word)) ( 0b0 ::  1 Word.word)
             ::  25 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (let (targetInstrSet :: InstrSet) = InstrSet_T32 in
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "imm10"  :: "(10)Word.word " 
  and  "J1"  :: "(1)Word.word " 
  and  "J2"  :: "(1)Word.word " 
  and  "imm11"  :: "(11)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BL_i_T2enc_A_txt : mword ty1 -> mword ty10 -> mword ty1 -> mword ty1 -> mword ty10 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BL_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(10)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(10)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BL_i_T2enc_A_txt S imm10H J1 J2 imm10L H = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((H = ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (I1 :: 1 bits) = ((not_vec ((xor_vec J1 S  ::  1 Word.word))  ::  1 Word.word)) in
     (let (I2 :: 1 bits) = ((not_vec ((xor_vec J2 S  ::  1 Word.word))  ::  1 Word.word)) in
     (let (imm32 :: 32 bits) =
       ((sign_extend
          ((concat_vec
              ((concat_vec
                  ((concat_vec ((concat_vec ((concat_vec S I1  ::  2 Word.word)) I2  ::  3 Word.word))
                      imm10H
                     ::  13 Word.word)) imm10L
                 ::  23 Word.word)) ( 0b00 ::  2 Word.word)
             ::  25 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (let (targetInstrSet :: InstrSet) = InstrSet_A32 in
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet)))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "imm10H"  :: "(10)Word.word " 
  and  "J1"  :: "(1)Word.word " 
  and  "J2"  :: "(1)Word.word " 
  and  "imm10L"  :: "(10)Word.word " 
  and  "H"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BLX_r_Op_A_txt : integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_BLX_r_Op_A_txt  :: \<open> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BLX_r_Op_A_txt m = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (target :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (next_instr_addr :: 32 bits) . 
   CurrentInstrSet ()  \<bind> ((\<lambda> (w__0 :: InstrSet) . 
   (if (((w__0 = InstrSet_A32))) then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (let (next_instr_addr :: 32 bits) = ((sub_vec_int w__1 (( 4 :: int)::ii)  ::  32 Word.word)) in
      LR_write next_instr_addr)))
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (let (next_instr_addr :: 32 bits) = ((sub_vec_int w__2 (( 2 :: int)::ii)  ::  32 Word.word)) in
      LR_write
        ((concat_vec ((subrange_vec_dec next_instr_addr (( 31 :: int)::ii) (( 1 :: int)::ii)  ::  31 Word.word))
            ( 0b1 ::  1 Word.word)
           ::  32 Word.word)))))) \<then>
   BXWritePC target BranchType_INDCALL)))))))\<close> 
  for  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_BLX_r_A1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BLX_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BLX_r_A1enc_A_txt cond Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2077.29-2077.30'') \<then>
     ((let m = (Word.uint Rm) in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BLX_r_Op_A_txt m))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BLX_r_T1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BLX_r_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BLX_r_T1enc_A_txt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let m = (Word.uint Rm) in
     ((if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BLX_r_Op_A_txt m)))
   else return () )))\<close> 
  for  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BX_Op_A_txt : integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_BX_Op_A_txt  :: \<open> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BX_Op_A_txt m = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  BXWritePC w__0 BranchType_INDIR)))\<close> 
  for  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_BX_A1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BX_A1enc_A_txt cond Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2135.29-2135.30'') \<then>
     ((let m = (Word.uint Rm) in
     execute_aarch32_instrs_BX_Op_A_txt m))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BX_T1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BX_T1enc_A_txt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let m = (Word.uint Rm) in
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BX_Op_A_txt m)))
   else return () )))\<close> 
  for  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_BXJ_Op_A_txt : integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_BXJ_Op_A_txt  :: \<open> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_BXJ_Op_A_txt m = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  BXWritePC w__0 BranchType_INDIR)))\<close> 
  for  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_BXJ_A1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BXJ_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BXJ_A1enc_A_txt cond Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2187.29-2187.30'') \<then>
     ((let m = (Word.uint Rm) in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BXJ_Op_A_txt m))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_BXJ_T1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_BXJ_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_BXJ_T1enc_A_txt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let m = (Word.uint Rm) in
     ((if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_BXJ_Op_A_txt m)))
   else return () )))\<close> 
  for  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CBNZ_Op_A_txt : mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_CBNZ_Op_A_txt  :: \<open>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CBNZ_Op_A_txt imm32 n nonzero = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   if ((neq_bool nonzero ((IsZero w__0)))) then
     (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     CBWritePC ((add_vec w__1 imm32  ::  32 Word.word))))
   else return () )))\<close> 
  for  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "nonzero"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_CBNZ_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty5 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CBNZ_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CBNZ_T1enc_A_txt op1 i imm5 Rn = (
   (let n = (Word.uint Rn) in
   (let (imm32 :: 32 bits) =
     ((place_slice (( 32 :: int)::ii) ((concat_vec i imm5  ::  6 Word.word)) (( 0 :: int)::ii) (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  32 Word.word)) in
   (let (nonzero :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_CBNZ_Op_A_txt imm32 n nonzero))))))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "i"  :: "(1)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "Rn"  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CLREX_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_CLREX_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_CLREX_Op_A_txt _ = ( ClearExclusiveLocal ((ProcessorID () )))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_CLREX_A1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_CLREX_A1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CLREX_A1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_CLREX_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_CLREX_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_CLREX_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CLREX_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_CLREX_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_CLZ_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_CLZ_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CLZ_Op_A_txt d m = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let result = (CountLeadingZeroBits w__0) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_CLZ_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CLZ_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CLZ_A1enc_A_txt cond Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2321.29-2321.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_CLZ_Op_A_txt d m)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CLZ_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CLZ_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CLZ_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let n = (Word.uint Rn) in
     (if (((((((((m \<noteq> n))) \<or> (((d = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_CLZ_Op_A_txt d m)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CMN_i_Op_A_txt : mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_CMN_i_Op_A_txt  :: \<open>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CMN_i_Op_A_txt imm32 n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__0 imm32 ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))))))))))))\<close> 
  for  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMN_i_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMN_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMN_i_A1enc_A_txt cond Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2381.29-2381.30'') \<then>
     ((let n = (Word.uint Rn) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_CMN_i_Op_A_txt imm32 n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMN_i_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMN_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMN_i_T1enc_A_txt i Rn imm3 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_CMN_i_Op_A_txt imm32 n)))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CMN_r_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_CMN_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CMN_r_Op_A_txt m n shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:2431.54-2431.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__2 shifted ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__3 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__4 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__5 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__6 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMN_r_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMN_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMN_r_A1enc_A_txt cond Rn imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2441.29-2441.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_CMN_r_Op_A_txt m n shift_n shift_t))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMN_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMN_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMN_r_T1enc_A_txt Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_CMN_r_Op_A_txt m n shift_n shift_t))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMN_r_T2enc_A_txt : mword ty4 -> mword ty3 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMN_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMN_r_T2enc_A_txt Rn imm3 imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_CMN_r_Op_A_txt m n shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CMN_rr_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_CMN_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CMN_rr_Op_A_txt m n s shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (tup__0, tup__1) = ((AddWithCarry w__3 shifted ( 0b0 ::  1 Word.word)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |)))))))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMN_rr_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMN_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMN_rr_A1enc_A_txt cond Rn Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2540.29-2540.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_CMN_rr_Op_A_txt m n s shift_t))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CMP_i_Op_A_txt : mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_CMP_i_Op_A_txt  :: \<open>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CMP_i_Op_A_txt imm32 n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__0 ((not_vec imm32  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))))))))))))\<close> 
  for  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_i_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_i_A1enc_A_txt cond Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2581.29-2581.30'') \<then>
     ((let n = (Word.uint Rn) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_CMP_i_Op_A_txt imm32 n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_i_T1enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_i_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_i_T1enc_A_txt Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_CMP_i_Op_A_txt imm32 n))
   else return () )))\<close> 
  for  "Rn"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_i_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_i_T2enc_A_txt i Rn imm3 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_CMP_i_Op_A_txt imm32 n)))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CMP_r_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_CMP_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:2649.54-2649.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__2 ((not_vec shifted  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__3 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__4 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__5 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__6 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_r_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_r_A1enc_A_txt cond Rn imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2659.29-2659.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_r_T1enc_A_txt Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_r_T2enc_A_txt N Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint ((concat_vec N Rn  ::  4 Word.word))) in
     (let m = (Word.uint Rm) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if (((((n < (( 8 :: int)::ii))) \<and> ((m < (( 8 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t)))))))))))))
   else return () )))\<close> 
  for  "N"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_r_T3enc_A_txt : mword ty4 -> mword ty3 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_r_T3enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_r_T3enc_A_txt Rn imm3 imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CMP_rr_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_CMP_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CMP_rr_Op_A_txt m n s shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__3 ((not_vec shifted  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |)))))))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_CMP_rr_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CMP_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CMP_rr_A1enc_A_txt cond Rn Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2789.29-2789.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_CMP_rr_Op_A_txt m n s shift_t))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_DBG_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_DBG_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_DBG_Op_A_txt _ = ( ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_DBG_A1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DBG_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DBG_A1enc_A_txt cond option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:2826.29-2826.30'') \<then>
     return ((execute_aarch32_instrs_DBG_Op_A_txt () ))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_DBG_T1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DBG_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DBG_T1enc_A_txt option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_DBG_Op_A_txt ()  else () ) in
   return () ))))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_DMB_Op_A_txt : mword ty4 -> M unit\<close>\<close>

definition execute_aarch32_instrs_DMB_Op_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_DMB_Op_A_txt option_name = (
   undefined_MBReqDomain ()  \<bind> ((\<lambda> (domain1 :: MBReqDomain) . 
   undefined_MBReqTypes ()  \<bind> ((\<lambda> (types1 :: MBReqTypes) . 
   (let b__0 = option_name in
   (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
     (if (((b__0 = ( 0x1 ::  4 Word.word)))) then
       (let (domain1 :: MBReqDomain) = MBReqDomain_OuterShareable in
       (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
       (domain1, types1)))
     else
       (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
         (if (((b__0 = ( 0x2 ::  4 Word.word)))) then
           (let (domain1 :: MBReqDomain) = MBReqDomain_OuterShareable in
           (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
           (domain1, types1)))
         else
           (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
             (if (((b__0 = ( 0x3 ::  4 Word.word)))) then
               (let (domain1 :: MBReqDomain) = MBReqDomain_OuterShareable in
               (let (types1 :: MBReqTypes) = MBReqTypes_All in
               (domain1, types1)))
             else
               (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                 (if (((b__0 = ( 0x5 ::  4 Word.word)))) then
                   (let (domain1 :: MBReqDomain) = MBReqDomain_Nonshareable in
                   (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
                   (domain1, types1)))
                 else
                   (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                     (if (((b__0 = ( 0x6 ::  4 Word.word)))) then
                       (let (domain1 :: MBReqDomain) = MBReqDomain_Nonshareable in
                       (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
                       (domain1, types1)))
                     else
                       (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                         (if (((b__0 = ( 0x7 ::  4 Word.word)))) then
                           (let (domain1 :: MBReqDomain) = MBReqDomain_Nonshareable in
                           (let (types1 :: MBReqTypes) = MBReqTypes_All in
                           (domain1, types1)))
                         else
                           (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                             (if (((b__0 = ( 0x9 ::  4 Word.word)))) then
                               (let (domain1 :: MBReqDomain) = MBReqDomain_InnerShareable in
                               (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
                               (domain1, types1)))
                             else
                               (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                                 (if (((b__0 = ( 0xA ::  4 Word.word)))) then
                                   (let (domain1 :: MBReqDomain) = MBReqDomain_InnerShareable in
                                   (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
                                   (domain1, types1)))
                                 else
                                   (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                                     (if (((b__0 = ( 0xB ::  4 Word.word)))) then
                                       (let (domain1 :: MBReqDomain) = MBReqDomain_InnerShareable in
                                       (let (types1 :: MBReqTypes) = MBReqTypes_All in
                                       (domain1, types1)))
                                     else
                                       (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                                         (if (((b__0 = ( 0xD ::  4 Word.word)))) then
                                           (let (domain1 :: MBReqDomain) = MBReqDomain_FullSystem in
                                           (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
                                           (domain1, types1)))
                                         else
                                           (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
                                             (if (((b__0 = ( 0xE ::  4 Word.word)))) then
                                               (let (domain1 :: MBReqDomain) = MBReqDomain_FullSystem in
                                               (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
                                               (domain1, types1)))
                                             else
                                               (let (domain1 :: MBReqDomain) = MBReqDomain_FullSystem in
                                               (let (types1 :: MBReqTypes) = MBReqTypes_All in
                                               (domain1, types1)))) in
                                           (domain1, types1))) in
                                       (domain1, types1))) in
                                   (domain1, types1))) in
                               (domain1, types1))) in
                           (domain1, types1))) in
                       (domain1, types1))) in
                   (domain1, types1))) in
               (domain1, types1))) in
           (domain1, types1))) in
       (domain1, types1))) in
   (let types1 = types1 in
   and_boolM
     (or_boolM
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL0))))))
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) = EL1)))))))
     ((EL2Enabled () )) \<bind> ((\<lambda> (w__4 :: bool) . 
   (if w__4 then
      (HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      (let (domain1 :: MBReqDomain) =
        (if (((((slice w__5 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) then
          MBReqDomain_FullSystem
        else domain1) in
      and_boolM
        ((HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
         return (((((slice w__6 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))
        (return (((domain1 \<noteq> MBReqDomain_FullSystem)))) \<bind> ((\<lambda> (w__7 :: bool) . 
      (let (domain1 :: MBReqDomain) = (if w__7 then MBReqDomain_OuterShareable else domain1) in
      and_boolM
        ((HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
         return (((((slice w__8 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
        (return (((domain1 = MBReqDomain_Nonshareable)))) \<bind> ((\<lambda> (w__9 :: bool) . 
      (let (domain1 :: MBReqDomain) = (if w__9 then MBReqDomain_InnerShareable else domain1) in
      return domain1)))))))))
    else return domain1) \<bind> ((\<lambda> (domain1 :: MBReqDomain) . 
   return ((DataMemoryBarrier domain1 types1))))))))))))))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_DMB_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DMB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DMB_A1enc_A_txt option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_DMB_Op_A_txt option_name
   else return () )))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_DMB_T1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DMB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DMB_T1enc_A_txt option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_DMB_Op_A_txt option_name
   else return () )))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_DSB_Op_A_txt : mword ty4 -> M unit\<close>\<close>

definition execute_aarch32_instrs_DSB_Op_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_DSB_Op_A_txt option_name = (
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (nXS :: bool) . 
   (if (((((HaveFeatXS () )) \<and> ((HaveFeatHCX () ))))) then
      and_boolM
        (and_boolM
           (and_boolM
              (or_boolM
                 (read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
                  return ((((ProcState_EL   w__0) = EL0))))))
                 (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
                  return ((((ProcState_EL   w__1) = EL1)))))))
              (ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3))))))
           ((IsHCRXEL2Enabled () )))
        ((read_reg HCRX_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
         return (((((slice w__7 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
    else return False) \<bind> ((\<lambda> (nXS :: bool) . 
   undefined_MBReqDomain ()  \<bind> ((\<lambda> (domain1 :: MBReqDomain) . 
   undefined_MBReqTypes ()  \<bind> ((\<lambda> (types1 :: MBReqTypes) . 
   (let b__0 = option_name in
   (if (((b__0 = ( 0x1 ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_OuterShareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
      return (domain1, types1)))
    else if (((b__0 = ( 0x2 ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_OuterShareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
      return (domain1, types1)))
    else if (((b__0 = ( 0x3 ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_OuterShareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_All in
      return (domain1, types1)))
    else if (((b__0 = ( 0x5 ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_Nonshareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
      return (domain1, types1)))
    else if (((b__0 = ( 0x6 ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_Nonshareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
      return (domain1, types1)))
    else if (((b__0 = ( 0x7 ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_Nonshareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_All in
      return (domain1, types1)))
    else if (((b__0 = ( 0x9 ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_InnerShareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
      return (domain1, types1)))
    else if (((b__0 = ( 0xA ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_InnerShareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
      return (domain1, types1)))
    else if (((b__0 = ( 0xB ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_InnerShareable in
      (let (types1 :: MBReqTypes) = MBReqTypes_All in
      return (domain1, types1)))
    else if (((b__0 = ( 0xD ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_FullSystem in
      (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
      return (domain1, types1)))
    else if (((b__0 = ( 0xE ::  4 Word.word)))) then
      (let (domain1 :: MBReqDomain) = MBReqDomain_FullSystem in
      (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
      return (domain1, types1)))
    else if (((option_name = ( 0x0 ::  4 Word.word)))) then throw (Error_See (''SSBB''))
    else if (((option_name = ( 0x4 ::  4 Word.word)))) then throw (Error_See (''PSSBB''))
    else
      (let (domain1 :: MBReqDomain) = MBReqDomain_FullSystem in
      (let (types1 :: MBReqTypes) = MBReqTypes_All in
      return (domain1, types1)))) \<bind> ((\<lambda> varstup .  (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) = varstup in
   and_boolM
     (or_boolM
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) .  return ((((ProcState_EL   w__9) = EL0))))))
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__10 :: ProcState) .  return ((((ProcState_EL   w__10) = EL1)))))))
     ((EL2Enabled () )) \<bind> ((\<lambda> (w__13 :: bool) . 
   (if w__13 then
      (HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
      (let (domain1 :: MBReqDomain) =
        (if (((((slice w__14 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) then
          MBReqDomain_FullSystem
        else domain1) in
      and_boolM
        ((HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
         return (((((slice w__15 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))
        (return (((domain1 \<noteq> MBReqDomain_FullSystem)))) \<bind> ((\<lambda> (w__16 :: bool) . 
      (let (domain1 :: MBReqDomain) = (if w__16 then MBReqDomain_OuterShareable else domain1) in
      and_boolM
        ((HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
         return (((((slice w__17 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
        (return (((domain1 = MBReqDomain_Nonshareable)))) \<bind> ((\<lambda> (w__18 :: bool) . 
      (let (domain1 :: MBReqDomain) = (if w__18 then MBReqDomain_InnerShareable else domain1) in
      return domain1)))))))))
    else return domain1) \<bind> ((\<lambda> (domain1 :: MBReqDomain) . 
   return ((DataSynchronizationBarrier domain1 types1 nXS)))))))))))))))))))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_DSB_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DSB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DSB_A1enc_A_txt option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_DSB_Op_A_txt option_name
   else return () )))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_DSB_T1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DSB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DSB_T1enc_A_txt option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_DSB_Op_A_txt option_name
   else return () )))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_EOR_i_Op_A_txt : mword ty1 -> integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_EOR_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_EOR_i_Op_A_txt carry d imm32 n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((xor_vec w__0 imm32  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg PSTATE_ref ( w__2 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_C := carry |))))))))
   else return () )))))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_EOR_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_EOR_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_EOR_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3118.29-3118.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_EOR_i_Op_A_txt carry d imm32 n setflags))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_EOR_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_EOR_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_EOR_i_T1enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''TEQ (immediate)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_EOR_i_Op_A_txt carry d imm32 n setflags)))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_EOR_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_EOR_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_EOR_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:3179.54-3179.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((xor_vec w__3 shifted  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_EOR_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_EOR_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_EOR_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3203.29-3203.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_EOR_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_EOR_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_EOR_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_EOR_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_EOR_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_EOR_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_EOR_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_EOR_r_T2enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''TEQ (register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_EOR_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_EOR_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_EOR_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_EOR_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((xor_vec w__4 shifted  ::  32 Word.word)) in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg PSTATE_ref ( w__6 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg PSTATE_ref ( w__7 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_EOR_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_EOR_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_EOR_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3315.29-3315.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_EOR_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ISB_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_ISB_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_ISB_Op_A_txt _ = ( InstructionSynchronizationBarrier ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_ISB_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ISB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ISB_A1enc_A_txt option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_ISB_Op_A_txt ()  else () ) in
   return () ))))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ISB_T1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ISB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ISB_T1enc_A_txt option_name = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_ISB_Op_A_txt ()  else () ) in
   return () ))))\<close> 
  for  "option_name"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_IT_Op_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition execute_aarch32_instrs_IT_Op_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_IT_Op_A_txt firstcond mask1 = (
   (AArch32_CheckITEnabled mask1 \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__0 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__0 (|
       ProcState_IT :=
         ((update_subrange_vec_dec(ProcState_IT   w__1) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((concat_vec firstcond mask1  ::  8 Word.word))
            ::  8 Word.word)) |)) \<then>
   write_reg ShouldAdvanceIT_ref False)))))\<close> 
  for  "firstcond"  :: "(4)Word.word " 
  and  "mask1"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_IT_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_IT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_IT_T1enc_A_txt firstcond mask1 = (
   (((if (((mask1 = ( 0x0 ::  4 Word.word)))) then throw (Error_See (''Related encodings''))
    else return () ) \<then>
   (if ((((((firstcond = ( 0xF ::  4 Word.word)))) \<or> ((((((firstcond = ( 0xE ::  4 Word.word)))) \<and> (((((BitCount mask1)) \<noteq> (( 1 :: int)::ii))))))))))
    then
      throw (Error_Unpredictable () )
    else return () )) \<then>
   InITBlock () ) \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_IT_Op_A_txt firstcond mask1)))\<close> 
  for  "firstcond"  :: "(4)Word.word " 
  and  "mask1"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDC_i_Op_A_txt : bool -> mword ty32 -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDC_i_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDC_i_Op_A_txt add imm32 index1 n wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_SysRegWriteDBGDTRTXint address \<then> (if wback then R_set n offset_addr else return () ))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDC_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDC_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDC_i_A1enc_A_txt cond P U W Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3435.29-3435.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDC (literal)''))
      else return () )) \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let n = (Word.uint Rn) in
     (let cp = ((( 14 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_LDC_i_Op_A_txt add imm32 index1 n wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDC_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDC_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDC_i_T1enc_A_txt P U W Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDC (literal)''))
      else return () ) \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let n = (Word.uint Rn) in
     (let cp = ((( 14 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_LDC_i_Op_A_txt add imm32 index1 n wback)))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDC_l_Op_A_txt : bool -> mword ty32 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDC_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDC_l_Op_A_txt add imm32 index1 = (
   (if add then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((add_vec w__1 imm32  ::  32 Word.word))))))
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (Align w__2 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 imm32  ::  32 Word.word))))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      (Align w__4 (( 4 :: int)::ii)  :: ( 32 Word.word) M)))) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_SysRegWriteDBGDTRTXint address)))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDC_l_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDC_l_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDC_l_A1enc_A_txt cond P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3510.29-3510.30'') \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let cp = ((( 14 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     or_boolM (return (((W = ( 0b1 ::  1 Word.word)))))
       (and_boolM (return (((P = ( 0b0 ::  1 Word.word)))))
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDC_l_Op_A_txt add imm32 index1)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDC_l_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDC_l_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDC_l_T1enc_A_txt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let cp = ((( 14 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     or_boolM (return (((W = ( 0b1 ::  1 Word.word)))))
       (and_boolM (return (((P = ( 0b0 ::  1 Word.word)))))
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDC_l_Op_A_txt add imm32 index1)))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDM_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDM_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDM_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
         R_set i w__0 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   ((if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) .  LoadWritePC w__1))
    else return () ) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))))))
    then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      R_set n ((add_vec_int w__2 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
    else return () )) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
   then
     (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) .  R_set n w__3))
   else return () ))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDM_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDM_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDM_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3592.29-3592.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDM_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDM_T1enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDM_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDM_T1enc_A_txt Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = ((concat_vec ( 0x00 ::  8 Word.word) register_list  ::  16 Word.word)) in
     (let (wback :: bool) =
       ((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)) in
     (if ((((BitCount registers1)) < (( 1 :: int)::ii))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDM_Op_A_txt n registers1 wback)))
   else return () )))\<close> 
  for  "Rn"  :: "(3)Word.word " 
  and  "register_list"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDM_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty14 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDM_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(14)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDM_T2enc_A_txt W Rn P M register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) =
       ((concat_vec ((concat_vec P M  ::  2 Word.word)) register_list  ::  16 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((((if (((((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 2 :: int)::ii)))))) \<or> ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((M = ( 0b1 ::  1 Word.word)))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec registers1 (( 13 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     and_boolM
       (and_boolM
          (return ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDM_Op_A_txt n registers1 wback)))))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "register_list"  :: "(14)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDMDA_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDMDA_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDMDA_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) =
     ((add_vec_int ((sub_vec_int w__0 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))
        (( 4 :: int)::ii)
       ::  32 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
         R_set i w__1 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   ((if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  LoadWritePC w__2))
    else return () ) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))))))
    then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      R_set n ((sub_vec_int w__3 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
    else return () )) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
   then
     (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) .  R_set n w__4))
   else return () )))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDMDA_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDMDA_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDMDA_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3700.29-3700.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDMDA_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDMDB_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDMDB_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDMDB_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) =
     ((sub_vec_int w__0 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
         R_set i w__1 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   ((if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  LoadWritePC w__2))
    else return () ) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))))))
    then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      R_set n ((sub_vec_int w__3 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
    else return () )) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
   then
     (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) .  R_set n w__4))
   else return () )))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDMDB_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDMDB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDMDB_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3752.29-3752.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDMDB_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDMDB_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty14 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDMDB_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(14)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDMDB_T1enc_A_txt W Rn P M register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) =
       ((concat_vec ((concat_vec P M  ::  2 Word.word)) register_list  ::  16 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((((if (((((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 2 :: int)::ii)))))) \<or> ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((M = ( 0b1 ::  1 Word.word)))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec registers1 (( 13 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     and_boolM
       (and_boolM
          (return ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDMDB_Op_A_txt n registers1 wback)))))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "register_list"  :: "(14)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDMIB_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDMIB_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDMIB_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) = ((add_vec_int w__0 (( 4 :: int)::ii)  ::  32 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
         R_set i w__1 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   ((if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  LoadWritePC w__2))
    else return () ) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))))))
    then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      R_set n ((add_vec_int w__3 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
    else return () )) \<then>
   (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
   then
     (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) .  R_set n w__4))
   else return () )))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDMIB_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDMIB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDMIB_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3838.29-3838.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDMIB_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRB_i_OpA_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition AArch32_SetLSInstructionSyndrome  :: \<open> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> unit \<close>  where 
     \<open> AArch32_SetLSInstructionSyndrome size1 sign_extend1 Rt acq_rel = ( ()  )\<close> 
  for  "size1"  :: " int " 
  and  "sign_extend1"  :: " bool " 
  and  "Rt"  :: " int " 
  and  "acq_rel"  :: " bool "


definition execute_aarch32_instrs_LDRB_i_OpA_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRB_i_OpA_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
   R_set t ((zero_extend w__3 (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_i_A1enc_A_txt cond P U W Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:3884.29-3884.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRB (literal)''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRBT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRB_i_OpA_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRB_i_OpT_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRB_i_OpT_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRB_i_OpT_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
   R_set t ((zero_extend w__3 (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_i_T1enc_A_txt imm5 Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm5 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDRB_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_i_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_i_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_i_T2enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRB (literal)''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDRB_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_i_T3enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_i_T3enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_i_T3enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((((if ((((((((((((Rt = ( 0xF ::  4 Word.word)))) \<and> (((P = ( 0b1 ::  1 Word.word))))))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''PLD, PLDW (immediate)''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRB (literal)''))
      else return () )) \<then>
     (if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''LDRBT''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRB_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRB_l_Op_A_txt : bool -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRB_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRB_l_Op_A_txt add imm32 t = (
   (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if add then (add_vec base imm32  ::  32 Word.word)
     else (sub_vec base imm32  ::  32 Word.word)) in
   (let (_ :: unit) =
     (if (((t \<noteq> (( 15 :: int)::ii)))) then AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
   R_set t ((zero_extend w__1 (( 32 :: int)::ii)  ::  32 Word.word)))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_l_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_l_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_l_A1enc_A_txt cond P U W Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4044.29-4044.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRBT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> wback))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRB_l_Op_A_txt add imm32 t)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_l_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_l_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_l_T1enc_A_txt U Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_LDRB_l_Op_A_txt add imm32 t))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRB_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRB_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRB_r_Op_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:4099.54-4099.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
   R_set t ((zero_extend w__5 (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_r_A1enc_A_txt cond P U W Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4118.29-4118.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRBT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRB_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LDRB_r_Op_A_txt add index1 m n shift_n shift_t t wback))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRB_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRB_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRB_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     ((if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRB (literal)''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRB_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRBT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> SRType -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRBT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   (((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:4229.54-4229.55'')) \<then>
   (if register_form then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M)))))
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      return ((add_vec w__4 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      return ((sub_vec w__5 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   and_boolM (return (((((\<not> postindex)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
      return ((((ProcState_T   w__7) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__8 :: bool) . 
   (let (_ :: unit) = (if w__8 then AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False else () ) in
   (MemU_unpriv_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__9 ::  8 Word.word) . 
   R_set t ((zero_extend w__9 (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if postindex then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRBT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRBT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRBT_A1enc_A_txt cond U Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4251.29-4251.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_LDRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRBT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRBT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRBT_A2enc_A_txt cond U Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4286.29-4286.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LDRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRBT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRBT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRBT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRB (literal)''))
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRD_i_Op_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRD_i_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRD_i_Op_A_txt add imm32 index1 n t t2 wback = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (Align address (( 8 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (if (((address = w__3))) then
      (MemA_read address (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
      BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__4 :: bool) . 
      if w__4 then
        R_set t ((subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
        R_set t2 ((subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
      else
        R_set t ((subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
        R_set t2 ((subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))
    else
      (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      (R_set t w__5 \<then>
      (MemA_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::
         32 Word.word) . 
      R_set t2 w__6))))) \<then>
   (if wback then R_set n offset_addr
   else return () ))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRD_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRD_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRD_i_A1enc_A_txt cond P U W Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4388.29-4388.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRD (literal)''))
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (((if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = t))) \<or> (((n = t2))))))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((t2 = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRD_i_Op_A_txt add imm32 index1 n t t2 wback))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRD_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRD_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRD_i_T1enc_A_txt P U W Rn Rt Rt2 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRD (literal)''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((if (((wback \<and> ((((((n = t))) \<or> (((n = t2))))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((t = t2)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRD_i_Op_A_txt add imm32 index1 n t t2 wback))))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRD_l_Op_A_txt : bool -> mword ty32 -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRD_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRD_l_Op_A_txt add imm32 t t2 = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
   (if add then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((add_vec w__1 imm32  ::  32 Word.word))))))
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (Align w__2 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 imm32  ::  32 Word.word))))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   (Align address (( 8 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   if (((address = w__4))) then
     (MemA_read address (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
     BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__5 :: bool) . 
     if w__5 then
       R_set t ((subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
       R_set t2 ((subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
     else
       R_set t ((subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
       R_set t2 ((subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))
   else
     (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
     (R_set t w__6 \<then>
     (MemA_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__7 ::
        32 Word.word) . 
     R_set t2 w__7)))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "t"  :: " int " 
  and  "t2"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRD_l_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRD_l_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRD_l_A1enc_A_txt cond U Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4496.29-4496.30'') \<then>
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (if (((t2 = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRD_l_Op_A_txt add imm32 t t2)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRD_l_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRD_l_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRD_l_T1enc_A_txt P U W Rt Rt2 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     ((if (((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((t = t2)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((W = ( 0b1 ::  1 Word.word)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRD_l_Op_A_txt add imm32 t t2)))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRD_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRD_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRD_r_Op_A_txt add index1 m n t t2 wback = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((add_vec w__0 w__1  ::  32 Word.word))))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__2 w__3  ::  32 Word.word))))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (Align address (( 8 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (if (((address = w__5))) then
      (MemA_read address (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
      BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__6 :: bool) . 
      if w__6 then
        R_set t ((subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
        R_set t2 ((subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
      else
        R_set t ((subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
        R_set t2 ((subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))
    else
      (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
      (R_set t w__7 \<then>
      (MemA_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__8 ::
         32 Word.word) . 
      R_set t2 w__8))))) \<then>
   (if wback then R_set n offset_addr
   else return () ))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRD_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRD_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRD_r_A1enc_A_txt cond P U W Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4591.29-4591.30'') \<then>
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (((if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((((((((t2 = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((m = t)))))) \<or> (((m = t2))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((wback \<and> (((((((((n = (( 15 :: int)::ii)))) \<or> (((n = t)))))) \<or> (((n = t2))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRD_r_Op_A_txt add index1 m n t t2 wback))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDREX_Op_A_txt : mword ty32 -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDREX_Op_A_txt  :: \<open>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDREX_Op_A_txt imm32 n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) = ((add_vec w__0 imm32  ::  32 Word.word)) in
   (AArch32_SetExclusiveMonitors address (( 4 :: int)::ii) \<then>
   (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  32 Word.word) .  R_set t w__1))))))\<close> 
  for  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREX_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4646.29-4646.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((Zeros (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREX_Op_A_txt imm32 n t))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREX_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREX_Op_A_txt imm32 n t)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDREXB_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDREXB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDREXB_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (AArch32_SetExclusiveMonitors address (( 1 :: int)::ii) \<then>
   (MemA_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  8 Word.word) . 
   R_set t ((zero_extend w__0 (( 32 :: int)::ii)  ::  32 Word.word)))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREXB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREXB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREXB_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4711.29-4711.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREXB_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREXB_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREXB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREXB_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREXB_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDREXD_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDREXD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDREXD_Op_A_txt n t t2 = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (AArch32_SetExclusiveMonitors address (( 8 :: int)::ii) \<then>
   (MemA_read address (( 8 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (value_name :: 64 bits) . 
   BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (w__1 ::  32 Word.word) =
     (if w__0 then (subrange_vec_dec value_name (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)
     else (subrange_vec_dec value_name (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (R_set t w__1 \<then>
   BigEndian AccType_ATOMIC) \<bind> ((\<lambda> (w__2 :: bool) . 
   (let (w__3 ::  32 Word.word) =
     (if w__2 then (subrange_vec_dec value_name (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)
     else (subrange_vec_dec value_name (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) in
   R_set t2 w__3)))))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREXD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREXD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREXD_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4777.29-4777.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     (if ((((((((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREXD_Op_A_txt n t t2))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREXD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREXD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREXD_T1enc_A_txt Rn Rt Rt2 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let n = (Word.uint Rn) in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((t = t2)))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREXD_Op_A_txt n t t2)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDREXH_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDREXH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDREXH_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (AArch32_SetExclusiveMonitors address (( 2 :: int)::ii) \<then>
   (MemA_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  16 Word.word) . 
   R_set t ((zero_extend w__0 (( 32 :: int)::ii)  ::  32 Word.word)))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREXH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREXH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREXH_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4842.29-4842.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREXH_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDREXH_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDREXH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDREXH_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDREXH_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRH_i_OpA_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRH_i_OpA_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRH_i_OpA_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   R_set t ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_i_A1enc_A_txt cond P U W Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:4912.29-4912.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRH (literal)''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRHT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRH_i_OpA_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRH_i_OpT_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRH_i_OpT_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRH_i_OpT_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   R_set t ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_i_T1enc_A_txt imm5 Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm5 (( 0 :: int)::ii) (( 5 :: int)::ii) (( 1 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDRH_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_i_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_i_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_i_T2enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD (immediate)''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRH (literal)''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDRH_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_i_T3enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_i_T3enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_i_T3enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRH (literal)''))
      else return () ) \<then>
     (if ((((((((((((Rt = ( 0xF ::  4 Word.word)))) \<and> (((P = ( 0b1 ::  1 Word.word))))))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''PLDW (immediate)''))
      else return () )) \<then>
     (if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''LDRHT''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRH_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRH_l_Op_A_txt : bool -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRH_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRH_l_Op_A_txt add imm32 t = (
   (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if add then (add_vec base imm32  ::  32 Word.word)
     else (sub_vec base imm32  ::  32 Word.word)) in
   (let (_ :: unit) =
     (if (((t \<noteq> (( 15 :: int)::ii)))) then AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   R_set t ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word)))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_l_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_l_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_l_A1enc_A_txt cond P U W Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5074.29-5074.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRHT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> wback))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRH_l_Op_A_txt add imm32 t)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_l_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_l_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_l_T1enc_A_txt U Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD (literal)''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_LDRH_l_Op_A_txt add imm32 t))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRH_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRH_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRH_r_Op_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:5130.54-5130.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((t \<noteq> (( 15 :: int)::ii)))) then AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   R_set t ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_r_A1enc_A_txt cond P U W Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5149.29-5149.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRHT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRH_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LDRH_r_Op_A_txt add index1 m n shift_n shift_t t wback))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRH_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRH_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRH_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     ((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRH (literal)''))
      else return () ) \<then>
     (if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLDW (register)''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRH_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRHT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRHT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRHT_Op_A_txt add imm32 m n postindex register_form t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   ((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if register_form then (R_read m  :: ( 32 Word.word) M)
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   and_boolM (return (((((\<not> postindex)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
      return ((((ProcState_T   w__5) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__6 :: bool) . 
   (let (_ :: unit) = (if w__6 then AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False else () ) in
   (MemU_unpriv_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   (if postindex then R_set n offset_addr
    else return () ) \<then>
   R_set t ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRHT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRHT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRHT_A1enc_A_txt cond U Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5280.29-5280.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_LDRHT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRHT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRHT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRHT_A2enc_A_txt cond U Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5316.29-5316.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     execute_aarch32_instrs_LDRHT_Op_A_txt add imm32 m n postindex register_form t))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRHT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRHT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRHT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRH (literal)''))
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRHT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDR_i_OpA_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDR_i_OpA_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDR_i_OpA_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   (if (((t = (( 15 :: int)::ii)))) then
     if (((((subrange_vec_dec address (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
       LoadWritePC data
     else throw (Error_Unpredictable () )
   else R_set t data)))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_i_A1enc_A_txt cond P U W Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5412.29-5412.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDR (literal)''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if (((wback \<and> (((n = t)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDR_i_OpA_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDR_i_OpT_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDR_i_OpT_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   (if (((t = (( 15 :: int)::ii)))) then
     if (((((subrange_vec_dec address (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
       LoadWritePC data
     else throw (Error_Unpredictable () )
   else R_set t data)))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_i_T1enc_A_txt imm5 Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm5 (( 0 :: int)::ii) (( 5 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_i_T2enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_i_T2enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_i_T2enc_A_txt Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = ((( 13 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "Rt"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_i_T3enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_i_T3enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_i_T3enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDR (literal)''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     and_boolM (and_boolM (return (((t = (( 15 :: int)::ii))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index1 n t wback)))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_i_T4enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_i_T4enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_i_T4enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDR (literal)''))
      else return () ) \<then>
     (if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''LDRT''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     or_boolM (return (((wback \<and> (((n = t)))))))
       (and_boolM (and_boolM (return (((t = (( 15 :: int)::ii))))) ((InITBlock () )))
          (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))) \<bind> ((\<lambda> w__5 . 
     (if w__5 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index1 n t wback)))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDR_l_Op_A_txt : bool -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDR_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDR_l_Op_A_txt add imm32 t = (
   (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if add then (add_vec base imm32  ::  32 Word.word)
     else (sub_vec base imm32  ::  32 Word.word)) in
   (let (_ :: unit) =
     (if (((t \<noteq> (( 15 :: int)::ii)))) then AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   if (((t = (( 15 :: int)::ii)))) then
     if (((((subrange_vec_dec address (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
       LoadWritePC data
     else throw (Error_Unpredictable () )
   else R_set t data)))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_l_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_l_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_l_A1enc_A_txt cond P U W Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5608.29-5608.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if wback then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDR_l_Op_A_txt add imm32 t)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_l_T1enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_l_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_l_T1enc_A_txt Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = True in
     execute_aarch32_instrs_LDR_l_Op_A_txt add imm32 t)))
   else return () )))\<close> 
  for  "Rt"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_l_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_l_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_l_T2enc_A_txt U Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     and_boolM (and_boolM (return (((t = (( 15 :: int)::ii))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDR_l_Op_A_txt add imm32 t)))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDR_r_OpA_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDR_r_OpA_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDR_r_OpA_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:5682.54-5682.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   (if (((t = (( 15 :: int)::ii)))) then
     if (((((subrange_vec_dec address (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
       LoadWritePC data
     else throw (Error_Unpredictable () )
   else R_set t data)))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_r_A1enc_A_txt cond P U W Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5709.29-5709.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDR_r_OpA_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDR_r_OpT_A_txt : integer -> integer -> integer -> SRType -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDR_r_OpT_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDR_r_OpT_A_txt m n shift_n shift_t t = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:5753.54-5753.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (offset_addr :: 32 bits) = ((add_vec w__2 offset  ::  32 Word.word)) in
   (let (address :: 32 bits) = offset_addr in
   (let (_ :: unit) =
     (if (((t \<noteq> (( 15 :: int)::ii)))) then AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   if (((t = (( 15 :: int)::ii)))) then
     if (((((subrange_vec_dec address (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
       LoadWritePC data
     else throw (Error_Unpredictable () )
   else R_set t data))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LDR_r_OpT_A_txt m n shift_n shift_t t)))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDR_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDR_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDR_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDR (literal)''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM (and_boolM (return (((t = (( 15 :: int)::ii))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDR_r_OpT_A_txt m n shift_n shift_t t))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSB_i_Op_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSB_i_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSB_i_Op_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) True t False
     else () ) in
   (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
   R_set t ((sign_extend w__3 (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_i_A1enc_A_txt cond P U W Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5852.29-5852.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSB (literal)''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSBT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSB_i_Op_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_i_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_i_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_i_T1enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLI''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSB (literal)''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDRSB_i_Op_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_i_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_i_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_i_T2enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((((if ((((((((((((Rt = ( 0xF ::  4 Word.word)))) \<and> (((P = ( 0b1 ::  1 Word.word))))))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''PLI''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSB (literal)''))
      else return () )) \<then>
     (if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSBT''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSB_i_Op_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSB_l_Op_A_txt : bool -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSB_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSB_l_Op_A_txt add imm32 t = (
   (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if add then (add_vec base imm32  ::  32 Word.word)
     else (sub_vec base imm32  ::  32 Word.word)) in
   (let (_ :: unit) =
     (if (((t \<noteq> (( 15 :: int)::ii)))) then AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) True t False
     else () ) in
   (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
   R_set t ((sign_extend w__1 (( 32 :: int)::ii)  ::  32 Word.word)))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_l_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_l_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_l_A1enc_A_txt cond P U W Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:5972.29-5972.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSBT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> wback))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSB_l_Op_A_txt add imm32 t)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_l_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_l_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_l_T1enc_A_txt U Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLI''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_LDRSB_l_Op_A_txt add imm32 t))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSB_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSB_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSB_r_Op_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:6028.54-6028.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) True t False
     else () ) in
   (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
   R_set t ((sign_extend w__5 (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_r_A1enc_A_txt cond P U W Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6047.29-6047.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSBT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRSB_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LDRSB_r_Op_A_txt add index1 m n shift_n shift_t t wback))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSB_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSB_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSB_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     ((if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLI''))
      else return () ) \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSB (literal)''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSB_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSBT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSBT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSBT_Op_A_txt add imm32 m n postindex register_form t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   ((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if register_form then (R_read m  :: ( 32 Word.word) M)
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   and_boolM (return (((((\<not> postindex)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
      return ((((ProcState_T   w__5) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__6 :: bool) . 
   (let (_ :: unit) = (if w__6 then AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) True t False else () ) in
   (MemU_unpriv_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__7 ::  8 Word.word) . 
   R_set t ((sign_extend w__7 (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if postindex then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSBT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSBT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSBT_A1enc_A_txt cond U Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6178.29-6178.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_LDRSBT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSBT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSBT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSBT_A2enc_A_txt cond U Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6214.29-6214.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     execute_aarch32_instrs_LDRSBT_Op_A_txt add imm32 m n postindex register_form t))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSBT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSBT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSBT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSB (literal)''))
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSBT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSH_i_Op_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSH_i_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSH_i_Op_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) True t False
     else () ) in
   (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   R_set t ((sign_extend data (( 32 :: int)::ii)  ::  32 Word.word))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_i_A1enc_A_txt cond P U W Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6302.29-6302.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSH (literal)''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSHT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSH_i_Op_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_i_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_i_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_i_T1enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSH (literal)''))
      else return () ) \<then>
     (if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''Related instructions''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_LDRSH_i_Op_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_i_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_i_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_i_T2enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSH (literal)''))
      else return () ) \<then>
     (if ((((((((((((Rt = ( 0xF ::  4 Word.word)))) \<and> (((P = ( 0b1 ::  1 Word.word))))))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related instructions''))
      else return () )) \<then>
     (if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSHT''))
      else return () )) \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSH_i_Op_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSH_l_Op_A_txt : bool -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSH_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSH_l_Op_A_txt add imm32 t = (
   (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if add then (add_vec base imm32  ::  32 Word.word)
     else (sub_vec base imm32  ::  32 Word.word)) in
   (let (_ :: unit) =
     (if (((t \<noteq> (( 15 :: int)::ii)))) then AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) True t False
     else () ) in
   (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   R_set t ((sign_extend data (( 32 :: int)::ii)  ::  32 Word.word)))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_l_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_l_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_l_A1enc_A_txt cond P U W Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6423.29-6423.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSHT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> wback))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSH_l_Op_A_txt add imm32 t)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_l_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_l_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_l_T1enc_A_txt U Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''Related instructions''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_LDRSH_l_Op_A_txt add imm32 t))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSH_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSH_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSH_r_Op_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:6479.54-6479.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) True t False
     else () ) in
   (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   (if wback then R_set n offset_addr
    else return () ) \<then>
   R_set t ((sign_extend data (( 32 :: int)::ii)  ::  32 Word.word))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_r_A1enc_A_txt cond P U W Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6498.29-6498.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''LDRSHT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDRSH_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LDRSH_r_Op_A_txt add index1 m n shift_n shift_t t wback))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSH_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSH_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSH_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     ((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSH (literal)''))
      else return () ) \<then>
     (if (((Rt = ( 0xF ::  4 Word.word)))) then throw (Error_See (''Related instructions''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSH_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRSHT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRSHT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRSHT_Op_A_txt add imm32 m n postindex register_form t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   ((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if register_form then (R_read m  :: ( 32 Word.word) M)
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   and_boolM (return (((((\<not> postindex)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
      return ((((ProcState_T   w__5) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__6 :: bool) . 
   (let (_ :: unit) = (if w__6 then AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) True t False else () ) in
   (MemU_unpriv_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (data :: 16 bits) . 
   (if postindex then R_set n offset_addr
    else return () ) \<then>
   R_set t ((sign_extend data (( 32 :: int)::ii)  ::  32 Word.word))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSHT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSHT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSHT_A1enc_A_txt cond U Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6629.29-6629.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_LDRSHT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSHT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSHT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSHT_A2enc_A_txt cond U Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6665.29-6665.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     execute_aarch32_instrs_LDRSHT_Op_A_txt add imm32 m n postindex register_form t))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRSHT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRSHT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRSHT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDRSH (literal)''))
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRSHT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDRT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> SRType -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDRT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   (((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:6739.54-6739.55'')) \<then>
   (if register_form then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M)))))
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      return ((add_vec w__4 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      return ((sub_vec w__5 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   and_boolM (return (((((\<not> postindex)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
      return ((((ProcState_T   w__7) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__8 :: bool) . 
   (let (_ :: unit) = (if w__8 then AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False else () ) in
   (MemU_unpriv_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   (if postindex then R_set n offset_addr else return () ) \<then> R_set t data))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRT_A1enc_A_txt cond U Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6761.29-6761.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_LDRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRT_A2enc_A_txt cond U Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:6796.29-6796.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LDRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDRT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDRT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDRT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''LDR (literal)''))
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LSL_i_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LSL_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LSL_i_Op_A_txt d m setflags shift_n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:6873.54-6873.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 SRType_LSL shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg PSTATE_ref ( w__4 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LSL_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LSL_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LSL_i_T1enc_A_txt imm5 Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     (if (((imm5 = ( 0b00000 ::  5 Word.word)))) then throw (Error_See (''MOV (register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     DecodeImmShift ( 0b00 ::  2 Word.word) imm5 \<bind> ((\<lambda> varstup .  (let (_, (tup_10 :: ii)) = varstup in
     (let (shift_n :: ii) = tup_10 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LSL_i_Op_A_txt d m setflags shift_n)))))))))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LSL_r_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LSL_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LSL_r_Op_A_txt d m n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 SRType_LSL shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LSL_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LSL_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LSL_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     execute_aarch32_instrs_LSL_r_Op_A_txt d m n setflags))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LSL_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LSL_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LSL_r_T2enc_A_txt S Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LSL_r_Op_A_txt d m n setflags))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LSR_i_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LSR_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LSR_i_Op_A_txt d m setflags shift_n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:6987.54-6987.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 SRType_LSR shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg PSTATE_ref ( w__4 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LSR_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LSR_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LSR_i_T1enc_A_txt imm5 Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     DecodeImmShift ( 0b01 ::  2 Word.word) imm5 \<bind> ((\<lambda> varstup .  (let (_, (tup_10 :: ii)) = varstup in
     (let (shift_n :: ii) = tup_10 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_LSR_i_Op_A_txt d m setflags shift_n))))))))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LSR_r_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LSR_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LSR_r_Op_A_txt d m n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 SRType_LSR shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LSR_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LSR_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LSR_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     execute_aarch32_instrs_LSR_r_Op_A_txt d m n setflags))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MCR_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_MCR_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MCR_Op_A_txt cp t = (
   (ThisInstr ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  AArch32_SysRegWrite cp w__0 t)))\<close> 
  for  "cp"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_MCR_A1enc_A_txt : mword ty4 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty3 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MCR_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MCR_A1enc_A_txt cond opc1 CRn Rt coproc opc2 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7078.29-7078.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MCR_Op_A_txt cp t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "opc1"  :: "(3)Word.word " 
  and  "CRn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc2"  :: "(3)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MCR_T1enc_A_txt : mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty3 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MCR_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MCR_T1enc_A_txt opc1 CRn Rt coproc opc2 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MCR_Op_A_txt cp t))
   else return () )))\<close> 
  for  "opc1"  :: "(3)Word.word " 
  and  "CRn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc2"  :: "(3)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MCRR_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_MCRR_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MCRR_Op_A_txt cp t t2 = (
   (ThisInstr ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   AArch32_SysRegWrite64 cp w__0 t t2)))\<close> 
  for  "cp"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_MCRR_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MCRR_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MCRR_A1enc_A_txt cond Rt2 Rt coproc opc1 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7138.29-7138.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MCRR_Op_A_txt cp t t2))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc1"  :: "(4)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MCRR_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MCRR_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MCRR_T1enc_A_txt Rt2 Rt coproc opc1 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MCRR_Op_A_txt cp t t2)))
   else return () )))\<close> 
  for  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc1"  :: "(4)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MLA_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MLA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MLA_Op_A_txt a d m n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let operand1 = (Word.sint w__0) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let operand2 = (Word.sint w__1) in
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let addend = (Word.sint w__2) in
   (let result = (((operand1 * operand2)) + addend) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((vec_of_bits [integer_access result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__4 (|
         ProcState_Z :=
           ((IsZeroBit ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))  ::  1 Word.word)) |))))))
   else return () ))))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MLA_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MLA_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MLA_A1enc_A_txt cond S Rd Ra Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7207.29-7207.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MLA_Op_A_txt a d m n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MLA_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MLA_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MLA_T1enc_A_txt Rn Ra Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''MUL''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (setflags :: bool) = False in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MLA_Op_A_txt a d m n setflags))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MLS_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_MLS_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MLS_Op_A_txt a d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let operand1 = (Word.sint w__0) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let operand2 = (Word.sint w__1) in
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let addend = (Word.sint w__2) in
   (let result = (addend - ((operand1 * operand2))) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)))))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_MLS_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MLS_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MLS_A1enc_A_txt cond Rd Ra Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7277.29-7277.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MLS_Op_A_txt a d m n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MLS_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MLS_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MLS_T1enc_A_txt Rn Ra Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MLS_Op_A_txt a d m n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MOV_i_Op_A_txt : mword ty1 -> integer -> mword ty32 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MOV_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags = (
   (let (result :: 32 bits) = imm32 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__0 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg PSTATE_ref ( w__1 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     write_reg PSTATE_ref ( w__2 (| ProcState_C := carry |))))))))
   else return () )))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_i_A1enc_A_txt cond S Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7351.29-7351.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_i_A2enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_i_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_i_A2enc_A_txt cond imm4 Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7379.29-7379.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4 imm12  ::  16 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let carry = carry in
     execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_i_T1enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_i_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_i_T1enc_A_txt Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (let (carry :: 1 bits) = ((ProcState_C   w__2)) in
     execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags))))))))
   else return () )))\<close> 
  for  "Rd"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_i_T2enc_A_txt i S imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let carry = carry in
     execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags))))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_i_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_i_T3enc_A_txt i imm4 imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend
          ((concat_vec ((concat_vec ((concat_vec imm4 i  ::  5 Word.word)) imm3  ::  8 Word.word)) imm8
             ::  16 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let carry = carry in
     execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags)))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MOV_r_Op_A_txt : integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_MOV_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:7485.54-7485.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (let (result :: 32 bits) = shifted in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg PSTATE_ref ( w__4 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_r_A1enc_A_txt cond S Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7509.29-7509.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_r_T1enc_A_txt D Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint ((concat_vec D Rd  ::  4 Word.word))) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     and_boolM (and_boolM (return (((d = (( 15 :: int)::ii))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_r_T2enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_r_T2enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_r_T2enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = True in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t))))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_r_T3enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_r_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_r_T3enc_A_txt S imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t))))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MOV_rr_Op_A_txt : integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_MOV_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MOV_rr_Op_A_txt d m s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_rr_A1enc_A_txt cond S Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7652.29-7652.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MOV_rr_Op_A_txt d m s setflags shift_t)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_rr_T1enc_A_txt : mword ty4 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_rr_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_rr_T1enc_A_txt op1 Rs Rdm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((\<not> ((((((op1 = ( 0x2 ::  4 Word.word)))) \<or> ((((((op1 = ( 0x3 ::  4 Word.word)))) \<or> ((((((op1 = ( 0x4 ::  4 Word.word)))) \<or> (((op1 = ( 0x7 ::  4 Word.word)))))))))))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     ((let d = (Word.uint Rdm) in
     (let m = (Word.uint Rdm) in
     (let s = (Word.uint Rs) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     DecodeRegShift
       ((concat_vec (vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word)
           (vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word)
          ::  2 Word.word)) \<bind> ((\<lambda> (shift_t :: SRType) . 
     execute_aarch32_instrs_MOV_rr_Op_A_txt d m s setflags shift_t)))))))))
   else return () )))\<close> 
  for  "op1"  :: "(4)Word.word " 
  and  "Rs"  :: "(3)Word.word " 
  and  "Rdm"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOV_rr_T2enc_A_txt : mword ty2 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOV_rr_T2enc_A_txt  :: \<open>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOV_rr_T2enc_A_txt stype S Rm Rd Rs = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MOV_rr_Op_A_txt d m s setflags shift_t))))))
   else return () )))\<close> 
  for  "stype"  :: "(2)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MOVT_Op_A_txt : integer -> mword ty16 -> M unit\<close>\<close>

definition execute_aarch32_instrs_MOVT_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MOVT_Op_A_txt d imm16 = (
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   R_set d ((update_subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii) imm16  ::  32 Word.word)))))\<close> 
  for  "d"  :: " int " 
  and  "imm16"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOVT_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOVT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOVT_A1enc_A_txt cond imm4 Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7744.29-7744.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let (imm16 :: 16 bits) = ((concat_vec imm4 imm12  ::  16 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MOVT_Op_A_txt d imm16)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MOVT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MOVT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MOVT_T1enc_A_txt i imm4 imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (imm16 :: 16 bits) =
       ((concat_vec ((concat_vec ((concat_vec imm4 i  ::  5 Word.word)) imm3  ::  8 Word.word)) imm8
         ::  16 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MOVT_Op_A_txt d imm16))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MRC_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_MRC_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MRC_Op_A_txt cp t = (
   or_boolM (return (((t \<noteq> (( 15 :: int)::ii)))))
     ((ThisInstr ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      AArch32_SysRegReadCanWriteAPSR cp w__0))) \<bind> ((\<lambda> (w__2 :: bool) . 
   if w__2 then
     (ThisInstr ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) .  AArch32_SysRegRead cp w__3 t))
   else throw (Error_Unpredictable () ))))\<close> 
  for  "cp"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRC_A1enc_A_txt : mword ty4 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty3 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRC_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRC_A1enc_A_txt cond opc1 CRn Rt coproc opc2 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7804.29-7804.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     execute_aarch32_instrs_MRC_Op_A_txt cp t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "opc1"  :: "(3)Word.word " 
  and  "CRn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc2"  :: "(3)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRC_T1enc_A_txt : mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty3 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRC_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRC_T1enc_A_txt opc1 CRn Rt coproc opc2 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     execute_aarch32_instrs_MRC_Op_A_txt cp t))
   else return () )))\<close> 
  for  "opc1"  :: "(3)Word.word " 
  and  "CRn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc2"  :: "(3)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MRRC_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_MRRC_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MRRC_Op_A_txt cp t t2 = (
   (ThisInstr ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  AArch32_SysRegRead64 cp w__0 t t2)))\<close> 
  for  "cp"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRRC_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRRC_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRRC_A1enc_A_txt cond Rt2 Rt coproc opc1 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7858.29-7858.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((t = t2)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MRRC_Op_A_txt cp t t2))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc1"  :: "(4)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRRC_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRRC_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRRC_T1enc_A_txt Rt2 Rt coproc opc1 CRm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let cp =
       (if ((((vec_of_bits [access_vec_dec coproc (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 14 :: int)::ii)
       else (( 15 :: int)::ii)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((t = t2)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MRRC_Op_A_txt cp t t2)))
   else return () )))\<close> 
  for  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "coproc"  :: "(1)Word.word " 
  and  "opc1"  :: "(4)Word.word " 
  and  "CRm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MUL_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MUL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MUL_Op_A_txt d m n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let operand1 = (Word.sint w__0) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let operand2 = (Word.sint w__1) in
   (let result = (operand1 * operand2) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_N := ((vec_of_bits [integer_access result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__3 (|
         ProcState_Z :=
           ((IsZeroBit ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))  ::  1 Word.word)) |))))))
   else return () )))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MUL_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MUL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MUL_A1enc_A_txt cond S Rd Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:7926.29-7926.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MUL_Op_A_txt d m n setflags)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MUL_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MUL_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MUL_T1enc_A_txt Rn Rdm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rdm) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rdm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     execute_aarch32_instrs_MUL_Op_A_txt d m n setflags))))))
   else return () )))\<close> 
  for  "Rn"  :: "(3)Word.word " 
  and  "Rdm"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MUL_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MUL_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MUL_T2enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MUL_Op_A_txt d m n setflags))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MVN_i_Op_A_txt : mword ty1 -> integer -> mword ty32 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MVN_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MVN_i_Op_A_txt carry d imm32 setflags = (
   (let (result :: 32 bits) = ((not_vec imm32  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__0 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg PSTATE_ref ( w__1 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     write_reg PSTATE_ref ( w__2 (| ProcState_C := carry |))))))))
   else return () )))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MVN_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MVN_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MVN_i_A1enc_A_txt cond S Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8023.29-8023.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_MVN_i_Op_A_txt carry d imm32 setflags)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MVN_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MVN_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MVN_i_T1enc_A_txt i S imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let carry = carry in
     execute_aarch32_instrs_MVN_i_Op_A_txt carry d imm32 setflags))))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MVN_r_Op_A_txt : integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_MVN_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MVN_r_Op_A_txt d m setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:8083.54-8083.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (let (result :: 32 bits) = ((not_vec shifted  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg PSTATE_ref ( w__4 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_MVN_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MVN_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MVN_r_A1enc_A_txt cond S Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8107.29-8107.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_MVN_r_Op_A_txt d m setflags shift_n shift_t)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MVN_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MVN_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MVN_r_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_MVN_r_Op_A_txt d m setflags shift_n shift_t)))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MVN_r_T2enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MVN_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MVN_r_T2enc_A_txt S imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_MVN_r_Op_A_txt d m setflags shift_n shift_t))))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MVN_rr_Op_A_txt : integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_MVN_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MVN_rr_Op_A_txt d m s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (let (result :: 32 bits) = ((not_vec shifted  ::  32 Word.word)) in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_MVN_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MVN_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MVN_rr_A1enc_A_txt cond S Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8217.29-8217.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MVN_rr_Op_A_txt d m s setflags shift_t)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_NOP_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_NOP_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_NOP_Op_A_txt _ = ( ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_NOP_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_NOP_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_NOP_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8256.29-8256.30'') \<then>
     return ((execute_aarch32_instrs_NOP_Op_A_txt () ))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_NOP_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_NOP_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_NOP_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_NOP_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_NOP_T2enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_NOP_T2enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_NOP_T2enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_NOP_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_ORN_i_Op_A_txt : mword ty1 -> integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ORN_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ORN_i_Op_A_txt carry d imm32 n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((or_vec w__0 ((not_vec imm32  ::  32 Word.word))  ::  32 Word.word)) in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg PSTATE_ref ( w__2 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_C := carry |))))))))
   else return () )))))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORN_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORN_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORN_i_T1enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''MVN (immediate)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ORN_i_Op_A_txt carry d imm32 n setflags)))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ORN_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ORN_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ORN_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:8358.54-8358.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((or_vec w__3 ((not_vec shifted  ::  32 Word.word))  ::  32 Word.word)) in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORN_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORN_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORN_r_T1enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''MVN (register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ORN_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ORR_i_Op_A_txt : mword ty1 -> integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ORR_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ORR_i_Op_A_txt carry d imm32 n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((or_vec w__0 imm32  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg PSTATE_ref ( w__2 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_C := carry |))))))))
   else return () )))))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORR_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORR_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORR_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8436.29-8436.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_ORR_i_Op_A_txt carry d imm32 n setflags))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORR_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORR_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORR_i_T1enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''MOV (immediate)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ORR_i_Op_A_txt carry d imm32 n setflags)))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ORR_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ORR_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ORR_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:8497.54-8497.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((or_vec w__3 shifted  ::  32 Word.word)) in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORR_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORR_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORR_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8521.29-8521.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ORR_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORR_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORR_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORR_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_ORR_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORR_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORR_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORR_r_T2enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''Related encodings''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ORR_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ORR_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_ORR_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ORR_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((or_vec w__4 shifted  ::  32 Word.word)) in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg PSTATE_ref ( w__6 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg PSTATE_ref ( w__7 (| ProcState_C := carry |))))))))
   else return () )))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_ORR_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ORR_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ORR_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8633.29-8633.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ORR_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_PKH_Op_A_txt : integer -> integer -> integer -> integer -> SRType -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_PKH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_PKH_Op_A_txt d m n shift_n shift_t tbform = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:8665.54-8665.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (operand2 :: 32 bits) . 
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (if tbform then return ((subrange_vec_dec operand2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (w__4 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii) w__4  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (if tbform then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
      return ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else return ((subrange_vec_dec operand2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))) \<bind> ((\<lambda> (w__7 ::
      16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "tbform"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_PKH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PKH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PKH_A1enc_A_txt cond Rn Rd imm5 tb Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:8678.29-8678.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (tbform :: bool) = (tb = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift ((concat_vec tb ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__1 ::
       (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_PKH_Op_A_txt d m n shift_n shift_t tbform)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "tb"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PKH_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PKH_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PKH_T1enc_A_txt S Rn imm3 Rd imm2 tb T Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((S = ( 0b1 ::  1 Word.word)))) \<or> (((T = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (tbform :: bool) = (tb = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift ((concat_vec tb ( 0b0 ::  1 Word.word)  ::  2 Word.word))
       ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_PKH_Op_A_txt d m n shift_n shift_t tbform)))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "tb"  :: "(1)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_PLD_i_Op_A_txt : bool -> mword ty32 -> bool -> integer -> M unit\<close>\<close>

definition Hint_PreloadData  :: \<open>(32)Word.word \<Rightarrow> unit \<close>  where 
     \<open> Hint_PreloadData address = ( ()  )\<close> 
  for  "address"  :: "(32)Word.word "


definition Hint_PreloadDataForWrite  :: \<open>(32)Word.word \<Rightarrow> unit \<close>  where 
     \<open> Hint_PreloadDataForWrite address = ( ()  )\<close> 
  for  "address"  :: "(32)Word.word "


definition execute_aarch32_instrs_PLD_i_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_PLD_i_Op_A_txt add imm32 is_pldw n = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   return (if is_pldw then Hint_PreloadDataForWrite address
           else Hint_PreloadData address))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "is_pldw"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLD_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLD_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLD_i_A1enc_A_txt U R Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD (literal)''))
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (is_pldw :: bool) = (R = ( 0b0 ::  1 Word.word)) in
     execute_aarch32_instrs_PLD_i_Op_A_txt add imm32 is_pldw n)))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLD_i_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLD_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLD_i_T1enc_A_txt W Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD (literal)''))
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = True in
     (let (is_pldw :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_PLD_i_Op_A_txt add imm32 is_pldw n)))))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLD_i_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLD_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLD_i_T2enc_A_txt W Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD (literal)''))
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = False in
     (let (is_pldw :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_PLD_i_Op_A_txt add imm32 is_pldw n)))))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_PLD_l_Op_A_txt : bool -> mword ty32 -> M unit\<close>\<close>

definition execute_aarch32_instrs_PLD_l_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_PLD_l_Op_A_txt add imm32 = (
   (if add then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((add_vec w__1 imm32  ::  32 Word.word))))))
    else
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (Align w__2 (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 imm32  ::  32 Word.word))))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   return ((Hint_PreloadData address)))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLD_l_A1enc_A_txt : mword ty1 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLD_l_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLD_l_A1enc_A_txt U imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_PLD_l_Op_A_txt add imm32))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLD_l_T1enc_A_txt : mword ty1 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLD_l_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLD_l_T1enc_A_txt U imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_PLD_l_Op_A_txt add imm32))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_PLD_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_PLD_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_PLD_r_Op_A_txt add is_pldw m n shift_n shift_t = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:8893.54-8893.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   return (if is_pldw then Hint_PreloadDataForWrite address
           else Hint_PreloadData address))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "is_pldw"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLD_r_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLD_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLD_r_A1enc_A_txt U R Rn imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (is_pldw :: bool) = (R = ( 0b0 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((m = (( 15 :: int)::ii)))) \<or> ((((((n = (( 15 :: int)::ii)))) \<and> is_pldw)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_PLD_r_Op_A_txt add is_pldw m n shift_n shift_t)))))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLD_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLD_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLD_r_T1enc_A_txt W Rn imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLD (literal)''))
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (add :: bool) = True in
     (let (is_pldw :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_PLD_r_Op_A_txt add is_pldw m n shift_n shift_t)))))))))))))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_PLI_i_Op_A_txt : bool -> mword ty32 -> integer -> M unit\<close>\<close>

definition Hint_PreloadInstr  :: \<open>(32)Word.word \<Rightarrow> unit \<close>  where 
     \<open> Hint_PreloadInstr address = ( ()  )\<close> 
  for  "address"  :: "(32)Word.word "


definition execute_aarch32_instrs_PLI_i_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n = (
   (if (((n = (( 15 :: int)::ii)))) then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M)))
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if add then (add_vec base imm32  ::  32 Word.word)
     else (sub_vec base imm32  ::  32 Word.word)) in
   return ((Hint_PreloadInstr address))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLI_i_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLI_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLI_i_A1enc_A_txt U Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n)))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLI_i_T1enc_A_txt : mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLI_i_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLI_i_T1enc_A_txt Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''encoding T3''))
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = True in
     execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLI_i_T2enc_A_txt : mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLI_i_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLI_i_T2enc_A_txt Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''encoding T3''))
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = False in
     execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLI_i_T3enc_A_txt : mword ty1 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLI_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLI_i_T3enc_A_txt U imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = ((( 15 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n)))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_PLI_r_Op_A_txt : bool -> integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_PLI_r_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_PLI_r_Op_A_txt add m n shift_n shift_t = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:9066.54-9066.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   return ((Hint_PreloadInstr address)))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLI_r_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLI_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLI_r_A1enc_A_txt U Rn imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_PLI_r_Op_A_txt add m n shift_n shift_t))))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PLI_r_T1enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PLI_r_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PLI_r_T1enc_A_txt Rn imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''PLI (immediate, literal)''))
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (add :: bool) = True in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_PLI_r_Op_A_txt add m n shift_n shift_t))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_POP_Op_A_txt : bool -> mword ty16 -> M unit\<close>\<close>

definition execute_aarch32_instrs_POP_Op_A_txt  :: \<open> bool \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_POP_Op_A_txt UnalignedAllowed registers1 = (
   (SP_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (if UnalignedAllowed then (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M)
          else (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
         R_set i w__2 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   ((if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      if UnalignedAllowed then
        if (((((subrange_vec_dec address (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
        then
          (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
          LoadWritePC w__3))
        else throw (Error_Unpredictable () )
      else
        (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) .  LoadWritePC w__4))
    else return () ) \<then>
   (if ((((vec_of_bits [access_vec_dec registers1 (( 13 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
    then
      (SP_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      SP_write ((add_vec_int w__5 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
    else return () )) \<then>
   (if ((((vec_of_bits [access_vec_dec registers1 (( 13 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
   then
     (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) .  SP_write w__6))
   else return () ))))))))\<close> 
  for  "UnalignedAllowed"  :: " bool " 
  and  "registers1"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_POP_T1enc_A_txt : mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_POP_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_POP_T1enc_A_txt P register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (registers1 :: 16 bits) =
       ((concat_vec ((concat_vec P ( 0b0000000 ::  7 Word.word)  ::  8 Word.word)) register_list  ::  16 Word.word)) in
     (let (UnalignedAllowed :: bool) = False in
     ((if ((((BitCount registers1)) < (( 1 :: int)::ii))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM
       (and_boolM
          (return ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))) ((InITBlock () )))
       (LastInITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_POP_Op_A_txt UnalignedAllowed registers1))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "register_list"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_PUSH_Op_A_txt : bool -> mword ty16 -> M unit\<close>\<close>

definition execute_aarch32_instrs_PUSH_Op_A_txt  :: \<open> bool \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_PUSH_Op_A_txt UnalignedAllowed registers1 = (
   (SP_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) =
     ((sub_vec_int w__0 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (if ((((((i = (( 13 :: int)::ii)))) \<and> (((i \<noteq> ((LowestSetBit registers1)))))))) then
            (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
            MemA_set address (( 4 :: int)::ii) w__1))
          else if UnalignedAllowed then
            (R_read i  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  MemU_set address (( 4 :: int)::ii) w__2))
          else
            (R_read i  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) .  MemA_set address (( 4 :: int)::ii) w__3))) \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   ((if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      if UnalignedAllowed then
        (PCStoreValue ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
        MemU_set address (( 4 :: int)::ii) w__4))
      else
        (PCStoreValue ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
        MemA_set address (( 4 :: int)::ii) w__5))
    else return () ) \<then>
   (SP_read__1 ()   :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   SP_write ((sub_vec_int w__6 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))))))))))\<close> 
  for  "UnalignedAllowed"  :: " bool " 
  and  "registers1"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_PUSH_T1enc_A_txt : mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_PUSH_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PUSH_T1enc_A_txt M register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (registers1 :: 16 bits) =
       ((concat_vec
          ((concat_vec ((concat_vec ( 0b0 ::  1 Word.word) M  ::  2 Word.word)) ( 0b000000 ::  6 Word.word)
             ::  8 Word.word)) register_list
         ::  16 Word.word)) in
     (let (UnalignedAllowed :: bool) = False in
     (if ((((BitCount registers1)) < (( 1 :: int)::ii))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_PUSH_Op_A_txt UnalignedAllowed registers1))
   else return () )))\<close> 
  for  "M"  :: "(1)Word.word " 
  and  "register_list"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QADD16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QADD16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QADD16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (SignedSat sum1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (SignedSat sum2 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QADD16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QADD16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QADD16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9257.29-9257.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QADD16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QADD16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QADD16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QADD16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QADD16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QADD8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QADD8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QADD8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let sum3 =
     (((Word.sint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let sum4 =
     (((Word.sint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (SignedSat sum1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__9 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii) w__9  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (SignedSat sum2 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__11 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__10 (( 15 :: int)::ii) (( 8 :: int)::ii) w__11  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
   (SignedSat sum3 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__13 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__12 (( 23 :: int)::ii) (( 16 :: int)::ii) w__13  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
   (SignedSat sum4 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__15 ::  8 Word.word) . 
   R_set d ((update_subrange_vec_dec w__14 (( 31 :: int)::ii) (( 24 :: int)::ii) w__15  ::  32 Word.word)))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QADD8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QADD8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QADD8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9324.29-9324.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QADD8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QADD8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QADD8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QADD8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QADD8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QADD_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QADD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QADD_Op_A_txt d m n = (
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (SignedSatQ ((((Word.sint w__0)) + ((Word.sint w__1)))) (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 32
     bits), (tup_10 :: bool)) = varstup in
   R_set d tup_00 \<then>
   ((let (sat :: bool) = tup_10 in
   if sat then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     write_reg PSTATE_ref ( w__2 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () ))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QADD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QADD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QADD_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9395.29-9395.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QADD_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QADD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QADD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QADD_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QADD_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QASX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QASX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QASX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (SignedSat diff (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (SignedSat sum1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QASX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QASX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QASX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9458.29-9458.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QASX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QASX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QASX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QASX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QASX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QDADD_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QDADD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QDADD_Op_A_txt d m n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (doubled :: 32 bits) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (SignedSatQ (((( 2 :: int)::ii) * ((Word.sint w__0)))) (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> (w__1 ::
     ( 32 Word.word * bool)) . 
   (let (tup__0, tup__1) = w__1 in
   (let (doubled :: 32 bits) = tup__0 in
   (let (sat1 :: bool) = tup__1 in
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (SignedSatQ ((((Word.sint w__2)) + ((Word.sint doubled)))) (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 32
     bits), (tup_10 :: bool)) = varstup in
   R_set d tup_00 \<then>
   ((let (sat2 :: bool) = tup_10 in
   if (((sat1 \<or> sat2))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QDADD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QDADD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QDADD_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9532.29-9532.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QDADD_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QDADD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QDADD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QDADD_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QDADD_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QDSUB_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QDSUB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QDSUB_Op_A_txt d m n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (doubled :: 32 bits) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (SignedSatQ (((( 2 :: int)::ii) * ((Word.sint w__0)))) (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> (w__1 ::
     ( 32 Word.word * bool)) . 
   (let (tup__0, tup__1) = w__1 in
   (let (doubled :: 32 bits) = tup__0 in
   (let (sat1 :: bool) = tup__1 in
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (SignedSatQ ((((Word.sint w__2)) - ((Word.sint doubled)))) (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 32
     bits), (tup_10 :: bool)) = varstup in
   R_set d tup_00 \<then>
   ((let (sat2 :: bool) = tup_10 in
   if (((sat1 \<or> sat2))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QDSUB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QDSUB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QDSUB_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9606.29-9606.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QDSUB_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QDSUB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QDSUB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QDSUB_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QDSUB_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QSAX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QSAX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QSAX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (SignedSat sum1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (SignedSat diff (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSAX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSAX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSAX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9669.29-9669.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSAX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSAX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSAX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSAX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSAX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QSUB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QSUB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QSUB16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (SignedSat diff1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (SignedSat diff2 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSUB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSUB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSUB16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9732.29-9732.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSUB16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSUB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSUB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSUB16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSUB16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QSUB8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QSUB8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QSUB8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let diff3 =
     (((Word.sint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let diff4 =
     (((Word.sint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (SignedSat diff1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__9 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii) w__9  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (SignedSat diff2 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__11 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__10 (( 15 :: int)::ii) (( 8 :: int)::ii) w__11  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
   (SignedSat diff3 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__13 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__12 (( 23 :: int)::ii) (( 16 :: int)::ii) w__13  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
   (SignedSat diff4 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__15 ::  8 Word.word) . 
   R_set d ((update_subrange_vec_dec w__14 (( 31 :: int)::ii) (( 24 :: int)::ii) w__15  ::  32 Word.word)))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSUB8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSUB8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSUB8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9799.29-9799.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSUB8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSUB8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSUB8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSUB8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSUB8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_QSUB_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_QSUB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_QSUB_Op_A_txt d m n = (
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (SignedSatQ ((((Word.sint w__0)) - ((Word.sint w__1)))) (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 32
     bits), (tup_10 :: bool)) = varstup in
   R_set d tup_00 \<then>
   ((let (sat :: bool) = tup_10 in
   if sat then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     write_reg PSTATE_ref ( w__2 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () ))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSUB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSUB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSUB_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9870.29-9870.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSUB_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_QSUB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_QSUB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_QSUB_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_QSUB_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RBIT_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_RBIT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RBIT_Op_A_txt d m = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 31 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) result
     ((\<lambda> i result . 
       (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
       (let result =
         ((update_vec_dec result (((( 31 :: int)::ii) - i))
            ((Bit (vec_of_bits [access_vec_dec w__0 i]  ::  1 Word.word)))
           ::  32 Word.word)) in
       return result)))))) \<bind> ((\<lambda> (result ::  32 Word.word) . 
   R_set d result)))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_RBIT_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RBIT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RBIT_A1enc_A_txt cond Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9934.29-9934.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RBIT_Op_A_txt d m)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_RBIT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RBIT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RBIT_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let n = (Word.uint Rn) in
     (if (((((((((m \<noteq> n))) \<or> (((d = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RBIT_Op_A_txt d m)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_REV16_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_REV16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_REV16_Op_A_txt d m = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 31 :: int)::ii) (( 24 :: int)::ii)
        ((subrange_vec_dec w__0 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 23 :: int)::ii) (( 16 :: int)::ii)
        ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 15 :: int)::ii) (( 8 :: int)::ii)
        ((subrange_vec_dec w__2 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 7 :: int)::ii) (( 0 :: int)::ii)
        ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   R_set d result)))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_REV16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REV16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REV16_A1enc_A_txt cond Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:9997.29-9997.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_REV16_Op_A_txt d m)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_REV16_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REV16_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REV16_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     execute_aarch32_instrs_REV16_Op_A_txt d m))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_REV16_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REV16_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REV16_T2enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let n = (Word.uint Rn) in
     (if (((((((((m \<noteq> n))) \<or> (((d = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_REV16_Op_A_txt d m)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_REV_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_REV_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_REV_Op_A_txt d m = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 31 :: int)::ii) (( 24 :: int)::ii)
        ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 23 :: int)::ii) (( 16 :: int)::ii)
        ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 15 :: int)::ii) (( 8 :: int)::ii)
        ((subrange_vec_dec w__2 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 7 :: int)::ii) (( 0 :: int)::ii)
        ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   R_set d result)))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_REV_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REV_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REV_A1enc_A_txt cond Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10078.29-10078.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_REV_Op_A_txt d m)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_REV_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REV_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REV_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     execute_aarch32_instrs_REV_Op_A_txt d m))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_REV_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REV_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REV_T2enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let n = (Word.uint Rn) in
     (if (((((((((m \<noteq> n))) \<or> (((d = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_REV_Op_A_txt d m)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_REVSH_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_REVSH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_REVSH_Op_A_txt d m = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 31 :: int)::ii) (( 8 :: int)::ii)
        ((sign_extend ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 24 :: int)::ii)  ::  24 Word.word))
       ::  32 Word.word)) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let result =
     ((update_subrange_vec_dec result (( 7 :: int)::ii) (( 0 :: int)::ii)
        ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
       ::  32 Word.word)) in
   R_set d result)))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_REVSH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REVSH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REVSH_A1enc_A_txt cond Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10157.29-10157.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_REVSH_Op_A_txt d m)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_REVSH_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REVSH_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REVSH_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     execute_aarch32_instrs_REVSH_Op_A_txt d m))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_REVSH_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_REVSH_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_REVSH_T2enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let n = (Word.uint Rn) in
     (if (((((((((m \<noteq> n))) \<or> (((d = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_REVSH_Op_A_txt d m)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ROR_r_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_ROR_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ROR_r_Op_A_txt d m n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 SRType_ROR shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (result :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |))))))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_ROR_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ROR_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ROR_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     execute_aarch32_instrs_ROR_r_Op_A_txt d m n setflags))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RSB_i_Op_A_txt : integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_RSB_i_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RSB_i_Op_A_txt d imm32 n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry ((not_vec w__0  ::  32 Word.word)) imm32 ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSB_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSB_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSB_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10286.29-10286.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_RSB_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSB_i_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSB_i_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSB_i_T1enc_A_txt Rn Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (imm32 :: 32 bits) = ((Zeros (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_RSB_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "Rn"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSB_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSB_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSB_i_T2enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RSB_i_Op_A_txt d imm32 n setflags)))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RSB_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_RSB_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RSB_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:10360.54-10360.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry ((not_vec w__2  ::  32 Word.word)) shifted ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__6 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSB_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSB_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSB_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10382.29-10382.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_RSB_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSB_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSB_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSB_r_T1enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_RSB_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RSB_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_RSB_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RSB_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry ((not_vec w__3  ::  32 Word.word)) shifted ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () ))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSB_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSB_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSB_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10467.29-10467.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RSB_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RSC_i_Op_A_txt : integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_RSC_i_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RSC_i_Op_A_txt d imm32 n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry ((not_vec w__0  ::  32 Word.word)) imm32(ProcState_C   w__1)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__5 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSC_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSC_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSC_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10521.29-10521.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_RSC_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RSC_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_RSC_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RSC_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:10548.54-10548.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry ((not_vec w__2  ::  32 Word.word)) shifted(ProcState_C   w__3)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSC_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSC_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSC_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10570.29-10570.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_RSC_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RSC_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_RSC_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RSC_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry ((not_vec w__3  ::  32 Word.word)) shifted(ProcState_C   w__4)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__7 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__8 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () ))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_RSC_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RSC_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RSC_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10617.29-10617.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RSC_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SADD16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SADD16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SADD16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((sum1 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((sum2 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SADD16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SADD16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SADD16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10661.29-10661.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SADD16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SADD16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SADD16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SADD16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SADD16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SADD8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SADD8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SADD8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let sum3 =
     (((Word.sint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let sum4 =
     (((Word.sint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange sum2 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum3 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange sum4 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__12 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__13 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__12 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__13) (( 0 :: int)::ii) (( 0 :: int)::ii)
             (if ((sum1 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__14 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__15 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__14 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__15) (( 1 :: int)::ii) (( 1 :: int)::ii)
             (if ((sum2 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__16 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__17 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__16 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__17) (( 2 :: int)::ii) (( 2 :: int)::ii)
             (if ((sum3 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__18 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__19 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__18 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__19) (( 3 :: int)::ii) (( 3 :: int)::ii)
             (if ((sum4 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SADD8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SADD8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SADD8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10732.29-10732.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SADD8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SADD8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SADD8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SADD8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SADD8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SASX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SASX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SASX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((diff \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((sum1 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SASX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SASX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SASX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10797.29-10797.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SASX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SASX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SASX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SASX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SASX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SB_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_SB_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_SB_Op_A_txt _ = ( SpeculationBarrier ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SB_A1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SB_A1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SB_A1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_SB_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SB_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SB_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SB_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     return ((execute_aarch32_instrs_SB_Op_A_txt () ))))
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_SBC_i_Op_A_txt : integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SBC_i_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SBC_i_Op_A_txt d imm32 n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__0 ((not_vec imm32  ::  32 Word.word))(ProcState_C   w__1)  :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__5 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBC_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBC_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBC_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10917.29-10917.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_SBC_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBC_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBC_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBC_i_T1enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SBC_i_Op_A_txt d imm32 n setflags)))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SBC_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_SBC_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SBC_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:10971.54-10971.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__2 ((not_vec shifted  ::  32 Word.word))(ProcState_C   w__3)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBC_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBC_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBC_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:10993.29-10993.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_SBC_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBC_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBC_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBC_r_T1enc_A_txt Rm Rdn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_SBC_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rdn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBC_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBC_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBC_r_T2enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_SBC_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SBC_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_SBC_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SBC_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__3 ((not_vec shifted  ::  32 Word.word))(ProcState_C   w__4)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__7 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__8 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () ))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBC_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBC_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBC_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11102.29-11102.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SBC_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SBFX_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SBFX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SBFX_Op_A_txt d lsbit n widthminus1 = (
   (let msbit = (lsbit + widthminus1) in
   if ((msbit \<le> (( 31 :: int)::ii))) then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     R_set d ((sext_subrange (( 32 :: int)::ii) w__0 msbit lsbit  ::  32 Word.word))))
   else throw (Error_Unpredictable () )))\<close> 
  for  "d"  :: " int " 
  and  "lsbit"  :: " int " 
  and  "n"  :: " int " 
  and  "widthminus1"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBFX_A1enc_A_txt : mword ty4 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBFX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBFX_A1enc_A_txt cond widthm1 Rd lsb1 Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11146.29-11146.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let lsbit = (Word.uint lsb1) in
     (let widthminus1 = (Word.uint widthm1) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SBFX_Op_A_txt d lsbit n widthminus1)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "widthm1"  :: "(5)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "lsb1"  :: "(5)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SBFX_T1enc_A_txt : mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SBFX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SBFX_T1enc_A_txt Rn imm3 Rd imm2 widthm1 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let lsbit = (Word.uint ((concat_vec imm3 imm2  ::  5 Word.word))) in
     (let widthminus1 = (Word.uint widthm1) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SBFX_Op_A_txt d lsbit n widthminus1))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "widthm1"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SDIV_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SDIV_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SDIV_Op_A_txt d m n = (
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (if (((((Word.sint w__0)) = (( 0 :: int)::ii)))) then return (( 0 :: int)::ii)
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (let result = (RoundTowardsZero (((((real_of_int ((Word.sint w__1))))) div (((real_of_int ((Word.sint w__2)))))))) in
      return result)))))) \<bind> ((\<lambda> (result :: ii) . 
   (let result = result in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SDIV_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SDIV_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SDIV_A1enc_A_txt cond Rd Ra Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11218.29-11218.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a \<noteq> (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SDIV_Op_A_txt d m n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SDIV_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SDIV_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SDIV_T1enc_A_txt Rn Ra Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a \<noteq> (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SDIV_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SEL_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SEL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SEL_Op_A_txt d m n = (
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (if ((((vec_of_bits [access_vec_dec(ProcState_GE   w__1) (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((subrange_vec_dec w__2 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((subrange_vec_dec w__3 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) \<bind> ((\<lambda> (w__4 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii) w__4  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__6 :: ProcState) . 
   (if ((((vec_of_bits [access_vec_dec(ProcState_GE   w__6) (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
      return ((subrange_vec_dec w__7 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
      return ((subrange_vec_dec w__8 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) \<bind> ((\<lambda> (w__9 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__5 (( 15 :: int)::ii) (( 8 :: int)::ii) w__9  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__11 :: ProcState) . 
   (if ((((vec_of_bits [access_vec_dec(ProcState_GE   w__11) (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
      return ((subrange_vec_dec w__12 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
      return ((subrange_vec_dec w__13 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) \<bind> ((\<lambda> (w__14 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii) w__14  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__16 :: ProcState) . 
   (if ((((vec_of_bits [access_vec_dec(ProcState_GE   w__16) (( 3 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
      return ((subrange_vec_dec w__17 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
      return ((subrange_vec_dec w__18 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) \<bind> ((\<lambda> (w__19 ::  8 Word.word) . 
   R_set d ((update_subrange_vec_dec w__15 (( 31 :: int)::ii) (( 24 :: int)::ii) w__19  ::  32 Word.word)))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SEL_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEL_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11293.29-11293.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SEL_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SEL_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEL_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SEL_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SETEND_Op_A_txt : bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SETEND_Op_A_txt  :: \<open> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SETEND_Op_A_txt set_bigend = (
   (AArch32_CheckSETENDEnabled ()  \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__0 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__0 (| ProcState_E := (if set_bigend then ( 0b1 ::  1 Word.word) else ( 0b0 ::  1 Word.word)) |)))))\<close> 
  for  "set_bigend"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SETEND_A1enc_A_txt : mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SETEND_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SETEND_A1enc_A_txt E = (
   (let (set_bigend :: bool) = (E = ( 0b1 ::  1 Word.word)) in
   execute_aarch32_instrs_SETEND_Op_A_txt set_bigend))\<close> 
  for  "E"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SETEND_T1enc_A_txt : mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SETEND_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SETEND_T1enc_A_txt E = (
   (let (set_bigend :: bool) = (E = ( 0b1 ::  1 Word.word)) in
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_SETEND_Op_A_txt set_bigend))))\<close> 
  for  "E"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SEV_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_SEV_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_SEV_Op_A_txt _ = ( SendEvent ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SEV_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEV_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEV_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11396.29-11396.30'') \<then>
     return ((execute_aarch32_instrs_SEV_Op_A_txt () ))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SEV_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEV_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEV_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_SEV_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SEV_T2enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEV_T2enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEV_T2enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_SEV_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_SHADD16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHADD16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHADD16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum2 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHADD16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHADD16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHADD16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11459.29-11459.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHADD16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHADD16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHADD16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHADD16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHADD16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHADD8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHADD8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHADD8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let sum3 =
     (((Word.sint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let sum4 =
     (((Word.sint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange sum2 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum3 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange sum4 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHADD8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHADD8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHADD8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11526.29-11526.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHADD8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHADD8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHADD8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHADD8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHADD8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHASX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHASX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHASX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHASX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHASX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHASX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11589.29-11589.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHASX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHASX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHASX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHASX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHASX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHSAX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHSAX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHSAX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHSAX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHSAX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHSAX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11652.29-11652.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHSAX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHSAX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHSAX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHSAX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHSAX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHSUB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHSUB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHSUB16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff2 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHSUB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHSUB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHSUB16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11715.29-11715.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHSUB16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHSUB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHSUB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHSUB16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHSUB16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHSUB8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHSUB8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHSUB8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let diff3 =
     (((Word.sint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let diff4 =
     (((Word.sint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange diff2 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff3 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange diff4 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHSUB8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHSUB8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHSUB8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11782.29-11782.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHSUB8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHSUB8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHSUB8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHSUB8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SHSUB8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLABB_Op_A_txt : integer -> integer -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLABB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLABB_Op_A_txt a d m m_high n n_high = (
   (if n_high then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand1 :: 16 bits) . 
   (if m_high then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand2 :: 16 bits) . 
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let result = (((((Word.sint operand1)) * ((Word.sint operand2)))) + ((Word.sint w__4))) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
   (if (((result \<noteq> ((Word.sint ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_high"  :: " bool " 
  and  "n"  :: " int " 
  and  "n_high"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLABB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLABB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLABB_A1enc_A_txt cond Rd Ra Rm M N Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11851.29-11851.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (n_high :: bool) = (N = ( 0b1 ::  1 Word.word)) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLABB_Op_A_txt a d m m_high n n_high)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLABB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLABB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLABB_T1enc_A_txt Rn Ra Rd N M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMULBB, SMULBT, SMULTB, SMULTT''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (n_high :: bool) = (N = ( 0b1 ::  1 Word.word)) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLABB_Op_A_txt a d m m_high n n_high)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLAD_Op_A_txt : integer -> integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLAD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLAD_Op_A_txt a d m m_swap n = (
   (if m_swap then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((ROR w__0 (( 16 :: int)::ii)  ::  32 Word.word))))
    else (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (operand2 :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let product1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let product2 =
     (((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let result = (((product1 + product2)) + ((Word.sint w__4))) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
   (if (((result \<noteq> ((Word.sint ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_swap"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLAD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLAD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLAD_A1enc_A_txt cond Rd Ra Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:11930.29-11930.30'') \<then>
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMUAD''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLAD_Op_A_txt a d m m_swap n))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLAD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLAD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLAD_T1enc_A_txt Rn Ra Rd M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMUAD''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLAD_Op_A_txt a d m m_swap n))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLAL_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLAL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLAL_Op_A_txt dHi dLo m n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_read dHi  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read dLo  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let result =
     (((((Word.sint w__0)) * ((Word.sint w__1)))) +
       ((Word.sint ((concat_vec w__2 w__3  ::  64 Word.word))))) in
   (R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [integer_access result (( 63 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__5 (|
         ProcState_Z :=
           ((IsZeroBit ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))  ::  1 Word.word)) |))))))
   else return () )))))))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLAL_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLAL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLAL_A1enc_A_txt cond S RdHi RdLo Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12007.29-12007.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLAL_Op_A_txt dHi dLo m n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLAL_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLAL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLAL_T1enc_A_txt Rn RdLo RdHi Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLAL_Op_A_txt dHi dLo m n setflags)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLALBB_Op_A_txt : integer -> integer -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLALBB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLALBB_Op_A_txt dHi dLo m m_high n n_high = (
   (if n_high then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand1 :: 16 bits) . 
   (if m_high then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand2 :: 16 bits) . 
   (R_read dHi  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read dLo  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let result =
     (((((Word.sint operand1)) * ((Word.sint operand2)))) +
       ((Word.sint ((concat_vec w__4 w__5  ::  64 Word.word))))) in
   R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "m_high"  :: " bool " 
  and  "n"  :: " int " 
  and  "n_high"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLALBB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLALBB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLALBB_A1enc_A_txt cond RdHi RdLo Rm M N Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12082.29-12082.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (n_high :: bool) = (N = ( 0b1 ::  1 Word.word)) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLALBB_Op_A_txt dHi dLo m m_high n n_high)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLALBB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLALBB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLALBB_T1enc_A_txt Rn RdLo RdHi N M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (n_high :: bool) = (N = ( 0b1 ::  1 Word.word)) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLALBB_Op_A_txt dHi dLo m m_high n n_high))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLALD_Op_A_txt : integer -> integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLALD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLALD_Op_A_txt dHi dLo m m_swap n = (
   (if m_swap then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((ROR w__0 (( 16 :: int)::ii)  ::  32 Word.word))))
    else (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (operand2 :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let product1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let product2 =
     (((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read dHi  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read dLo  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let result =
     (((product1 + product2)) + ((Word.sint ((concat_vec w__4 w__5  ::  64 Word.word))))) in
   R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "m_swap"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLALD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLALD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLALD_A1enc_A_txt cond RdHi RdLo Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12161.29-12161.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLALD_Op_A_txt dHi dLo m m_swap n))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLALD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLALD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLALD_T1enc_A_txt Rn RdLo RdHi M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLALD_Op_A_txt dHi dLo m m_swap n)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLAWB_Op_A_txt : integer -> integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLAWB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLAWB_Op_A_txt a d m m_high n = (
   (if m_high then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand2 :: 16 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let result =
     (((((Word.sint w__2)) * ((Word.sint operand2)))) + ((shl_int ((Word.sint w__3)) (( 16 :: int)::ii)))) in
   (R_set d ((integer_subrange result (( 47 :: int)::ii) (( 16 :: int)::ii)  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   if (((((shr_int result (( 16 :: int)::ii))) \<noteq> ((Word.sint w__4))))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () ))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_high"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLAWB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLAWB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLAWB_A1enc_A_txt cond Rd Ra Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12238.29-12238.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLAWB_Op_A_txt a d m m_high n))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLAWB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLAWB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLAWB_T1enc_A_txt Rn Ra Rd M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMULWB, SMULWT''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLAWB_Op_A_txt a d m m_high n))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLSD_Op_A_txt : integer -> integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLSD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLSD_Op_A_txt a d m m_swap n = (
   (if m_swap then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((ROR w__0 (( 16 :: int)::ii)  ::  32 Word.word))))
    else (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (operand2 :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let product1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let product2 =
     (((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let result = (((product1 - product2)) + ((Word.sint w__4))) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
   (if (((result \<noteq> ((Word.sint ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref ( w__5 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_swap"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLSD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLSD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLSD_A1enc_A_txt cond Rd Ra Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12313.29-12313.30'') \<then>
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMUSD''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLSD_Op_A_txt a d m m_swap n))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLSD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLSD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLSD_T1enc_A_txt Rn Ra Rd M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMUSD''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMLSD_Op_A_txt a d m m_swap n))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMLSLD_Op_A_txt : integer -> integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMLSLD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMLSLD_Op_A_txt dHi dLo m m_swap n = (
   (if m_swap then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((ROR w__0 (( 16 :: int)::ii)  ::  32 Word.word))))
    else (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (operand2 :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let product1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let product2 =
     (((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read dHi  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read dLo  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let result =
     (((product1 - product2)) + ((Word.sint ((concat_vec w__4 w__5  ::  64 Word.word))))) in
   R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "m_swap"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLSLD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLSLD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLSLD_A1enc_A_txt cond RdHi RdLo Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12388.29-12388.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLSLD_Op_A_txt dHi dLo m m_swap n))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMLSLD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMLSLD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMLSLD_T1enc_A_txt Rn RdLo RdHi M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMLSLD_Op_A_txt dHi dLo m m_swap n)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMMLA_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMMLA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMMLA_Op_A_txt a d m n round1 = (
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (result :: ii) =
     (((shl_int ((Word.sint w__0)) (( 32 :: int)::ii))) + ((((Word.sint w__1)) * ((Word.sint w__2))))) in
   (let (result :: ii) =
     (if round1 then result + ((Word.uint ( 0x80000000 ::  32 Word.word)))
     else result) in
   (let result = result in
   R_set d ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "round1"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMMLA_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMMLA_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMMLA_A1enc_A_txt cond Rd Ra Rm R Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12463.29-12463.30'') \<then>
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMMUL''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (round1 :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMMLA_Op_A_txt a d m n round1))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMMLA_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMMLA_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMMLA_T1enc_A_txt Rn Ra Rd R Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SMMUL''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (round1 :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMMLA_Op_A_txt a d m n round1))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMMLS_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMMLS_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMMLS_Op_A_txt a d m n round1 = (
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (result :: ii) =
     (((shl_int ((Word.sint w__0)) (( 32 :: int)::ii))) - ((((Word.sint w__1)) * ((Word.sint w__2))))) in
   (let (result :: ii) =
     (if round1 then result + ((Word.uint ( 0x80000000 ::  32 Word.word)))
     else result) in
   (let result = result in
   R_set d ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "round1"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMMLS_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMMLS_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMMLS_A1enc_A_txt cond Rd Ra Rm R Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12538.29-12538.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (round1 :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMMLS_Op_A_txt a d m n round1))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMMLS_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMMLS_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMMLS_T1enc_A_txt Rn Ra Rd R Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (let (round1 :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMMLS_Op_A_txt a d m n round1)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMMUL_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMMUL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMMUL_Op_A_txt d m n round1 = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let (result :: ii) = (((Word.sint w__0)) * ((Word.sint w__1))) in
   (let (result :: ii) =
     (if round1 then result + ((Word.uint ( 0x80000000 ::  32 Word.word)))
     else result) in
   (let result = result in
   R_set d ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "round1"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMMUL_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMMUL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMMUL_A1enc_A_txt cond Rd Rm R Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12607.29-12607.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (round1 :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMMUL_Op_A_txt d m n round1)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMMUL_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMMUL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMMUL_T1enc_A_txt Rn Rd R Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (round1 :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMMUL_Op_A_txt d m n round1))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMUAD_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMUAD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMUAD_Op_A_txt d m m_swap n = (
   (if m_swap then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((ROR w__0 (( 16 :: int)::ii)  ::  32 Word.word))))
    else (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (operand2 :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let product1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let product2 =
     (((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (let result = (product1 + product2) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
   (if (((result \<noteq> ((Word.sint ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg PSTATE_ref ( w__4 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_swap"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMUAD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMUAD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMUAD_A1enc_A_txt cond Rd Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12675.29-12675.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMUAD_Op_A_txt d m m_swap n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMUAD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMUAD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMUAD_T1enc_A_txt Rn Rd M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMUAD_Op_A_txt d m m_swap n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMULBB_Op_A_txt : integer -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMULBB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMULBB_Op_A_txt d m m_high n n_high = (
   (if n_high then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand1 :: 16 bits) . 
   (if m_high then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand2 :: 16 bits) . 
   (let result = (((Word.sint operand1)) * ((Word.sint operand2))) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_high"  :: " bool " 
  and  "n"  :: " int " 
  and  "n_high"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMULBB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMULBB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMULBB_A1enc_A_txt cond Rd Rm M N Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12740.29-12740.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (n_high :: bool) = (N = ( 0b1 ::  1 Word.word)) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMULBB_Op_A_txt d m m_high n n_high))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMULBB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMULBB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMULBB_T1enc_A_txt Rn Rd N M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (n_high :: bool) = (N = ( 0b1 ::  1 Word.word)) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMULBB_Op_A_txt d m m_high n n_high)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMULL_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMULL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMULL_Op_A_txt dHi dLo m n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let result = (((Word.sint w__0)) * ((Word.sint w__1))) in
   (R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_N := ((vec_of_bits [integer_access result (( 63 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__3 (|
         ProcState_Z :=
           ((IsZeroBit ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))  ::  1 Word.word)) |))))))
   else return () )))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMULL_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMULL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMULL_A1enc_A_txt cond S RdHi RdLo Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12815.29-12815.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMULL_Op_A_txt dHi dLo m n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMULL_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMULL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMULL_T1enc_A_txt Rn RdLo RdHi Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_SMULL_Op_A_txt dHi dLo m n setflags)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMULWB_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMULWB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMULWB_Op_A_txt d m m_high n = (
   (if m_high then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))
    else
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (operand2 :: 16 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let product = (((Word.sint w__2)) * ((Word.sint operand2))) in
   R_set d ((integer_subrange product (( 47 :: int)::ii) (( 16 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_high"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMULWB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMULWB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMULWB_A1enc_A_txt cond Rd Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12887.29-12887.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMULWB_Op_A_txt d m m_high n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMULWB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMULWB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMULWB_T1enc_A_txt Rn Rd M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_high :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMULWB_Op_A_txt d m m_high n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMUSD_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMUSD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMUSD_Op_A_txt d m m_swap n = (
   (if m_swap then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((ROR w__0 (( 16 :: int)::ii)  ::  32 Word.word))))
    else (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (operand2 :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let product1 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let product2 =
     (((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) *
       ((Word.sint ((subrange_vec_dec operand2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (let result = (product1 - product2) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "m_swap"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMUSD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMUSD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMUSD_A1enc_A_txt cond Rd Rm M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:12955.29-12955.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMUSD_Op_A_txt d m m_swap n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMUSD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMUSD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMUSD_T1enc_A_txt Rn Rd M Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (m_swap :: bool) = (M = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMUSD_Op_A_txt d m m_swap n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SSAT16_Op_A_txt : forall 'saturate_to. Size 'saturate_to => integer -> integer -> itself 'saturate_to -> M unit\<close>\<close>

definition execute_aarch32_instrs_SSAT16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('saturate_to::len)itself \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SSAT16_Op_A_txt d n saturate_to = (
   (let saturate_to = (size_itself_int saturate_to) in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 saturate_to))  :: (( 'saturate_to::len)Word.word) M) \<bind> ((\<lambda> (result1 ::
     ( 'saturate_to::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 saturate_to))  :: (( 'saturate_to::len)Word.word) M) \<bind> ((\<lambda> (result2 ::
     ( 'saturate_to::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (SignedSatQ ((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) saturate_to
     :: ((( 'saturate_to::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__1 :: (( 'saturate_to::len)Word.word * bool)) . 
   (let (tup__0, tup__1) = w__1 in
   (let (result1 :: ( 'saturate_to::len)Word.word) = tup__0 in
   (let (sat1 :: bool) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (SignedSatQ ((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) saturate_to
     :: ((( 'saturate_to::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__3 :: (( 'saturate_to::len)Word.word * bool)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (result2 :: ( 'saturate_to::len)Word.word) = tup__0 in
   (let (sat2 :: bool) = tup__1 in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) ((sign_extend result1 (( 16 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii) ((sign_extend result2 (( 16 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (if (((sat1 \<or> sat2))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "saturate_to"  :: "('saturate_to::len)itself "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSAT16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSAT16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSAT16_A1enc_A_txt cond b__0 Rd Rn = (
   if (((b__0 = ( 0x0 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 1 :: int)::ii)  ::  1 itself)))))
     else return () ))
   else if (((b__0 = ( 0x1 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 2 :: int)::ii)  ::  2 itself)))))
     else return () ))
   else if (((b__0 = ( 0x2 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 3 :: int)::ii)  ::  3 itself)))))
     else return () ))
   else if (((b__0 = ( 0x3 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 4 :: int)::ii)  ::  4 itself)))))
     else return () ))
   else if (((b__0 = ( 0x4 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 5 :: int)::ii)  ::  5 itself)))))
     else return () ))
   else if (((b__0 = ( 0x5 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
     if w__5 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 6 :: int)::ii)  ::  6 itself)))))
     else return () ))
   else if (((b__0 = ( 0x6 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 7 :: int)::ii)  ::  7 itself)))))
     else return () ))
   else if (((b__0 = ( 0x7 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__7 :: bool) . 
     if w__7 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 8 :: int)::ii)  ::  8 itself)))))
     else return () ))
   else if (((b__0 = ( 0x8 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 9 :: int)::ii)  ::  9 itself)))))
     else return () ))
   else if (((b__0 = ( 0x9 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__9 :: bool) . 
     if w__9 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 10 :: int)::ii)  ::  10 itself)))))
     else return () ))
   else if (((b__0 = ( 0xA ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 11 :: int)::ii)  ::  11 itself)))))
     else return () ))
   else if (((b__0 = ( 0xB ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__11 :: bool) . 
     if w__11 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 12 :: int)::ii)  ::  12 itself)))))
     else return () ))
   else if (((b__0 = ( 0xC ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
     if w__12 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 13 :: int)::ii)  ::  13 itself)))))
     else return () ))
   else if (((b__0 = ( 0xD ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__13 :: bool) . 
     if w__13 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 14 :: int)::ii)  ::  14 itself)))))
     else return () ))
   else if (((b__0 = ( 0xE ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
     if w__14 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 15 :: int)::ii)  ::  15 itself)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__15 :: bool) . 
   if w__15 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13026.29-13026.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 16 :: int)::ii)  ::  16 itself)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "b__0"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSAT16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSAT16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSAT16_T1enc_A_txt Rn Rd b__0 = (
   if (((b__0 = ( 0x0 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 1 :: int)::ii)  ::  1 itself))))
     else return () ))
   else if (((b__0 = ( 0x1 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 2 :: int)::ii)  ::  2 itself))))
     else return () ))
   else if (((b__0 = ( 0x2 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 3 :: int)::ii)  ::  3 itself))))
     else return () ))
   else if (((b__0 = ( 0x3 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 4 :: int)::ii)  ::  4 itself))))
     else return () ))
   else if (((b__0 = ( 0x4 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 5 :: int)::ii)  ::  5 itself))))
     else return () ))
   else if (((b__0 = ( 0x5 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
     if w__5 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 6 :: int)::ii)  ::  6 itself))))
     else return () ))
   else if (((b__0 = ( 0x6 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 7 :: int)::ii)  ::  7 itself))))
     else return () ))
   else if (((b__0 = ( 0x7 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__7 :: bool) . 
     if w__7 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 8 :: int)::ii)  ::  8 itself))))
     else return () ))
   else if (((b__0 = ( 0x8 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 9 :: int)::ii)  ::  9 itself))))
     else return () ))
   else if (((b__0 = ( 0x9 ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__9 :: bool) . 
     if w__9 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 10 :: int)::ii)  ::  10 itself))))
     else return () ))
   else if (((b__0 = ( 0xA ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 11 :: int)::ii)  ::  11 itself))))
     else return () ))
   else if (((b__0 = ( 0xB ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__11 :: bool) . 
     if w__11 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 12 :: int)::ii)  ::  12 itself))))
     else return () ))
   else if (((b__0 = ( 0xC ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
     if w__12 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 13 :: int)::ii)  ::  13 itself))))
     else return () ))
   else if (((b__0 = ( 0xD ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__13 :: bool) . 
     if w__13 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 14 :: int)::ii)  ::  14 itself))))
     else return () ))
   else if (((b__0 = ( 0xE ::  4 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
     if w__14 then
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 15 :: int)::ii)  ::  15 itself))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__15 :: bool) . 
   if w__15 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSAT16_Op_A_txt d n ((make_the_value (( 16 :: int)::ii)  ::  16 itself))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "b__0"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SSAT_Op_A_txt : forall 'saturate_to. Size 'saturate_to => integer -> integer -> itself 'saturate_to -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_SSAT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('saturate_to::len)itself \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SSAT_Op_A_txt d n saturate_to shift_n shift_t = (
   (let saturate_to = (size_itself_int saturate_to) in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 saturate_to))  :: (( 'saturate_to::len)Word.word) M) \<bind> ((\<lambda> (result ::
     ( 'saturate_to::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:13085.54-13085.55'') \<then>
   (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (operand :: 32 bits) . 
   (SignedSatQ ((Word.sint operand)) saturate_to  :: ((( 'saturate_to::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__2 ::
     (( 'saturate_to::len)Word.word * bool)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (result :: ( 'saturate_to::len)Word.word) = tup__0 in
   (let (sat :: bool) = tup__1 in
   R_set d ((sign_extend result (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   (if sat then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () ))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "saturate_to"  :: "('saturate_to::len)itself " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSAT_A1enc_A_txt : mword ty4 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSAT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSAT_A1enc_A_txt cond b__0 Rd imm5 sh Rn = (
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__1 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__1 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__3 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__3 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__5 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__5 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 3 :: int)::ii)  ::  3 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__7 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__7 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 4 :: int)::ii)  ::  4 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__9 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__9 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__11 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__11 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 6 :: int)::ii)  ::  6 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
     if w__12 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__13 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__13 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 7 :: int)::ii)  ::  7 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
     if w__14 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__15 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__15 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__16 :: bool) . 
     if w__16 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__17 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__17 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 9 :: int)::ii)  ::  9 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__18 :: bool) . 
     if w__18 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__19 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__19 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 10 :: int)::ii)  ::  10 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__20 :: bool) . 
     if w__20 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__21 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__21 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 11 :: int)::ii)  ::  11 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__22 :: bool) . 
     if w__22 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__23 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__23 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 12 :: int)::ii)  ::  12 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__24 :: bool) . 
     if w__24 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__25 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__25 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 13 :: int)::ii)  ::  13 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__26 :: bool) . 
     if w__26 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__27 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__27 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 14 :: int)::ii)  ::  14 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__28 :: bool) . 
     if w__28 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__29 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__29 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 15 :: int)::ii)  ::  15 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__30 :: bool) . 
     if w__30 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__31 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__31 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__32 :: bool) . 
     if w__32 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__33 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__33 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 17 :: int)::ii)  ::  17 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__34 :: bool) . 
     if w__34 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__35 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__35 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 18 :: int)::ii)  ::  18 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__36 :: bool) . 
     if w__36 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__37 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__37 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 19 :: int)::ii)  ::  19 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__38 :: bool) . 
     if w__38 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__39 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__39 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 20 :: int)::ii)  ::  20 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__40 :: bool) . 
     if w__40 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__41 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__41 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 21 :: int)::ii)  ::  21 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__42 :: bool) . 
     if w__42 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__43 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__43 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 22 :: int)::ii)  ::  22 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__44 :: bool) . 
     if w__44 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__45 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__45 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 23 :: int)::ii)  ::  23 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__46 :: bool) . 
     if w__46 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__47 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__47 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 24 :: int)::ii)  ::  24 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__48 :: bool) . 
     if w__48 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__49 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__49 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 25 :: int)::ii)  ::  25 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__50 :: bool) . 
     if w__50 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__51 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__51 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 26 :: int)::ii)  ::  26 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__52 :: bool) . 
     if w__52 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__53 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__53 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 27 :: int)::ii)  ::  27 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__54 :: bool) . 
     if w__54 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__55 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__55 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 28 :: int)::ii)  ::  28 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__56 :: bool) . 
     if w__56 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__57 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__57 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 29 :: int)::ii)  ::  29 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__58 :: bool) . 
     if w__58 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__59 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__59 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 30 :: int)::ii)  ::  30 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__60 :: bool) . 
     if w__60 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__61 ::
         (SRType * ii)) . 
       (let (tup__0, tup__1) = w__61 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let shift_t = shift_t in
       (let shift_n = shift_n in
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 31 :: int)::ii)  ::  31 itself)) shift_n
         shift_t)))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__62 :: bool) . 
   if w__62 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13099.29-13099.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__63 ::
       (SRType * ii)) . 
     (let (tup__0, tup__1) = w__63 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift_n
       shift_t)))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "b__0"  :: "(5)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "sh"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSAT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSAT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSAT_T1enc_A_txt sh Rn imm3 Rd imm2 b__0 = (
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__1 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__3 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__3 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__5 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__5 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 3 :: int)::ii)  ::  3 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__7 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__7 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 4 :: int)::ii)  ::  4 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__9 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__9 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__11 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__11 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 6 :: int)::ii)  ::  6 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
     if w__12 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__13 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__13 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 7 :: int)::ii)  ::  7 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
     if w__14 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__15 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__15 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__16 :: bool) . 
     if w__16 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__17 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__17 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 9 :: int)::ii)  ::  9 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__18 :: bool) . 
     if w__18 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__19 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__19 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 10 :: int)::ii)  ::  10 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__20 :: bool) . 
     if w__20 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__21 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__21 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 11 :: int)::ii)  ::  11 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__22 :: bool) . 
     if w__22 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__23 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__23 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 12 :: int)::ii)  ::  12 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__24 :: bool) . 
     if w__24 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__25 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__25 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 13 :: int)::ii)  ::  13 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__26 :: bool) . 
     if w__26 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__27 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__27 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 14 :: int)::ii)  ::  14 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__28 :: bool) . 
     if w__28 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__29 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__29 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 15 :: int)::ii)  ::  15 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__30 :: bool) . 
     if w__30 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__31 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__31 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__32 :: bool) . 
     if w__32 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__33 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__33 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 17 :: int)::ii)  ::  17 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__34 :: bool) . 
     if w__34 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__35 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__35 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 18 :: int)::ii)  ::  18 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__36 :: bool) . 
     if w__36 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__37 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__37 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 19 :: int)::ii)  ::  19 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__38 :: bool) . 
     if w__38 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__39 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__39 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 20 :: int)::ii)  ::  20 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__40 :: bool) . 
     if w__40 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__41 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__41 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 21 :: int)::ii)  ::  21 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__42 :: bool) . 
     if w__42 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__43 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__43 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 22 :: int)::ii)  ::  22 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__44 :: bool) . 
     if w__44 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__45 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__45 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 23 :: int)::ii)  ::  23 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__46 :: bool) . 
     if w__46 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__47 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__47 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 24 :: int)::ii)  ::  24 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__48 :: bool) . 
     if w__48 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__49 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__49 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 25 :: int)::ii)  ::  25 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__50 :: bool) . 
     if w__50 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__51 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__51 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 26 :: int)::ii)  ::  26 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__52 :: bool) . 
     if w__52 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__53 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__53 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 27 :: int)::ii)  ::  27 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__54 :: bool) . 
     if w__54 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__55 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__55 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 28 :: int)::ii)  ::  28 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__56 :: bool) . 
     if w__56 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__57 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__57 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 29 :: int)::ii)  ::  29 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__58 :: bool) . 
     if w__58 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__59 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__59 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 30 :: int)::ii)  ::  30 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__60 :: bool) . 
     if w__60 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
       undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
       (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
          throw (Error_See (''SSAT16''))
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
         ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__61 :: (SRType * ii)) . 
       (let (tup__0, tup__1) = w__61 in
       (let (shift_t :: SRType) = tup__0 in
       (let (shift_n :: ii) = tup__1 in
       (let shift_n = shift_n in
       (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 31 :: int)::ii)  ::  31 itself)) shift_n
         shift_t)))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__62 :: bool) . 
   if w__62 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
        throw (Error_See (''SSAT16''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
       ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__63 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__63 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSAT_Op_A_txt d n ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift_n
       shift_t)))))))))))))
   else return () )))\<close> 
  for  "sh"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "b__0"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SSAX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SSAX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SSAX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.sint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((sum1 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((diff \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSAX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSAX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSAX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13182.29-13182.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSAX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSAX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSAX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSAX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSAX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SSUB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SSUB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SSUB16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((diff1 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((diff2 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSUB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSUB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSUB16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13247.29-13247.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSUB16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSUB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSUB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSUB16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSUB16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SSUB8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SSUB8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SSUB8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.sint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.sint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let diff3 =
     (((Word.sint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let diff4 =
     (((Word.sint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.sint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange diff2 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff3 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange diff4 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__12 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__13 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__12 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__13) (( 0 :: int)::ii) (( 0 :: int)::ii)
             (if ((diff1 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__14 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__15 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__14 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__15) (( 1 :: int)::ii) (( 1 :: int)::ii)
             (if ((diff2 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__16 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__17 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__16 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__17) (( 2 :: int)::ii) (( 2 :: int)::ii)
             (if ((diff3 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__18 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__19 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__18 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__19) (( 3 :: int)::ii) (( 3 :: int)::ii)
             (if ((diff4 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSUB8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSUB8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSUB8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13318.29-13318.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSUB8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SSUB8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSUB8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSUB8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SSUB8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STC_Op_A_txt : bool -> mword ty32 -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STC_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STC_Op_A_txt add imm32 index1 n wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   Halted ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   (if w__3 then
      (DBGDTR_EL0_read (((( 8 :: int)::ii) * (( 4 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      MemA_set address (( 4 :: int)::ii) w__4))
    else
    read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
    if ((((ProcState_EL   w__5) = EL0))) then
      and_boolM (ELUsingAArch32 EL1 \<bind> ((\<lambda> (w__6 :: bool) .  return ((\<not> w__6)))))
        ((read_reg MDSCR_EL1_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
         return (((((slice w__7 (( 12 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__8 ::
        bool) . 
      if w__8 then
        and_boolM
          (and_boolM ((EL2Enabled () ))
             (ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__10 :: bool) .  return ((\<not> w__10))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
           return (((((slice w__12 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
          bool) . 
        if w__13 then AArch64_AArch32SystemAccessTrap EL2 ((Word.uint ( 0x06 ::  8 Word.word)))
        else AArch64_AArch32SystemAccessTrap EL1 ((Word.uint ( 0x06 ::  8 Word.word)))))
      else
      and_boolM ((ELUsingAArch32 EL1))
        ((DBGDSCRext_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
         return (((((slice w__15 (( 12 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__16 ::
        bool) . 
      if w__16 then
        and_boolM
          (and_boolM ((EL2Enabled () ))
             (ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__18 :: bool) .  return ((\<not> w__18))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
           return (((((slice w__20 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__21 ::
          bool) . 
        if w__21 then AArch64_AArch32SystemAccessTrap EL2 ((Word.uint ( 0x06 ::  8 Word.word)))
        else
        and_boolM (and_boolM ((EL2Enabled () )) ((ELUsingAArch32 EL2)))
          ((HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
           return (((((slice w__25 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__26 ::
          bool) . 
        if w__26 then AArch32_TakeHypTrapException ((Word.uint ( 0x00 ::  8 Word.word)))
        else throw (Error_Undefined () )))))
      else
      and_boolM
        (and_boolM ((EL2Enabled () ))
           (ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__28 :: bool) .  return ((\<not> w__28))))))
        ((read_reg MDCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
         return (((((slice w__30 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__31 ::
        bool) . 
      if w__31 then AArch64_AArch32SystemAccessTrap EL2 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM (and_boolM ((EL2Enabled () )) ((ELUsingAArch32 EL2)))
        ((HDCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__35 ::  32 Word.word) . 
         return (((((slice w__35 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__36 ::
        bool) . 
      if w__36 then AArch32_TakeHypTrapException ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM
        (and_boolM ((EL2Enabled () ))
           (ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__38 :: bool) .  return ((\<not> w__38))))))
        (or_boolM
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__40 ::  64 Word.word) . 
            return (((((slice w__40 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
           ((read_reg MDCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__41 ::  64 Word.word) . 
            (read_reg MDCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__42 ::  64 Word.word) . 
            return (((((concat_vec ((slice w__41 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                           ((slice w__42 (( 9 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                          ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))))) \<bind> ((\<lambda> (w__44 :: bool) . 
      if w__44 then AArch64_AArch32SystemAccessTrap EL2 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM (and_boolM ((EL2Enabled () )) ((ELUsingAArch32 EL2)))
        (or_boolM
           ((HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__48 ::  32 Word.word) . 
            return (((((slice w__48 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
           ((HDCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__49 ::  32 Word.word) . 
            (HDCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__50 ::  32 Word.word) . 
            return (((((concat_vec ((slice w__49 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                           ((slice w__50 (( 9 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                          ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))))) \<bind> ((\<lambda> (w__52 :: bool) . 
      if w__52 then AArch32_TakeHypTrapException ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM
        (and_boolM (return ((HaveEL EL3)))
           (ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__53 :: bool) .  return ((\<not> w__53))))))
        ((read_reg MDCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__55 ::  64 Word.word) . 
         return (((((slice w__55 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__56 ::
        bool) . 
      if w__56 then AArch64_AArch32SystemAccessTrap EL3 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM (and_boolM (return ((HaveEL EL3))) ((ELUsingAArch32 EL3)))
        ((read_reg SDCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__59 ::  32 Word.word) . 
         return (((((slice w__59 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__60 ::
        bool) . 
      if w__60 then AArch32_TakeMonitorTrapException () 
      else
      and_boolM
        (and_boolM (return ((HaveEL EL3)))
           (ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__61 :: bool) .  return ((\<not> w__61))))))
        ((read_reg MDCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__63 ::  64 Word.word) . 
         return (((((slice w__63 (( 9 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__64 ::
        bool) . 
      if w__64 then AArch64_AArch32SystemAccessTrap EL3 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
        (DBGDTR_EL0_read (((( 8 :: int)::ii) * (( 4 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__65 ::
           32 Word.word) . 
        MemA_set address (( 4 :: int)::ii) w__65))))))))))))))))))))
    else
    read_reg PSTATE_ref \<bind> ((\<lambda> (w__66 :: ProcState) . 
    if ((((ProcState_EL   w__66) = EL1))) then
      and_boolM
        (and_boolM ((EL2Enabled () ))
           (ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__68 :: bool) .  return ((\<not> w__68))))))
        ((read_reg MDCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__70 ::  64 Word.word) . 
         return (((((slice w__70 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__71 ::
        bool) . 
      if w__71 then AArch64_AArch32SystemAccessTrap EL2 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM (and_boolM ((EL2Enabled () )) ((ELUsingAArch32 EL2)))
        ((HDCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__75 ::  32 Word.word) . 
         return (((((slice w__75 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__76 ::
        bool) . 
      if w__76 then AArch32_TakeHypTrapException ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM
        (and_boolM ((EL2Enabled () ))
           (ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__78 :: bool) .  return ((\<not> w__78))))))
        ((read_reg MDCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__80 ::  64 Word.word) . 
         (read_reg MDCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__81 ::  64 Word.word) . 
         return (((((concat_vec ((slice w__80 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                        ((slice w__81 (( 9 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                       ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))))) \<bind> ((\<lambda> (w__82 :: bool) . 
      if w__82 then AArch64_AArch32SystemAccessTrap EL2 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM (and_boolM ((EL2Enabled () )) ((ELUsingAArch32 EL2)))
        ((HDCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__86 ::  32 Word.word) . 
         (HDCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__87 ::  32 Word.word) . 
         return (((((concat_vec ((slice w__86 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                        ((slice w__87 (( 9 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                       ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))))) \<bind> ((\<lambda> (w__88 :: bool) . 
      if w__88 then AArch32_TakeHypTrapException ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM
        (and_boolM (return ((HaveEL EL3)))
           (ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__89 :: bool) .  return ((\<not> w__89))))))
        ((read_reg MDCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__91 ::  64 Word.word) . 
         return (((((slice w__91 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__92 ::
        bool) . 
      if w__92 then AArch64_AArch32SystemAccessTrap EL3 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM (and_boolM (return ((HaveEL EL3))) ((ELUsingAArch32 EL3)))
        ((read_reg SDCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__95 ::  32 Word.word) . 
         return (((((slice w__95 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__96 ::
        bool) . 
      if w__96 then AArch32_TakeMonitorTrapException () 
      else
      and_boolM
        (and_boolM (return ((HaveEL EL3)))
           (ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__97 :: bool) .  return ((\<not> w__97))))))
        ((read_reg MDCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__99 ::  64 Word.word) . 
         return (((((slice w__99 (( 9 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__100 ::
        bool) . 
      if w__100 then AArch64_AArch32SystemAccessTrap EL3 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
        (DBGDTR_EL0_read (((( 8 :: int)::ii) * (( 4 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__101 ::
           32 Word.word) . 
        MemA_set address (( 4 :: int)::ii) w__101))))))))))))))))
    else
    read_reg PSTATE_ref \<bind> ((\<lambda> (w__102 :: ProcState) . 
    if ((((ProcState_EL   w__102) = EL2))) then
      and_boolM
        (and_boolM (return ((HaveEL EL3)))
           (ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__103 :: bool) .  return ((\<not> w__103))))))
        ((read_reg MDCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__105 ::  64 Word.word) . 
         return (((((slice w__105 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__106 ::
        bool) . 
      if w__106 then AArch64_AArch32SystemAccessTrap EL3 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
      and_boolM (and_boolM (return ((HaveEL EL3))) ((ELUsingAArch32 EL3)))
        ((read_reg SDCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__109 ::  32 Word.word) . 
         return (((((slice w__109 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__110 ::
        bool) . 
      if w__110 then AArch32_TakeMonitorTrapException () 
      else
      and_boolM
        (and_boolM (return ((HaveEL EL3)))
           (ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__111 :: bool) .  return ((\<not> w__111))))))
        ((read_reg MDCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__113 ::  64 Word.word) . 
         return (((((slice w__113 (( 9 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__114 ::
        bool) . 
      if w__114 then AArch64_AArch32SystemAccessTrap EL3 ((Word.uint ( 0x06 ::  8 Word.word)))
      else
        (DBGDTR_EL0_read (((( 8 :: int)::ii) * (( 4 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__115 ::
           32 Word.word) . 
        MemA_set address (( 4 :: int)::ii) w__115))))))))
    else
    read_reg PSTATE_ref \<bind> ((\<lambda> (w__116 :: ProcState) . 
    if ((((ProcState_EL   w__116) = EL3))) then
      and_boolM
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__117 :: ProcState) . 
         return ((((ProcState_M   w__117) \<noteq> M32_Monitor))))))
        ((read_reg SDCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__118 ::  32 Word.word) . 
         return (((((slice w__118 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__119 ::
        bool) . 
      if w__119 then AArch32_TakeMonitorTrapException () 
      else
        (DBGDTR_EL0_read (((( 8 :: int)::ii) * (( 4 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__120 ::
           32 Word.word) . 
        MemA_set address (( 4 :: int)::ii) w__120))))
    else return () ))))))))) \<then>
   (if wback then R_set n offset_addr
   else return () ))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STC_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STC_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STC_A1enc_A_txt cond P U W Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13453.29-13453.30'') \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let n = (Word.uint Rn) in
     (let cp = ((( 14 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STC_Op_A_txt add imm32 index1 n wback)))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STC_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STC_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STC_T1enc_A_txt P U W Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let n = (Word.uint Rn) in
     (let cp = ((( 14 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STC_Op_A_txt add imm32 index1 n wback)))))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STM_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STM_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STM_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (if (((((((((i = n))) \<and> wback))) \<and> (((i \<noteq> ((LowestSetBit registers1)))))))) then
            (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
            MemS_set address (( 4 :: int)::ii) w__0))
          else
            (R_read i  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) .  MemS_set address (( 4 :: int)::ii) w__1))) \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   (if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (PCStoreValue ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      MemS_set address (( 4 :: int)::ii) w__2))
    else return () ) \<then>
   (if wback then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     R_set n ((add_vec_int w__3 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
   else return () ))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STM_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STM_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STM_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13542.29-13542.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STM_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STM_T1enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STM_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STM_T1enc_A_txt Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = ((concat_vec ( 0x00 ::  8 Word.word) register_list  ::  16 Word.word)) in
     (let (wback :: bool) = True in
     (if ((((BitCount registers1)) < (( 1 :: int)::ii))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STM_Op_A_txt n registers1 wback)))
   else return () )))\<close> 
  for  "Rn"  :: "(3)Word.word " 
  and  "register_list"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STM_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty14 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STM_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(14)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STM_T2enc_A_txt W Rn P M register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) =
       ((concat_vec ((concat_vec P M  ::  2 Word.word)) register_list  ::  16 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 2 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec registers1 (( 13 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STM_Op_A_txt n registers1 wback)))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "register_list"  :: "(14)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STMDA_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STMDA_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STMDA_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) =
     ((add_vec_int ((sub_vec_int w__0 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))
        (( 4 :: int)::ii)
       ::  32 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (if (((((((((i = n))) \<and> wback))) \<and> (((i \<noteq> ((LowestSetBit registers1)))))))) then
            (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
            MemS_set address (( 4 :: int)::ii) w__1))
          else
            (R_read i  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  MemS_set address (( 4 :: int)::ii) w__2))) \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   (if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (PCStoreValue ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      MemS_set address (( 4 :: int)::ii) w__3))
    else return () ) \<then>
   (if wback then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     R_set n ((sub_vec_int w__4 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
   else return () )))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STMDA_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STMDA_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STMDA_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13648.29-13648.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STMDA_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STMDB_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STMDB_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STMDB_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) =
     ((sub_vec_int w__0 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (if (((((((((i = n))) \<and> wback))) \<and> (((i \<noteq> ((LowestSetBit registers1)))))))) then
            (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
            MemS_set address (( 4 :: int)::ii) w__1))
          else
            (R_read i  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  MemS_set address (( 4 :: int)::ii) w__2))) \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   (if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (PCStoreValue ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      MemS_set address (( 4 :: int)::ii) w__3))
    else return () ) \<then>
   (if wback then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     R_set n ((sub_vec_int w__4 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
   else return () )))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STMDB_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STMDB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STMDB_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13698.29-13698.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STMDB_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STMDB_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty14 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STMDB_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(14)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STMDB_T1enc_A_txt W Rn P M register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) =
       ((concat_vec ((concat_vec P M  ::  2 Word.word)) register_list  ::  16 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 2 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec registers1 (( 13 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STMDB_Op_A_txt n registers1 wback)))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "register_list"  :: "(14)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STMIB_Op_A_txt : integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STMIB_Op_A_txt  :: \<open> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STMIB_Op_A_txt n registers1 wback = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) = ((add_vec_int w__0 (( 4 :: int)::ii)  ::  32 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 14 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
     ((\<lambda> i address . 
       if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
         (if (((((((((i = n))) \<and> wback))) \<and> (((i \<noteq> ((LowestSetBit registers1)))))))) then
            (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
            MemS_set address (( 4 :: int)::ii) w__1))
          else
            (R_read i  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  MemS_set address (( 4 :: int)::ii) w__2))) \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))
       else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   (if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
    then
      (PCStoreValue ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      MemS_set address (( 4 :: int)::ii) w__3))
    else return () ) \<then>
   (if wback then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     R_set n ((add_vec_int w__4 (((( 4 :: int)::ii) * ((BitCount registers1))))  ::  32 Word.word))))
   else return () )))))))))\<close> 
  for  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STMIB_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STMIB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STMIB_A1enc_A_txt cond W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13782.29-13782.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STMIB_Op_A_txt n registers1 wback))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRB_i_OpA_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRB_i_OpA_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRB_i_OpA_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False
     else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   MemU_set address (( 1 :: int)::ii) ((subrange_vec_dec w__3 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRB_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRB_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRB_i_A1enc_A_txt cond P U W Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13825.29-13825.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''STRBT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     ((if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STRB_i_OpA_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRB_i_OpT_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRB_i_OpT_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRB_i_OpT_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False
     else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   MemU_set address (( 1 :: int)::ii) ((subrange_vec_dec w__3 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRB_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRB_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRB_i_T1enc_A_txt imm5 Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm5 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_STRB_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRB_i_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRB_i_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRB_i_T2enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRB_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRB_i_T3enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRB_i_T3enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRB_i_T3enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''STRBT''))
      else return () ) \<then>
     (if ((((((Rn = ( 0xF ::  4 Word.word)))) \<or> ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word)))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRB_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRB_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRB_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRB_r_Op_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:13968.54-13968.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False
     else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   MemU_set address (( 1 :: int)::ii) ((subrange_vec_dec w__5 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRB_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRB_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRB_r_A1enc_A_txt cond P U W Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:13987.29-13987.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''STRBT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STRB_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRB_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRB_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRB_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_STRB_r_Op_A_txt add index1 m n shift_n shift_t t wback))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRB_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRB_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRB_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRB_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRBT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> SRType -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRBT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   (((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:14095.54-14095.55'')) \<then>
   (if register_form then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M)))))
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      return ((add_vec w__4 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      return ((sub_vec w__5 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   and_boolM (return (((((\<not> postindex)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
      return ((((ProcState_T   w__7) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__8 :: bool) . 
   (let (_ :: unit) = (if w__8 then AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t False else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   MemU_unpriv_set address (( 1 :: int)::ii) ((subrange_vec_dec w__9 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
   (if postindex then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRBT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRBT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRBT_A1enc_A_txt cond U Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14117.29-14117.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_STRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRBT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRBT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRBT_A2enc_A_txt cond U Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14152.29-14152.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_STRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRBT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRBT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRBT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRD_i_Op_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRD_i_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRD_i_Op_A_txt add imm32 index1 n t t2 wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (Align address (( 8 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (if (((address = w__3))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
      BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__4 :: bool) . 
      (if w__4 then
         (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii) w__5  ::  64 Word.word)) in
         (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii) w__6  ::  64 Word.word)) in
         return data))))))
       else
         (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii) w__7  ::  64 Word.word)) in
         (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii) w__8  ::  64 Word.word)) in
         return data))))))) \<bind> ((\<lambda> (data ::  64 Word.word) . 
      MemA_set address (( 8 :: int)::ii) data))))))
    else
      (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
      (MemA_set address (( 4 :: int)::ii) w__9 \<then>
      (R_read t2  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
      MemA_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__10))))) \<then>
   (if wback then R_set n offset_addr
   else return () ))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRD_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRD_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRD_i_A1enc_A_txt cond P U W Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14254.29-14254.30'') \<then>
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (((if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> (((((((((n = (( 15 :: int)::ii)))) \<or> (((n = t)))))) \<or> (((n = t2))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((t2 = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STRD_i_Op_A_txt add imm32 index1 n t t2 wback))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRD_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRD_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRD_i_T1enc_A_txt P U W Rn Rt Rt2 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     ((if (((wback \<and> ((((((n = t))) \<or> (((n = t2))))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((n = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((t2 = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STRD_i_Op_A_txt add imm32 index1 n t t2 wback))))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRD_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRD_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRD_r_Op_A_txt add index1 m n t t2 wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((add_vec w__0 w__1  ::  32 Word.word))))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__2 w__3  ::  32 Word.word))))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (Align address (( 8 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (if (((address = w__5))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (data :: 64 bits) . 
      BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__6 :: bool) . 
      (if w__6 then
         (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii) w__7  ::  64 Word.word)) in
         (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii) w__8  ::  64 Word.word)) in
         return data))))))
       else
         (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 31 :: int)::ii) (( 0 :: int)::ii) w__9  ::  64 Word.word)) in
         (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
         (let data = ((update_subrange_vec_dec data (( 63 :: int)::ii) (( 32 :: int)::ii) w__10  ::  64 Word.word)) in
         return data))))))) \<bind> ((\<lambda> (data ::  64 Word.word) . 
      MemA_set address (( 8 :: int)::ii) data))))))
    else
      (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
      (MemA_set address (( 4 :: int)::ii) w__11 \<then>
      (R_read t2  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
      MemA_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__12))))) \<then>
   (if wback then R_set n offset_addr
   else return () ))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRD_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRD_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRD_r_A1enc_A_txt cond P U W Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14361.29-14361.30'') \<then>
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (((if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((t2 = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((wback \<and> (((((((((n = (( 15 :: int)::ii)))) \<or> (((n = t)))))) \<or> (((n = t2))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STRD_r_Op_A_txt add index1 m n t t2 wback))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STREX_Op_A_txt : integer -> mword ty32 -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STREX_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STREX_Op_A_txt d imm32 n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (address :: 32 bits) = ((add_vec w__0 imm32  ::  32 Word.word)) in
   AArch32_ExclusiveMonitorsPass address (( 4 :: int)::ii) \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
     MemA_set address (( 4 :: int)::ii) w__2 \<then> R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREX_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14420.29-14420.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((Zeros (( 32 :: int)::ii)  ::  32 Word.word)) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREX_Op_A_txt d imm32 n t)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREX_T1enc_A_txt Rn Rt Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREX_Op_A_txt d imm32 n t))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STREXB_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STREXB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STREXB_Op_A_txt d n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_ExclusiveMonitorsPass address (( 1 :: int)::ii) \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     MemA_set address (( 1 :: int)::ii) ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
     R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word)))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREXB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREXB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREXB_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14495.29-14495.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREXB_Op_A_txt d n t))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREXB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREXB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREXB_T1enc_A_txt Rn Rt Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREXB_Op_A_txt d n t)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STREXD_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STREXD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STREXD_Op_A_txt d n t t2 = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then
      (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((concat_vec w__1 w__2  ::  64 Word.word))))))
    else
      (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      return ((concat_vec w__3 w__4  ::  64 Word.word))))))) \<bind> ((\<lambda> (value_name :: 64 bits) . 
   AArch32_ExclusiveMonitorsPass address (( 8 :: int)::ii) \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then
     MemA_set address (( 8 :: int)::ii) value_name \<then>
     R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREXD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREXD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREXD_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14575.29-14575.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     ((if ((((((((((((d = (( 15 :: int)::ii)))) \<or> ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((d = n))) \<or> (((d = t)))))) \<or> (((d = t2)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREXD_Op_A_txt d n t t2)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREXD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREXD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREXD_T1enc_A_txt Rn Rt Rt2 Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let n = (Word.uint Rn) in
     ((if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((d = n))) \<or> (((d = t)))))) \<or> (((d = t2)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREXD_Op_A_txt d n t t2))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STREXH_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STREXH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STREXH_Op_A_txt d n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_ExclusiveMonitorsPass address (( 2 :: int)::ii) \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     MemA_set address (( 2 :: int)::ii) ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) \<then>
     R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word)))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREXH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREXH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREXH_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14650.29-14650.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREXH_Op_A_txt d n t))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STREXH_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STREXH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STREXH_T1enc_A_txt Rn Rt Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STREXH_Op_A_txt d n t)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRH_i_OpA_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRH_i_OpA_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRH_i_OpA_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False
     else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   MemU_set address (( 2 :: int)::ii) ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRH_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRH_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRH_i_A1enc_A_txt cond P U W Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14730.29-14730.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''STRHT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     ((if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STRH_i_OpA_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRH_i_OpT_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRH_i_OpT_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRH_i_OpT_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False
     else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   MemU_set address (( 2 :: int)::ii) ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRH_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRH_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRH_i_T1enc_A_txt imm5 Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm5 (( 0 :: int)::ii) (( 5 :: int)::ii) (( 1 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_STRH_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRH_i_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRH_i_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRH_i_T2enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRH_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRH_i_T3enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRH_i_T3enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRH_i_T3enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''STRHT''))
      else return () ) \<then>
     (if ((((((Rn = ( 0xF ::  4 Word.word)))) \<or> ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word)))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRH_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRH_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRH_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRH_r_Op_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:14874.54-14874.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False
     else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   MemU_set address (( 2 :: int)::ii) ((subrange_vec_dec w__5 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) \<then>
   (if wback then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRH_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRH_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRH_r_A1enc_A_txt cond P U W Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:14893.29-14893.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''STRHT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STRH_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRH_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRH_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRH_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_STRH_r_Op_A_txt add index1 m n shift_n shift_t t wback))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRH_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRH_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRH_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRH_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRHT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRHT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRHT_Op_A_txt add imm32 m n postindex register_form t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   ((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if register_form then (R_read m  :: ( 32 Word.word) M)
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   and_boolM (return (((t \<noteq> (( 15 :: int)::ii)))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
      return ((((ProcState_T   w__5) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__6 :: bool) . 
   (let (_ :: unit) = (if w__6 then AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t False else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   MemU_unpriv_set address (( 2 :: int)::ii) ((subrange_vec_dec w__7 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) \<then>
   (if postindex then R_set n offset_addr
   else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRHT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRHT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRHT_A1enc_A_txt cond U Rn Rt imm4H imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15021.29-15021.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec imm4H imm4L  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_STRHT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRHT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRHT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRHT_A2enc_A_txt cond U Rn Rt Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15057.29-15057.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     execute_aarch32_instrs_STRHT_Op_A_txt add imm32 m n postindex register_form t))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRHT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRHT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRHT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRHT_Op_A_txt add imm32 m n postindex register_form t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STR_i_OpA_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STR_i_OpA_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STR_i_OpA_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   (if (((t = (( 15 :: int)::ii)))) then (PCStoreValue ()   :: ( 32 Word.word) M)
    else (R_read t  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   MemU_set address (( 4 :: int)::ii) w__5 \<then> (if wback then R_set n offset_addr else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_i_A1enc_A_txt cond P U W Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15145.29-15145.30'') \<then>
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''STRT''))
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STR_i_OpA_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STR_i_OpT_A_txt : bool -> mword ty32 -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STR_i_OpT_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index1 n t wback = (
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   MemU_set address (( 4 :: int)::ii) w__3 \<then> (if wback then R_set n offset_addr else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "index1"  :: " bool " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_i_T1enc_A_txt : mword ty5 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_i_T1enc_A_txt  :: \<open>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_i_T1enc_A_txt imm5 Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm5 (( 0 :: int)::ii) (( 5 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "imm5"  :: "(5)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_i_T2enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_i_T2enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_i_T2enc_A_txt Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = ((( 13 :: int)::ii)) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index1 n t wback))))))
   else return () )))\<close> 
  for  "Rt"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_i_T3enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_i_T3enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_i_T3enc_A_txt Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_i_T4enc_A_txt : mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_i_T4enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_i_T4enc_A_txt Rn Rt P U W imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((U = ( 0b1 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''STRT''))
      else return () ) \<then>
     (if ((((((Rn = ( 0xF ::  4 Word.word)))) \<or> ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word)))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((wback \<and> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index1 n t wback)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STR_r_Op_A_txt : bool -> bool -> integer -> integer -> integer -> SRType -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STR_r_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STR_r_Op_A_txt add index1 m n shift_n shift_t t wback = (
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:15307.54-15307.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((add_vec w__2 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      return ((sub_vec w__3 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if index1 then return offset_addr
    else (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   (if (((t = (( 15 :: int)::ii)))) then (PCStoreValue ()   :: ( 32 Word.word) M)
    else (R_read t  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (data ::  32 Word.word) . 
   (let (_ :: unit) =
     (if (((((\<not> wback)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))) then
       AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False
     else () ) in
   MemU_set address (( 4 :: int)::ii) data \<then> (if wback then R_set n offset_addr else return () )))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "index1"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_r_A1enc_A_txt cond P U W Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15332.29-15332.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''STRT''))
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = (P = ( 0b1 ::  1 Word.word)) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = ((((P = ( 0b0 ::  1 Word.word)))) \<or> (((W = ( 0b1 ::  1 Word.word))))) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     ((if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t))))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STR_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_r_T1enc_A_txt Rm Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_STR_r_Op_A_txt add index1 m n shift_n shift_t t wback))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rt"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STR_r_T2enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STR_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STR_r_T2enc_A_txt Rn Rt imm2 Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (index1 :: bool) = True in
     (let (add :: bool) = True in
     (let (wback :: bool) = False in
     (let (tup__0, tup__1) = (SRType_LSL, Word.uint imm2) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STR_r_Op_A_txt add index1 m n shift_n shift_t t wback)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STRT_Op_A_txt : bool -> mword ty32 -> integer -> integer -> bool -> bool -> integer -> SRType -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STRT_Op_A_txt  :: \<open> bool \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   (((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Unpredictable () )
    else return () ) \<then>
   assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:15440.54-15440.55'')) \<then>
   (if register_form then
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M)))))
    else return imm32)) \<bind> ((\<lambda> (offset :: 32 bits) . 
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      return ((add_vec w__4 offset  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      return ((sub_vec w__5 offset  ::  32 Word.word))))) \<bind> ((\<lambda> (offset_addr :: 32 bits) . 
   (if postindex then (R_read n  :: ( 32 Word.word) M)
    else return offset_addr) \<bind> ((\<lambda> (address :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (data :: 32 bits) . 
   (if (((t = (( 15 :: int)::ii)))) then (PCStoreValue ()   :: ( 32 Word.word) M)
    else (R_read t  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (data ::  32 Word.word) . 
   and_boolM (return (((((\<not> postindex)) \<and> (((t \<noteq> (( 15 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
      return ((((ProcState_T   w__9) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__10 :: bool) . 
   (let (_ :: unit) = (if w__10 then AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t False else () ) in
   MemU_unpriv_set address (( 4 :: int)::ii) data \<then> (if postindex then R_set n offset_addr else return () )))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "imm32"  :: "(32)Word.word " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "postindex"  :: " bool " 
  and  "register_form"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRT_A1enc_A_txt cond U Rn Rt imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15468.29-15468.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm12 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> (((n = t)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     execute_aarch32_instrs_STRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRT_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRT_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRT_A2enc_A_txt cond U Rn Rt imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15503.29-15503.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (postindex :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (register_form :: bool) = True in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((n = (( 15 :: int)::ii)))) \<or> (((n = t)))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_STRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STRT_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STRT_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STRT_T1enc_A_txt Rn Rt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     (let m = m in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (let (postindex :: bool) = False in
     (let (add :: bool) = True in
     (let (register_form :: bool) = False in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SUB_i_Op_A_txt : integer -> mword ty32 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SUB_i_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__0 ((not_vec imm32  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_i_A1enc_A_txt cond S Rn Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15600.29-15600.30'') \<then>
     (if ((((((Rn = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''ADR''))
      else return () )) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''SUB (SP minus immediate)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_i_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_i_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_i_T1enc_A_txt imm3 Rn Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (imm32 :: 32 bits) = ((zero_extend imm3 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "imm3"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_i_T2enc_A_txt : mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_i_T2enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_i_T2enc_A_txt Rdn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rdn) in
     (let n = (Word.uint Rdn) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "Rdn"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_i_T3enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_i_T3enc_A_txt i S Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMP (immediate)''))
      else return () ) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''SUB (SP minus immediate)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if (((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_i_T4enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_i_T4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_i_T4enc_A_txt i Rn imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''ADR''))
      else return () ) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''SUB (SP minus immediate)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags)))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_i_T5enc_A_txt : mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_i_T5enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_i_T5enc_A_txt Rn imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Rn = ( 0xE ::  4 Word.word)))) \<and> ((IsZero imm8))))) then throw (Error_See (''ERET''))
      else return () ) \<then>
     ((let d = ((( 15 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     (let (setflags :: bool) = True in
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     ((if (((n \<noteq> (( 14 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags)))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SUB_r_Op_A_txt : integer -> integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_SUB_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SUB_r_Op_A_txt d m n setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:15772.54-15772.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__2 ((not_vec shifted  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__6 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_r_A1enc_A_txt cond S Rn Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15794.29-15794.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''SUB (SP minus register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_SUB_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_r_T1enc_A_txt : mword ty3 -> mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_r_T1enc_A_txt Rm Rn Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (let (setflags :: bool) = (\<not> w__1) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_SUB_r_Op_A_txt d m n setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_r_T2enc_A_txt S Rn imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     ((if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMP (register)''))
      else return () ) \<then>
     (if (((Rn = ( 0xD ::  4 Word.word)))) then throw (Error_See (''SUB (SP minus register)''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_r_Op_A_txt d m n setflags shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SUB_rr_Op_A_txt : integer -> integer -> integer -> integer -> bool -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_SUB_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SUB_rr_Op_A_txt d m n s setflags shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift w__1 shift_t shift_n(ProcState_C   w__2)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__3 ((not_vec shifted  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__6 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__7 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () ))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_rr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_rr_A1enc_A_txt cond S Rn Rd Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15911.29-15911.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_rr_Op_A_txt d m n s setflags shift_t))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SUB_SP_i_Op_A_txt : integer -> mword ty32 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SUB_SP_i_Op_A_txt  :: \<open> int \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (SP_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__0 ((not_vec imm32  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__1 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__4 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_SP_i_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_SP_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_SP_i_A1enc_A_txt cond S Rd imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:15964.29-15964.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (A32ExpandImm imm12  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_SP_i_T1enc_A_txt : mword ty7 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_SP_i_T1enc_A_txt  :: \<open>(7)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_SP_i_T1enc_A_txt imm7 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = ((( 13 :: int)::ii)) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm7 (( 0 :: int)::ii) (( 7 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags)))
   else return () )))\<close> 
  for  "imm7"  :: "(7)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_SP_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_SP_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_SP_i_T2enc_A_txt i S imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMP (immediate)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     (T32ExpandImm ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (if ((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags)))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_SP_i_T3enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_SP_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_SP_i_T3enc_A_txt i imm3 Rd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (setflags :: bool) = False in
     (let (imm32 :: 32 bits) =
       ((zero_extend ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word)) (( 32 :: int)::ii)
         ::  32 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags)))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SUB_SP_r_Op_A_txt : integer -> integer -> bool -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_SUB_SP_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SUB_SP_r_Op_A_txt d m setflags shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:16059.54-16059.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (SP_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (let (tup__0, tup__1) =
     ((AddWithCarry w__2 ((not_vec shifted  ::  32 Word.word)) ( 0b1 ::  1 Word.word)
       :: ( 32 Word.word *  4 Word.word))) in
   (let (result :: 32 bits) = tup__0 in
   (let (nzcv :: 4 bits) = tup__1 in
   if (((d = (( 15 :: int)::ii)))) then if setflags then ALUExceptionReturn result else ALUWritePC result
   else
   R_set d result \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__3 (| ProcState_N := ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_Z := ((subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__5 (| ProcState_C := ((subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__6 (| ProcState_V := ((subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |))))))))))
   else return () )))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "setflags"  :: " bool " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_SP_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_SP_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_SP_r_A1enc_A_txt cond S Rd imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16081.29-16081.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_SUB_SP_r_Op_A_txt d m setflags shift_n shift_t)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SUB_SP_r_T1enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SUB_SP_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SUB_SP_r_T1enc_A_txt S imm3 Rd imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((Rd = ( 0xF ::  4 Word.word)))) \<and> (((S = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_See (''CMP (register)''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if (((((((((d = (( 15 :: int)::ii)))) \<and> ((\<not> setflags))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SUB_SP_r_Op_A_txt d m setflags shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SVC_Op_A_txt : mword ty32 -> M unit\<close>\<close>

definition execute_aarch32_instrs_SVC_Op_A_txt  :: \<open>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SVC_Op_A_txt imm32 = (
   AArch32_CheckForSVCTrap ((subrange_vec_dec imm32 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) \<then>
   AArch32_CallSupervisor ((subrange_vec_dec imm32 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))\<close> 
  for  "imm32"  :: "(32)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SVC_A1enc_A_txt : mword ty4 -> mword ty24 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SVC_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SVC_A1enc_A_txt cond imm24 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16153.29-16153.30'') \<then>
     ((let (imm32 :: 32 bits) = ((zero_extend imm24 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_SVC_Op_A_txt imm32))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm24"  :: "(24)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SVC_T1enc_A_txt : mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SVC_T1enc_A_txt  :: \<open>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SVC_T1enc_A_txt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (imm32 :: 32 bits) = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_SVC_Op_A_txt imm32)
   else return () )))\<close> 
  for  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SXTAB16_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SXTAB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SXTAB16_Op_A_txt d m n rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((add_vec ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
             ((sign_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)
                ::  16 Word.word))
            ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((add_vec ((subrange_vec_dec w__4 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
             ((sign_extend ((subrange_vec_dec rotated (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)
                ::  16 Word.word))
            ::  16 Word.word))
        ::  32 Word.word))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTAB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTAB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTAB16_A1enc_A_txt cond Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16197.29-16197.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SXTB16''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTAB16_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTAB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTAB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTAB16_T1enc_A_txt Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SXTB16''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTAB16_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SXTAB_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SXTAB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SXTAB_Op_A_txt d m n rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   R_set d
     ((add_vec w__1
         ((sign_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  32 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTAB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTAB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTAB_A1enc_A_txt cond Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16272.29-16272.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SXTB''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTAB_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTAB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTAB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTAB_T1enc_A_txt Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SXTB''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTAB_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SXTAH_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SXTAH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SXTAH_Op_A_txt d m n rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   R_set d
     ((add_vec w__1
         ((sign_extend ((subrange_vec_dec rotated (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) (( 32 :: int)::ii)
            ::  32 Word.word))
        ::  32 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTAH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTAH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTAH_A1enc_A_txt cond Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16347.29-16347.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SXTH''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTAH_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTAH_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTAH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTAH_T1enc_A_txt Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''SXTH''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTAH_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SXTB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SXTB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SXTB16_Op_A_txt d m rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((sign_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((sign_extend ((subrange_vec_dec rotated (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)
            ::  16 Word.word))
        ::  32 Word.word))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTB16_A1enc_A_txt cond Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16423.29-16423.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTB16_Op_A_txt d m rotation))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTB16_T1enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTB16_T1enc_A_txt Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTB16_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SXTB_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SXTB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SXTB_Op_A_txt d m rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   R_set d
     ((sign_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTB_A1enc_A_txt cond Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16488.29-16488.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTB_Op_A_txt d m rotation))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTB_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTB_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTB_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = ((( 0 :: int)::ii)) in
     execute_aarch32_instrs_SXTB_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTB_T2enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTB_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTB_T2enc_A_txt Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTB_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SXTH_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SXTH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SXTH_Op_A_txt d m rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   R_set d
     ((sign_extend ((subrange_vec_dec rotated (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTH_A1enc_A_txt cond Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16572.29-16572.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTH_Op_A_txt d m rotation))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTH_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTH_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTH_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = ((( 0 :: int)::ii)) in
     execute_aarch32_instrs_SXTH_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SXTH_T2enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SXTH_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SXTH_T2enc_A_txt Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SXTH_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_TBB_Op_A_txt : bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_TBB_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_TBB_Op_A_txt is_tbh m n = (
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 65535 :: int)::ii) \<bind> ((\<lambda> (halfwords :: int) . 
   (if is_tbh then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (MemU_read ((add_vec w__0 ((shiftl w__1 (( 1 :: int)::ii)  ::  32 Word.word))  ::  32 Word.word)) (( 2 :: int)::ii)
        :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
      (let halfwords = (Word.uint w__2) in
      return halfwords)))))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      (MemU_read ((add_vec w__3 w__4  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::
         8 Word.word) . 
      (let halfwords = (Word.uint w__5) in
      return halfwords)))))))) \<bind> ((\<lambda> (halfwords :: int) . 
   (let halfwords = halfwords in
   (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   BranchWritePC ((add_vec_int w__6 (((( 2 :: int)::ii) * halfwords))  ::  32 Word.word))
     BranchType_INDIR))))))))\<close> 
  for  "is_tbh"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_TBB_T1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TBB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TBB_T1enc_A_txt Rn H Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (is_tbh :: bool) = (H = ( 0b1 ::  1 Word.word)) in
     ((if (((m = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_TBB_Op_A_txt is_tbh m n)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "H"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_TEQ_i_Op_A_txt : mword ty1 -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_TEQ_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_TEQ_i_Op_A_txt carry imm32 n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((xor_vec w__0 imm32  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__1 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (write_reg PSTATE_ref ( w__2 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
   write_reg PSTATE_ref ( w__3 (| ProcState_C := carry |))))))))))))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_TEQ_i_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TEQ_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TEQ_i_A1enc_A_txt cond Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16702.29-16702.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let n = (Word.uint Rn) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_TEQ_i_Op_A_txt carry imm32 n))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_TEQ_i_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TEQ_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TEQ_i_T1enc_A_txt i Rn imm3 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let n = (Word.uint Rn) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let carry = carry in
     execute_aarch32_instrs_TEQ_i_Op_A_txt carry imm32 n)))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_TEQ_r_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_TEQ_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_TEQ_r_Op_A_txt m n shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:16758.54-16758.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((xor_vec w__3 shifted  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |)))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_TEQ_r_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TEQ_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TEQ_r_A1enc_A_txt cond Rn imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16770.29-16770.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_TEQ_r_Op_A_txt m n shift_n shift_t))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_TEQ_r_T1enc_A_txt : mword ty4 -> mword ty3 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TEQ_r_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TEQ_r_T1enc_A_txt Rn imm3 imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_TEQ_r_Op_A_txt m n shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_TEQ_rr_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_TEQ_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_TEQ_rr_Op_A_txt m n s shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((xor_vec w__4 shifted  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__5 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   (write_reg PSTATE_ref ( w__6 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
   write_reg PSTATE_ref ( w__7 (| ProcState_C := carry |))))))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_TEQ_rr_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TEQ_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TEQ_rr_A1enc_A_txt cond Rn Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16849.29-16849.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_TEQ_rr_Op_A_txt m n s shift_t))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_TST_i_Op_A_txt : mword ty1 -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_TST_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_TST_i_Op_A_txt carry imm32 n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__0 imm32  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__1 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (write_reg PSTATE_ref ( w__2 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
   write_reg PSTATE_ref ( w__3 (| ProcState_C := carry |))))))))))))\<close> 
  for  "carry"  :: "(1)Word.word " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_TST_i_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TST_i_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TST_i_A1enc_A_txt cond Rn imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16890.29-16890.30'') \<then>
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let n = (Word.uint Rn) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (A32ExpandImm_C imm12(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
       ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     execute_aarch32_instrs_TST_i_Op_A_txt carry imm32 n))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_TST_i_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TST_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TST_i_T1enc_A_txt i Rn imm3 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let n = (Word.uint Rn) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (T32ExpandImm_C ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm8  ::  12 Word.word))(ProcState_C  
        w__1)
       :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 :: ( 32 Word.word *  1 Word.word)) . 
     (let (tup__0, tup__1) = w__2 in
     (let (imm32 :: 32 bits) = tup__0 in
     (let (carry :: 1 bits) = tup__1 in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let imm32 = imm32 in
     (let carry = carry in
     execute_aarch32_instrs_TST_i_Op_A_txt carry imm32 n)))))))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_TST_r_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_TST_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_TST_r_Op_A_txt m n shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:16946.54-16946.55'') \<then>
   (R_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift_C w__0 shift_t shift_n(ProcState_C   w__1)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__3 shifted  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__4 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg PSTATE_ref ( w__5 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   write_reg PSTATE_ref ( w__6 (| ProcState_C := carry |)))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_TST_r_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty5 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TST_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TST_r_A1enc_A_txt cond Rn imm5 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:16958.29-16958.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype imm5 \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_TST_r_Op_A_txt m n shift_n shift_t))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_TST_r_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TST_r_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TST_r_T1enc_A_txt Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (tup__0, tup__1) = (SRType_LSL, (( 0 :: int)::ii)) in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     execute_aarch32_instrs_TST_r_Op_A_txt m n shift_n shift_t))))))))))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rn"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_TST_r_T2enc_A_txt : mword ty4 -> mword ty3 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TST_r_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TST_r_T2enc_A_txt Rn imm3 imm2 stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     DecodeImmShift stype ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_TST_r_Op_A_txt m n shift_n shift_t)))))))))))))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_TST_rr_Op_A_txt : integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_TST_rr_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_TST_rr_Op_A_txt m n s shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (carry :: 1 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (shifted :: 32 bits) . 
   (R_read s  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let shift_n = (Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
   (Shift_C w__1 shift_t shift_n(ProcState_C   w__2)  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__3 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (shifted :: 32 bits) = tup__0 in
   (let (carry :: 1 bits) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (let (result :: 32 bits) = ((and_vec w__4 shifted  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__5 (| ProcState_N := ((vec_of_bits [access_vec_dec result (( 31 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   (write_reg PSTATE_ref ( w__6 (| ProcState_Z := ((IsZeroBit result  ::  1 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
   write_reg PSTATE_ref ( w__7 (| ProcState_C := carry |))))))))))))))))))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "s"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_TST_rr_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TST_rr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TST_rr_A1enc_A_txt cond Rn Rs stype Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17059.29-17059.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let s = (Word.uint Rs) in
     DecodeRegShift stype \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if (((((((((n = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((s = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_TST_rr_Op_A_txt m n s shift_t))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rs"  :: "(4)Word.word " 
  and  "stype"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UADD16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UADD16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UADD16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((sum1 \<ge> ((Word.uint ( 0x10000 ::  20 Word.word))))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((sum2 \<ge> ((Word.uint ( 0x10000 ::  20 Word.word))))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UADD16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UADD16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UADD16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17103.29-17103.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UADD16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UADD16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UADD16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UADD16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UADD16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UADD8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UADD8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UADD8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let sum3 =
     (((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let sum4 =
     (((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange sum2 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum3 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange sum4 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__12 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__13 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__12 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__13) (( 0 :: int)::ii) (( 0 :: int)::ii)
             (if ((sum1 \<ge> ((Word.uint ( 0x100 ::  12 Word.word))))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__14 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__15 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__14 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__15) (( 1 :: int)::ii) (( 1 :: int)::ii)
             (if ((sum2 \<ge> ((Word.uint ( 0x100 ::  12 Word.word))))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__16 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__17 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__16 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__17) (( 2 :: int)::ii) (( 2 :: int)::ii)
             (if ((sum3 \<ge> ((Word.uint ( 0x100 ::  12 Word.word))))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__18 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__19 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__18 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__19) (( 3 :: int)::ii) (( 3 :: int)::ii)
             (if ((sum4 \<ge> ((Word.uint ( 0x100 ::  12 Word.word))))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UADD8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UADD8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UADD8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17174.29-17174.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UADD8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UADD8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UADD8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UADD8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UADD8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UASX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UASX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UASX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((diff \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((sum1 \<ge> ((Word.uint ( 0x10000 ::  20 Word.word))))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UASX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UASX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UASX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17239.29-17239.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UASX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UASX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UASX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UASX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UASX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UBFX_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UBFX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UBFX_Op_A_txt d lsbit n widthminus1 = (
   (let msbit = (lsbit + widthminus1) in
   if ((msbit \<le> (( 31 :: int)::ii))) then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     R_set d ((zext_subrange (( 32 :: int)::ii) w__0 msbit lsbit  ::  32 Word.word))))
   else throw (Error_Unpredictable () )))\<close> 
  for  "d"  :: " int " 
  and  "lsbit"  :: " int " 
  and  "n"  :: " int " 
  and  "widthminus1"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UBFX_A1enc_A_txt : mword ty4 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UBFX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UBFX_A1enc_A_txt cond widthm1 Rd lsb1 Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17304.29-17304.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let lsbit = (Word.uint lsb1) in
     (let widthminus1 = (Word.uint widthm1) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UBFX_Op_A_txt d lsbit n widthminus1)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "widthm1"  :: "(5)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "lsb1"  :: "(5)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UBFX_T1enc_A_txt : mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UBFX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UBFX_T1enc_A_txt Rn imm3 Rd imm2 widthm1 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let lsbit = (Word.uint ((concat_vec imm3 imm2  ::  5 Word.word))) in
     (let widthminus1 = (Word.uint widthm1) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UBFX_Op_A_txt d lsbit n widthminus1))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "widthm1"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UDF_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_UDF_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UDF_Op_A_txt _ = ( throw (Error_Undefined () ))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_UDF_A1enc_A_txt : mword ty12 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UDF_A1enc_A_txt  :: \<open>(12)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UDF_A1enc_A_txt imm12 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let imm32 = ((zero_extend ((concat_vec imm12 imm4  ::  16 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_UDF_Op_A_txt () )
   else return () )))\<close> 
  for  "imm12"  :: "(12)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UDF_T1enc_A_txt : mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UDF_T1enc_A_txt  :: \<open>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UDF_T1enc_A_txt imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let imm32 = ((zero_extend imm8 (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_UDF_Op_A_txt () )
   else return () )))\<close> 
  for  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UDF_T2enc_A_txt : mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UDF_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UDF_T2enc_A_txt imm4 imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let imm32 = ((zero_extend ((concat_vec imm4 imm12  ::  16 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word)) in
     execute_aarch32_instrs_UDF_Op_A_txt () )
   else return () )))\<close> 
  for  "imm4"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UDIV_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UDIV_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UDIV_Op_A_txt d m n = (
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (if (((((Word.uint w__0)) = (( 0 :: int)::ii)))) then return (( 0 :: int)::ii)
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (let result = (RoundTowardsZero (((((real_of_int ((Word.uint w__1))))) div (((real_of_int ((Word.uint w__2)))))))) in
      return result)))))) \<bind> ((\<lambda> (result :: ii) . 
   (let result = result in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UDIV_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UDIV_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UDIV_A1enc_A_txt cond Rd Ra Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17432.29-17432.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a \<noteq> (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UDIV_Op_A_txt d m n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UDIV_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UDIV_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UDIV_T1enc_A_txt Rn Ra Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) \<or> (((a \<noteq> (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UDIV_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UHADD16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UHADD16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UHADD16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum2 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHADD16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHADD16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHADD16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17495.29-17495.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHADD16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHADD16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHADD16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHADD16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHADD16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UHADD8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UHADD8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UHADD8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let sum3 =
     (((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let sum4 =
     (((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange sum2 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum3 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange sum4 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHADD8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHADD8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHADD8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17562.29-17562.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHADD8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHADD8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHADD8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHADD8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHADD8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UHASX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UHASX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UHASX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange sum1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHASX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHASX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHASX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17625.29-17625.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHASX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHASX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHASX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHASX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHASX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UHSAX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UHSAX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UHSAX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHSAX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHSAX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHSAX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17688.29-17688.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHSAX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHSAX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHSAX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHSAX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHSAX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UHSUB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UHSUB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UHSUB16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff2 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHSUB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHSUB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHSUB16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17751.29-17751.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHSUB16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHSUB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHSUB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHSUB16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHSUB16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UHSUB8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UHSUB8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UHSUB8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let diff3 =
     (((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let diff4 =
     (((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange diff2 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff3 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange diff4 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHSUB8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHSUB8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHSUB8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17818.29-17818.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHSUB8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UHSUB8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UHSUB8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UHSUB8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UHSUB8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UMAAL_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UMAAL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UMAAL_Op_A_txt dHi dLo m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_read dHi  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read dLo  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let result =
     (((((((Word.uint w__0)) * ((Word.uint w__1)))) + ((Word.uint w__2)))) +
       ((Word.uint w__3))) in
   R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UMAAL_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UMAAL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UMAAL_A1enc_A_txt cond RdHi RdLo Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17880.29-17880.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_UMAAL_Op_A_txt dHi dLo m n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UMAAL_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UMAAL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UMAAL_T1enc_A_txt Rn RdLo RdHi Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_UMAAL_Op_A_txt dHi dLo m n))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UMLAL_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_UMLAL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UMLAL_Op_A_txt dHi dLo m n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_read dHi  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read dLo  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let result =
     (((((Word.uint w__0)) * ((Word.uint w__1)))) +
       ((Word.uint ((concat_vec w__2 w__3  ::  64 Word.word))))) in
   (R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__4 (| ProcState_N := ((vec_of_bits [integer_access result (( 63 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__5 (|
         ProcState_Z :=
           ((IsZeroBit ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))  ::  1 Word.word)) |))))))
   else return () )))))))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_UMLAL_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UMLAL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UMLAL_A1enc_A_txt cond S RdHi RdLo Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:17953.29-17953.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_UMLAL_Op_A_txt dHi dLo m n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UMLAL_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UMLAL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UMLAL_T1enc_A_txt Rn RdLo RdHi Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_UMLAL_Op_A_txt dHi dLo m n setflags)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UMULL_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_UMULL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UMULL_Op_A_txt dHi dLo m n setflags = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let result = (((Word.uint w__0)) * ((Word.uint w__1))) in
   (R_set dHi ((integer_subrange result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
   R_set dLo ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) \<then>
   (if setflags then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
     (write_reg
       PSTATE_ref
       ( w__2 (| ProcState_N := ((vec_of_bits [integer_access result (( 63 :: int)::ii)]  ::  1 Word.word)) |)) \<then>
     read_reg PSTATE_ref) \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg
       PSTATE_ref
       ( w__3 (|
         ProcState_Z :=
           ((IsZeroBit ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))  ::  1 Word.word)) |))))))
   else return () )))))))\<close> 
  for  "dHi"  :: " int " 
  and  "dLo"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "setflags"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_UMULL_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UMULL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UMULL_A1enc_A_txt cond S RdHi RdLo Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18029.29-18029.30'') \<then>
     ((let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_UMULL_Op_A_txt dHi dLo m n setflags))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UMULL_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UMULL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UMULL_T1enc_A_txt Rn RdLo RdHi Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let dLo = (Word.uint RdLo) in
     (let dHi = (Word.uint RdHi) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (setflags :: bool) = False in
     ((if ((((((((((((dLo = (( 15 :: int)::ii)))) \<or> (((dHi = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((dHi = dLo))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_UMULL_Op_A_txt dHi dLo m n setflags)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "RdLo"  :: "(4)Word.word " 
  and  "RdHi"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UQADD16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UQADD16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UQADD16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (UnsignedSat sum1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (UnsignedSat sum2 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQADD16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQADD16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQADD16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18101.29-18101.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQADD16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQADD16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQADD16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQADD16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQADD16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UQADD8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UQADD8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UQADD8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let sum3 =
     (((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let sum4 =
     (((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (UnsignedSat sum1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__9 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii) w__9  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (UnsignedSat sum2 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__11 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__10 (( 15 :: int)::ii) (( 8 :: int)::ii) w__11  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
   (UnsignedSat sum3 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__13 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__12 (( 23 :: int)::ii) (( 16 :: int)::ii) w__13  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
   (UnsignedSat sum4 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__15 ::  8 Word.word) . 
   R_set d ((update_subrange_vec_dec w__14 (( 31 :: int)::ii) (( 24 :: int)::ii) w__15  ::  32 Word.word)))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQADD8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQADD8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQADD8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18168.29-18168.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQADD8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQADD8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQADD8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQADD8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQADD8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UQASX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UQASX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UQASX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (UnsignedSat diff (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (UnsignedSat sum1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQASX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQASX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQASX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18231.29-18231.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQASX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQASX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQASX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQASX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQASX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UQSAX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UQSAX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UQSAX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (UnsignedSat sum1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (UnsignedSat diff (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQSAX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQSAX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQSAX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18294.29-18294.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQSAX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQSAX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQSAX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQSAX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQSAX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UQSUB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UQSUB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UQSUB16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (UnsignedSat diff1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) w__5  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (UnsignedSat diff2 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
   R_set d ((update_subrange_vec_dec w__6 (( 31 :: int)::ii) (( 16 :: int)::ii) w__7  ::  32 Word.word)))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQSUB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQSUB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQSUB16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18357.29-18357.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQSUB16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQSUB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQSUB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQSUB16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQSUB16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UQSUB8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UQSUB8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UQSUB8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let diff3 =
     (((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let diff4 =
     (((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (UnsignedSat diff1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__9 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii) w__9  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (UnsignedSat diff2 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__11 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__10 (( 15 :: int)::ii) (( 8 :: int)::ii) w__11  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
   (UnsignedSat diff3 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__13 ::  8 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__12 (( 23 :: int)::ii) (( 16 :: int)::ii) w__13  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
   (UnsignedSat diff4 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__15 ::  8 Word.word) . 
   R_set d ((update_subrange_vec_dec w__14 (( 31 :: int)::ii) (( 24 :: int)::ii) w__15  ::  32 Word.word)))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQSUB8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQSUB8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQSUB8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18424.29-18424.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQSUB8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UQSUB8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UQSUB8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UQSUB8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UQSUB8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_USAD8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_USAD8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_USAD8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let absdiff1 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let absdiff2 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let absdiff3 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let absdiff4 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))))) in
   (let result = (((((absdiff1 + absdiff2)) + absdiff3)) + absdiff4) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAD8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAD8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAD8_A1enc_A_txt cond Rd Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18489.29-18489.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USAD8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAD8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAD8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAD8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USAD8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_USADA8_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_USADA8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_USADA8_Op_A_txt a d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let absdiff1 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let absdiff2 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let absdiff3 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let absdiff4 =
     (abs
       ((((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
           ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))))) in
   (R_read a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (let result =
     (((((((((Word.uint w__8)) + absdiff1)) + absdiff2)) + absdiff3))
       +
       absdiff4) in
   R_set d ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))))))))))))))))\<close> 
  for  "a"  :: " int " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_USADA8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USADA8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USADA8_A1enc_A_txt cond Rd Ra Rm Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18550.29-18550.30'') \<then>
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''USAD8''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USADA8_Op_A_txt a d m n)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_USADA8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USADA8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USADA8_T1enc_A_txt Rn Ra Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Ra = ( 0xF ::  4 Word.word)))) then throw (Error_See (''USAD8''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let a = (Word.uint Ra) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USADA8_Op_A_txt a d m n)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Ra"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_USAT16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_USAT16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_USAT16_Op_A_txt d n saturate_to = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result1 :: 16 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result2 :: 16 bits) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
   (assert_exp (((( 0 :: int)::ii) \<le> ((((id0 saturate_to)) - (( 1 :: int)::ii))))) (''src/instrs32.sail:18613.44-18613.45'') \<then>
   (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (ZeroUnsignedSatQ ((Word.sint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) saturate_to
      (( 16 :: int)::ii)
     :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> (w__1 :: ( 16 Word.word * bool)) . 
   (let (tup__0, tup__1) = w__1 in
   (let (result1 :: 16 bits) = tup__0 in
   (let (sat1 :: bool) = tup__1 in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (ZeroUnsignedSatQ ((Word.sint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) saturate_to
      (( 16 :: int)::ii)
     :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> (w__3 :: ( 16 Word.word * bool)) . 
   (let (tup__0, tup__1) = w__3 in
   (let (result2 :: 16 bits) = tup__0 in
   (let (sat2 :: bool) = tup__1 in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii) result1  ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   R_set d ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii) result2  ::  32 Word.word)) \<then>
   (if (((sat1 \<or> sat2))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref ( w__6 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () ))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "saturate_to"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAT16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAT16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAT16_A1enc_A_txt cond sat_imm Rd Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18628.29-18628.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let saturate_to = (Word.uint sat_imm) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USAT16_Op_A_txt d n saturate_to))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "sat_imm"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAT16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAT16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAT16_T1enc_A_txt Rn Rd sat_imm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let saturate_to = (Word.uint sat_imm) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USAT16_Op_A_txt d n saturate_to)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "sat_imm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_USAT_Op_A_txt : integer -> integer -> integer -> integer -> SRType -> M unit\<close>\<close>

definition execute_aarch32_instrs_USAT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> SRType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_USAT_Op_A_txt d n saturate_to shift_n shift_t = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   (assert_exp (((((((id0 shift_n)) \<ge> (( 0 :: int)::ii))) \<or> (((((id0 shift_n)) = (( 0 :: int)::ii))))))) (''src/instrs32.sail:18687.54-18687.55'') \<then>
   (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   (Shift w__0 shift_t shift_n(ProcState_C   w__1)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (operand :: 32 bits) . 
   (assert_exp (((( 0 :: int)::ii) \<le> ((((id0 saturate_to)) - (( 1 :: int)::ii))))) (''src/instrs32.sail:18689.44-18689.45'') \<then>
   (ZeroUnsignedSatQ ((Word.sint operand)) saturate_to (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M)) \<bind> ((\<lambda> (w__2 ::
     ( 32 Word.word * bool)) . 
   (let (tup__0, tup__1) = w__2 in
   (let (result :: 32 bits) = tup__0 in
   (let (sat :: bool) = tup__1 in
   R_set d result \<then>
   (if sat then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref ( w__3 (| ProcState_Q := (( 0b1 ::  1 Word.word)) |))))
   else return () )))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "saturate_to"  :: " int " 
  and  "shift_n"  :: " int " 
  and  "shift_t"  :: " SRType "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAT_A1enc_A_txt : mword ty4 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAT_A1enc_A_txt cond sat_imm Rd imm5 sh Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18702.29-18702.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let saturate_to = (Word.uint sat_imm) in
     DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word)) imm5 \<bind> ((\<lambda> (w__1 ::
       (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let shift_t = shift_t in
     (let shift_n = shift_n in
     execute_aarch32_instrs_USAT_Op_A_txt d n saturate_to shift_n shift_t))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "sat_imm"  :: "(5)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm5"  :: "(5)Word.word " 
  and  "sh"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAT_T1enc_A_txt sh Rn imm3 Rd imm2 sat_imm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_n :: ii) . 
     undefined_SRType ()  \<bind> ((\<lambda> (shift_t :: SRType) . 
     (if ((((((sh = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec imm3 imm2  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word))))))) then
        throw (Error_See (''USAT16''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let saturate_to = (Word.uint sat_imm) in
     DecodeImmShift ((concat_vec sh ( 0b0 ::  1 Word.word)  ::  2 Word.word))
       ((concat_vec imm3 imm2  ::  5 Word.word)) \<bind> ((\<lambda> (w__1 :: (SRType * ii)) . 
     (let (tup__0, tup__1) = w__1 in
     (let (shift_t :: SRType) = tup__0 in
     (let (shift_n :: ii) = tup__1 in
     (let shift_n = shift_n in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USAT_Op_A_txt d n saturate_to shift_n shift_t))))))))))))))
   else return () )))\<close> 
  for  "sh"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "imm2"  :: "(2)Word.word " 
  and  "sat_imm"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_USAX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_USAX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_USAX_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let sum1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) +
       ((Word.uint ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange sum1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((sum1 \<ge> ((Word.uint ( 0x10000 ::  20 Word.word))))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((diff \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAX_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18785.29-18785.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USAX_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_USAX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USAX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USAX_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USAX_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_USUB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_USUB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_USUB16_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__5 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__6 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__7) (( 1 :: int)::ii) (( 0 :: int)::ii)
             (if ((diff1 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__8 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__8 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__9) (( 3 :: int)::ii) (( 2 :: int)::ii)
             (if ((diff2 \<ge> (( 0 :: int)::ii))) then ( 0b11 ::  2 Word.word)
              else ( 0b00 ::  2 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_USUB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USUB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USUB16_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18850.29-18850.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USUB16_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_USUB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USUB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USUB16_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USUB16_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_USUB8_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_USUB8_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_USUB8_Op_A_txt d m n = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (let diff1 =
     (((Word.uint ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (let diff2 =
     (((Word.uint ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
   (let diff3 =
     (((Word.uint ((subrange_vec_dec w__4 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__5 (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word))))) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
   (let diff4 =
     (((Word.uint ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) -
       ((Word.uint ((subrange_vec_dec w__7 (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__8 (( 7 :: int)::ii) (( 0 :: int)::ii)
         ((integer_subrange diff1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__9 (( 15 :: int)::ii) (( 8 :: int)::ii)
         ((integer_subrange diff2 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__10 (( 23 :: int)::ii) (( 16 :: int)::ii)
         ((integer_subrange diff3 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__11 (( 31 :: int)::ii) (( 24 :: int)::ii)
         ((integer_subrange diff4 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
        ::  32 Word.word)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__12 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__13 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__12 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__13) (( 0 :: int)::ii) (( 0 :: int)::ii)
             (if ((diff1 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__14 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__15 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__14 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__15) (( 1 :: int)::ii) (( 1 :: int)::ii)
             (if ((diff2 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__16 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__17 :: ProcState) . 
   (write_reg
     PSTATE_ref
     ( w__16 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__17) (( 2 :: int)::ii) (( 2 :: int)::ii)
             (if ((diff3 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)) \<then>
   read_reg PSTATE_ref) \<bind> ((\<lambda> (w__18 :: ProcState) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__19 :: ProcState) . 
   write_reg
     PSTATE_ref
     ( w__18 (|
       ProcState_GE :=
         ((update_subrange_vec_dec(ProcState_GE   w__19) (( 3 :: int)::ii) (( 3 :: int)::ii)
             (if ((diff4 \<ge> (( 0 :: int)::ii))) then ( 0b1 ::  1 Word.word)
              else ( 0b0 ::  1 Word.word))
            ::  4 Word.word)) |)))))))))))))))))))))))))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_USUB8_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USUB8_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USUB8_A1enc_A_txt cond Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18921.29-18921.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USUB8_Op_A_txt d m n))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_USUB8_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_USUB8_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_USUB8_T1enc_A_txt Rn Rd Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_USUB8_Op_A_txt d m n)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UXTAB16_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UXTAB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UXTAB16_Op_A_txt d m n rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((add_vec ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
             ((zero_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)
                ::  16 Word.word))
            ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__3 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((add_vec ((subrange_vec_dec w__4 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
             ((zero_extend ((subrange_vec_dec rotated (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)
                ::  16 Word.word))
            ::  16 Word.word))
        ::  32 Word.word))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTAB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTAB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTAB16_A1enc_A_txt cond Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:18983.29-18983.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''UXTB16''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTAB16_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTAB16_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTAB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTAB16_T1enc_A_txt Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''UXTB16''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTAB16_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UXTAB_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UXTAB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UXTAB_Op_A_txt d m n rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   R_set d
     ((add_vec w__1
         ((zero_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  32 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTAB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTAB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTAB_A1enc_A_txt cond Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19058.29-19058.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''UXTB''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTAB_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTAB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTAB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTAB_T1enc_A_txt Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''UXTB''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTAB_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UXTAH_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UXTAH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UXTAH_Op_A_txt d m n rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   R_set d
     ((add_vec w__1
         ((zero_extend ((subrange_vec_dec rotated (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) (( 32 :: int)::ii)
            ::  32 Word.word))
        ::  32 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTAH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTAH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTAH_A1enc_A_txt cond Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19133.29-19133.30'') \<then>
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''UXTH''))
      else return () )) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTAH_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTAH_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTAH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTAH_T1enc_A_txt Rn Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((Rn = ( 0xF ::  4 Word.word)))) then throw (Error_See (''UXTH''))
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTAH_Op_A_txt d m n rotation)))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UXTB16_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UXTB16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UXTB16_Op_A_txt d m rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   (R_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (R_set d
     ((update_subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)
         ((zero_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)) \<then>
   (R_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   R_set d
     ((update_subrange_vec_dec w__2 (( 31 :: int)::ii) (( 16 :: int)::ii)
         ((zero_extend ((subrange_vec_dec rotated (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)) (( 16 :: int)::ii)
            ::  16 Word.word))
        ::  32 Word.word))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTB16_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTB16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTB16_A1enc_A_txt cond Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19209.29-19209.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTB16_Op_A_txt d m rotation))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTB16_T1enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTB16_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTB16_T1enc_A_txt Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTB16_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UXTB_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UXTB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UXTB_Op_A_txt d m rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   R_set d
     ((zero_extend ((subrange_vec_dec rotated (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTB_A1enc_A_txt cond Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19274.29-19274.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTB_Op_A_txt d m rotation))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTB_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTB_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTB_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = ((( 0 :: int)::ii)) in
     execute_aarch32_instrs_UXTB_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTB_T2enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTB_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTB_T2enc_A_txt Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTB_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_UXTH_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_UXTH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_UXTH_Op_A_txt d m rotation = (
   (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (let (rotated :: 32 bits) = ((ROR w__0 rotation  ::  32 Word.word)) in
   R_set d
     ((zero_extend ((subrange_vec_dec rotated (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) (( 32 :: int)::ii)  ::  32 Word.word))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "rotation"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTH_A1enc_A_txt cond Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19358.29-19358.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTH_Op_A_txt d m rotation))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTH_T1enc_A_txt : mword ty3 -> mword ty3 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTH_T1enc_A_txt  :: \<open>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTH_T1enc_A_txt Rm Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = ((( 0 :: int)::ii)) in
     execute_aarch32_instrs_UXTH_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rm"  :: "(3)Word.word " 
  and  "Rd"  :: "(3)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_UXTH_T2enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_UXTH_T2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_UXTH_T2enc_A_txt Rd rotate Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let m = (Word.uint Rm) in
     (let rotation = (Word.uint ((concat_vec rotate ( 0b000 ::  3 Word.word)  ::  5 Word.word))) in
     (if ((((((d = (( 15 :: int)::ii)))) \<or> (((m = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_UXTH_Op_A_txt d m rotation)))
   else return () )))\<close> 
  for  "Rd"  :: "(4)Word.word " 
  and  "rotate"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VABA_Op_A_txt : integer -> integer -> integer -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VABA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VABA_Op_A_txt d__arg elements l__359 long_destination m n regs is_unsigned = (
   if (((l__359 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op1 :: 8 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op2 :: 8 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
             (let op1 = w__1 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
             (let op2 = w__3 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__4 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
                (Elem_read w__5 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::  16 Word.word) . 
                (Elem_set w__4 e (( 16 :: int)::ii) ((add_vec_int w__6 absdiff  ::  16 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__7))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
                (Elem_read w__9 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__10 ::  8 Word.word) . 
                (Elem_set w__8 e (( 8 :: int)::ii) ((add_vec_int w__10 absdiff  ::  8 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::
                   64 Word.word) . 
                D_set ((d + r)) w__11))))))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::  8 Word.word), (op2 ::
        8 Word.word)) = varstup in
     return () )))))))))))))
   else if (((l__359 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op1 :: 16 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op2 :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
             (Elem_read w__12 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__13 ::  16 Word.word) . 
             (let op1 = w__13 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
             (Elem_read w__14 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__15 ::  16 Word.word) . 
             (let op2 = w__15 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__16 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__17 ::  128 Word.word) . 
                (Elem_read w__17 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
                (Elem_set w__16 e (( 32 :: int)::ii) ((add_vec_int w__18 absdiff  ::  32 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__19))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
                (Elem_read w__21 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__22 ::  16 Word.word) . 
                (Elem_set w__20 e (( 16 :: int)::ii) ((add_vec_int w__22 absdiff  ::  16 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
                D_set ((d + r)) w__23))))))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::
        16 Word.word), (op2 ::  16 Word.word)) = varstup in
     return () )))))))))))))
   else if (((l__359 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op2 :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
             (Elem_read w__24 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
             (let op1 = w__25 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
             (Elem_read w__26 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__27 ::  32 Word.word) . 
             (let op2 = w__27 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__28 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__29 ::  128 Word.word) . 
                (Elem_read w__29 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
                (Elem_set w__28 e (( 64 :: int)::ii) ((add_vec_int w__30 absdiff  ::  64 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__31 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__31))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__33 ::  64 Word.word) . 
                (Elem_read w__33 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__34 ::  32 Word.word) . 
                (Elem_set w__32 e (( 32 :: int)::ii) ((add_vec_int w__34 absdiff  ::  32 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
                D_set ((d + r)) w__35))))))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::
        32 Word.word), (op2 ::  32 Word.word)) = varstup in
     return () )))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op1 :: 64 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op2 :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
             (Elem_read w__36 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__37 ::  64 Word.word) . 
             (let op1 = w__37 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__38 ::  64 Word.word) . 
             (Elem_read w__38 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__39 ::  64 Word.word) . 
             (let op2 = w__39 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__40 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__41 ::  128 Word.word) . 
                (Elem_read w__41 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__42 ::  128 Word.word) . 
                (Elem_set w__40 e (( 128 :: int)::ii) ((add_vec_int w__42 absdiff  ::  128 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__43 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__43))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__44 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::  64 Word.word) . 
                (Elem_read w__45 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__46 ::  64 Word.word) . 
                (Elem_set w__44 e (( 64 :: int)::ii) ((add_vec_int w__46 absdiff  ::  64 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__47 ::  64 Word.word) . 
                D_set ((d + r)) w__47))))))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::
        64 Word.word), (op2 ::  64 Word.word)) = varstup in
     return () ))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__359"  :: " int " 
  and  "long_destination"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABA_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABA_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABA_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABA_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABA_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABA_A2enc_A_txt U D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABA_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABA_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABA_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABA_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABA_T2enc_A_txt U D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABA_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VABD_f_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VABD_f_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VABD_f_Op_A_txt d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2)
     ((\<lambda> r varstup .  (let (op1, op2) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2)
         ((\<lambda> e varstup .  (let (op1, op2) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = w__3 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           (FPSub op1 op2 w__5  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
           (FPAbs w__6  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
           (Elem_set w__4 e esize w__7  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
           D_set ((d + r)) w__8 \<then> return (op1, op2))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (op2 :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABD_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABD_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABD_f_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VABD_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABD_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABD_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABD_f_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VABD_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VABD_i_Op_A_txt : integer -> integer -> integer -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VABD_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VABD_i_Op_A_txt d__arg elements l__356 long_destination m n regs is_unsigned = (
   if (((l__356 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op1 :: 8 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op2 :: 8 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
             (let op1 = w__1 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
             (let op2 = w__3 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__4 ::  128 Word.word) . 
                (Elem_set w__4 e (( 16 :: int)::ii) ((integer_subrange absdiff (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__5))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
                (Elem_set w__6 e (( 8 :: int)::ii) ((integer_subrange absdiff (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
                D_set ((d + r)) w__7))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::  8 Word.word), (op2 ::
        8 Word.word)) = varstup in
     return () )))))))))))))
   else if (((l__356 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op1 :: 16 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op2 :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
             (Elem_read w__8 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__9 ::  16 Word.word) . 
             (let op1 = w__9 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
             (Elem_read w__10 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
             (let op2 = w__11 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
                (Elem_set w__12 e (( 32 :: int)::ii) ((integer_subrange absdiff (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__13 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__13))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
                (Elem_set w__14 e (( 16 :: int)::ii) ((integer_subrange absdiff (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
                D_set ((d + r)) w__15))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::
        16 Word.word), (op2 ::  16 Word.word)) = varstup in
     return () )))))))))))))
   else if (((l__356 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op2 :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
             (Elem_read w__16 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
             (let op1 = w__17 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
             (Elem_read w__18 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
             (let op2 = w__19 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__20 ::  128 Word.word) . 
                (Elem_set w__20 e (( 64 :: int)::ii) ((integer_subrange absdiff (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__21))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
                (Elem_set w__22 e (( 32 :: int)::ii) ((integer_subrange absdiff (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
                D_set ((d + r)) w__23))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::
        32 Word.word), (op2 ::  32 Word.word)) = varstup in
     return () )))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (absdiff :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op1 :: 64 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op2 :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
       ((\<lambda> r varstup .  (let (absdiff, op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (absdiff, op1, op2)
           ((\<lambda> e varstup .  (let (absdiff, op1, op2) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
             (Elem_read w__24 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__25 ::  64 Word.word) . 
             (let op1 = w__25 in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
             (Elem_read w__26 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
             (let op2 = w__27 in
             (let (absdiff :: ii) =
               (abs ((((asl_Int op1 is_unsigned)) - ((asl_Int op2 is_unsigned))))) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__28 ::  128 Word.word) . 
                (Elem_set w__28 e (( 128 :: int)::ii)
                   ((integer_subrange absdiff (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__29 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__29))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
                (Elem_set w__30 e (( 64 :: int)::ii) ((integer_subrange absdiff (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
                D_set ((d + r)) w__31))))) \<then>
             return (absdiff, op1, op2)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((absdiff :: ii), (op1 ::
        64 Word.word), (op2 ::  64 Word.word)) = varstup in
     return () ))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__356"  :: " int " 
  and  "long_destination"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABD_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABD_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABD_i_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABD_i_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABD_i_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABD_i_A2enc_A_txt U D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABD_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABD_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABD_i_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABD_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABD_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABD_i_T2enc_A_txt U D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VABD_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VABS_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VABS_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VABS_Op_A_txt advsimd d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
       ((\<lambda> r result . 
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
           ((\<lambda> e result . 
             if floating_point then
               (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:19894.61-19894.62'') \<then>
               (D_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
               (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
               (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
               (FPAbs w__2  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
               (Elem_set w__0 e esize w__3  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
               D_set ((d + r)) w__4 \<then> return result))))))))))
             else
               (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
               (Elem_read w__5 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
               (let result = (abs ((Word.sint w__6))) in
               (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
               (Elem_set w__7 e esize
                  ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
                 :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
               D_set ((d + r)) w__8 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))
   else
     (let l__353 = esize in
     if (((l__353 = (( 16 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
       (FPAbs ((subrange_vec_dec w__9 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__10 ::
          16 Word.word) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__10  ::  32 Word.word))))))
     else if (((l__353 = (( 32 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
       (FPAbs w__11  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) .  S_set d w__12))))
     else if (((l__353 = (( 64 :: int)::ii)))) then
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
       (FPAbs w__13  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) .  D_set d w__14))))
     else return () )))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABS_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABS_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABS_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABS_Op_A_txt True d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABS_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABS_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABS_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABS_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABS_A2enc_A_txt cond D Vd b__0 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19959.29-19959.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       (if (((True \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VABS_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19959.29-19959.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
          return (((((slice w__5 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
          return (((((slice w__6 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__7 ::
         bool) . 
       (if w__7 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VABS_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19959.29-19959.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
          return (((((slice w__9 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          return (((((slice w__10 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__11 ::
         bool) . 
       (if w__11 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VABS_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   if w__12 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:19959.29-19959.30'') \<then>
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return (((((slice w__13 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
        return (((((slice w__14 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__15 ::
       bool) . 
     (((if w__15 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VABS_Op_A_txt False d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABS_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABS_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABS_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABS_Op_A_txt True d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABS_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VABS_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VABS_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VABS_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VABS_T2enc_A_txt D Vd b__0 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       and_boolM (return True) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
       (if w__5 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VABS_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) floating_point m regs))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
          return (((((slice w__7 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
          return (((((slice w__8 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__9 ::
         bool) . 
       (if w__9 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VABS_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
          return (((((slice w__11 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return (((((slice w__12 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
         bool) . 
       (if w__13 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VABS_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
   if w__14 then
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
        return (((((slice w__15 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
        return (((((slice w__16 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__17 ::
       bool) . 
     (((if w__17 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__19 :: bool) . 
     (if w__19 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VABS_Op_A_txt False d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VACGE_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VACGE_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VACGE_Op_A_txt d__arg elements esize m n or_equal regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2)
     ((\<lambda> r varstup .  (let (op1, op2) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2)
         ((\<lambda> e varstup .  (let (op1, op2) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (FPAbs w__1  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (let op1 = w__2 in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (FPAbs w__4  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
           (let op2 = w__5 in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (if or_equal then
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
              FPCompareGE op1 op2 w__6))
            else
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
              FPCompareGT op1 op2 w__8))) \<bind> ((\<lambda> (test_passed :: bool) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
           (Elem_set w__10 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
           D_set ((d + r)) w__11 \<then> return (op1, op2))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (op2 :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "or_equal"  :: " bool " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VACGE_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VACGE_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VACGE_A1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (or_equal :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VACGE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         or_equal regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (or_equal :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VACGE_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       or_equal regs))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VACGE_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VACGE_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VACGE_T1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (or_equal :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VACGE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         or_equal regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (or_equal :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VACGE_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       or_equal regs))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VADD_f_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VADD_f_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VADD_f_Op_A_txt advsimd d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
       ((\<lambda> r unit_var . 
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
           ((\<lambda> e unit_var . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
             (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             (FPAdd w__2 w__4 w__5  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
             (Elem_set w__0 e esize w__6  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
             D_set ((d + r)) w__7))))))))))))))))))))))))))
   else
     (let l__350 = esize in
     if (((l__350 = (( 16 :: int)::ii)))) then
       (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
       (FPAdd ((subrange_vec_dec w__8 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ((subrange_vec_dec w__9 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__10
         :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__11  ::  32 Word.word))))))))))
     else if (((l__350 = (( 32 :: int)::ii)))) then
       (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
       (FPAdd w__12 w__13 w__14  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) .  S_set d w__15))))))))
     else if (((l__350 = (( 64 :: int)::ii)))) then
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
       (FPAdd w__16 w__17 w__18  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) .  D_set d w__19))))))))
     else return () )))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADD_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADD_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADD_f_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_f_Op_A_txt True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VADD_f_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADD_f_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADD_f_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADD_f_A2enc_A_txt cond D Vn Vd b__0 N M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:20321.29-20321.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       (if (((True \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:20321.29-20321.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
          return (((((slice w__5 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
          return (((((slice w__6 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__7 ::
         bool) . 
       (if w__7 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:20321.29-20321.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
          return (((((slice w__9 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          return (((((slice w__10 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__11 ::
         bool) . 
       (if w__11 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   if w__12 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:20321.29-20321.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return (((((slice w__13 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
        return (((((slice w__14 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__15 ::
       bool) . 
     (((if w__15 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADD_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADD_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADD_f_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_f_Op_A_txt True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VADD_f_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n regs)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADD_f_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADD_f_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADD_f_T2enc_A_txt D Vn Vd b__0 N M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       and_boolM (return True) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
       (if w__5 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
          return (((((slice w__7 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
          return (((((slice w__8 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__9 ::
         bool) . 
       (if w__9 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
          return (((((slice w__11 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return (((((slice w__12 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
         bool) . 
       (if w__13 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
   if w__14 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
        return (((((slice w__15 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
        return (((((slice w__16 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__17 ::
       bool) . 
     (((if w__17 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__19 :: bool) . 
     (if w__19 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VADD_f_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VADDHN_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VADDHN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VADDHN_Op_A_txt d__arg elements l__347 m n = (
   if (((l__347 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::  128 Word.word) . 
         (Elem_read w__2 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
         (let result = ((add_vec w__1 w__3  ::  16 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_set w__4 e (( 8 :: int)::ii) ((subrange_vec_dec result (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
         D_set d w__5 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  16 Word.word) . 
     return () ))))))))
   else if (((l__347 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_read w__6 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
         (Elem_read w__8 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (let result = ((add_vec w__7 w__9  ::  32 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (Elem_set w__10 e (( 16 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  32 Word.word) . 
     return () ))))))))
   else if (((l__347 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         (Elem_read w__12 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_read w__14 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         (let result = ((add_vec w__13 w__15  ::  64 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
         (Elem_set w__16 e (( 32 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
         D_set d w__17 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (result :: 128 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
         (Elem_read w__18 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__20 ::  128 Word.word) . 
         (Elem_read w__20 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
         (let result = ((add_vec w__19 w__21  ::  128 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
         (Elem_set w__22 e (( 64 :: int)::ii) ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
         D_set d w__23 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  128 Word.word) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__347"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADDHN_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADDHN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADDHN_A1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADDHN_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADDHN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADDHN_T1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VADD_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VADD_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VADD_i_Op_A_txt d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize ((add_vec w__2 w__4  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::
              64 Word.word) . 
           D_set ((d + r)) w__5))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADD_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADD_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADD_i_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VADD_i_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADD_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADD_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADD_i_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VADD_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VADD_i_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VADDL_Op_A_txt : integer -> integer -> integer -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VADDL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VADDL_Op_A_txt d__arg elements l__344 is_vaddw m n is_unsigned = (
   if (((l__344 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vaddw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
            (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
            (let op1 = (asl_Int w__1 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
            (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
            (let op1 = (asl_Int w__3 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_read w__4 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
         (let result = (op1 + ((asl_Int w__5 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_set w__6 e (( 16 :: int)::ii) ((integer_subrange result (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__7 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__344 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vaddw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
            (Elem_read w__8 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
            (let op1 = (asl_Int w__9 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
            (Elem_read w__10 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
            (let op1 = (asl_Int w__11 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
         (Elem_read w__12 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__13 ::  16 Word.word) . 
         (let result = (op1 + ((asl_Int w__13 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_set w__14 e (( 32 :: int)::ii) ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__15 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__15 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__344 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vaddw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__16 ::  128 Word.word) . 
            (Elem_read w__16 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
            (let op1 = (asl_Int w__17 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
            (Elem_read w__18 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
            (let op1 = (asl_Int w__19 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
         (Elem_read w__20 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
         (let result = (op1 + ((asl_Int w__21 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__22 ::  128 Word.word) . 
         (Elem_set w__22 e (( 64 :: int)::ii) ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__23 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__23 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vaddw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__24 ::  128 Word.word) . 
            (Elem_read w__24 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__25 ::  128 Word.word) . 
            (let op1 = (asl_Int w__25 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
            (Elem_read w__26 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
            (let op1 = (asl_Int w__27 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
         (Elem_read w__28 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
         (let result = (op1 + ((asl_Int w__29 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__30 ::  128 Word.word) . 
         (Elem_set w__30 e (( 128 :: int)::ii) ((integer_subrange result (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__31 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__31 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__344"  :: " int " 
  and  "is_vaddw"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADDL_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADDL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADDL_A1enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vaddw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) is_vaddw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vaddw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) is_vaddw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vaddw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) is_vaddw m n is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VADDL_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VADDL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VADDL_T1enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vaddw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) is_vaddw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vaddw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) is_vaddw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vaddw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VADDL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) is_vaddw m n is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VAND_r_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VAND_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VAND_r_Op_A_txt d m n regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       D_set ((d + r)) ((and_vec w__0 w__1  ::  64 Word.word)))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VAND_r_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VAND_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VAND_r_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VAND_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VAND_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VAND_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VAND_r_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VAND_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VBIC_i_Op_A_txt : integer -> mword ty64 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VBIC_i_Op_A_txt  :: \<open> int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       D_set ((d + r)) ((and_vec w__0 ((not_vec imm64  ::  64 Word.word))  ::  64 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm64"  :: "(64)Word.word " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIC_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIC_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIC_i_A1enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIC_i_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIC_i_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIC_i_A2enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIC_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIC_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIC_i_T1enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIC_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIC_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIC_i_T2enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VBIC_r_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VBIC_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VBIC_r_Op_A_txt d m n regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       D_set ((d + r)) ((and_vec w__0 ((not_vec w__1  ::  64 Word.word))  ::  64 Word.word)))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIC_r_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIC_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIC_r_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIC_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIC_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIC_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIC_r_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIC_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VBIF_Op_A_txt : integer -> integer -> integer -> VBitOps -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VBIF_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> VBitOps \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VBIF_Op_A_txt d m n operation regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (case  operation of
         VBitOps_VBIF =>
          (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
          (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
          (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
          (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
          D_set ((d + r))
            ((or_vec ((and_vec w__0 w__1  ::  64 Word.word))
                ((and_vec w__2 ((not_vec w__3  ::  64 Word.word))  ::  64 Word.word))
               ::  64 Word.word))))))))))
       | VBitOps_VBIT =>
          (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
          (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
          (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
          (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
          D_set ((d + r))
            ((or_vec ((and_vec w__4 w__5  ::  64 Word.word))
                ((and_vec w__6 ((not_vec w__7  ::  64 Word.word))  ::  64 Word.word))
               ::  64 Word.word))))))))))
       | VBitOps_VBSL =>
          (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
          (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
          (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
          (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
          D_set ((d + r))
            ((or_vec ((and_vec w__8 w__9  ::  64 Word.word))
                ((and_vec w__10 ((not_vec w__11  ::  64 Word.word))  ::  64 Word.word))
               ::  64 Word.word))))))))))
       ))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "operation"  :: " VBitOps " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIF_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIF_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIF_A1enc_A_txt D op1 Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (operation :: VBitOps) = VBitOps_VBIF in
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VEOR''))
      else return () )) \<then>
     ((let (operation :: VBitOps) =
       (if (((op1 = ( 0b01 ::  2 Word.word)))) then VBitOps_VBSL
       else operation) in
     (let (operation :: VBitOps) =
       (if (((op1 = ( 0b10 ::  2 Word.word)))) then VBitOps_VBIT
       else operation) in
     (let (operation :: VBitOps) =
       (if (((op1 = ( 0b11 ::  2 Word.word)))) then VBitOps_VBIF
       else operation) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIF_Op_A_txt d m n operation regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VBIF_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VBIF_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VBIF_T1enc_A_txt D op1 Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (operation :: VBitOps) = VBitOps_VBIF in
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VEOR''))
      else return () )) \<then>
     ((let (operation :: VBitOps) =
       (if (((op1 = ( 0b01 ::  2 Word.word)))) then VBitOps_VBSL
       else operation) in
     (let (operation :: VBitOps) =
       (if (((op1 = ( 0b10 ::  2 Word.word)))) then VBitOps_VBIT
       else operation) in
     (let (operation :: VBitOps) =
       (if (((op1 = ( 0b11 ::  2 Word.word)))) then VBitOps_VBIF
       else operation) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VBIF_Op_A_txt d m n operation regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCEQ_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCEQ_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCEQ_i_Op_A_txt d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (if floating_point then
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:21125.57-21125.58'') \<then>
              (FPZero esize ( 0b0 ::  1 Word.word)  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (zero :: ( 'esize::len)Word.word) . 
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
              (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              FPCompareEQ w__1 zero w__2))))))))
            else
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let test_passed = (w__5 = ((Zeros esize  :: ( 'esize::len)Word.word))) in
              return test_passed)))))) \<bind> ((\<lambda> (test_passed :: bool) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCEQ_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCEQ_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCEQ_i_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCEQ_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCEQ_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCEQ_i_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCEQ_r_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCEQ_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCEQ_r_Op_A_txt d__arg elements esize int_operation m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2)
     ((\<lambda> r varstup .  (let (op1, op2) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2)
         ((\<lambda> e varstup .  (let (op1, op2) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = w__3 in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (if int_operation then
              (let (test_passed :: bool) = (op1 = op2) in
              return test_passed)
            else
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:21231.57-21231.58'') \<then>
              (StandardFPSCRValue ()   :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              FPCompareEQ op1 op2 w__4))) \<bind> ((\<lambda> (test_passed :: bool) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7 \<then> return (op1, op2))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (op2 :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "int_operation"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCEQ_r_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCEQ_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCEQ_r_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) True
         m n regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         True m n regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         True m n regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCEQ_r_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCEQ_r_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCEQ_r_A2enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         False m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) False
       m n regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCEQ_r_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCEQ_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCEQ_r_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) True
         m n regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         True m n regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         True m n regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCEQ_r_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCEQ_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCEQ_r_T2enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         False m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCEQ_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) False
       m n regs)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCGE_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCGE_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCGE_i_Op_A_txt d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (if floating_point then
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:21420.57-21420.58'') \<then>
              (FPZero esize ( 0b0 ::  1 Word.word)  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (zero :: ( 'esize::len)Word.word) . 
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
              (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              FPCompareGE w__1 zero w__2))))))))
            else
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let test_passed = (((Word.sint w__5)) \<ge> (( 0 :: int)::ii)) in
              return test_passed)))))) \<bind> ((\<lambda> (test_passed :: bool) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGE_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGE_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGE_i_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGE_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGE_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGE_i_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCGE_r_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> VCGEType -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCGE_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> VCGEType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCGE_r_Op_A_txt d__arg elements esize m n regs vtype = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2)
     ((\<lambda> r varstup .  (let (op1, op2) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2)
         ((\<lambda> e varstup .  (let (op1, op2) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = w__3 in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (case  vtype of
             VCGEType_signed =>
              (let (test_passed :: bool) = (((Word.sint op1)) \<ge> ((Word.sint op2))) in
              return test_passed)
           | VCGEType_unsigned =>
              (let (test_passed :: bool) = (((Word.uint op1)) \<ge> ((Word.uint op2))) in
              return test_passed)
           | VCGEType_fp =>
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:21531.59-21531.60'') \<then>
              (StandardFPSCRValue ()   :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              FPCompareGE op1 op2 w__4))
           ) \<bind> ((\<lambda> (test_passed :: bool) . 
           (let test_passed = test_passed in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7 \<then> return (op1, op2)))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (op2 :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "vtype"  :: " VCGEType "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGE_r_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGE_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGE_r_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGEType) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGEType_unsigned
         else VCGEType_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGEType) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGEType_unsigned
         else VCGEType_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGEType) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGEType_unsigned
         else VCGEType_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs vtype))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGE_r_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGE_r_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGE_r_A2enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs VCGEType_fp)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs VCGEType_fp)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGE_r_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGE_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGE_r_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGEType) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGEType_unsigned
         else VCGEType_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGEType) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGEType_unsigned
         else VCGEType_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGEType) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGEType_unsigned
         else VCGEType_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs vtype))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGE_r_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGE_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGE_r_T2enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs VCGEType_fp)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCGE_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs VCGEType_fp)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCGT_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCGT_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCGT_i_Op_A_txt d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (if floating_point then
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:21726.57-21726.58'') \<then>
              (FPZero esize ( 0b0 ::  1 Word.word)  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (zero :: ( 'esize::len)Word.word) . 
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
              (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              FPCompareGT w__1 zero w__2))))))))
            else
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let test_passed = (((Word.sint w__5)) > (( 0 :: int)::ii)) in
              return test_passed)))))) \<bind> ((\<lambda> (test_passed :: bool) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGT_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGT_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGT_i_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGT_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGT_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGT_i_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCGT_r_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> VCGTtype -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCGT_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> VCGTtype \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCGT_r_Op_A_txt d__arg elements esize m n regs vtype = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2)
     ((\<lambda> r varstup .  (let (op1, op2) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2)
         ((\<lambda> e varstup .  (let (op1, op2) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = w__3 in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (case  vtype of
             VCGTtype_signed =>
              (let (test_passed :: bool) = (((Word.sint op1)) > ((Word.sint op2))) in
              return test_passed)
           | VCGTtype_unsigned =>
              (let (test_passed :: bool) = (((Word.uint op1)) > ((Word.uint op2))) in
              return test_passed)
           | VCGTtype_fp =>
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:21837.59-21837.60'') \<then>
              (StandardFPSCRValue ()   :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              FPCompareGT op1 op2 w__4))
           ) \<bind> ((\<lambda> (test_passed :: bool) . 
           (let test_passed = test_passed in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7 \<then> return (op1, op2)))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (op2 :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "vtype"  :: " VCGTtype "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGT_r_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGT_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGT_r_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGTtype) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGTtype_unsigned
         else VCGTtype_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGTtype) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGTtype_unsigned
         else VCGTtype_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGTtype) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGTtype_unsigned
         else VCGTtype_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs vtype))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGT_r_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGT_r_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGT_r_A2enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs VCGTtype_fp)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs VCGTtype_fp)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGT_r_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGT_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGT_r_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGTtype) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGTtype_unsigned
         else VCGTtype_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGTtype) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGTtype_unsigned
         else VCGTtype_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs vtype))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (vtype :: VCGTtype) =
         (if (((U = ( 0b1 ::  1 Word.word)))) then VCGTtype_unsigned
         else VCGTtype_signed) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs vtype))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCGT_r_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCGT_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCGT_r_T2enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs VCGTtype_fp)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCGT_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs VCGTtype_fp)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCLE_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCLE_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCLE_i_Op_A_txt d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (if floating_point then
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:22032.57-22032.58'') \<then>
              (FPZero esize ( 0b0 ::  1 Word.word)  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (zero :: ( 'esize::len)Word.word) . 
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
              (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              FPCompareGE zero w__1 w__2))))))))
            else
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let test_passed = (((Word.sint w__5)) \<le> (( 0 :: int)::ii)) in
              return test_passed)))))) \<bind> ((\<lambda> (test_passed :: bool) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLE_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLE_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLE_i_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLE_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLE_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLE_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLE_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLE_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLE_i_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLE_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLE_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLE_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCLS_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCLS_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCLS_Op_A_txt d__arg elements esize m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize
              ((integer_subrange ((CountLeadingSignBits w__2)) ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)
                 :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           D_set ((d + r)) w__3))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLS_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLS_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLS_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLS_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLS_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLS_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLS_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLS_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCLT_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCLT_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCLT_i_Op_A_txt d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (test_passed :: bool) . 
           (if floating_point then
              (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:22208.57-22208.58'') \<then>
              (FPZero esize ( 0b0 ::  1 Word.word)  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (zero :: ( 'esize::len)Word.word) . 
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
              (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              FPCompareGT zero w__1 w__2))))))))
            else
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let test_passed = (((Word.sint w__5)) < (( 0 :: int)::ii)) in
              return test_passed)))))) \<bind> ((\<lambda> (test_passed :: bool) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize
              (if test_passed then (Ones esize  :: ( 'esize::len)Word.word)
               else (Zeros esize  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLT_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLT_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLT_i_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLT_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLT_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLT_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLT_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLT_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLT_i_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLT_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLT_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLT_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCLZ_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCLZ_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCLZ_Op_A_txt d__arg elements esize m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize
              ((integer_subrange ((CountLeadingZeroBits w__2)) ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)
                 :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           D_set ((d + r)) w__3))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLZ_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLZ_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLZ_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLZ_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLZ_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLZ_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCLZ_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCLZ_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCLZ_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLZ_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLZ_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCLZ_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCMP_Op_A_txt : integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCMP_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero = (
   (CheckVFPEnabled True \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M)) \<bind> ((\<lambda> (nzcv :: 4 bits) . 
   (let l__341 = esize in
   (if (((l__341 = (( 16 :: int)::ii)))) then
      (if with_zero then
         (FPZero (((( 0 :: int)::ii) + (((((( 15 :: int)::ii) - (( 0 :: int)::ii))) + (( 1 :: int)::ii)))))
            ( 0b0 ::  1 Word.word)
           :: ( 16 Word.word) M)
       else
         (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
         return ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (op16 :: 16 bits) . 
      (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      (FPCompare ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) op16 quiet_nan_exc w__3
        :: ( 4 Word.word) M)))))))
    else if (((l__341 = (( 32 :: int)::ii)))) then
      (if with_zero then (FPZero (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  :: ( 32 Word.word) M)
       else (S_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (op32 :: 32 bits) . 
      (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
      (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
      (FPCompare w__7 op32 quiet_nan_exc w__8  :: ( 4 Word.word) M)))))))
    else if (((l__341 = (( 64 :: int)::ii)))) then
      (if with_zero then (FPZero (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  :: ( 64 Word.word) M)
       else (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (op64 :: 64 bits) . 
      (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
      (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
      (FPCompare w__12 op64 quiet_nan_exc w__13  :: ( 4 Word.word) M)))))))
    else return nzcv) \<bind> ((\<lambda> (nzcv ::  4 Word.word) . 
   (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
   FPSCR_write ((update_subrange_vec_dec w__15 (( 31 :: int)::ii) (( 28 :: int)::ii) nzcv  ::  32 Word.word))))))))))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "quiet_nan_exc"  :: " bool " 
  and  "with_zero"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMP_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMP_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMP_A1enc_A_txt cond D Vd size1 E M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:22404.29-22404.30'') \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (quiet_nan_exc :: bool) = (E = ( 0b1 ::  1 Word.word)) in
     (let (with_zero :: bool) = False in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "E"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMP_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMP_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMP_A2enc_A_txt cond D Vd size1 E = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:22458.29-22458.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (m :: ii) . 
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let m = m in
     (let (quiet_nan_exc :: bool) = (E = ( 0b1 ::  1 Word.word)) in
     (let (with_zero :: bool) = True in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (d, esize)))
       else
         (let ((d :: int), (esize :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (d, esize)))
           else
             (let ((d :: int), (esize :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (d, esize)))
               else (d, esize)) in
             (d, esize))) in
         (d, esize))) in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "E"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMP_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMP_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMP_T1enc_A_txt D Vd size1 E M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (quiet_nan_exc :: bool) = (E = ( 0b1 ::  1 Word.word)) in
     (let (with_zero :: bool) = False in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero)))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "E"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMP_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMP_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMP_T2enc_A_txt D Vd size1 E = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let m = m in
     (let (quiet_nan_exc :: bool) = (E = ( 0b1 ::  1 Word.word)) in
     (let (with_zero :: bool) = True in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (d, esize)))
       else
         (let ((d :: int), (esize :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (d, esize)))
           else
             (let ((d :: int), (esize :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (d, esize)))
               else (d, esize)) in
             (d, esize))) in
         (d, esize))) in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero)))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "E"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCNT_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCNT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCNT_Op_A_txt d__arg elements esize m regs = (
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__2 ::  8 Word.word) . 
           (Elem_set w__0 e esize
              ((integer_subrange ((BitCount w__2)) ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  8 Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           D_set ((d + r)) w__3)))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCNT_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCNT_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCNT_A1enc_A_txt D size1 Vd Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let esize = ((( 8 :: int)::ii)) in
     (let elements = ((( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCNT_Op_A_txt d elements esize m regs))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCNT_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCNT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCNT_T1enc_A_txt D size1 Vd Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let esize = ((( 8 :: int)::ii)) in
     (let elements = ((( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCNT_Op_A_txt d elements esize m regs))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVTB_Op_A_txt : bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVTB_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVTB_Op_A_txt convert_from_half d lowbit m uses_double = (
   (CheckVFPEnabled True \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> ((\<lambda> (hp :: 16 bits) . 
   if convert_from_half then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (let (hp :: 16 bits) = ((slice w__0 lowbit (( 16 :: int)::ii)  ::  16 Word.word)) in
     if uses_double then
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (FPConvert__1 (( 64 :: int)::ii) hp w__1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) .  D_set d w__2))))
     else
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
       (FPConvert__1 (( 32 :: int)::ii) hp w__3  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) .  S_set d w__4)))))))
   else
     (if uses_double then
        (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
        (FPConvert__1 (( 16 :: int)::ii) w__5 w__6  :: ( 16 Word.word) M)))))
      else
        (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
        (FPConvert__1 (( 16 :: int)::ii) w__8 w__9  :: ( 16 Word.word) M)))))) \<bind> ((\<lambda> (hp ::  16 Word.word) . 
     (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
     S_set d ((update_subrange_vec_dec w__11 ((lowbit + (( 15 :: int)::ii))) lowbit hp  ::  32 Word.word)))))))))\<close> 
  for  "convert_from_half"  :: " bool " 
  and  "d"  :: " int " 
  and  "lowbit"  :: " int " 
  and  "m"  :: " int " 
  and  "uses_double"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTB_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTB_A1enc_A_txt cond D op1 Vd sz T M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:22714.29-22714.30'') \<then>
     ((let (uses_double :: bool) = (sz = ( 0b1 ::  1 Word.word)) in
     (let (convert_from_half :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let lowbit = (if (((T = ( 0b1 ::  1 Word.word)))) then (( 16 :: int)::ii) else (( 0 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let ((d :: int), (m :: int)) =
       (if uses_double then
         (let ((d :: int), (m :: int)) =
           (if convert_from_half then
             (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, m)))
           else
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
             (d, m)))) in
         (d, m))
       else
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, m)))) in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VCVTB_Op_A_txt convert_from_half d lowbit m uses_double)))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "sz"  :: "(1)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTB_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTB_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTB_T1enc_A_txt D op1 Vd sz T M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (uses_double :: bool) = (sz = ( 0b1 ::  1 Word.word)) in
     (let (convert_from_half :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let lowbit = (if (((T = ( 0b1 ::  1 Word.word)))) then (( 16 :: int)::ii) else (( 0 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let ((d :: int), (m :: int)) =
       (if uses_double then
         (let ((d :: int), (m :: int)) =
           (if convert_from_half then
             (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, m)))
           else
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
             (d, m)))) in
         (d, m))
       else
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, m)))) in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VCVTB_Op_A_txt convert_from_half d lowbit m uses_double))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "sz"  :: "(1)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVT_ds_Op_A_txt : integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVT_ds_Op_A_txt  :: \<open> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVT_ds_Op_A_txt d double_to_single m = (
   CheckVFPEnabled True \<then>
   (if double_to_single then
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (FPConvert__1 (( 32 :: int)::ii) w__0 w__1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  S_set d w__2))))))
   else
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     (FPConvert__1 (( 64 :: int)::ii) w__3 w__4  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) .  D_set d w__5))))))))\<close> 
  for  "d"  :: " int " 
  and  "double_to_single"  :: " bool " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_ds_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_ds_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_ds_A1enc_A_txt cond D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:22809.29-22809.30'') \<then>
     ((let (double_to_single :: bool) = (size1 = ( 0b11 ::  2 Word.word)) in
     (let d =
       (if double_to_single then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m =
       (if double_to_single then Word.uint ((concat_vec M Vm  ::  5 Word.word))
       else Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 d)))) \<and> ((((id0 d)) \<le> (( 31 :: int)::ii)))))))))))) (''src/instrs32.sail:22813.68-22813.69'') \<then>
     execute_aarch32_instrs_VCVT_ds_Op_A_txt d double_to_single m))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_ds_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_ds_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_ds_T1enc_A_txt D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (double_to_single :: bool) = (size1 = ( 0b11 ::  2 Word.word)) in
     (let d =
       (if double_to_single then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m =
       (if double_to_single then Word.uint ((concat_vec M Vm  ::  5 Word.word))
       else Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 d)))) \<and> ((((id0 d)) \<le> (( 31 :: int)::ii)))))))))))) (''src/instrs32.sail:22837.68-22837.69'') \<then>
     execute_aarch32_instrs_VCVT_ds_Op_A_txt d double_to_single m)))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVT_hs_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVT_hs_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVT_hs_Op_A_txt d__arg elements half_to_single m = (
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
     ((\<lambda> e unit_var . 
       if half_to_single then
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
         (Elem_read w__1 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
         (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         (FPConvert__1 (( 32 :: int)::ii) w__2 w__3  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
         (Elem_set w__0 e (( 32 :: int)::ii) w__4  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__5))))))))))))
       else
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
         (Elem_read w__7 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
         (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
         (FPConvert__1 (( 16 :: int)::ii) w__8 w__9  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__10 ::  16 Word.word) . 
         (Elem_set w__6 e (( 16 :: int)::ii) w__10  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "half_to_single"  :: " bool " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_hs_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_hs_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_hs_A1enc_A_txt D size1 Vd op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 \<noteq> ( 0b01 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (half_to_single :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     ((if (((half_to_single \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((\<not> half_to_single)) \<and> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let esize = ((( 16 :: int)::ii)) in
     (let elements = ((( 4 :: int)::ii)) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     execute_aarch32_instrs_VCVT_hs_Op_A_txt d elements half_to_single m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_hs_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_hs_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_hs_T1enc_A_txt D size1 Vd op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 \<noteq> ( 0b01 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (half_to_single :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     ((if (((half_to_single \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((\<not> half_to_single)) \<and> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let esize = ((( 16 :: int)::ii)) in
     (let elements = ((( 4 :: int)::ii)) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     execute_aarch32_instrs_VCVT_hs_Op_A_txt d elements half_to_single m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVT_is_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVT_is_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVT_is_Op_A_txt d__arg elements esize m regs to_integer is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, result)
     ((\<lambda> r varstup .  (let (op1, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, result)
         ((\<lambda> e varstup .  (let (op1, result) = varstup in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (if to_integer then
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              (FPToFixed esize op1 (( 0 :: int)::ii) is_unsigned w__2 FPRounding_ZERO  :: (( 'esize::len)Word.word) M)))
            else
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (FixedToFP esize op1 (( 0 :: int)::ii) is_unsigned w__4 FPRounding_TIEEVEN  :: (( 'esize::len)Word.word) M)))) \<bind> ((\<lambda> (result ::
             ( 'esize::len)Word.word) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7 \<then> return (op1, result)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (result :: ( 'esize::len)Word.word)) = varstup in
   return () ))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "to_integer"  :: " bool " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_is_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_is_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_is_A1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (to_integer :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (is_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_is_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs to_integer is_unsigned))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (to_integer :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (is_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_is_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs to_integer is_unsigned))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
   if w__2 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (to_integer :: bool) =
       ((vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
     (let (is_unsigned :: bool) =
       ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVT_is_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       regs to_integer is_unsigned))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_is_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_is_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_is_T1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       and_boolM (return True) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
       (if w__2 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let (to_integer :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (is_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_is_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs to_integer is_unsigned))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (to_integer :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (is_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_is_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs to_integer is_unsigned))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
   if w__4 then
     (((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__6 :: bool) . 
     (if w__6 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (to_integer :: bool) =
       ((vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
     (let (is_unsigned :: bool) =
       ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVT_is_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       regs to_integer is_unsigned))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVT_iv_Op_A_txt : integer -> integer -> integer -> FPRounding -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVT_iv_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVT_iv_Op_A_txt d esize m rounding to_integer is_unsigned = (
   CheckVFPEnabled True \<then>
   (if to_integer then
     (let l__338 = esize in
     if (((l__338 = (( 16 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (FPToFixed (( 32 :: int)::ii) ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) (( 0 :: int)::ii) is_unsigned
          w__1 rounding
         :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
       S_set d w__2))))))
     else if (((l__338 = (( 32 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
       (FPToFixed (( 32 :: int)::ii) w__3 (( 0 :: int)::ii) is_unsigned w__4 rounding  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::
          32 Word.word) . 
       S_set d w__5))))))
     else if (((l__338 = (( 64 :: int)::ii)))) then
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
       (FPToFixed (( 32 :: int)::ii) w__6 (( 0 :: int)::ii) is_unsigned w__7 rounding  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::
          32 Word.word) . 
       S_set d w__8))))))
     else return () )
   else
     (let l__335 = esize in
     if (((l__335 = (( 16 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
       (FixedToFP (( 16 :: int)::ii) w__9 (( 0 :: int)::ii) is_unsigned w__10 rounding  :: ( 16 Word.word) M) \<bind> ((\<lambda> (fp16 :: 16
         bits) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) fp16  ::  32 Word.word))))))))
     else if (((l__335 = (( 32 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
       (FixedToFP (( 32 :: int)::ii) w__11 (( 0 :: int)::ii) is_unsigned w__12 rounding  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::
          32 Word.word) . 
       S_set d w__13))))))
     else if (((l__335 = (( 64 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
       (FixedToFP (( 64 :: int)::ii) w__14 (( 0 :: int)::ii) is_unsigned w__15 rounding  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::
          64 Word.word) . 
       D_set d w__16))))))
     else return () )))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "rounding"  :: " FPRounding " 
  and  "to_integer"  :: " bool " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_iv_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_iv_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_iv_A1enc_A_txt cond D opc2 Vd size1 op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23096.29-23096.30'') \<then>
     (if ((((((opc2 \<noteq> ( 0b000 ::  3 Word.word)))) \<and> ((let b__0 = opc2 in
             \<not> (if (((((subrange_vec_dec b__0 (( 2 :: int)::ii) (( 1 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))
                then
                  True
                else False)))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii)) \<bind> ((\<lambda> (d :: int) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (is_unsigned :: bool) . 
     undefined_FPRounding ()  \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (to_integer :: bool) =
       ((vec_of_bits [access_vec_dec opc2 (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
     (if to_integer then
        (let (is_unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opc2 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)) in
        (if (((op1 = ( 0b1 ::  1 Word.word)))) then return FPRounding_ZERO
         else (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  FPRoundingMode w__1))) \<bind> ((\<lambda> (w__3 ::
          FPRounding) . 
        (let rounding = w__3 in
        (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
        (let b__4 = size1 in
        (let ((esize :: int), (m :: int)) =
          (if (((b__4 = ( 0b01 ::  2 Word.word)))) then
            (let (esize :: int) = ((( 16 :: int)::ii)) in
            (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
            (esize, m)))
          else
            (let ((esize :: int), (m :: int)) =
              (if (((b__4 = ( 0b10 ::  2 Word.word)))) then
                (let (esize :: int) = ((( 32 :: int)::ii)) in
                (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
                (esize, m)))
              else
                (let ((esize :: int), (m :: int)) =
                  (if (((b__4 = ( 0b11 ::  2 Word.word)))) then
                    (let (esize :: int) = ((( 64 :: int)::ii)) in
                    (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                    (esize, m)))
                  else (esize, m)) in
                (esize, m))) in
            (esize, m))) in
        return (d, esize, is_unsigned, m, rounding))))))))
      else
        (let (is_unsigned :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
        FPRoundingMode w__4 \<bind> ((\<lambda> (w__5 :: FPRounding) . 
        (let rounding = w__5 in
        (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
        (let b__1 = size1 in
        (let ((d :: int), (esize :: int)) =
          (if (((b__1 = ( 0b01 ::  2 Word.word)))) then
            (let (esize :: int) = ((( 16 :: int)::ii)) in
            (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
            (d, esize)))
          else
            (let ((d :: int), (esize :: int)) =
              (if (((b__1 = ( 0b10 ::  2 Word.word)))) then
                (let (esize :: int) = ((( 32 :: int)::ii)) in
                (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
                (d, esize)))
              else
                (let ((d :: int), (esize :: int)) =
                  (if (((b__1 = ( 0b11 ::  2 Word.word)))) then
                    (let (esize :: int) = ((( 64 :: int)::ii)) in
                    (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                    (d, esize)))
                  else (d, esize)) in
                (d, esize))) in
            (d, esize))) in
        return (d, esize, is_unsigned, m, rounding))))))))))) \<bind> ((\<lambda> varstup .  (let ((d :: int), (esize ::
       int), (is_unsigned :: bool), (m :: int), (rounding :: FPRounding)) = varstup in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VCVT_iv_Op_A_txt d esize m rounding to_integer is_unsigned))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "opc2"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_iv_T1enc_A_txt : mword ty1 -> mword ty3 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_iv_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_iv_T1enc_A_txt D opc2 Vd size1 op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((((((opc2 \<noteq> ( 0b000 ::  3 Word.word)))) \<and> ((let b__0 = opc2 in
             \<not> (if (((((subrange_vec_dec b__0 (( 2 :: int)::ii) (( 1 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))
                then
                  True
                else False)))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (is_unsigned :: bool) . 
     undefined_FPRounding ()  \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (to_integer :: bool) =
       ((vec_of_bits [access_vec_dec opc2 (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
     (if to_integer then
        (let (is_unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opc2 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)) in
        (if (((op1 = ( 0b1 ::  1 Word.word)))) then return FPRounding_ZERO
         else (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) .  FPRoundingMode w__3))) \<bind> ((\<lambda> (w__5 ::
          FPRounding) . 
        (let rounding = w__5 in
        (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
        (let b__4 = size1 in
        (let ((esize :: int), (m :: int)) =
          (if (((b__4 = ( 0b01 ::  2 Word.word)))) then
            (let (esize :: int) = ((( 16 :: int)::ii)) in
            (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
            (esize, m)))
          else
            (let ((esize :: int), (m :: int)) =
              (if (((b__4 = ( 0b10 ::  2 Word.word)))) then
                (let (esize :: int) = ((( 32 :: int)::ii)) in
                (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
                (esize, m)))
              else
                (let ((esize :: int), (m :: int)) =
                  (if (((b__4 = ( 0b11 ::  2 Word.word)))) then
                    (let (esize :: int) = ((( 64 :: int)::ii)) in
                    (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                    (esize, m)))
                  else (esize, m)) in
                (esize, m))) in
            (esize, m))) in
        return (d, esize, is_unsigned, m, rounding))))))))
      else
        (let (is_unsigned :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
        FPRoundingMode w__6 \<bind> ((\<lambda> (w__7 :: FPRounding) . 
        (let rounding = w__7 in
        (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
        (let b__1 = size1 in
        (let ((d :: int), (esize :: int)) =
          (if (((b__1 = ( 0b01 ::  2 Word.word)))) then
            (let (esize :: int) = ((( 16 :: int)::ii)) in
            (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
            (d, esize)))
          else
            (let ((d :: int), (esize :: int)) =
              (if (((b__1 = ( 0b10 ::  2 Word.word)))) then
                (let (esize :: int) = ((( 32 :: int)::ii)) in
                (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
                (d, esize)))
              else
                (let ((d :: int), (esize :: int)) =
                  (if (((b__1 = ( 0b11 ::  2 Word.word)))) then
                    (let (esize :: int) = ((( 64 :: int)::ii)) in
                    (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                    (d, esize)))
                  else (d, esize)) in
                (d, esize))) in
            (d, esize))) in
        return (d, esize, is_unsigned, m, rounding))))))))))) \<bind> ((\<lambda> varstup .  (let ((d :: int), (esize ::
       int), (is_unsigned :: bool), (m :: int), (rounding :: FPRounding)) = varstup in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VCVT_iv_Op_A_txt d esize m rounding to_integer is_unsigned)))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "opc2"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVT_xs_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVT_xs_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVT_xs_Op_A_txt d__arg elements esize frac_bits m regs to_fixed is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, result)
     ((\<lambda> r varstup .  (let (op1, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, result)
         ((\<lambda> e varstup .  (let (op1, result) = varstup in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (if to_fixed then
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              (FPToFixed esize op1 frac_bits is_unsigned w__2 FPRounding_ZERO  :: (( 'esize::len)Word.word) M)))
            else
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (FixedToFP esize op1 frac_bits is_unsigned w__4 FPRounding_TIEEVEN  :: (( 'esize::len)Word.word) M)))) \<bind> ((\<lambda> (result ::
             ( 'esize::len)Word.word) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (Elem_set w__6 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           D_set ((d + r)) w__7 \<then> return (op1, result)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (result :: ( 'esize::len)Word.word)) = varstup in
   return () ))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "frac_bits"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "to_fixed"  :: " bool " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_xs_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_xs_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_xs_A1enc_A_txt U D imm6 Vd b__0 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if (((True \<and> ((let b__2 = imm6 in
               if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))
               then
                 True
               else False))))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((let b__3 = imm6 in
          if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         frac_bits m regs False is_unsigned))))))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((((if ((let b__5 = imm6 in
          if (((((subrange_vec_dec b__5 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if (((True \<and> ((let b__6 = imm6 in
               if (((((subrange_vec_dec b__6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))
               then
                 True
               else False))))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((let b__7 = imm6 in
          if (((((subrange_vec_dec b__7 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         frac_bits m regs True is_unsigned))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (((if ((let b__9 = imm6 in
          if (((((subrange_vec_dec b__9 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((let b__10 = imm6 in
          if (((((subrange_vec_dec b__10 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         frac_bits m regs False is_unsigned))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (((if ((let b__11 = imm6 in
        if (((((subrange_vec_dec b__11 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((let b__12 = imm6 in
        if (((((subrange_vec_dec b__12 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
          True
        else False)) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       frac_bits m regs True is_unsigned))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_xs_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_xs_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_xs_T1enc_A_txt U D imm6 Vd b__0 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if (((True \<and> ((let b__2 = imm6 in
               if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))
               then
                 True
               else False))))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((let b__3 = imm6 in
          if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         frac_bits m regs False is_unsigned))))))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((((if ((let b__5 = imm6 in
          if (((((subrange_vec_dec b__5 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if (((True \<and> ((let b__6 = imm6 in
               if (((((subrange_vec_dec b__6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))
               then
                 True
               else False))))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((let b__7 = imm6 in
          if (((((subrange_vec_dec b__7 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         frac_bits m regs True is_unsigned))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (((if ((let b__9 = imm6 in
          if (((((subrange_vec_dec b__9 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((let b__10 = imm6 in
          if (((((subrange_vec_dec b__10 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () )) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         frac_bits m regs False is_unsigned))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (((if ((let b__11 = imm6 in
        if (((((subrange_vec_dec b__11 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((let b__12 = imm6 in
        if (((((subrange_vec_dec b__12 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
          True
        else False)) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let frac_bits = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVT_xs_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       frac_bits m regs True is_unsigned))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVT_xv_Op_A_txt : forall 'size. Size 'size => integer -> integer -> integer -> itself 'size -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVT_xv_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('size::len)itself \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVT_xv_Op_A_txt d fp_size frac_bits size1 to_fixed is_unsigned = (
   (let size1 = (size_itself_int size1) in
   CheckVFPEnabled True \<then>
   (if to_fixed then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 size1))  :: (( 'size::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'size::len)Word.word) . 
     (let l__332 = fp_size in
     if (((l__332 = (( 16 :: int)::ii)))) then
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (FPToFixed size1 ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) frac_bits is_unsigned
          w__1 FPRounding_ZERO
         :: (( 'size::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'size::len)Word.word) . 
       S_set d
         (if is_unsigned then (zero_extend result (( 32 :: int)::ii)  ::  32 Word.word)
          else (sign_extend result (( 32 :: int)::ii)  ::  32 Word.word))))))))
     else if (((l__332 = (( 32 :: int)::ii)))) then
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
       (FPToFixed size1 w__2 frac_bits is_unsigned w__3 FPRounding_ZERO  :: (( 'size::len)Word.word) M) \<bind> ((\<lambda> (result ::
         ( 'size::len)Word.word) . 
       S_set d
         (if is_unsigned then (zero_extend result (( 32 :: int)::ii)  ::  32 Word.word)
          else (sign_extend result (( 32 :: int)::ii)  ::  32 Word.word))))))))
     else if (((l__332 = (( 64 :: int)::ii)))) then
       (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
       (FPToFixed size1 w__4 frac_bits is_unsigned w__5 FPRounding_ZERO  :: (( 'size::len)Word.word) M) \<bind> ((\<lambda> (result ::
         ( 'size::len)Word.word) . 
       D_set d
         (if is_unsigned then (zero_extend result (( 64 :: int)::ii)  ::  64 Word.word)
          else (sign_extend result (( 64 :: int)::ii)  ::  64 Word.word))))))))
     else return () )))
   else
     (let l__329 = fp_size in
     if (((l__329 = (( 16 :: int)::ii)))) then
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
       (FixedToFP (( 16 :: int)::ii)
          ((subrange_vec_dec w__6 ((size1 - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'size::len)Word.word)) frac_bits
          is_unsigned w__7 FPRounding_TIEEVEN
         :: ( 16 Word.word) M) \<bind> ((\<lambda> (fp16 :: 16 bits) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) fp16  ::  32 Word.word))))))))
     else if (((l__329 = (( 32 :: int)::ii)))) then
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
       (FixedToFP (( 32 :: int)::ii)
          ((subrange_vec_dec w__8 ((size1 - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'size::len)Word.word)) frac_bits
          is_unsigned w__9 FPRounding_TIEEVEN
         :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
       S_set d w__10))))))
     else if (((l__329 = (( 64 :: int)::ii)))) then
       (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
       (FixedToFP (( 64 :: int)::ii)
          ((subrange_vec_dec w__11 ((size1 - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'size::len)Word.word)) frac_bits
          is_unsigned w__12 FPRounding_TIEEVEN
         :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
       D_set d w__13))))))
     else return () ))))\<close> 
  for  "d"  :: " int " 
  and  "fp_size"  :: " int " 
  and  "frac_bits"  :: " int " 
  and  "size1"  :: "('size::len)itself " 
  and  "to_fixed"  :: " bool " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_xv_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_xv_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_xv_A1enc_A_txt cond D op1 U Vd sf b__0 i imm4 = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23456.29-23456.30'') \<then>
       (if ((((((sf = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
        else return () )) \<then>
       (if ((((((sf = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
          throw (Error_Unpredictable () )
        else return () )) \<then>
       ((let (to_fixed :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let frac_bits = ((( 16 :: int)::ii) - ((Word.uint ((concat_vec imm4 i  ::  5 Word.word))))) in
       (let (fp_size :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       (let b__1 = sf in
       (let ((d :: int), (fp_size :: int)) =
         (if (((b__1 = ( 0b01 ::  2 Word.word)))) then
           (let (fp_size :: int) = ((( 16 :: int)::ii)) in
           (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
           (d, fp_size)))
         else
           (let ((d :: int), (fp_size :: int)) =
             (if (((b__1 = ( 0b10 ::  2 Word.word)))) then
               (let (fp_size :: int) = ((( 32 :: int)::ii)) in
               (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
               (d, fp_size)))
             else
               (let ((d :: int), (fp_size :: int)) =
                 (if (((b__1 = ( 0b11 ::  2 Word.word)))) then
                   (let (fp_size :: int) = ((( 64 :: int)::ii)) in
                   (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                   (d, fp_size)))
                 else (d, fp_size)) in
               (d, fp_size))) in
           (d, fp_size))) in
       (let fp_size = fp_size in
       (let d = d in
       (if ((frac_bits < (( 0 :: int)::ii))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let d = d in
       execute_aarch32_instrs_VCVT_xv_Op_A_txt d fp_size frac_bits
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) to_fixed is_unsigned)))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23456.29-23456.30'') \<then>
     (if ((((((sf = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((sf = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (to_fixed :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let frac_bits = ((( 32 :: int)::ii) - ((Word.uint ((concat_vec imm4 i  ::  5 Word.word))))) in
     (let (fp_size :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__4 = sf in
     (let ((d :: int), (fp_size :: int)) =
       (if (((b__4 = ( 0b01 ::  2 Word.word)))) then
         (let (fp_size :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (d, fp_size)))
       else
         (let ((d :: int), (fp_size :: int)) =
           (if (((b__4 = ( 0b10 ::  2 Word.word)))) then
             (let (fp_size :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (d, fp_size)))
           else
             (let ((d :: int), (fp_size :: int)) =
               (if (((b__4 = ( 0b11 ::  2 Word.word)))) then
                 (let (fp_size :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (d, fp_size)))
               else (d, fp_size)) in
             (d, fp_size))) in
         (d, fp_size))) in
     (let fp_size = fp_size in
     (let d = d in
     (let d = d in
     execute_aarch32_instrs_VCVT_xv_Op_A_txt d fp_size frac_bits
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) to_fixed is_unsigned))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "sf"  :: "(2)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "i"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_xv_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_xv_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_xv_T1enc_A_txt D op1 U Vd sf b__0 i imm4 = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((sf = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
        else return () ) \<then>
       and_boolM (return (((sf = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
       (if w__2 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let (to_fixed :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let frac_bits = ((( 16 :: int)::ii) - ((Word.uint ((concat_vec imm4 i  ::  5 Word.word))))) in
       (let (fp_size :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       (let b__1 = sf in
       (let ((d :: int), (fp_size :: int)) =
         (if (((b__1 = ( 0b01 ::  2 Word.word)))) then
           (let (fp_size :: int) = ((( 16 :: int)::ii)) in
           (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
           (d, fp_size)))
         else
           (let ((d :: int), (fp_size :: int)) =
             (if (((b__1 = ( 0b10 ::  2 Word.word)))) then
               (let (fp_size :: int) = ((( 32 :: int)::ii)) in
               (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
               (d, fp_size)))
             else
               (let ((d :: int), (fp_size :: int)) =
                 (if (((b__1 = ( 0b11 ::  2 Word.word)))) then
                   (let (fp_size :: int) = ((( 64 :: int)::ii)) in
                   (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                   (d, fp_size)))
                 else (d, fp_size)) in
               (d, fp_size))) in
           (d, fp_size))) in
       (let fp_size = fp_size in
       (let d = d in
       (if ((frac_bits < (( 0 :: int)::ii))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let d = d in
       execute_aarch32_instrs_VCVT_xv_Op_A_txt d fp_size frac_bits
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) to_fixed is_unsigned)))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((((((sf = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((sf = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
     (if w__5 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (to_fixed :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let frac_bits = ((( 32 :: int)::ii) - ((Word.uint ((concat_vec imm4 i  ::  5 Word.word))))) in
     (let (fp_size :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__4 = sf in
     (let ((d :: int), (fp_size :: int)) =
       (if (((b__4 = ( 0b01 ::  2 Word.word)))) then
         (let (fp_size :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (d, fp_size)))
       else
         (let ((d :: int), (fp_size :: int)) =
           (if (((b__4 = ( 0b10 ::  2 Word.word)))) then
             (let (fp_size :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (d, fp_size)))
           else
             (let ((d :: int), (fp_size :: int)) =
               (if (((b__4 = ( 0b11 ::  2 Word.word)))) then
                 (let (fp_size :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (d, fp_size)))
               else (d, fp_size)) in
             (d, fp_size))) in
         (d, fp_size))) in
     (let fp_size = fp_size in
     (let d = d in
     (let d = d in
     execute_aarch32_instrs_VCVT_xv_Op_A_txt d fp_size frac_bits
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) to_fixed is_unsigned))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "sf"  :: "(2)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "i"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VDIV_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VDIV_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VDIV_Op_A_txt d esize m n = (
   CheckVFPEnabled True \<then>
   ((let l__326 = esize in
   if (((l__326 = (( 16 :: int)::ii)))) then
     (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (FPDiv ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__2
       :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
     S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__3  ::  32 Word.word))))))))))
   else if (((l__326 = (( 32 :: int)::ii)))) then
     (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (FPDiv w__4 w__5 w__6  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) .  S_set d w__7))))))))
   else if (((l__326 = (( 64 :: int)::ii)))) then
     (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
     (FPDiv w__8 w__9 w__10  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) .  D_set d w__11))))))))
   else return () )))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDIV_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDIV_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDIV_A1enc_A_txt cond D Vn Vd size1 N M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23588.29-23588.30'') \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VDIV_Op_A_txt d esize m n))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDIV_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDIV_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDIV_T1enc_A_txt D Vn Vd size1 N M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () )) \<bind> ((\<lambda> (w__2 :: bool) . 
     ((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
        return (((((slice w__3 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
        return (((((slice w__4 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__5 ::
       bool) . 
     ((if w__5 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VDIV_Op_A_txt d esize m n))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VDUP_r_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VDUP_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VDUP_r_Op_A_txt d__arg elements esize regs t = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
           (Elem_set w__0 e esize
              ((subrange_vec_dec w__1 ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           D_set ((d + r)) w__2))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "regs"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDUP_r_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDUP_r_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDUP_r_A1enc_A_txt cond b__0 Q Vd Rt D b__1 = (
   if ((((((b__0 = ( 0b0 ::  1 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23723.29-23723.30'') \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let t = (Word.uint Rt) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_VDUP_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         regs t))))))))
     else return () ))
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23723.29-23723.30'') \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let t = (Word.uint Rt) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_VDUP_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         regs t))))))))
     else return () ))
   else if (((b__1 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23723.29-23723.30'') \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let t = (Word.uint Rt) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_VDUP_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) regs
         t))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:23723.29-23723.30'') \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let t = (Word.uint Rt) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     throw (Error_Undefined () )))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__1"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDUP_r_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDUP_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDUP_r_T1enc_A_txt b__0 Q Vd Rt D b__1 = (
   if ((((((b__0 = ( 0b0 ::  1 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let t = (Word.uint Rt) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_VDUP_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         regs t))))))))
     else return () ))
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let t = (Word.uint Rt) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_VDUP_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         regs t))))))))
     else return () ))
   else if (((b__1 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let t = (Word.uint Rt) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_VDUP_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) regs
         t))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let t = (Word.uint Rt) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     throw (Error_Undefined () )))))))
   else return () )))\<close> 
  for  "b__0"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__1"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VDUP_s_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VDUP_s_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VDUP_s_Op_A_txt d__arg elements esize index1 m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (CheckAdvSIMDEnabled ()  \<then>
   (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (Elem_read w__0 index1 esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (scalar :: ( 'esize::len)Word.word) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_set w__1 e esize scalar  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           D_set ((d + r)) w__2)))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDUP_s_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDUP_s_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDUP_s_A1enc_A_txt D imm4 Vd Q M Vm = (
   if (((((subrange_vec_dec imm4 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm4 in
          if (((((subrange_vec_dec b__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (index1 :: int) = (Word.uint ((subrange_vec_dec imm4 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
       (let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1
         m regs))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm4 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm4 in
          if (((((subrange_vec_dec b__1 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (index1 :: int) = (Word.uint ((subrange_vec_dec imm4 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
       (let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m regs))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm4 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm4 in
          if (((((subrange_vec_dec b__2 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (index1 :: int) = (Word.uint (vec_of_bits [access_vec_dec imm4 (( 3 :: int)::ii)]  ::  1 Word.word)) in
       (let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m regs))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm4 in
        if (((((subrange_vec_dec b__3 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
     (let index1 = index1 in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m
       regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDUP_s_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDUP_s_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDUP_s_T1enc_A_txt D imm4 Vd Q M Vm = (
   if (((((subrange_vec_dec imm4 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm4 in
          if (((((subrange_vec_dec b__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (index1 :: int) = (Word.uint ((subrange_vec_dec imm4 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
       (let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1
         m regs))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm4 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm4 in
          if (((((subrange_vec_dec b__1 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (index1 :: int) = (Word.uint ((subrange_vec_dec imm4 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
       (let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m regs))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm4 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm4 in
          if (((((subrange_vec_dec b__2 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (index1 :: int) = (Word.uint (vec_of_bits [access_vec_dec imm4 (( 3 :: int)::ii)]  ::  1 Word.word)) in
       (let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m regs))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm4 in
        if (((((subrange_vec_dec b__3 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 7 :: int)::ii) \<bind> ((\<lambda> (index1 :: int) . 
     (let index1 = index1 in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VDUP_s_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m
       regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VEOR_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VEOR_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VEOR_Op_A_txt d m n regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       D_set ((d + r)) ((xor_vec w__0 w__1  ::  64 Word.word)))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VEOR_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VEOR_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VEOR_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VEOR_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VEOR_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VEOR_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VEOR_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VEOR_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VEXT_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VEXT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VEXT_Op_A_txt d m n position quadword_operation = (
   CheckAdvSIMDEnabled ()  \<then>
   (if quadword_operation then
     (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
     (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__1 ::  128 Word.word) . 
     Q_set ((shr_int d (( 1 :: int)::ii)))
       ((slice ((concat_vec w__0 w__1  ::  256 Word.word)) position (( 128 :: int)::ii)  ::  128 Word.word))))))
   else
     (assert_exp ((((((id0 position)) + (( 63 :: int)::ii))) < (( 128 :: int)::ii))) (''src/instrs32.sail:24032.47-24032.48'') \<then>
     (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
     D_set d ((slice ((concat_vec w__2 w__3  ::  128 Word.word)) position (( 64 :: int)::ii)  ::  64 Word.word))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "position"  :: " int " 
  and  "quadword_operation"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VEXT_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VEXT_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VEXT_A1enc_A_txt D Vn Vd imm4 N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec imm4 (( 3 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
     (let position = ((( 8 :: int)::ii) * ((Word.uint imm4))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VEXT_Op_A_txt d m n position quadword_operation))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VEXT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VEXT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VEXT_T1enc_A_txt D Vn Vd imm4 N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec imm4 (( 3 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
     (let position = ((( 8 :: int)::ii) * ((Word.uint imm4))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VEXT_Op_A_txt d m n position quadword_operation))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm4"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VFMA_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VFMA_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VFMA_Op_A_txt advsimd d__arg elements esize m n op1_neg regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op16 :: 16 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op32 :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op64 :: 64 bits) . 
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
       ((\<lambda> r unit_var . 
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
           ((\<lambda> e unit_var . 
             (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
             (if op1_neg then (FPNeg op1  :: (( 'esize::len)Word.word) M)
              else return op1) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
             (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             (Elem_read w__5 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
             (FPMulAdd w__4 op1 w__6 w__7  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__8 :: ( 'esize::len)Word.word) . 
             (Elem_set w__2 e esize w__8  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
             D_set ((d + r)) w__9))))))))))))))))))))))))))))))))
   else
     (let l__323 = esize in
     if (((l__323 = (( 16 :: int)::ii)))) then
       (if op1_neg then
          (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          (FPNeg ((subrange_vec_dec w__10 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M)))
        else
          (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return ((subrange_vec_dec w__12 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (op16 :: 16 bits) . 
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
       (FPMulAdd ((subrange_vec_dec w__13 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) op16
          ((subrange_vec_dec w__14 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__15
         :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__16 ::  16 Word.word) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__16  ::  32 Word.word))))))))))))
     else if (((l__323 = (( 32 :: int)::ii)))) then
       (if op1_neg then
          (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
          (FPNeg w__17  :: ( 32 Word.word) M)))
        else (S_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (op32 :: 32 bits) . 
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__20 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
       (FPMulAdd w__20 op32 w__21 w__22  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
       S_set d w__23))))))))))
     else if (((l__323 = (( 64 :: int)::ii)))) then
       (if op1_neg then
          (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
          (FPNeg w__24  :: ( 64 Word.word) M)))
        else (D_read n  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (op64 :: 64 bits) . 
       (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
       (FPMulAdd w__27 op64 w__28 w__29  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
       D_set d w__30))))))))))
     else return () )))))))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "op1_neg"  :: " bool " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_A1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VFMA_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         m n op1_neg regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VFMA_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       n op1_neg regs))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_A2enc_A_txt cond D Vn Vd b__0 N op1 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:24199.29-24199.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       (if (((True \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VFMA_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n op1_neg regs)))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:24199.29-24199.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
          return (((((slice w__5 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
          return (((((slice w__6 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__7 ::
         bool) . 
       (if w__7 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VFMA_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n op1_neg regs)))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:24199.29-24199.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
          return (((((slice w__9 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          return (((((slice w__10 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__11 ::
         bool) . 
       (if w__11 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VFMA_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n op1_neg regs)))))))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   if w__12 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:24199.29-24199.30'') \<then>
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return (((((slice w__13 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
        return (((((slice w__14 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__15 ::
       bool) . 
     (((if w__15 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VFMA_Op_A_txt False d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n op1_neg regs)))))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_T1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VFMA_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         m n op1_neg regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VFMA_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       n op1_neg regs))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_T2enc_A_txt D Vn Vd b__0 N op1 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       and_boolM (return True) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
       (if w__5 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VFMA_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n op1_neg regs)))))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
          return (((((slice w__7 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
          return (((((slice w__8 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__9 ::
         bool) . 
       (if w__9 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VFMA_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n op1_neg regs)))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
          return (((((slice w__11 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return (((((slice w__12 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
         bool) . 
       (if w__13 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VFMA_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n op1_neg regs)))))))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
   if w__14 then
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
        return (((((slice w__15 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
        return (((((slice w__16 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__17 ::
       bool) . 
     (((if w__17 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__19 :: bool) . 
     (if w__19 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VFMA_Op_A_txt False d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n op1_neg regs)))))))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VFNMA_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VFNMA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VFNMA_Op_A_txt d esize m n op1_neg = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op16 :: 16 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op32 :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op64 :: 64 bits) . 
   CheckVFPEnabled True \<then>
   ((let l__320 = esize in
   if (((l__320 = (( 16 :: int)::ii)))) then
     (if op1_neg then
        (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
        (FPNeg ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M)))
      else
        (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> ((\<lambda> (op16 :: 16 bits) . 
     (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     (FPNeg ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__4 ::
        16 Word.word) . 
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (FPMulAdd w__4 op16 ((subrange_vec_dec w__5 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__6
       :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
     S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__7  ::  32 Word.word))))))))))))))
   else if (((l__320 = (( 32 :: int)::ii)))) then
     (if op1_neg then
        (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) .  (FPNeg w__8  :: ( 32 Word.word) M)))
      else (S_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (op32 :: 32 bits) . 
     (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
     (FPNeg w__11  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
     (FPMulAdd w__12 op32 w__13 w__14  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
     S_set d w__15))))))))))))
   else if (((l__320 = (( 64 :: int)::ii)))) then
     (if op1_neg then
        (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) .  (FPNeg w__16  :: ( 64 Word.word) M)))
      else (D_read n  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (op64 :: 64 bits) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) . 
     (FPNeg w__19  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
     (FPMulAdd w__20 op64 w__21 w__22  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
     D_set d w__23))))))))))))
   else return () )))))))))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "op1_neg"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFNMA_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFNMA_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFNMA_A1enc_A_txt cond D Vn Vd size1 N op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:24416.29-24416.30'') \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VFNMA_Op_A_txt d esize m n op1_neg)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFNMA_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFNMA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFNMA_T1enc_A_txt D Vn Vd size1 N op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
     (if w__5 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (op1_neg :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VFNMA_Op_A_txt d esize m n op1_neg)))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VHADD_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VHADD_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VHADD_Op_A_txt add d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
     ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
         ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = (asl_Int w__1 is_unsigned) in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = (asl_Int w__3 is_unsigned) in
           (let (result :: ii) = (if add then op1 + op2 else op1 - op2) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize ((integer_subrange result esize (( 1 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (op1, op2, result)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ii), (op2 :: ii), (result :: ii)) = varstup in
   return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VHADD_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VHADD_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VHADD_A1enc_A_txt U D b__0 Vn Vd op1 N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VHADD_Op_A_txt add d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VHADD_Op_A_txt add d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         m n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VHADD_Op_A_txt add d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         m n regs is_unsigned)))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VHADD_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VHADD_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VHADD_T1enc_A_txt U D b__0 Vn Vd op1 N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VHADD_Op_A_txt add d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VHADD_Op_A_txt add d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         m n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VHADD_Op_A_txt add d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         m n regs is_unsigned)))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD1_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD1_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d__arg l__318 index1 m n register_index wback = (
   if (((l__318 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__0 :: 64 Word.word) . 
                     (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        (Elem_set__1 (( 8 :: int):: ii) w__0 index1 w__1 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__2 :: 64 Word.word) . 
                           D_set d w__2 \<then>
                             (
                             if wback then
                               if register_index then
                                 (R_read n :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__3 :: 32 Word.word) . 
                                    (R_read m :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__4 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec w__3 w__4 :: 32 Word.word))))))
                               else
                                 (R_read n :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__5 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec_int w__5 (( 1 :: int):: ii) :: 32 Word.word))))
                             else return () )))))))
                  ))))))
   else if (((l__318 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__6 :: 64 Word.word) . 
                     (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__7 :: 16 Word.word) . 
                        (Elem_set__1 (( 16 :: int):: ii) w__6 index1 w__7 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__8 :: 64 Word.word) . 
                           D_set d w__8 \<then>
                             (
                             if wback then
                               if register_index then
                                 (R_read n :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__9 :: 32 Word.word) . 
                                    (R_read m :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__10 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec w__9 w__10 :: 32 Word.word))))))
                               else
                                 (R_read n :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__11 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec_int w__11 (( 2 :: int):: ii) :: 32 Word.word))))
                             else return () )))))))
                  ))))))
   else
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>
     (let (d :: ii) = d__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__12 :: 64 Word.word) . 
                     (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__13 :: 32 Word.word) . 
                        (Elem_set__1 (( 32 :: int):: ii) w__12 index1 w__13 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__14 :: 64 Word.word) . 
                           D_set d w__14 \<then>
                             (
                             if wback then
                               if register_index then
                                 (R_read n :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__15 :: 32 Word.word) . 
                                    (R_read m :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__16 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec w__15 w__16 :: 32 Word.word))))))
                               else
                                 (R_read n :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__17 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec_int w__17 (( 4 :: int):: ii) :: 32 Word.word))))
                             else return () )))))))
                  )))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d__arg"  :: " int " 
  and  "l__318"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD1 (single element to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let alignment = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD1 (single element to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD1 (single element to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD1 (single element to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let alignment = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD1 (single element to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD1 (single element to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD1_a_Op_A_txt : integer -> integer -> integer -> integer -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD1_a_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD1_a_Op_A_txt alignment d l__315 m n register_index regs wback = (
   if (((l__315 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__0 :: 8 Word.word) . 
                     (let (replicated_element :: 64 bits) = ((Replicate__1
                                                                (( 64 :: int):: ii)
                                                                w__0 :: 64 Word.word)) in
                     (let loop_r_lower = ((( 0 :: int):: ii)) in
                     (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                     (foreachM
                        (index_list loop_r_lower loop_r_upper
                           (( 1 :: int):: ii)) () 
                        ((\<lambda> r unit_var .  D_set ((d + r))
                                                    replicated_element)))
                       \<then>
                       (
                       if wback then
                         if register_index then
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__1 :: 32 Word.word) . 
                              (R_read m :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__2 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec w__1 w__2 :: 32 Word.word))))))
                         else
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__3 :: 32 Word.word) . 
                              R_set n
                                ((add_vec_int w__3 (( 1 :: int):: ii) :: 32 Word.word))))
                       else return () ))))))
                  )))))
   else if (((l__315 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__4 :: 16 Word.word) . 
                     (let (replicated_element :: 64 bits) = ((Replicate__1
                                                                (( 64 :: int):: ii)
                                                                w__4 :: 64 Word.word)) in
                     (let loop_r_lower = ((( 0 :: int):: ii)) in
                     (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                     (foreachM
                        (index_list loop_r_lower loop_r_upper
                           (( 1 :: int):: ii)) () 
                        ((\<lambda> r unit_var .  D_set ((d + r))
                                                    replicated_element)))
                       \<then>
                       (
                       if wback then
                         if register_index then
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__5 :: 32 Word.word) . 
                              (R_read m :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__6 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec w__5 w__6 :: 32 Word.word))))))
                         else
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__7 :: 32 Word.word) . 
                              R_set n
                                ((add_vec_int w__7 (( 2 :: int):: ii) :: 32 Word.word))))
                       else return () ))))))
                  )))))
   else if (((l__315 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__8 :: 32 Word.word) . 
                     (let (replicated_element :: 64 bits) = ((Replicate__1
                                                                (( 64 :: int):: ii)
                                                                w__8 :: 64 Word.word)) in
                     (let loop_r_lower = ((( 0 :: int):: ii)) in
                     (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                     (foreachM
                        (index_list loop_r_lower loop_r_upper
                           (( 1 :: int):: ii)) () 
                        ((\<lambda> r unit_var .  D_set ((d + r))
                                                    replicated_element)))
                       \<then>
                       (
                       if wback then
                         if register_index then
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__9 :: 32 Word.word) . 
                              (R_read m :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__10 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec w__9 w__10 :: 32 Word.word))))))
                         else
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__11 :: 32 Word.word) . 
                              R_set n
                                ((add_vec_int w__11 (( 4 :: int):: ii) :: 32 Word.word))))
                       else return () ))))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 8 :: int):: ii) :: ( 64 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__12 :: 64 Word.word) . 
                     (let (replicated_element :: 64 bits) = ((Replicate__1
                                                                (( 64 :: int):: ii)
                                                                w__12 :: 64 Word.word)) in
                     (let loop_r_lower = ((( 0 :: int):: ii)) in
                     (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                     (foreachM
                        (index_list loop_r_lower loop_r_upper
                           (( 1 :: int):: ii)) () 
                        ((\<lambda> r unit_var .  D_set ((d + r))
                                                    replicated_element)))
                       \<then>
                       (
                       if wback then
                         if register_index then
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__13 :: 32 Word.word) . 
                              (R_read m :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__14 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec w__13 w__14 :: 32 Word.word))))))
                         else
                           (R_read n :: ( 32 Word.word) M) \<bind>
                             ((\<lambda> (w__15 :: 32 Word.word) . 
                              R_set n
                                ((add_vec_int w__15 (( 8 :: int):: ii) :: 32 Word.word))))
                       else return () ))))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "l__315"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "regs"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_a_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_a_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_a_A1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b00 ::  2 Word.word)))) \<and> (((a = ( 0b1 ::  1 Word.word)))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let regs = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let alignment = (if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_a_Op_A_txt alignment d ebytes m n register_index regs wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_a_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_a_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_a_T1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b00 ::  2 Word.word)))) \<and> (((a = ( 0b1 ::  1 Word.word)))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let regs = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let alignment = (if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD1_a_Op_A_txt alignment d ebytes m n register_index regs wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD1_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD1_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d__arg l__312 elements m n register_index regs wback = (
   if (((l__312 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (undefined_bitvector
                             instance_Sail2_values_Bitvector_Machine_word_mword_dict
                             instance_Sail2_values_Register_Value_Armv9_types_register_value_dict
                             (( 8 :: int):: ii) :: ( 8 Word.word) M) \<bind>
                            ((\<lambda> (data :: 8 bits) . 
                             (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__0 :: 8 Word.word) . 
                                (let data = w__0 in
                                (D_read ((d + r)) :: ( 64 Word.word) M)
                                  \<bind>
                                  ((\<lambda> (w__1 :: 64 Word.word) . 
                                   (Elem_set__1 (( 8 :: int):: ii) w__1 
                                    e data :: ( 64 Word.word) M) \<bind>
                                     ((\<lambda> (w__2 :: 64 Word.word) . 
                                      D_set ((d + r)) w__2 \<then>
                                        ((let (address :: 32 bits) = 
                                              ((add_vec_int address
                                                  (( 1 :: int):: ii) :: 32 Word.word)) in
                                         return address)))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__3 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__4 :: 32 Word.word) . 
                               R_set n ((add_vec w__3 w__4 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__5 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__5
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  ))))))
   else if (((l__312 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (undefined_bitvector
                             instance_Sail2_values_Bitvector_Machine_word_mword_dict
                             instance_Sail2_values_Register_Value_Armv9_types_register_value_dict
                             (( 16 :: int):: ii) :: ( 16 Word.word) M)
                            \<bind>
                            ((\<lambda> (data :: 16 bits) . 
                             (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__6 :: 16 Word.word) . 
                                (let data = w__6 in
                                (D_read ((d + r)) :: ( 64 Word.word) M)
                                  \<bind>
                                  ((\<lambda> (w__7 :: 64 Word.word) . 
                                   (Elem_set__1 (( 16 :: int):: ii) w__7 
                                    e data :: ( 64 Word.word) M) \<bind>
                                     ((\<lambda> (w__8 :: 64 Word.word) . 
                                      D_set ((d + r)) w__8 \<then>
                                        ((let (address :: 32 bits) = 
                                              ((add_vec_int address
                                                  (( 2 :: int):: ii) :: 32 Word.word)) in
                                         return address)))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__9 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__10 :: 32 Word.word) . 
                               R_set n ((add_vec w__9 w__10 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__11 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__11
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  ))))))
   else if (((l__312 = (( 4 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (undefined_bitvector
                             instance_Sail2_values_Bitvector_Machine_word_mword_dict
                             instance_Sail2_values_Register_Value_Armv9_types_register_value_dict
                             (( 32 :: int):: ii) :: ( 32 Word.word) M)
                            \<bind>
                            ((\<lambda> (data :: 32 bits) . 
                             (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__12 :: 32 Word.word) . 
                                (let data = w__12 in
                                (D_read ((d + r)) :: ( 64 Word.word) M)
                                  \<bind>
                                  ((\<lambda> (w__13 :: 64 Word.word) . 
                                   (Elem_set__1 (( 32 :: int):: ii) w__13 
                                    e data :: ( 64 Word.word) M) \<bind>
                                     ((\<lambda> (w__14 :: 64 Word.word) . 
                                      D_set ((d + r)) w__14 \<then>
                                        ((let (address :: 32 bits) = 
                                              ((add_vec_int address
                                                  (( 4 :: int):: ii) :: 32 Word.word)) in
                                         return address)))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__15 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__16 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__15 w__16 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__17 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__17
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  ))))))
   else
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>
     (let (d :: ii) = d__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (undefined_bitvector
                             instance_Sail2_values_Bitvector_Machine_word_mword_dict
                             instance_Sail2_values_Register_Value_Armv9_types_register_value_dict
                             (( 64 :: int):: ii) :: ( 64 Word.word) M)
                            \<bind>
                            ((\<lambda> (data :: 64 bits) . 
                             AArch32_CheckAlignment address
                               (( 8 :: int):: ii) AccType_NORMAL False
                               \<bind>
                               ((\<lambda>x .  (case  x of
                                                   _ =>
                                               BigEndian AccType_NORMAL
                                                 \<bind>
                                                 ((\<lambda> (w__18 :: bool) . 
                                                  (
                                                  if w__18 then
                                                    (MemU_read
                                                       ((add_vec_int 
                                                         address
                                                           (( 4 :: int):: ii) :: 32 Word.word))
                                                       (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                                  else
                                                    (MemU_read address
                                                       (( 4 :: int):: ii) :: ( 32 Word.word) M))
                                                    \<bind>
                                                    ((\<lambda> (w__21 :: 32 Word.word) . 
                                                     (let data = ((update_subrange_vec_dec
                                                                    data
                                                                    (
                                                                    (
                                                                     31 :: int):: ii)
                                                                    (
                                                                    (
                                                                     0 :: int):: ii)
                                                                    w__21 :: 64 Word.word)) in
                                                     BigEndian AccType_NORMAL
                                                       \<bind>
                                                       ((\<lambda> (w__22 :: bool) . 
                                                        (
                                                        if w__22 then
                                                          (MemU_read 
                                                           address
                                                             (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                                        else
                                                          (MemU_read
                                                             ((add_vec_int
                                                                 address
                                                                 (( 4 :: int):: ii) :: 32 Word.word))
                                                             (( 4 :: int):: ii) :: ( 32 Word.word) M))
                                                          \<bind>
                                                          ((\<lambda> (w__25 ::
                                                           32 Word.word) . 
                                                           (let data = 
                                                                ((update_subrange_vec_dec
                                                                    data
                                                                    (
                                                                    (
                                                                     63 :: int):: ii)
                                                                    (
                                                                    (
                                                                     32 :: int):: ii)
                                                                    w__25 :: 64 Word.word)) in
                                                           (D_read ((d + r)) :: ( 64 Word.word) M)
                                                             \<bind>
                                                             ((\<lambda> (w__26 :: 64 Word.word) . 
                                                              (Elem_set__1
                                                                 (( 64 :: int):: ii)
                                                                 w__26 
                                                               e data :: ( 64 Word.word) M)
                                                                \<bind>
                                                                ((\<lambda> (w__27 :: 64 Word.word) . 
                                                                 D_set
                                                                   ((d + r))
                                                                   w__27
                                                                   \<then>
                                                                   ((let 
                                                                    (address :: 32 bits) = 
                                                                    (
                                                                    (
                                                                    add_vec_int
                                                                    address
                                                                    (
                                                                    (
                                                                     8 :: int):: ii) :: 32 Word.word)) in
                                                                    return
                                                                    address))))))))))))))))
                                               ))))))))))))) \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__28 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__29 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__28 w__29 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__30 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__30
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  )))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d__arg"  :: " int " 
  and  "l__312"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "regs"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25039.58-25039.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_A2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 2 :: int)::ii)) in
     (if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25076.58-25076.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_A3enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25113.58-25113.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_A4enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_A4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_A4enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 4 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25147.58-25147.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25184.58-25184.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_T2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 2 :: int)::ii)) in
     (if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25221.58-25221.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_T3enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25258.58-25258.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD1_m_T4enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD1_m_T4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD1_m_T4enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 4 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25292.58-25292.59'')) \<then>
     execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD2_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD2_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d__arg d2__arg l__310 index1 m n register_index wback = (
   if (((l__310 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__0 :: 64 Word.word) . 
                     (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        (Elem_set__1 (( 8 :: int):: ii) w__0 index1 w__1 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__2 :: 64 Word.word) . 
                           (D_set d w__2 \<then>
                              (D_read d2 :: ( 64 Word.word) M)) \<bind>
                             ((\<lambda> (w__3 :: 64 Word.word) . 
                              (MemU_read
                                 ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                 (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                \<bind>
                                ((\<lambda> (w__4 :: 8 Word.word) . 
                                 (Elem_set__1 (( 8 :: int):: ii) w__3 
                                  index1 w__4 :: ( 64 Word.word) M) \<bind>
                                   ((\<lambda> (w__5 :: 64 Word.word) . 
                                    D_set d2 w__5 \<then>
                                      (
                                      if wback then
                                        if register_index then
                                          (R_read n :: ( 32 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__6 :: 32 Word.word) . 
                                             (R_read m :: ( 32 Word.word) M)
                                               \<bind>
                                               ((\<lambda> (w__7 :: 32 Word.word) . 
                                                R_set n
                                                  ((add_vec w__6 w__7 :: 32 Word.word))))))
                                        else
                                          (R_read n :: ( 32 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__8 :: 32 Word.word) . 
                                             R_set n
                                               ((add_vec_int w__8
                                                   (( 2 :: int):: ii) :: 32 Word.word))))
                                      else return () )))))))))))))
                  )))))))
   else if (((l__310 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__9 :: 64 Word.word) . 
                     (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__10 :: 16 Word.word) . 
                        (Elem_set__1 (( 16 :: int):: ii) w__9 index1 w__10 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__11 :: 64 Word.word) . 
                           (D_set d w__11 \<then>
                              (D_read d2 :: ( 64 Word.word) M)) \<bind>
                             ((\<lambda> (w__12 :: 64 Word.word) . 
                              (MemU_read
                                 ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                 (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                \<bind>
                                ((\<lambda> (w__13 :: 16 Word.word) . 
                                 (Elem_set__1 (( 16 :: int):: ii) w__12
                                    index1 w__13 :: ( 64 Word.word) M)
                                   \<bind>
                                   ((\<lambda> (w__14 :: 64 Word.word) . 
                                    D_set d2 w__14 \<then>
                                      (
                                      if wback then
                                        if register_index then
                                          (R_read n :: ( 32 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__15 :: 32 Word.word) . 
                                             (R_read m :: ( 32 Word.word) M)
                                               \<bind>
                                               ((\<lambda> (w__16 :: 32 Word.word) . 
                                                R_set n
                                                  ((add_vec w__15 w__16 :: 32 Word.word))))))
                                        else
                                          (R_read n :: ( 32 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__17 :: 32 Word.word) . 
                                             R_set n
                                               ((add_vec_int w__17
                                                   (( 4 :: int):: ii) :: 32 Word.word))))
                                      else return () )))))))))))))
                  )))))))
   else
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__18 :: 64 Word.word) . 
                     (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__19 :: 32 Word.word) . 
                        (Elem_set__1 (( 32 :: int):: ii) w__18 index1 w__19 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__20 :: 64 Word.word) . 
                           (D_set d w__20 \<then>
                              (D_read d2 :: ( 64 Word.word) M)) \<bind>
                             ((\<lambda> (w__21 :: 64 Word.word) . 
                              (MemU_read
                                 ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                 (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                \<bind>
                                ((\<lambda> (w__22 :: 32 Word.word) . 
                                 (Elem_set__1 (( 32 :: int):: ii) w__21
                                    index1 w__22 :: ( 64 Word.word) M)
                                   \<bind>
                                   ((\<lambda> (w__23 :: 64 Word.word) . 
                                    D_set d2 w__23 \<then>
                                      (
                                      if wback then
                                        if register_index then
                                          (R_read n :: ( 32 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__24 :: 32 Word.word) . 
                                             (R_read m :: ( 32 Word.word) M)
                                               \<bind>
                                               ((\<lambda> (w__25 :: 32 Word.word) . 
                                                R_set n
                                                  ((add_vec w__24 w__25 :: 32 Word.word))))))
                                        else
                                          (R_read n :: ( 32 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__26 :: 32 Word.word) . 
                                             R_set n
                                               ((add_vec_int w__26
                                                   (( 8 :: int):: ii) :: 32 Word.word))))
                                      else return () )))))))))))))
                  ))))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d__arg"  :: " int " 
  and  "d2__arg"  :: " int " 
  and  "l__310"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD2 (single 2-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD2 (single 2-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD2 (single 2-element structure to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD2 (single 2-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD2 (single 2-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD2 (single 2-element structure to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD2_a_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD2_a_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD2_a_Op_A_txt alignment d d2 l__307 m n register_index wback = (
   if (((l__307 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__0 :: 8 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__0 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                           (( 1 :: int):: ii) :: ( 8 Word.word) M)) \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        D_set d2
                          ((Replicate__1 (( 64 :: int):: ii) w__1 :: 64 Word.word))
                          \<then>
                          (
                          if wback then
                            if register_index then
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__2 :: 32 Word.word) . 
                                 (R_read m :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__3 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec w__2 w__3 :: 32 Word.word))))))
                            else
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__4 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec_int w__4 (( 2 :: int):: ii) :: 32 Word.word))))
                          else return () )))))
                  )))))
   else if (((l__307 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__5 :: 16 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__5 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                           (( 2 :: int):: ii) :: ( 16 Word.word) M)) \<bind>
                       ((\<lambda> (w__6 :: 16 Word.word) . 
                        D_set d2
                          ((Replicate__1 (( 64 :: int):: ii) w__6 :: 64 Word.word))
                          \<then>
                          (
                          if wback then
                            if register_index then
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__7 :: 32 Word.word) . 
                                 (R_read m :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__8 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec w__7 w__8 :: 32 Word.word))))))
                            else
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__9 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec_int w__9 (( 4 :: int):: ii) :: 32 Word.word))))
                          else return () )))))
                  )))))
   else if (((l__307 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__10 :: 32 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__10 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                           (( 4 :: int):: ii) :: ( 32 Word.word) M)) \<bind>
                       ((\<lambda> (w__11 :: 32 Word.word) . 
                        D_set d2
                          ((Replicate__1 (( 64 :: int):: ii) w__11 :: 64 Word.word))
                          \<then>
                          (
                          if wback then
                            if register_index then
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__12 :: 32 Word.word) . 
                                 (R_read m :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__13 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec w__12 w__13 :: 32 Word.word))))))
                            else
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__14 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec_int w__14 (( 8 :: int):: ii) :: 32 Word.word))))
                          else return () )))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 8 :: int):: ii) :: ( 64 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__15 :: 64 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__15 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 8 :: int):: ii) :: 32 Word.word))
                           (( 8 :: int):: ii) :: ( 64 Word.word) M)) \<bind>
                       ((\<lambda> (w__16 :: 64 Word.word) . 
                        D_set d2
                          ((Replicate__1 (( 64 :: int):: ii) w__16 :: 64 Word.word))
                          \<then>
                          (
                          if wback then
                            if register_index then
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__17 :: 32 Word.word) . 
                                 (R_read m :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__18 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec w__17 w__18 :: 32 Word.word))))))
                            else
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__19 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec_int w__19 (( 16 :: int):: ii) :: 32 Word.word))))
                          else return () )))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "l__307"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_a_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_a_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_a_A1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let alignment = (if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii) * ebytes) in
     (let inc_name = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_a_Op_A_txt alignment d d2 ebytes m n register_index wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_a_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_a_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_a_T1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let alignment = (if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii) * ebytes) in
     (let inc_name = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD2_a_Op_A_txt alignment d d2 ebytes m n register_index wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD2_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD2_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d__arg d2__arg l__304 elements m n pairs register_index wback = (
   if (((l__304 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__0 :: 64 Word.word) . 
                             (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__1 :: 8 Word.word) . 
                                (Elem_set__1 (( 8 :: int):: ii) w__0 e w__1 :: ( 64 Word.word) M)
                                  \<bind>
                                  ((\<lambda> (w__2 :: 64 Word.word) . 
                                   (D_set ((d + r)) w__2 \<then>
                                      (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                     \<bind>
                                     ((\<lambda> (w__3 :: 64 Word.word) . 
                                      (MemU_read
                                         ((add_vec_int address
                                             (( 1 :: int):: ii) :: 32 Word.word))
                                         (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                        \<bind>
                                        ((\<lambda> (w__4 :: 8 Word.word) . 
                                         (Elem_set__1 (( 8 :: int):: ii) 
                                          w__3 e w__4 :: ( 64 Word.word) M)
                                           \<bind>
                                           ((\<lambda> (w__5 :: 64 Word.word) . 
                                            D_set ((d2 + r)) w__5 \<then>
                                              ((let (address :: 32 bits) = 
                                                    ((add_vec_int address
                                                        (( 2 :: int):: ii) :: 32 Word.word)) in
                                               return address))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__6 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__7 :: 32 Word.word) . 
                               R_set n ((add_vec w__6 w__7 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__8 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__8
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  )))))))
   else if (((l__304 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__9 :: 64 Word.word) . 
                             (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__10 :: 16 Word.word) . 
                                (Elem_set__1 (( 16 :: int):: ii) w__9 e w__10 :: ( 64 Word.word) M)
                                  \<bind>
                                  ((\<lambda> (w__11 :: 64 Word.word) . 
                                   (D_set ((d + r)) w__11 \<then>
                                      (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                     \<bind>
                                     ((\<lambda> (w__12 :: 64 Word.word) . 
                                      (MemU_read
                                         ((add_vec_int address
                                             (( 2 :: int):: ii) :: 32 Word.word))
                                         (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                        \<bind>
                                        ((\<lambda> (w__13 ::
                                         16 Word.word) . 
                                         (Elem_set__1 (( 16 :: int):: ii)
                                            w__12 e w__13 :: ( 64 Word.word) M)
                                           \<bind>
                                           ((\<lambda> (w__14 :: 64 Word.word) . 
                                            D_set ((d2 + r)) w__14 \<then>
                                              ((let (address :: 32 bits) = 
                                                    ((add_vec_int address
                                                        (( 4 :: int):: ii) :: 32 Word.word)) in
                                               return address))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__15 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__16 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__15 w__16 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__17 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__17
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  )))))))
   else if (((l__304 = (( 4 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__18 :: 64 Word.word) . 
                             (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__19 :: 32 Word.word) . 
                                (Elem_set__1 (( 32 :: int):: ii) w__18 
                                 e w__19 :: ( 64 Word.word) M) \<bind>
                                  ((\<lambda> (w__20 :: 64 Word.word) . 
                                   (D_set ((d + r)) w__20 \<then>
                                      (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                     \<bind>
                                     ((\<lambda> (w__21 :: 64 Word.word) . 
                                      (MemU_read
                                         ((add_vec_int address
                                             (( 4 :: int):: ii) :: 32 Word.word))
                                         (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                        \<bind>
                                        ((\<lambda> (w__22 ::
                                         32 Word.word) . 
                                         (Elem_set__1 (( 32 :: int):: ii)
                                            w__21 e w__22 :: ( 64 Word.word) M)
                                           \<bind>
                                           ((\<lambda> (w__23 :: 64 Word.word) . 
                                            D_set ((d2 + r)) w__23 \<then>
                                              ((let (address :: 32 bits) = 
                                                    ((add_vec_int address
                                                        (( 8 :: int):: ii) :: 32 Word.word)) in
                                               return address))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__24 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__25 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__24 w__25 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__26 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__26
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  )))))))
   else
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__27 :: 64 Word.word) . 
                             (MemU_read address (( 8 :: int):: ii) :: ( 64 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__28 :: 64 Word.word) . 
                                (Elem_set__1 (( 64 :: int):: ii) w__27 
                                 e w__28 :: ( 64 Word.word) M) \<bind>
                                  ((\<lambda> (w__29 :: 64 Word.word) . 
                                   (D_set ((d + r)) w__29 \<then>
                                      (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                     \<bind>
                                     ((\<lambda> (w__30 :: 64 Word.word) . 
                                      (MemU_read
                                         ((add_vec_int address
                                             (( 8 :: int):: ii) :: 32 Word.word))
                                         (( 8 :: int):: ii) :: ( 64 Word.word) M)
                                        \<bind>
                                        ((\<lambda> (w__31 ::
                                         64 Word.word) . 
                                         (Elem_set__1 (( 64 :: int):: ii)
                                            w__30 e w__31 :: ( 64 Word.word) M)
                                           \<bind>
                                           ((\<lambda> (w__32 :: 64 Word.word) . 
                                            D_set ((d2 + r)) w__32 \<then>
                                              ((let (address :: 32 bits) = 
                                                    ((add_vec_int address
                                                        (( 16 :: int):: ii) :: 32 Word.word)) in
                                               return address))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__33 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__34 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__33 w__34 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__35 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__35
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  ))))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d__arg"  :: " int " 
  and  "d2__arg"  :: " int " 
  and  "l__304"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "pairs"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 1 :: int)::ii)) in
     ((if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let inc_name = (if (((itype = ( 0x9 ::  4 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25703.58-25703.59'')) \<then>
     execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_m_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_m_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_m_A2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 2 :: int)::ii)) in
     (let inc_name = ((( 2 :: int)::ii)) in
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25742.58-25742.59'')) \<then>
     execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 1 :: int)::ii)) in
     ((if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let inc_name = (if (((itype = ( 0x9 ::  4 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25784.58-25784.59'')) \<then>
     execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD2_m_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD2_m_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD2_m_T2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 2 :: int)::ii)) in
     (let inc_name = ((( 2 :: int)::ii)) in
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:25823.58-25823.59'')) \<then>
     execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD3_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD3_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD3_1_Op_A_txt d__arg d2__arg d3__arg l__302 index1 m n register_index wback = (
   if (((l__302 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
     (Elem_set__1 (( 8 :: int)::ii) w__0 index1 w__1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (D_set d w__2 \<then>
     (D_read d2  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
     (MemU_read ((add_vec_int address (( 1 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__4 ::
        8 Word.word) . 
     (Elem_set__1 (( 8 :: int)::ii) w__3 index1 w__4  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
     (D_set d2 w__5 \<then>
     (D_read d3  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (MemU_read ((add_vec_int address (( 2 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__7 ::
        8 Word.word) . 
     (Elem_set__1 (( 8 :: int)::ii) w__6 index1 w__7  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
     D_set d3 w__8 \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
         R_set n ((add_vec w__9 w__10  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
         R_set n ((add_vec_int w__11 (( 3 :: int)::ii)  ::  32 Word.word))))
     else return () ))))))))))))))))))))))))
   else if (((l__302 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
     (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__13 ::  16 Word.word) . 
     (Elem_set__1 (( 16 :: int)::ii) w__12 index1 w__13  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
     (D_set d w__14 \<then>
     (D_read d2  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
     (MemU_read ((add_vec_int address (( 2 :: int)::ii)  ::  32 Word.word)) (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__16 ::
        16 Word.word) . 
     (Elem_set__1 (( 16 :: int)::ii) w__15 index1 w__16  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
     (D_set d2 w__17 \<then>
     (D_read d3  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
     (MemU_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__19 ::
        16 Word.word) . 
     (Elem_set__1 (( 16 :: int)::ii) w__18 index1 w__19  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
     D_set d3 w__20 \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__22 ::  32 Word.word) . 
         R_set n ((add_vec w__21 w__22  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
         R_set n ((add_vec_int w__23 (( 6 :: int)::ii)  ::  32 Word.word))))
     else return () ))))))))))))))))))))))))
   else
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
     (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
     (Elem_set__1 (( 32 :: int)::ii) w__24 index1 w__25  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
     (D_set d w__26 \<then>
     (D_read d2  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
     (MemU_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__28 ::
        32 Word.word) . 
     (Elem_set__1 (( 32 :: int)::ii) w__27 index1 w__28  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
     (D_set d2 w__29 \<then>
     (D_read d3  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
     (MemU_read ((add_vec_int address (( 8 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__31 ::
        32 Word.word) . 
     (Elem_set__1 (( 32 :: int)::ii) w__30 index1 w__31  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
     D_set d3 w__32 \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__33 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__34 ::  32 Word.word) . 
         R_set n ((add_vec w__33 w__34  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__35 ::  32 Word.word) . 
         R_set n ((add_vec_int w__35 (( 12 :: int)::ii)  ::  32 Word.word))))
     else return () )))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "d2__arg"  :: " int " 
  and  "d3__arg"  :: " int " 
  and  "l__302"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD3 (single 3-element structure to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD3 (single 3-element structure to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD3 (single 3-element structure to all lanes)''))
      else return () ) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD3 (single 3-element structure to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD3 (single 3-element structure to all lanes)''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD3 (single 3-element structure to all lanes)''))
      else return () ) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD3_a_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD3_a_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD3_a_Op_A_txt d d2 d3 l__299 m n register_index wback = (
   if (((l__299 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (MemU_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__0 ::  8 Word.word) . 
     (D_set d ((Replicate__1 (( 64 :: int)::ii) w__0  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 1 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> ((\<lambda> (w__1 ::
        8 Word.word) . 
     (D_set d2 ((Replicate__1 (( 64 :: int)::ii) w__1  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 2 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> ((\<lambda> (w__2 ::
        8 Word.word) . 
     D_set d3 ((Replicate__1 (( 64 :: int)::ii) w__2  ::  64 Word.word)) \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
         R_set n ((add_vec w__3 w__4  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
         R_set n ((add_vec_int w__5 (( 3 :: int)::ii)  ::  32 Word.word))))
     else return () )))))))))
   else if (((l__299 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (MemU_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::  16 Word.word) . 
     (D_set d ((Replicate__1 (( 64 :: int)::ii) w__6  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 2 :: int)::ii)  ::  32 Word.word)) (( 2 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> ((\<lambda> (w__7 ::
        16 Word.word) . 
     (D_set d2 ((Replicate__1 (( 64 :: int)::ii) w__7  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 2 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> ((\<lambda> (w__8 ::
        16 Word.word) . 
     D_set d3 ((Replicate__1 (( 64 :: int)::ii) w__8  ::  64 Word.word)) \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
         R_set n ((add_vec w__9 w__10  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
         R_set n ((add_vec_int w__11 (( 6 :: int)::ii)  ::  32 Word.word))))
     else return () )))))))))
   else if (((l__299 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (MemU_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
     (D_set d ((Replicate__1 (( 64 :: int)::ii) w__12  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__13 ::
        32 Word.word) . 
     (D_set d2 ((Replicate__1 (( 64 :: int)::ii) w__13  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 8 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__14 ::
        32 Word.word) . 
     D_set d3 ((Replicate__1 (( 64 :: int)::ii) w__14  ::  64 Word.word)) \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
         R_set n ((add_vec w__15 w__16  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
         R_set n ((add_vec_int w__17 (( 12 :: int)::ii)  ::  32 Word.word))))
     else return () )))))))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (MemU_read address (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
     (D_set d ((Replicate__1 (( 64 :: int)::ii) w__18  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 8 :: int)::ii)  ::  32 Word.word)) (( 8 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__19 ::
        64 Word.word) . 
     (D_set d2 ((Replicate__1 (( 64 :: int)::ii) w__19  ::  64 Word.word)) \<then>
     (MemU_read ((add_vec_int address (( 16 :: int)::ii)  ::  32 Word.word)) (( 8 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__20 ::
        64 Word.word) . 
     D_set d3 ((Replicate__1 (( 64 :: int)::ii) w__20  ::  64 Word.word)) \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__22 ::  32 Word.word) . 
         R_set n ((add_vec w__21 w__22  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
         R_set n ((add_vec_int w__23 (( 24 :: int)::ii)  ::  32 Word.word))))
     else return () ))))))))))\<close> 
  for  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "d3"  :: " int " 
  and  "l__299"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_a_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_a_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_a_A1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> (((a = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let inc_name = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_a_Op_A_txt d d2 d3 ebytes m n register_index wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_a_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_a_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_a_T1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> (((a = ( 0b1 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let inc_name = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_a_Op_A_txt d d2 d3 ebytes m n register_index wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD3_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD3_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD3_m_Op_A_txt alignment d__arg d2__arg d3__arg l__296 elements m n register_index wback = (
   if (((l__296 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__0 :: 64 Word.word) . 
                         (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__1 :: 8 Word.word) . 
                            (Elem_set__1 (( 8 :: int):: ii) w__0 e w__1 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__2 :: 64 Word.word) . 
                               (D_set d w__2 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__3 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                     (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__4 :: 8 Word.word) . 
                                     (Elem_set__1 (( 8 :: int):: ii) 
                                      w__3 e w__4 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__5 :: 64 Word.word) . 
                                        (D_set d2 w__5 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__6 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 2 :: int):: ii) :: 32 Word.word))
                                              (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__7 ::
                                              8 Word.word) . 
                                              (Elem_set__1 (( 8 :: int):: ii)
                                                 w__6 e w__7 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__8 :: 64 Word.word) . 
                                                 D_set d3 w__8 \<then>
                                                   ((let (address :: 32 bits) = 
                                                         ((add_vec_int
                                                             address
                                                             (( 3 :: int):: ii) :: 32 Word.word)) in
                                                    return address)))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__9 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__10 :: 32 Word.word) . 
                               R_set n ((add_vec w__9 w__10 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__11 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__11 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  ))))))))
   else if (((l__296 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__12 :: 64 Word.word) . 
                         (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__13 :: 16 Word.word) . 
                            (Elem_set__1 (( 16 :: int):: ii) w__12 e w__13 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__14 :: 64 Word.word) . 
                               (D_set d w__14 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__15 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                     (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__16 :: 16 Word.word) . 
                                     (Elem_set__1 (( 16 :: int):: ii) 
                                      w__15 e w__16 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__17 :: 64 Word.word) . 
                                        (D_set d2 w__17 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__18 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 4 :: int):: ii) :: 32 Word.word))
                                              (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__19 ::
                                              16 Word.word) . 
                                              (Elem_set__1
                                                 (( 16 :: int):: ii) 
                                               w__18 e w__19 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__20 :: 64 Word.word) . 
                                                 D_set d3 w__20 \<then>
                                                   ((let (address :: 32 bits) = 
                                                         ((add_vec_int
                                                             address
                                                             (( 6 :: int):: ii) :: 32 Word.word)) in
                                                    return address)))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__21 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__22 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__21 w__22 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__23 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__23 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  ))))))))
   else if (((l__296 = (( 4 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__24 :: 64 Word.word) . 
                         (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__25 :: 32 Word.word) . 
                            (Elem_set__1 (( 32 :: int):: ii) w__24 e w__25 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__26 :: 64 Word.word) . 
                               (D_set d w__26 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__27 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                     (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__28 :: 32 Word.word) . 
                                     (Elem_set__1 (( 32 :: int):: ii) 
                                      w__27 e w__28 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__29 :: 64 Word.word) . 
                                        (D_set d2 w__29 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__30 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 8 :: int):: ii) :: 32 Word.word))
                                              (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__31 ::
                                              32 Word.word) . 
                                              (Elem_set__1
                                                 (( 32 :: int):: ii) 
                                               w__30 e w__31 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__32 :: 64 Word.word) . 
                                                 D_set d3 w__32 \<then>
                                                   ((let (address :: 32 bits) = 
                                                         ((add_vec_int
                                                             address
                                                             (( 12 :: int):: ii) :: 32 Word.word)) in
                                                    return address)))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__33 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__34 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__33 w__34 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__35 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__35 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  ))))))))
   else
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__36 :: 64 Word.word) . 
                         (MemU_read address (( 8 :: int):: ii) :: ( 64 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__37 :: 64 Word.word) . 
                            (Elem_set__1 (( 64 :: int):: ii) w__36 e w__37 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__38 :: 64 Word.word) . 
                               (D_set d w__38 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__39 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 8 :: int):: ii) :: 32 Word.word))
                                     (( 8 :: int):: ii) :: ( 64 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__40 :: 64 Word.word) . 
                                     (Elem_set__1 (( 64 :: int):: ii) 
                                      w__39 e w__40 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__41 :: 64 Word.word) . 
                                        (D_set d2 w__41 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__42 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 16 :: int):: ii) :: 32 Word.word))
                                              (( 8 :: int):: ii) :: ( 64 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__43 ::
                                              64 Word.word) . 
                                              (Elem_set__1
                                                 (( 64 :: int):: ii) 
                                               w__42 e w__43 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__44 :: 64 Word.word) . 
                                                 D_set d3 w__44 \<then>
                                                   ((let (address :: 32 bits) = 
                                                         ((add_vec_int
                                                             address
                                                             (( 24 :: int):: ii) :: 32 Word.word)) in
                                                    return address)))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__45 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__46 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__45 w__46 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__47 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__47 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d__arg"  :: " int " 
  and  "d2__arg"  :: " int " 
  and  "d3__arg"  :: " int " 
  and  "l__296"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x4 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x5 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if ((((vec_of_bits [access_vec_dec align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
       wback))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD3_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD3_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD3_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x4 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x5 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if ((((vec_of_bits [access_vec_dec align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
       wback))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD4_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD4_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d__arg d2__arg d3__arg d4__arg l__294 index1 m n register_index wback = (
   if (((l__294 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (let (d4 :: ii) = d4__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__0 :: 64 Word.word) . 
                     (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        (Elem_set__1 (( 8 :: int):: ii) w__0 index1 w__1 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__2 :: 64 Word.word) . 
                           (D_set d w__2 \<then>
                              (D_read d2 :: ( 64 Word.word) M)) \<bind>
                             ((\<lambda> (w__3 :: 64 Word.word) . 
                              (MemU_read
                                 ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                 (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                \<bind>
                                ((\<lambda> (w__4 :: 8 Word.word) . 
                                 (Elem_set__1 (( 8 :: int):: ii) w__3 
                                  index1 w__4 :: ( 64 Word.word) M) \<bind>
                                   ((\<lambda> (w__5 :: 64 Word.word) . 
                                    (D_set d2 w__5 \<then>
                                       (D_read d3 :: ( 64 Word.word) M))
                                      \<bind>
                                      ((\<lambda> (w__6 :: 64 Word.word) . 
                                       (MemU_read
                                          ((add_vec_int address
                                              (( 2 :: int):: ii) :: 32 Word.word))
                                          (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__7 :: 8 Word.word) . 
                                          (Elem_set__1 (( 8 :: int):: ii)
                                             w__6 index1 w__7 :: ( 64 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__8 :: 64 Word.word) . 
                                             (D_set d3 w__8 \<then>
                                                (D_read d4 :: ( 64 Word.word) M))
                                               \<bind>
                                               ((\<lambda> (w__9 :: 64 Word.word) . 
                                                (MemU_read
                                                   ((add_vec_int address
                                                       (( 3 :: int):: ii) :: 32 Word.word))
                                                   (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__10 ::
                                                   8 Word.word) . 
                                                   (Elem_set__1
                                                      (( 8 :: int):: ii) 
                                                    w__9 index1 w__10 :: ( 64 Word.word) M)
                                                     \<bind>
                                                     ((\<lambda> (w__11 :: 64 Word.word) . 
                                                      D_set d4 w__11 \<then>
                                                        (
                                                        if wback then
                                                          if register_index then
                                                            (R_read n :: ( 32 Word.word) M)
                                                              \<bind>
                                                              ((\<lambda> (w__12 :: 32 Word.word) . 
                                                               (R_read m :: ( 32 Word.word) M)
                                                                 \<bind>
                                                                 ((\<lambda> (w__13 :: 32 Word.word) . 
                                                                  R_set 
                                                                  n
                                                                    (
                                                                    (
                                                                    add_vec
                                                                    w__12
                                                                    w__13 :: 32 Word.word))))))
                                                          else
                                                            (R_read n :: ( 32 Word.word) M)
                                                              \<bind>
                                                              ((\<lambda> (w__14 :: 32 Word.word) . 
                                                               R_set 
                                                               n
                                                                 ((add_vec_int
                                                                    w__14
                                                                    (
                                                                    (
                                                                     4 :: int):: ii) :: 32 Word.word))))
                                                        else return () )))))))))))))))))))))))))
                  )))))))))
   else if (((l__294 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (let (d4 :: ii) = d4__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__15 :: 64 Word.word) . 
                     (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__16 :: 16 Word.word) . 
                        (Elem_set__1 (( 16 :: int):: ii) w__15 index1 w__16 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__17 :: 64 Word.word) . 
                           (D_set d w__17 \<then>
                              (D_read d2 :: ( 64 Word.word) M)) \<bind>
                             ((\<lambda> (w__18 :: 64 Word.word) . 
                              (MemU_read
                                 ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                 (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                \<bind>
                                ((\<lambda> (w__19 :: 16 Word.word) . 
                                 (Elem_set__1 (( 16 :: int):: ii) w__18
                                    index1 w__19 :: ( 64 Word.word) M)
                                   \<bind>
                                   ((\<lambda> (w__20 :: 64 Word.word) . 
                                    (D_set d2 w__20 \<then>
                                       (D_read d3 :: ( 64 Word.word) M))
                                      \<bind>
                                      ((\<lambda> (w__21 :: 64 Word.word) . 
                                       (MemU_read
                                          ((add_vec_int address
                                              (( 4 :: int):: ii) :: 32 Word.word))
                                          (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__22 ::
                                          16 Word.word) . 
                                          (Elem_set__1 (( 16 :: int):: ii)
                                             w__21 index1 w__22 :: ( 64 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__23 :: 64 Word.word) . 
                                             (D_set d3 w__23 \<then>
                                                (D_read d4 :: ( 64 Word.word) M))
                                               \<bind>
                                               ((\<lambda> (w__24 :: 64 Word.word) . 
                                                (MemU_read
                                                   ((add_vec_int address
                                                       (( 6 :: int):: ii) :: 32 Word.word))
                                                   (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__25 ::
                                                   16 Word.word) . 
                                                   (Elem_set__1
                                                      (( 16 :: int):: ii)
                                                      w__24 index1 w__25 :: ( 64 Word.word) M)
                                                     \<bind>
                                                     ((\<lambda> (w__26 :: 64 Word.word) . 
                                                      D_set d4 w__26 \<then>
                                                        (
                                                        if wback then
                                                          if register_index then
                                                            (R_read n :: ( 32 Word.word) M)
                                                              \<bind>
                                                              ((\<lambda> (w__27 :: 32 Word.word) . 
                                                               (R_read m :: ( 32 Word.word) M)
                                                                 \<bind>
                                                                 ((\<lambda> (w__28 :: 32 Word.word) . 
                                                                  R_set 
                                                                  n
                                                                    (
                                                                    (
                                                                    add_vec
                                                                    w__27
                                                                    w__28 :: 32 Word.word))))))
                                                          else
                                                            (R_read n :: ( 32 Word.word) M)
                                                              \<bind>
                                                              ((\<lambda> (w__29 :: 32 Word.word) . 
                                                               R_set 
                                                               n
                                                                 ((add_vec_int
                                                                    w__29
                                                                    (
                                                                    (
                                                                     8 :: int):: ii) :: 32 Word.word))))
                                                        else return () )))))))))))))))))))))))))
                  )))))))))
   else
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (let (d4 :: ii) = d4__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__30 :: 64 Word.word) . 
                     (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__31 :: 32 Word.word) . 
                        (Elem_set__1 (( 32 :: int):: ii) w__30 index1 w__31 :: ( 64 Word.word) M)
                          \<bind>
                          ((\<lambda> (w__32 :: 64 Word.word) . 
                           (D_set d w__32 \<then>
                              (D_read d2 :: ( 64 Word.word) M)) \<bind>
                             ((\<lambda> (w__33 :: 64 Word.word) . 
                              (MemU_read
                                 ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                 (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                \<bind>
                                ((\<lambda> (w__34 :: 32 Word.word) . 
                                 (Elem_set__1 (( 32 :: int):: ii) w__33
                                    index1 w__34 :: ( 64 Word.word) M)
                                   \<bind>
                                   ((\<lambda> (w__35 :: 64 Word.word) . 
                                    (D_set d2 w__35 \<then>
                                       (D_read d3 :: ( 64 Word.word) M))
                                      \<bind>
                                      ((\<lambda> (w__36 :: 64 Word.word) . 
                                       (MemU_read
                                          ((add_vec_int address
                                              (( 8 :: int):: ii) :: 32 Word.word))
                                          (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__37 ::
                                          32 Word.word) . 
                                          (Elem_set__1 (( 32 :: int):: ii)
                                             w__36 index1 w__37 :: ( 64 Word.word) M)
                                            \<bind>
                                            ((\<lambda> (w__38 :: 64 Word.word) . 
                                             (D_set d3 w__38 \<then>
                                                (D_read d4 :: ( 64 Word.word) M))
                                               \<bind>
                                               ((\<lambda> (w__39 :: 64 Word.word) . 
                                                (MemU_read
                                                   ((add_vec_int address
                                                       (( 12 :: int):: ii) :: 32 Word.word))
                                                   (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__40 ::
                                                   32 Word.word) . 
                                                   (Elem_set__1
                                                      (( 32 :: int):: ii)
                                                      w__39 index1 w__40 :: ( 64 Word.word) M)
                                                     \<bind>
                                                     ((\<lambda> (w__41 :: 64 Word.word) . 
                                                      D_set d4 w__41 \<then>
                                                        (
                                                        if wback then
                                                          if register_index then
                                                            (R_read n :: ( 32 Word.word) M)
                                                              \<bind>
                                                              ((\<lambda> (w__42 :: 32 Word.word) . 
                                                               (R_read m :: ( 32 Word.word) M)
                                                                 \<bind>
                                                                 ((\<lambda> (w__43 :: 32 Word.word) . 
                                                                  R_set 
                                                                  n
                                                                    (
                                                                    (
                                                                    add_vec
                                                                    w__42
                                                                    w__43 :: 32 Word.word))))))
                                                          else
                                                            (R_read n :: ( 32 Word.word) M)
                                                              \<bind>
                                                              ((\<lambda> (w__44 :: 32 Word.word) . 
                                                               R_set 
                                                               n
                                                                 ((add_vec_int
                                                                    w__44
                                                                    (
                                                                    (
                                                                     16 :: int):: ii) :: 32 Word.word))))
                                                        else return () )))))))))))))))))))))))))
                  ))))))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d__arg"  :: " int " 
  and  "d2__arg"  :: " int " 
  and  "d3__arg"  :: " int " 
  and  "d4__arg"  :: " int " 
  and  "l__294"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD4 (single 4-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD4 (single 4-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD4 (single 4-element structure to all lanes)''))
      else return () ) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint ((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:26449.58-26449.59'')) \<then>
     execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD4 (single 4-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD4 (single 4-element structure to all lanes)''))
      else return () ) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then
        throw (Error_See (''VLD4 (single 4-element structure to all lanes)''))
      else return () ) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint ((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:26568.58-26568.59'')) \<then>
     execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD4_a_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD4_a_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD4_a_Op_A_txt alignment d d2 d3 d4 l__291 m n register_index wback = (
   if (((l__291 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__0 :: 8 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__0 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                           (( 1 :: int):: ii) :: ( 8 Word.word) M)) \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        (D_set d2
                           ((Replicate__1 (( 64 :: int):: ii) w__1 :: 64 Word.word))
                           \<then>
                           (MemU_read
                              ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                              (( 1 :: int):: ii) :: ( 8 Word.word) M))
                          \<bind>
                          ((\<lambda> (w__2 :: 8 Word.word) . 
                           (D_set d3
                              ((Replicate__1 (( 64 :: int):: ii) w__2 :: 64 Word.word))
                              \<then>
                              (MemU_read
                                 ((add_vec_int address (( 3 :: int):: ii) :: 32 Word.word))
                                 (( 1 :: int):: ii) :: ( 8 Word.word) M))
                             \<bind>
                             ((\<lambda> (w__3 :: 8 Word.word) . 
                              D_set d4
                                ((Replicate__1 (( 64 :: int):: ii) w__3 :: 64 Word.word))
                                \<then>
                                (
                                if wback then
                                  if register_index then
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__4 :: 32 Word.word) . 
                                       (R_read m :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__5 :: 32 Word.word) . 
                                          R_set n
                                            ((add_vec w__4 w__5 :: 32 Word.word))))))
                                  else
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__6 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec_int w__6
                                             (( 4 :: int):: ii) :: 32 Word.word))))
                                else return () )))))))))
                  )))))
   else if (((l__291 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__7 :: 16 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__7 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                           (( 2 :: int):: ii) :: ( 16 Word.word) M)) \<bind>
                       ((\<lambda> (w__8 :: 16 Word.word) . 
                        (D_set d2
                           ((Replicate__1 (( 64 :: int):: ii) w__8 :: 64 Word.word))
                           \<then>
                           (MemU_read
                              ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                              (( 2 :: int):: ii) :: ( 16 Word.word) M))
                          \<bind>
                          ((\<lambda> (w__9 :: 16 Word.word) . 
                           (D_set d3
                              ((Replicate__1 (( 64 :: int):: ii) w__9 :: 64 Word.word))
                              \<then>
                              (MemU_read
                                 ((add_vec_int address (( 6 :: int):: ii) :: 32 Word.word))
                                 (( 2 :: int):: ii) :: ( 16 Word.word) M))
                             \<bind>
                             ((\<lambda> (w__10 :: 16 Word.word) . 
                              D_set d4
                                ((Replicate__1 (( 64 :: int):: ii) w__10 :: 64 Word.word))
                                \<then>
                                (
                                if wback then
                                  if register_index then
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__11 :: 32 Word.word) . 
                                       (R_read m :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__12 :: 32 Word.word) . 
                                          R_set n
                                            ((add_vec w__11 w__12 :: 32 Word.word))))))
                                  else
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__13 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec_int w__13
                                             (( 8 :: int):: ii) :: 32 Word.word))))
                                else return () )))))))))
                  )))))
   else if (((l__291 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__14 :: 32 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__14 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                           (( 4 :: int):: ii) :: ( 32 Word.word) M)) \<bind>
                       ((\<lambda> (w__15 :: 32 Word.word) . 
                        (D_set d2
                           ((Replicate__1 (( 64 :: int):: ii) w__15 :: 64 Word.word))
                           \<then>
                           (MemU_read
                              ((add_vec_int address (( 8 :: int):: ii) :: 32 Word.word))
                              (( 4 :: int):: ii) :: ( 32 Word.word) M))
                          \<bind>
                          ((\<lambda> (w__16 :: 32 Word.word) . 
                           (D_set d3
                              ((Replicate__1 (( 64 :: int):: ii) w__16 :: 64 Word.word))
                              \<then>
                              (MemU_read
                                 ((add_vec_int address (( 12 :: int):: ii) :: 32 Word.word))
                                 (( 4 :: int):: ii) :: ( 32 Word.word) M))
                             \<bind>
                             ((\<lambda> (w__17 :: 32 Word.word) . 
                              D_set d4
                                ((Replicate__1 (( 64 :: int):: ii) w__17 :: 64 Word.word))
                                \<then>
                                (
                                if wback then
                                  if register_index then
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__18 :: 32 Word.word) . 
                                       (R_read m :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__19 :: 32 Word.word) . 
                                          R_set n
                                            ((add_vec w__18 w__19 :: 32 Word.word))))))
                                  else
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__20 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec_int w__20
                                             (( 16 :: int):: ii) :: 32 Word.word))))
                                else return () )))))))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (MemU_read address (( 8 :: int):: ii) :: ( 64 Word.word) M)
                    \<bind>
                    ((\<lambda> (w__21 :: 64 Word.word) . 
                     (D_set d
                        ((Replicate__1 (( 64 :: int):: ii) w__21 :: 64 Word.word))
                        \<then>
                        (MemU_read
                           ((add_vec_int address (( 8 :: int):: ii) :: 32 Word.word))
                           (( 8 :: int):: ii) :: ( 64 Word.word) M)) \<bind>
                       ((\<lambda> (w__22 :: 64 Word.word) . 
                        (D_set d2
                           ((Replicate__1 (( 64 :: int):: ii) w__22 :: 64 Word.word))
                           \<then>
                           (MemU_read
                              ((add_vec_int address (( 16 :: int):: ii) :: 32 Word.word))
                              (( 8 :: int):: ii) :: ( 64 Word.word) M))
                          \<bind>
                          ((\<lambda> (w__23 :: 64 Word.word) . 
                           (D_set d3
                              ((Replicate__1 (( 64 :: int):: ii) w__23 :: 64 Word.word))
                              \<then>
                              (MemU_read
                                 ((add_vec_int address (( 24 :: int):: ii) :: 32 Word.word))
                                 (( 8 :: int):: ii) :: ( 64 Word.word) M))
                             \<bind>
                             ((\<lambda> (w__24 :: 64 Word.word) . 
                              D_set d4
                                ((Replicate__1 (( 64 :: int):: ii) w__24 :: 64 Word.word))
                                \<then>
                                (
                                if wback then
                                  if register_index then
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__25 :: 32 Word.word) . 
                                       (R_read m :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__26 :: 32 Word.word) . 
                                          R_set n
                                            ((add_vec w__25 w__26 :: 32 Word.word))))))
                                  else
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__27 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec_int w__27
                                             (( 32 :: int):: ii) :: 32 Word.word))))
                                else return () )))))))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "d3"  :: " int " 
  and  "d4"  :: " int " 
  and  "l__291"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_a_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_a_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_a_A1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<and> (((a = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (ebytes :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (alignment :: ii) . 
     (let ((alignment :: ii), (ebytes :: int)) =
       (if (((size1 = ( 0b11 ::  2 Word.word)))) then
         (let (ebytes :: int) = ((( 4 :: int)::ii)) in
         (let (alignment :: ii) = ((( 16 :: int)::ii)) in
         (alignment, ebytes)))
       else
         (let (ebytes :: int) = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
         (let (alignment :: ii) =
           (if (((size1 = ( 0b10 ::  2 Word.word)))) then
             if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii)
             else (( 8 :: int)::ii)
           else if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii)
           else (( 4 :: int)::ii) * ebytes) in
         (alignment, ebytes)))) in
     (let ebytes = ebytes in
     (let alignment = alignment in
     (let inc_name = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let alignment = alignment in
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:26644.58-26644.59'') \<then>
     execute_aarch32_instrs_VLD4_a_Op_A_txt alignment d d2 d3 d4 ebytes m n register_index wback))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_a_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_a_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_a_T1enc_A_txt D Rn Vd size1 T a Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<and> (((a = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (ebytes :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (alignment :: ii) . 
     (let ((alignment :: ii), (ebytes :: int)) =
       (if (((size1 = ( 0b11 ::  2 Word.word)))) then
         (let (ebytes :: int) = ((( 4 :: int)::ii)) in
         (let (alignment :: ii) = ((( 16 :: int)::ii)) in
         (alignment, ebytes)))
       else
         (let (ebytes :: int) = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
         (let (alignment :: ii) =
           (if (((size1 = ( 0b10 ::  2 Word.word)))) then
             if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii)
             else (( 8 :: int)::ii)
           else if (((a = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii)
           else (( 4 :: int)::ii) * ebytes) in
         (alignment, ebytes)))) in
     (let ebytes = ebytes in
     (let alignment = alignment in
     (let inc_name = (if (((T = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let alignment = alignment in
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:26697.58-26697.59'') \<then>
     execute_aarch32_instrs_VLD4_a_Op_A_txt alignment d d2 d3 d4 ebytes m n register_index wback))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "T"  :: "(1)Word.word " 
  and  "a"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLD4_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLD4_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLD4_m_Op_A_txt alignment d__arg d2__arg d3__arg d4__arg l__288 elements m n register_index wback = (
   if (((l__288 = (( 1 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (let (d4 :: ii) = d4__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__0 :: 64 Word.word) . 
                         (MemU_read address (( 1 :: int):: ii) :: ( 8 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__1 :: 8 Word.word) . 
                            (Elem_set__1 (( 8 :: int):: ii) w__0 e w__1 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__2 :: 64 Word.word) . 
                               (D_set d w__2 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__3 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                     (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__4 :: 8 Word.word) . 
                                     (Elem_set__1 (( 8 :: int):: ii) 
                                      w__3 e w__4 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__5 :: 64 Word.word) . 
                                        (D_set d2 w__5 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__6 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 2 :: int):: ii) :: 32 Word.word))
                                              (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__7 ::
                                              8 Word.word) . 
                                              (Elem_set__1 (( 8 :: int):: ii)
                                                 w__6 e w__7 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__8 :: 64 Word.word) . 
                                                 (D_set d3 w__8 \<then>
                                                    (D_read d4 :: ( 64 Word.word) M))
                                                   \<bind>
                                                   ((\<lambda> (w__9 :: 64 Word.word) . 
                                                    (MemU_read
                                                       ((add_vec_int 
                                                         address
                                                           (( 3 :: int):: ii) :: 32 Word.word))
                                                       (( 1 :: int):: ii) :: ( 8 Word.word) M)
                                                      \<bind>
                                                      ((\<lambda> (w__10 ::
                                                       8 Word.word) . 
                                                       (Elem_set__1
                                                          (( 8 :: int):: ii)
                                                          w__9 e w__10 :: ( 64 Word.word) M)
                                                         \<bind>
                                                         ((\<lambda> (w__11 :: 64 Word.word) . 
                                                          D_set d4 w__11
                                                            \<then>
                                                            ((let (address :: 32 bits) = 
                                                                  ((add_vec_int
                                                                    address
                                                                    (
                                                                    (
                                                                     4 :: int):: ii) :: 32 Word.word)) in
                                                             return address)))))))))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__12 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__13 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__12 w__13 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__14 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__14 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))))))
   else if (((l__288 = (( 2 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (let (d4 :: ii) = d4__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__15 :: 64 Word.word) . 
                         (MemU_read address (( 2 :: int):: ii) :: ( 16 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__16 :: 16 Word.word) . 
                            (Elem_set__1 (( 16 :: int):: ii) w__15 e w__16 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__17 :: 64 Word.word) . 
                               (D_set d w__17 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__18 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                     (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__19 :: 16 Word.word) . 
                                     (Elem_set__1 (( 16 :: int):: ii) 
                                      w__18 e w__19 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__20 :: 64 Word.word) . 
                                        (D_set d2 w__20 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__21 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 4 :: int):: ii) :: 32 Word.word))
                                              (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__22 ::
                                              16 Word.word) . 
                                              (Elem_set__1
                                                 (( 16 :: int):: ii) 
                                               w__21 e w__22 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__23 :: 64 Word.word) . 
                                                 (D_set d3 w__23 \<then>
                                                    (D_read d4 :: ( 64 Word.word) M))
                                                   \<bind>
                                                   ((\<lambda> (w__24 :: 64 Word.word) . 
                                                    (MemU_read
                                                       ((add_vec_int 
                                                         address
                                                           (( 6 :: int):: ii) :: 32 Word.word))
                                                       (( 2 :: int):: ii) :: ( 16 Word.word) M)
                                                      \<bind>
                                                      ((\<lambda> (w__25 ::
                                                       16 Word.word) . 
                                                       (Elem_set__1
                                                          (( 16 :: int):: ii)
                                                          w__24 e w__25 :: ( 64 Word.word) M)
                                                         \<bind>
                                                         ((\<lambda> (w__26 :: 64 Word.word) . 
                                                          D_set d4 w__26
                                                            \<then>
                                                            ((let (address :: 32 bits) = 
                                                                  ((add_vec_int
                                                                    address
                                                                    (
                                                                    (
                                                                     8 :: int):: ii) :: 32 Word.word)) in
                                                             return address)))))))))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__27 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__28 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__27 w__28 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__29 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__29 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))))))
   else if (((l__288 = (( 4 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (let (d4 :: ii) = d4__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__30 :: 64 Word.word) . 
                         (MemU_read address (( 4 :: int):: ii) :: ( 32 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__31 :: 32 Word.word) . 
                            (Elem_set__1 (( 32 :: int):: ii) w__30 e w__31 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__32 :: 64 Word.word) . 
                               (D_set d w__32 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__33 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                     (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__34 :: 32 Word.word) . 
                                     (Elem_set__1 (( 32 :: int):: ii) 
                                      w__33 e w__34 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__35 :: 64 Word.word) . 
                                        (D_set d2 w__35 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__36 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 8 :: int):: ii) :: 32 Word.word))
                                              (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__37 ::
                                              32 Word.word) . 
                                              (Elem_set__1
                                                 (( 32 :: int):: ii) 
                                               w__36 e w__37 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__38 :: 64 Word.word) . 
                                                 (D_set d3 w__38 \<then>
                                                    (D_read d4 :: ( 64 Word.word) M))
                                                   \<bind>
                                                   ((\<lambda> (w__39 :: 64 Word.word) . 
                                                    (MemU_read
                                                       ((add_vec_int 
                                                         address
                                                           (( 12 :: int):: ii) :: 32 Word.word))
                                                       (( 4 :: int):: ii) :: ( 32 Word.word) M)
                                                      \<bind>
                                                      ((\<lambda> (w__40 ::
                                                       32 Word.word) . 
                                                       (Elem_set__1
                                                          (( 32 :: int):: ii)
                                                          w__39 e w__40 :: ( 64 Word.word) M)
                                                         \<bind>
                                                         ((\<lambda> (w__41 :: 64 Word.word) . 
                                                          D_set d4 w__41
                                                            \<then>
                                                            ((let (address :: 32 bits) = 
                                                                  ((add_vec_int
                                                                    address
                                                                    (
                                                                    (
                                                                     16 :: int):: ii) :: 32 Word.word)) in
                                                             return address)))))))))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__42 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__43 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__42 w__43 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__44 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__44 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))))))
   else
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>
     (let (d :: ii) = d__arg in
     (let (d2 :: ii) = d2__arg in
     (let (d3 :: ii) = d3__arg in
     (let (d4 :: ii) = d4__arg in
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC False \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__45 :: 64 Word.word) . 
                         (MemU_read address (( 8 :: int):: ii) :: ( 64 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__46 :: 64 Word.word) . 
                            (Elem_set__1 (( 64 :: int):: ii) w__45 e w__46 :: ( 64 Word.word) M)
                              \<bind>
                              ((\<lambda> (w__47 :: 64 Word.word) . 
                               (D_set d w__47 \<then>
                                  (D_read d2 :: ( 64 Word.word) M)) \<bind>
                                 ((\<lambda> (w__48 :: 64 Word.word) . 
                                  (MemU_read
                                     ((add_vec_int address (( 8 :: int):: ii) :: 32 Word.word))
                                     (( 8 :: int):: ii) :: ( 64 Word.word) M)
                                    \<bind>
                                    ((\<lambda> (w__49 :: 64 Word.word) . 
                                     (Elem_set__1 (( 64 :: int):: ii) 
                                      w__48 e w__49 :: ( 64 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__50 :: 64 Word.word) . 
                                        (D_set d2 w__50 \<then>
                                           (D_read d3 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__51 :: 64 Word.word) . 
                                           (MemU_read
                                              ((add_vec_int address
                                                  (( 16 :: int):: ii) :: 32 Word.word))
                                              (( 8 :: int):: ii) :: ( 64 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__52 ::
                                              64 Word.word) . 
                                              (Elem_set__1
                                                 (( 64 :: int):: ii) 
                                               w__51 e w__52 :: ( 64 Word.word) M)
                                                \<bind>
                                                ((\<lambda> (w__53 :: 64 Word.word) . 
                                                 (D_set d3 w__53 \<then>
                                                    (D_read d4 :: ( 64 Word.word) M))
                                                   \<bind>
                                                   ((\<lambda> (w__54 :: 64 Word.word) . 
                                                    (MemU_read
                                                       ((add_vec_int 
                                                         address
                                                           (( 24 :: int):: ii) :: 32 Word.word))
                                                       (( 8 :: int):: ii) :: ( 64 Word.word) M)
                                                      \<bind>
                                                      ((\<lambda> (w__55 ::
                                                       64 Word.word) . 
                                                       (Elem_set__1
                                                          (( 64 :: int):: ii)
                                                          w__54 e w__55 :: ( 64 Word.word) M)
                                                         \<bind>
                                                         ((\<lambda> (w__56 :: 64 Word.word) . 
                                                          D_set d4 w__56
                                                            \<then>
                                                            ((let (address :: 32 bits) = 
                                                                  ((add_vec_int
                                                                    address
                                                                    (
                                                                    (
                                                                     32 :: int):: ii) :: 32 Word.word)) in
                                                             return address)))))))))))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__57 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__58 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__57 w__58 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__59 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__59 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  ))))))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d__arg"  :: " int " 
  and  "d2__arg"  :: " int " 
  and  "d3__arg"  :: " int " 
  and  "d4__arg"  :: " int " 
  and  "l__288"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x0 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x1 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:26780.58-26780.59'')) \<then>
     execute_aarch32_instrs_VLD4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n register_index
       wback)))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLD4_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLD4_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLD4_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x0 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x1 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:26832.58-26832.59'')) \<then>
     execute_aarch32_instrs_VLD4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n register_index
       wback)))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLDM_Op_A_txt : bool -> integer -> mword ty32 -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLDM_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (word1 :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (word2 :: 32 bits) . 
   (CheckVFPEnabled True \<then>
   (if add then (R_read n  :: ( 32 Word.word) M)
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word)))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (address, word1, word2)
     ((\<lambda> r varstup .  (let (address, word1, word2) = varstup in
       if single_regs then
         (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
         S_set ((d + r)) w__2 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return (address, word1, word2)))))
       else
         (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
         (let word1 = w__3 in
         (MemA_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::
            32 Word.word) . 
         (let word2 = w__4 in
         (let (address :: 32 bits) = ((add_vec_int address (( 8 :: int)::ii)  ::  32 Word.word)) in
         BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__5 :: bool) . 
         (let (w__6 ::  64 Word.word) =
           (if w__5 then (concat_vec word1 word2  ::  64 Word.word)
           else (concat_vec word2 word1  ::  64 Word.word)) in
         D_set ((d + r)) w__6 \<then> return (address, word1, word2))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((address ::
      32 Word.word), (word1 ::  32 Word.word), (word2 ::  32 Word.word)) = varstup in
   if wback then
     (if add then
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
        return ((add_vec w__7 imm32  ::  32 Word.word))))
      else
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
        return ((sub_vec w__8 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
     R_set n w__9))
   else return () ))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "single_regs"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLDM_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLDM_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLDM_A1enc_A_txt cond P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:26881.29-26881.30'') \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VLDR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = False in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (((Word.uint imm8)) div (( 2 :: int)::ii)) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     (((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((regs = (( 0 :: int)::ii)))) \<or> ((regs > (( 16 :: int)::ii)))))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec imm8 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> ((((d + regs)) > (( 16 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLDM_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLDM_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLDM_A2enc_A_txt cond P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:26929.29-26929.30'') \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VLDR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (Word.uint imm8) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((regs = (( 0 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLDM_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLDM_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLDM_T1enc_A_txt P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VLDR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = False in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (((Word.uint imm8)) div (( 2 :: int)::ii)) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     (((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((regs = (( 0 :: int)::ii)))) \<or> ((regs > (( 16 :: int)::ii)))))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec imm8 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> ((((d + regs)) > (( 16 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLDM_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLDM_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLDM_T2enc_A_txt P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VLDR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (Word.uint imm8) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((regs = (( 0 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VLDR_Op_A_txt : bool -> integer -> integer -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VLDR_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VLDR_Op_A_txt add d esize imm32 n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (word1 :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (word2 :: 32 bits) . 
   (CheckVFPEnabled True \<then>
   (if (((n = (( 15 :: int)::ii)))) then
      (PC_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (Align w__0 (( 4 :: int)::ii)  :: ( 32 Word.word) M)))
    else (R_read n  :: ( 32 Word.word) M))) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if add then (add_vec base imm32  ::  32 Word.word)
     else (sub_vec base imm32  ::  32 Word.word)) in
   (let l__285 = esize in
   if (((l__285 = (( 16 :: int)::ii)))) then
     (MemA_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
     S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__3  ::  32 Word.word))))
   else if (((l__285 = (( 32 :: int)::ii)))) then
     (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) .  S_set d w__4))
   else if (((l__285 = (( 64 :: int)::ii)))) then
     (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (word1 :: 32 bits) . 
     (MemA_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (word2 :: 32
       bits) . 
     BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__5 :: bool) . 
     (let (w__6 ::  64 Word.word) =
       (if w__5 then (concat_vec word1 word2  ::  64 Word.word)
       else (concat_vec word2 word1  ::  64 Word.word)) in
     D_set d w__6)))))))
   else return () )))))))))\<close> 
  for  "add"  :: " bool " 
  and  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLDR_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLDR_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLDR_A1enc_A_txt cond U D Rn Vd size1 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:27090.29-27090.30'') \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let esize = (shl_int (( 8 :: int)::ii) ((Word.uint size1))) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (imm32 :: 32 bits) =
       (if (((esize = (( 16 :: int)::ii)))) then (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  32 Word.word)
       else (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__0 = size1 in
     (let (d :: int) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b10 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b11 ::  2 Word.word)))) then Word.uint ((concat_vec D Vd  ::  5 Word.word))
       else d) in
     (let d = d in
     (let n = (Word.uint Rn) in
     execute_aarch32_instrs_VLDR_Op_A_txt add d esize imm32 n))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VLDR_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VLDR_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VLDR_T1enc_A_txt U D Rn Vd size1 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let esize = (shl_int (( 8 :: int)::ii) ((Word.uint size1))) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (imm32 :: 32 bits) =
       (if (((esize = (( 16 :: int)::ii)))) then (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  32 Word.word)
       else (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__0 = size1 in
     (let (d :: int) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b10 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b11 ::  2 Word.word)))) then Word.uint ((concat_vec D Vd  ::  5 Word.word))
       else d) in
     (let d = d in
     (let n = (Word.uint Rn) in
     execute_aarch32_instrs_VLDR_Op_A_txt add d esize imm32 n))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMAX_f_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMAX_f_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMAX_f_Op_A_txt d__arg elements esize m maximum n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2)
     ((\<lambda> r varstup .  (let (op1, op2) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2)
         ((\<lambda> e varstup .  (let (op1, op2) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = w__3 in
           (if maximum then
              (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
              (FPMax op1 op2 w__5  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
              (Elem_set w__4 e esize w__6  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
              D_set ((d + r)) w__7))))))))
            else
              (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
              (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
              (FPMin op1 op2 w__9  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__10 :: ( 'esize::len)Word.word) . 
              (Elem_set w__8 e esize w__10  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
              D_set ((d + r)) w__11))))))))) \<then>
           return (op1, op2))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ( 'esize::len)Word.word), (op2 :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "maximum"  :: " bool " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAX_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAX_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAX_f_A1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMAX_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       maximum n regs))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAX_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAX_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAX_f_T1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMAX_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       maximum n regs))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMAX_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMAX_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMAX_i_Op_A_txt d__arg elements esize m maximum n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
     ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
         ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = (asl_Int w__1 is_unsigned) in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = (asl_Int w__3 is_unsigned) in
           (let (result :: ii) = (if maximum then max_int op1 op2 else min_int op1 op2) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize
              ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (op1, op2, result)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ii), (op2 :: ii), (result :: ii)) = varstup in
   return () )))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "maximum"  :: " bool " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAX_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAX_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAX_i_A1enc_A_txt U D b__0 Vn Vd N Q M op1 Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         maximum n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         maximum n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n regs is_unsigned)))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAX_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAX_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAX_i_T1enc_A_txt U D b__0 Vn Vd N Q M op1 Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         maximum n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         maximum n regs is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMAX_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n regs is_unsigned)))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMLA_f_Op_A_txt : forall 'esize. Size 'esize => bool -> bool -> integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMLA_f_Op_A_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMLA_f_Op_A_txt add advsimd d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (addend :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (addend16 :: 16 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (addend32 :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (addend64 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (product :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (addend, product)
       ((\<lambda> r varstup .  (let (addend, product) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (addend, product)
           ((\<lambda> e varstup .  (let (addend, product) = varstup in
             (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
             (FPMul w__1 w__3 w__4  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
             (let product = w__5 in
             (if add then return product
              else (FPNeg product  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
             (let addend = w__7 in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
             (Elem_read w__9 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__10 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
             (FPAdd w__10 addend w__11  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__12 :: ( 'esize::len)Word.word) . 
             (Elem_set w__8 e esize w__12  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
             D_set ((d + r)) w__13 \<then> return (addend, product))))))))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((addend ::
       ( 'esize::len)Word.word), (product :: ( 'esize::len)Word.word)) = varstup in
     return () )))))
   else
     (let l__282 = esize in
     if (((l__282 = (( 16 :: int)::ii)))) then
       (if add then
          (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
          (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
          (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
          (FPMul ((subrange_vec_dec w__14 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
             ((subrange_vec_dec w__15 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__16
            :: ( 16 Word.word) M)))))))
        else
          (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
          (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
          (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
          (FPMul ((subrange_vec_dec w__18 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
             ((subrange_vec_dec w__19 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__20
            :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__21 ::  16 Word.word) . 
          (FPNeg w__21  :: ( 16 Word.word) M)))))))))) \<bind> ((\<lambda> (addend16 :: 16 bits) . 
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
       (FPAdd ((subrange_vec_dec w__23 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) addend16 w__24
         :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__25 ::  16 Word.word) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__25  ::  32 Word.word))))))))))
     else if (((l__282 = (( 32 :: int)::ii)))) then
       (if add then
          (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__26 ::  32 Word.word) . 
          (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__27 ::  32 Word.word) . 
          (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
          (FPMul w__26 w__27 w__28  :: ( 32 Word.word) M)))))))
        else
          (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__30 ::  32 Word.word) . 
          (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__31 ::  32 Word.word) . 
          (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
          (FPMul w__30 w__31 w__32  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__33 ::  32 Word.word) . 
          (FPNeg w__33  :: ( 32 Word.word) M)))))))))) \<bind> ((\<lambda> (addend32 :: 32 bits) . 
       (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__35 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
       (FPAdd w__35 addend32 w__36  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__37 ::  32 Word.word) .  S_set d w__37))))))))
     else if (((l__282 = (( 64 :: int)::ii)))) then
       (if add then
          (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__38 ::  64 Word.word) . 
          (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__39 ::  64 Word.word) . 
          (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__40 ::  64 Word.word) . 
          (FPMul w__38 w__39 w__40  :: ( 64 Word.word) M)))))))
        else
          (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__42 ::  64 Word.word) . 
          (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__43 ::  64 Word.word) . 
          (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__44 ::  64 Word.word) . 
          (FPMul w__42 w__43 w__44  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::  64 Word.word) . 
          (FPNeg w__45  :: ( 64 Word.word) M)))))))))) \<bind> ((\<lambda> (addend64 :: 64 bits) . 
       (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__47 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__48 ::  64 Word.word) . 
       (FPAdd w__47 addend64 w__48  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__49 ::  64 Word.word) .  D_set d w__49))))))))
     else return () )))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_f_A1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMLA_f_Op_A_txt add True d (( 4 :: int)::ii)
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_f_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_f_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_f_A2enc_A_txt cond D Vn Vd b__0 N op1 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:27498.29-27498.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       ((if (((True \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       (if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:27498.29-27498.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
          return (((((slice w__5 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
          return (((((slice w__6 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__7 ::
         bool) . 
       (if w__7 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:27498.29-27498.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
          return (((((slice w__9 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          return (((((slice w__10 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__11 ::
         bool) . 
       (if w__11 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs)))))))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   if w__12 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:27498.29-27498.30'') \<then>
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (((if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return (((((slice w__13 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
        return (((((slice w__14 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__15 ::
       bool) . 
     (if w__15 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_f_T1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMLA_f_Op_A_txt add True d (( 4 :: int)::ii)
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_f_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_f_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_f_T2enc_A_txt D Vn Vd b__0 N op1 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       and_boolM (return True) ((InITBlock () )) \<bind> ((\<lambda> (w__2 :: bool) . 
       ((if w__2 then throw (Error_Unpredictable () )
        else return () ) \<then>
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
          return (((((slice w__3 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
          return (((((slice w__4 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__5 ::
         bool) . 
       (if w__5 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
          return (((((slice w__7 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
          return (((((slice w__8 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__9 ::
         bool) . 
       (if w__9 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
          return (((((slice w__11 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return (((((slice w__12 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
         bool) . 
       (if w__13 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs)))))))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
   if w__14 then
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     ((if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__16 :: bool) . 
     ((if w__16 then throw (Error_Unpredictable () )
      else return () ) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
        return (((((slice w__17 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
        return (((((slice w__18 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__19 ::
       bool) . 
     (if w__19 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMLA_f_Op_A_txt add False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMLA_i_Op_A_txt : bool -> integer -> integer -> integer -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMLA_i_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMLA_i_Op_A_txt add d__arg elements l__279 long_destination m n regs is_unsigned = (
   if (((l__279 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (addend :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (product :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (addend, product)
       ((\<lambda> r varstup .  (let (addend, product) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (addend, product)
           ((\<lambda> e varstup .  (let (addend, product) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
             (let product = (((asl_Int w__1 is_unsigned)) * ((asl_Int w__3 is_unsigned))) in
             (let (addend :: ii) = (if add then product else - product) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__4 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
                (Elem_read w__5 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::  16 Word.word) . 
                (Elem_set w__4 e (( 16 :: int)::ii) ((add_vec_int w__6 addend  ::  16 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__7))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
                (Elem_read w__9 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__10 ::  8 Word.word) . 
                (Elem_set w__8 e (( 8 :: int)::ii) ((add_vec_int w__10 addend  ::  8 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::
                   64 Word.word) . 
                D_set ((d + r)) w__11))))))))) \<then>
             return (addend, product))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (product :: ii)) = varstup in
     return () )))))))))))
   else if (((l__279 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (addend :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (product :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (addend, product)
       ((\<lambda> r varstup .  (let (addend, product) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (addend, product)
           ((\<lambda> e varstup .  (let (addend, product) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
             (Elem_read w__12 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__13 ::  16 Word.word) . 
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
             (Elem_read w__14 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__15 ::  16 Word.word) . 
             (let product = (((asl_Int w__13 is_unsigned)) * ((asl_Int w__15 is_unsigned))) in
             (let (addend :: ii) = (if add then product else - product) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__16 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__17 ::  128 Word.word) . 
                (Elem_read w__17 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
                (Elem_set w__16 e (( 32 :: int)::ii) ((add_vec_int w__18 addend  ::  32 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__19))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
                (Elem_read w__21 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__22 ::  16 Word.word) . 
                (Elem_set w__20 e (( 16 :: int)::ii) ((add_vec_int w__22 addend  ::  16 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
                D_set ((d + r)) w__23))))))))) \<then>
             return (addend, product))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (product :: ii)) = varstup in
     return () )))))))))))
   else if (((l__279 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (addend :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (product :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (addend, product)
       ((\<lambda> r varstup .  (let (addend, product) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (addend, product)
           ((\<lambda> e varstup .  (let (addend, product) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
             (Elem_read w__24 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
             (Elem_read w__26 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__27 ::  32 Word.word) . 
             (let product = (((asl_Int w__25 is_unsigned)) * ((asl_Int w__27 is_unsigned))) in
             (let (addend :: ii) = (if add then product else - product) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__28 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__29 ::  128 Word.word) . 
                (Elem_read w__29 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
                (Elem_set w__28 e (( 64 :: int)::ii) ((add_vec_int w__30 addend  ::  64 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__31 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__31))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__33 ::  64 Word.word) . 
                (Elem_read w__33 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__34 ::  32 Word.word) . 
                (Elem_set w__32 e (( 32 :: int)::ii) ((add_vec_int w__34 addend  ::  32 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
                D_set ((d + r)) w__35))))))))) \<then>
             return (addend, product))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (product :: ii)) = varstup in
     return () )))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (addend :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (product :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (addend, product)
       ((\<lambda> r varstup .  (let (addend, product) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (addend, product)
           ((\<lambda> e varstup .  (let (addend, product) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
             (Elem_read w__36 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__37 ::  64 Word.word) . 
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__38 ::  64 Word.word) . 
             (Elem_read w__38 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__39 ::  64 Word.word) . 
             (let product = (((asl_Int w__37 is_unsigned)) * ((asl_Int w__39 is_unsigned))) in
             (let (addend :: ii) = (if add then product else - product) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__40 ::  128 Word.word) . 
                (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__41 ::  128 Word.word) . 
                (Elem_read w__41 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__42 ::  128 Word.word) . 
                (Elem_set w__40 e (( 128 :: int)::ii) ((add_vec_int w__42 addend  ::  128 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__43 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__43))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__44 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::  64 Word.word) . 
                (Elem_read w__45 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__46 ::  64 Word.word) . 
                (Elem_set w__44 e (( 64 :: int)::ii) ((add_vec_int w__46 addend  ::  64 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__47 ::  64 Word.word) . 
                D_set ((d + r)) w__47))))))))) \<then>
             return (addend, product))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (product :: ii)) = varstup in
     return () ))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__279"  :: " int " 
  and  "long_destination"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_i_A1enc_A_txt op1 D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n regs False))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n regs False))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n regs False))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_i_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_i_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_i_A2enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_i_T1enc_A_txt op1 D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n regs False))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n regs False))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n regs False))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_i_T2enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMLA_i_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n (( 1 :: int)::ii) is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMLA_s_Op_A_txt : bool -> integer -> integer -> integer -> bool -> integer -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMLA_s_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMLA_s_Op_A_txt add d__arg elements l__278 floating_point index1 long_destination m n regs is_unsigned = (
   if (((l__278 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (addend :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (fp_addend :: 16 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op1 :: 16 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (CheckAdvSIMDEnabled ()  \<then>
     (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (Elem_read w__0 index1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op2 :: 16 bits) . 
     (let op2val = (asl_Int op2 is_unsigned) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (addend, fp_addend, op1, op1val)
       ((\<lambda> r varstup .  (let (addend, fp_addend, op1, op1val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (addend, fp_addend, op1, op1val)
           ((\<lambda> e varstup .  (let (addend, fp_addend, op1, op1val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Elem_read w__1 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
             (let op1 = w__2 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (if floating_point then
                (if add then
                   (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
                   (FPMul op1 op2 w__3  :: ( 16 Word.word) M)))
                 else
                   (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
                   (FPMul op1 op2 w__5  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::  16 Word.word) . 
                   (FPNeg w__6  :: ( 16 Word.word) M)))))) \<bind> ((\<lambda> (w__8 ::  16 Word.word) . 
                (let fp_addend = w__8 in
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
                (Elem_read w__10 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
                (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
                (FPAdd w__11 fp_addend w__12  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__13 ::  16 Word.word) . 
                (Elem_set w__9 e (( 16 :: int)::ii) w__13  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
                D_set ((d + r)) w__14 \<then> return (addend, fp_addend))))))))))))))))
              else
                (let (addend :: ii) =
                  (if add then op1val * op2val
                  else ((- op1val)) * op2val) in
                (if long_destination then
                   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__15 ::  128 Word.word) . 
                   (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__16 ::  128 Word.word) . 
                   (Elem_read w__16 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
                   (Elem_set w__15 e (( 32 :: int)::ii) ((add_vec_int w__17 addend  ::  32 Word.word))
                     :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
                   Q_set ((shr_int d (( 1 :: int)::ii))) w__18))))))))
                 else
                   (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) . 
                   (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
                   (Elem_read w__20 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__21 ::  16 Word.word) . 
                   (Elem_set w__19 e (( 16 :: int)::ii) ((add_vec_int w__21 addend  ::  16 Word.word))
                     :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
                   D_set ((d + r)) w__22))))))))) \<then>
                return (addend, fp_addend))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (fp_addend ::
                16 Word.word)) = varstup in
             return (addend, fp_addend, op1, op1val)))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (fp_addend ::
        16 Word.word), (op1 ::  16 Word.word), (op1val :: ii)) = varstup in
     return () )))))))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 32 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (addend :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (fp_addend :: 32 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (CheckAdvSIMDEnabled ()  \<then>
     (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
     (Elem_read w__23 index1 (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op2 :: 32 bits) . 
     (let op2val = (asl_Int op2 is_unsigned) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (addend, fp_addend, op1, op1val)
       ((\<lambda> r varstup .  (let (addend, fp_addend, op1, op1val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (addend, fp_addend, op1, op1val)
           ((\<lambda> e varstup .  (let (addend, fp_addend, op1, op1val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
             (Elem_read w__24 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
             (let op1 = w__25 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (if floating_point then
                (if add then
                   (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
                   (FPMul op1 op2 w__26  :: ( 32 Word.word) M)))
                 else
                   (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
                   (FPMul op1 op2 w__28  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__29 ::  32 Word.word) . 
                   (FPNeg w__29  :: ( 32 Word.word) M)))))) \<bind> ((\<lambda> (w__31 ::  32 Word.word) . 
                (let fp_addend = w__31 in
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
                (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__33 ::  64 Word.word) . 
                (Elem_read w__33 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__34 ::  32 Word.word) . 
                (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
                (FPAdd w__34 fp_addend w__35  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__36 ::  32 Word.word) . 
                (Elem_set w__32 e (( 32 :: int)::ii) w__36  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__37 ::  64 Word.word) . 
                D_set ((d + r)) w__37 \<then> return (addend, fp_addend))))))))))))))))
              else
                (let (addend :: ii) =
                  (if add then op1val * op2val
                  else ((- op1val)) * op2val) in
                (if long_destination then
                   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__38 ::  128 Word.word) . 
                   (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__39 ::  128 Word.word) . 
                   (Elem_read w__39 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__40 ::  64 Word.word) . 
                   (Elem_set w__38 e (( 64 :: int)::ii) ((add_vec_int w__40 addend  ::  64 Word.word))
                     :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__41 ::  128 Word.word) . 
                   Q_set ((shr_int d (( 1 :: int)::ii))) w__41))))))))
                 else
                   (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__42 ::  64 Word.word) . 
                   (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__43 ::  64 Word.word) . 
                   (Elem_read w__43 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__44 ::  32 Word.word) . 
                   (Elem_set w__42 e (( 32 :: int)::ii) ((add_vec_int w__44 addend  ::  32 Word.word))
                     :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::  64 Word.word) . 
                   D_set ((d + r)) w__45))))))))) \<then>
                return (addend, fp_addend))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (fp_addend ::
                32 Word.word)) = varstup in
             return (addend, fp_addend, op1, op1val)))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((addend :: ii), (fp_addend ::
        32 Word.word), (op1 ::  32 Word.word), (op1val :: ii)) = varstup in
     return () ))))))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__278"  :: " int " 
  and  "floating_point"  :: " bool " 
  and  "index1"  :: " int " 
  and  "long_destination"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_s_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_s_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_s_A1enc_A_txt Q D b__0 Vn Vd op1 F N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:27933.72-27933.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) floating_point index1 False m n
         regs False))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:27933.72-27933.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) floating_point index1 False m n
         regs False))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_s_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_s_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_s_A2enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:27991.72-27991.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:27991.72-27991.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_s_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_s_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_s_T1enc_A_txt Q D b__0 Vn Vd op1 F N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:28054.72-28054.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) floating_point index1 False m n
         regs False))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:28054.72-28054.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) floating_point index1 False m n
         regs False))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMLA_s_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMLA_s_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMLA_s_T2enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:28112.72-28112.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:28112.72-28112.73'') \<then>
       execute_aarch32_instrs_VMLA_s_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOVX_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOVX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOVX_Op_A_txt d m = (
   (CheckVFPEnabled True \<then>
   (S_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   S_set d
     ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))
         ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOVX_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOVX_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOVX_A1enc_A_txt D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((\<not> ((HaveFP16Ext () )))) then throw (Error_Undefined () )
      else return () ) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VMOVX_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOVX_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOVX_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOVX_T1enc_A_txt D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((\<not> ((HaveFP16Ext () )))) then throw (Error_Undefined () )
      else return () )) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
        return (((((slice w__3 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__4 ::
       bool) . 
     (if w__4 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VMOVX_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VINS_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VINS_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VINS_Op_A_txt d m = (
   (CheckVFPEnabled True \<then>
   (S_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   S_set d
     ((concat_vec ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
         ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ::  32 Word.word)))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VINS_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VINS_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VINS_A1enc_A_txt D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((\<not> ((HaveFP16Ext () )))) then throw (Error_Undefined () )
      else return () ) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VINS_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VINS_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VINS_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VINS_T1enc_A_txt D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((\<not> ((HaveFP16Ext () )))) then throw (Error_Undefined () )
      else return () )) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
        return (((((slice w__3 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__4 ::
       bool) . 
     (if w__4 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VINS_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_d_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_d_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_d_Op_A_txt m t t2 to_arm_registers = (
   CheckVFPEnabled True \<then>
   (if to_arm_registers then
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (R_set t ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
     (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     R_set t2 ((subrange_vec_dec w__1 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))
   else
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     (D_set m ((update_subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii) w__3  ::  64 Word.word)) \<then>
     (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
     D_set m ((update_subrange_vec_dec w__4 (( 63 :: int)::ii) (( 32 :: int)::ii) w__5  ::  64 Word.word))))))))))))\<close> 
  for  "m"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int " 
  and  "to_arm_registers"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_d_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_d_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_d_A1enc_A_txt cond op1 Rt2 Rt M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:28279.29-28279.30'') \<then>
     ((let (to_arm_registers :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((to_arm_registers \<and> (((t = t2)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMOV_d_Op_A_txt m t t2 to_arm_registers)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_d_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_d_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_d_T1enc_A_txt op1 Rt2 Rt M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (to_arm_registers :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     ((if ((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((to_arm_registers \<and> (((t = t2)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMOV_d_Op_A_txt m t t2 to_arm_registers))))
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_i_Op_A_txt : bool -> integer -> mword ty32 -> mword ty64 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_i_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register = (
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if single_register then S_set d imm32
   else
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
       ((\<lambda> r unit_var .  D_set ((d + r)) imm64)))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "imm64"  :: "(64)Word.word " 
  and  "regs"  :: " int " 
  and  "single_register"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_A1enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_A2enc_A_txt cond D imm4H Vd size1 imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:28392.29-28392.30'') \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (single_register :: bool) = (size1 \<noteq> ( 0b11 ::  2 Word.word)) in
     (let (advsimd :: bool) = False in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (imm16 :: 16 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let (regs :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = size1 in
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
        (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
        (VFPExpandImm (( 16 :: int)::ii) ((concat_vec imm4H imm4L  ::  8 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (imm16 :: 16
          bits) . 
        (let (imm32 :: 32 bits) = ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) imm16  ::  32 Word.word)) in
        return (d, imm32, imm64, regs)))))
      else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
        (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
        (VFPExpandImm (( 32 :: int)::ii) ((concat_vec imm4H imm4L  ::  8 Word.word))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::
           32 Word.word) . 
        (let imm32 = w__4 in
        return (d, imm32, imm64, regs)))))
      else
        (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
           (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
           (VFPExpandImm (( 64 :: int)::ii) ((concat_vec imm4H imm4L  ::  8 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::
              64 Word.word) . 
           (let imm64 = w__5 in
           (let (regs :: int) = ((( 1 :: int)::ii)) in
           return (d, imm64, regs))))))
         else return (d, imm64, regs)) \<bind> ((\<lambda> varstup .  (let ((d :: int), (imm64 ::  64 Word.word), (regs ::
          int)) = varstup in
        return (d, imm32, imm64, regs))))) \<bind> ((\<lambda> varstup .  (let ((d :: int), (imm32 ::  32 Word.word), (imm64 ::
        64 Word.word), (regs :: int)) = varstup in
     (let regs = regs in
     (let d = d in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_A3enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_A3enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_A4enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_A4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_A4enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_A5enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_A5enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_A5enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_T1enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_T2enc_A_txt D imm4H Vd size1 imm4L = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
     (if w__5 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (single_register :: bool) = (size1 \<noteq> ( 0b11 ::  2 Word.word)) in
     (let (advsimd :: bool) = False in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (imm16 :: 16 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let (regs :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = size1 in
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
        (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
        (VFPExpandImm (( 16 :: int)::ii) ((concat_vec imm4H imm4L  ::  8 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (imm16 :: 16
          bits) . 
        (let (imm32 :: 32 bits) = ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) imm16  ::  32 Word.word)) in
        return (d, imm32, imm64, regs)))))
      else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
        (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
        (VFPExpandImm (( 32 :: int)::ii) ((concat_vec imm4H imm4L  ::  8 Word.word))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::
           32 Word.word) . 
        (let imm32 = w__6 in
        return (d, imm32, imm64, regs)))))
      else
        (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
           (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
           (VFPExpandImm (( 64 :: int)::ii) ((concat_vec imm4H imm4L  ::  8 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::
              64 Word.word) . 
           (let imm64 = w__7 in
           (let (regs :: int) = ((( 1 :: int)::ii)) in
           return (d, imm64, regs))))))
         else return (d, imm64, regs)) \<bind> ((\<lambda> varstup .  (let ((d :: int), (imm64 ::  64 Word.word), (regs ::
          int)) = varstup in
        return (d, imm32, imm64, regs))))) \<bind> ((\<lambda> varstup .  (let ((d :: int), (imm32 ::  32 Word.word), (imm64 ::
        64 Word.word), (regs :: int)) = varstup in
     (let regs = regs in
     (let d = d in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm4H"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "imm4L"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_T3enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_T3enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_T4enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_T4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_T4enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_i_T5enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_i_T5enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_i_T5enc_A_txt i D imm3 Vd cmode Q op1 imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (((if (((((((((op1 = ( 0b0 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VORR (immediate)''))
      else return () ) \<then>
     (if ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((cmode \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let imm32 = imm32 in
     (let (single_register :: bool) = False in
     (let (advsimd :: bool) = True in
     (AdvSIMDExpandImm op1 cmode ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))))))))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOVL_Op_A_txt : integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOVL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOVL_Op_A_txt d__arg elements l__271 m is_unsigned = (
   if (((l__271 = (( 0 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
       ((\<lambda> e unit_var . 
         assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 0 :: int)::ii))))) \<and> ((((((id0 e)) * (( 0 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 0 :: int)::ii))) + (( 0 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 0 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         exit0 () )))))))))
   else if (((l__271 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 8 :: int)::ii))))) \<and> ((((((id0 e)) * (( 8 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 8 :: int)::ii))) + (( 8 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 8 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
         (Elem_read w__0 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
         (let result = (asl_Int w__1 is_unsigned) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::  128 Word.word) . 
         (Elem_set w__2 e (( 16 :: int)::ii) ((integer_subrange result (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__3 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__3 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__271 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 16 :: int)::ii))))) \<and> ((((((id0 e)) * (( 16 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 16 :: int)::ii))) + (( 16 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 16 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_read w__4 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
         (let result = (asl_Int w__5 is_unsigned) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_set w__6 e (( 32 :: int)::ii) ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__7 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__271 = (( 24 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 24 :: int)::ii))))) \<and> ((((((id0 e)) * (( 24 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 24 :: int)::ii))) + (( 24 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 24 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
         (Elem_read w__8 e (( 24 :: int)::ii)  :: ( 24 Word.word) M) \<bind> ((\<lambda> (w__9 ::  24 Word.word) . 
         (let result = (asl_Int w__9 is_unsigned) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__10 ::  128 Word.word) . 
         (Elem_set w__10 e (( 48 :: int)::ii) ((integer_subrange result (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__11 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__11 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__271 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 32 :: int)::ii))))) \<and> ((((((id0 e)) * (( 32 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 32 :: int)::ii))) + (( 32 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 32 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
         (Elem_read w__12 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
         (let result = (asl_Int w__13 is_unsigned) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_set w__14 e (( 64 :: int)::ii) ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__15 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__15 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__271 = (( 40 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 40 :: int)::ii))))) \<and> ((((((id0 e)) * (( 40 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 40 :: int)::ii))) + (( 40 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 40 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
         (Elem_read w__16 e (( 40 :: int)::ii)  :: ( 40 Word.word) M) \<bind> ((\<lambda> (w__17 ::  40 Word.word) . 
         (let result = (asl_Int w__17 is_unsigned) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
         (Elem_set w__18 e (( 80 :: int)::ii) ((integer_subrange result (( 79 :: int)::ii) (( 0 :: int)::ii)  ::  80 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__19 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__271 = (( 48 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 48 :: int)::ii))))) \<and> ((((((id0 e)) * (( 48 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 48 :: int)::ii))) + (( 48 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 48 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
         (Elem_read w__20 e (( 48 :: int)::ii)  :: ( 48 Word.word) M) \<bind> ((\<lambda> (w__21 ::  48 Word.word) . 
         (let result = (asl_Int w__21 is_unsigned) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__22 ::  128 Word.word) . 
         (Elem_set w__22 e (( 96 :: int)::ii) ((integer_subrange result (( 95 :: int)::ii) (( 0 :: int)::ii)  ::  96 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__23 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__23 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 56 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (assert_exp (((((((((( 0 :: int)::ii) \<le> ((((id0 e)) * (( 56 :: int)::ii))))) \<and> ((((((id0 e)) * (( 56 :: int)::ii))) \<le>
                                ((((((((id0 e)) * (( 56 :: int)::ii))) + (( 56 :: int)::ii)))
                                    - (( 1 :: int)::ii)))))))) \<or> ((\<not> (((((((id0 e)) \<ge> (( 0 :: int)::ii))) \<and> ((((((((id0 e)) + (( 1 :: int)::ii))) * (( 56 :: int)::ii))) \<le>
                                    (( 64 :: int)::ii))))))))))) (''src/instrs32.sail:28781.155-28781.156'') \<then>
         (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
         (Elem_read w__24 e (( 56 :: int)::ii)  :: ( 56 Word.word) M) \<bind> ((\<lambda> (w__25 ::  56 Word.word) . 
         (let result = (asl_Int w__25 is_unsigned) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__26 ::  128 Word.word) . 
         (Elem_set w__26 e (( 112 :: int)::ii) ((integer_subrange result (( 111 :: int)::ii) (( 0 :: int)::ii)  ::  112 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__27 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__27 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__271"  :: " int " 
  and  "m"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOVL_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOVL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOVL_A1enc_A_txt U D b__0 Vd M Vm = (
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_See (''Related encodings''))
     else return () ))
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if (((((((((( 0b001 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b001 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b001 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 8 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 8 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((((((((( 0b010 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b010 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b010 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 16 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       ((if (((((((((( 0b011 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b011 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b011 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 24 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 24 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       ((if (((((((((( 0b100 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b100 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b100 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 32 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
     if w__5 then
       ((if (((((((((( 0b101 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b101 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b101 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 40 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 40 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       ((if (((((((((( 0b110 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b110 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b110 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 48 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 48 :: int)::ii) m is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__7 :: bool) . 
   if w__7 then
     ((if (((((((((( 0b111 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b111 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b111 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
        throw (Error_See (''VSHLL''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let elements = ((( 64 :: int)::ii) div (( 56 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 56 :: int)::ii) m is_unsigned)))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOVL_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOVL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOVL_T1enc_A_txt U D b__0 Vd L M Vm = (
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_See (''Related encodings''))
     else return () ))
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if (((((((((( 0b001 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b001 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b001 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 8 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 8 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((((((((( 0b010 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b010 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b010 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 16 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       ((if (((((((((( 0b011 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b011 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b011 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 24 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 24 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       ((if (((((((((( 0b100 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b100 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b100 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 32 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
     if w__5 then
       ((if (((((((((( 0b101 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b101 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b101 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 40 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 40 :: int)::ii) m is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       ((if (((((((((( 0b110 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b110 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b110 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
          throw (Error_See (''VSHLL''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let elements = ((( 64 :: int)::ii) div (( 48 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 48 :: int)::ii) m is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__7 :: bool) . 
   if w__7 then
     ((if (((((((((( 0b111 ::  3 Word.word) \<noteq> ( 0b001 ::  3 Word.word)))) \<and> (((( 0b111 ::  3 Word.word) \<noteq> ( 0b010 ::  3 Word.word))))))) \<and> (((( 0b111 ::  3 Word.word) \<noteq> ( 0b100 ::  3 Word.word))))))) then
        throw (Error_See (''VSHLL''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let elements = ((( 64 :: int)::ii) div (( 56 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VMOVL_Op_A_txt d elements (( 56 :: int)::ii) m is_unsigned)))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOVN_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOVN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOVN_Op_A_txt d__arg elements l__268 m = (
   if (((l__268 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
       ((\<lambda> e unit_var . 
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__1 ::  128 Word.word) . 
         (Elem_read w__1 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
         (Elem_set w__0 e (( 8 :: int)::ii) ((subrange_vec_dec w__2 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         D_set d w__3)))))))))))))))
   else if (((l__268 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
       ((\<lambda> e unit_var . 
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
         (Elem_read w__5 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
         (Elem_set w__4 e (( 16 :: int)::ii) ((subrange_vec_dec w__6 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
         D_set d w__7)))))))))))))))
   else if (((l__268 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
       ((\<lambda> e unit_var . 
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__9 ::  128 Word.word) . 
         (Elem_read w__9 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (Elem_set w__8 e (( 32 :: int)::ii) ((subrange_vec_dec w__10 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11)))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
       ((\<lambda> e unit_var . 
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__13 ::  128 Word.word) . 
         (Elem_read w__13 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_set w__12 e (( 64 :: int)::ii) ((subrange_vec_dec w__14 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         D_set d w__15))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__268"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOVN_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOVN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOVN_A1enc_A_txt D b__0 Vd M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m)))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m)))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m)))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOVN_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOVN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOVN_T1enc_A_txt D b__0 Vd M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m)))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m)))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMOVN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m)))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_h_Op_A_txt : integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_h_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_h_Op_A_txt n t to_arm_register = (
   CheckVFPEnabled True \<then>
   (if to_arm_register then
     (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     R_set t
       ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))
           ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ::  32 Word.word))))
   else
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     S_set n
       ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))
           ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ::  32 Word.word))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "to_arm_register"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_h_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_h_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_h_A1enc_A_txt cond op1 Vn Rt N = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:28943.29-28943.30'') \<then>
     (if ((\<not> ((HaveFP16Ext () )))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (to_arm_register :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VMOV_h_Op_A_txt n t to_arm_register))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_h_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_h_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_h_T1enc_A_txt op1 Vn Rt N = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((\<not> ((HaveFP16Ext () )))) then throw (Error_Undefined () )
      else return () ) \<then>
     InITBlock () ) \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (to_arm_register :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VMOV_h_Op_A_txt n t to_arm_register))))))
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_r_Op_A_txt : bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_r_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_r_Op_A_txt advsimd d m regs single_register = (
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if single_register then (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  S_set d w__0))
   else
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
       ((\<lambda> r unit_var . 
         (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
         D_set ((d + r)) w__1)))))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "single_register"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_r_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_r_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_r_A2enc_A_txt cond D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29028.29-29028.30'') \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (single_register :: bool) = (size1 = ( 0b10 ::  2 Word.word)) in
     (let (advsimd :: bool) = False in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (regs :: int) = ((( 1 :: int)::ii)) in
     (let ((d :: int), (m :: int), (regs :: int)) =
       (if single_register then
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, m, regs)))
       else
         (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
         (let (regs :: int) = ((( 1 :: int)::ii)) in
         (d, m, regs))))) in
     (let regs = regs in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMOV_r_Op_A_txt advsimd d m regs single_register))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_r_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_r_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_r_T2enc_A_txt D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (single_register :: bool) = (size1 = ( 0b10 ::  2 Word.word)) in
     (let (advsimd :: bool) = False in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (regs :: int) = ((( 1 :: int)::ii)) in
     (let ((d :: int), (m :: int), (regs :: int)) =
       (if single_register then
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, m, regs)))
       else
         (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
         (let (regs :: int) = ((( 1 :: int)::ii)) in
         (d, m, regs))))) in
     (let regs = regs in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMOV_r_Op_A_txt advsimd d m regs single_register))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_rs_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_rs_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d__arg esize index1 t = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (D_read d  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (Elem_set w__0 index1 esize
      ((subrange_vec_dec w__1 ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
     :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   D_set d w__2)))))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_rs_A1enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty2 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_rs_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_rs_A1enc_A_txt cond opc1 Vd Rt D opc2 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29116.29-29116.30'') \<then>
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (advsimd :: bool) . 
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let b__0 = ((concat_vec opc1 opc2  ::  4 Word.word)) in
     (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 8 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word) opc2  ::  3 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
      then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 16 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)
                (vec_of_bits [access_vec_dec opc2 (( 1 :: int)::ii)]  ::  1 Word.word)
               ::  2 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
      then
        (let (advsimd :: bool) = False in
        (let (esize :: int) = ((( 32 :: int)::ii)) in
        (let (index1 :: ii) = (Word.uint (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)) in
        return (advsimd, esize, index1))))
      else throw (Error_Undefined () )) \<bind> ((\<lambda> varstup .  (let ((advsimd :: bool), (esize :: int), (index1 ::
       ii)) = varstup in
     (let advsimd = advsimd in
     (let index1 = index1 in
     (let esize = esize in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let t = (Word.uint Rt) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let l__265 = esize in
     if (((l__265 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         index1 t
     else if (((l__265 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 t
     else if (((l__265 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 t
     else assert_exp False (''src/instrs32.sail:29159.26-29159.27'') \<then> exit0 () ))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "opc1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "opc2"  :: "(2)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_rs_T1enc_A_txt : mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty2 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_rs_T1enc_A_txt  :: \<open>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_rs_T1enc_A_txt opc1 Vd Rt D opc2 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (advsimd :: bool) . 
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let b__0 = ((concat_vec opc1 opc2  ::  4 Word.word)) in
     (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 8 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word) opc2  ::  3 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
      then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 16 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)
                (vec_of_bits [access_vec_dec opc2 (( 1 :: int)::ii)]  ::  1 Word.word)
               ::  2 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
      then
        (let (advsimd :: bool) = False in
        (let (esize :: int) = ((( 32 :: int)::ii)) in
        (let (index1 :: ii) = (Word.uint (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)) in
        return (advsimd, esize, index1))))
      else throw (Error_Undefined () )) \<bind> ((\<lambda> varstup .  (let ((advsimd :: bool), (esize :: int), (index1 ::
       ii)) = varstup in
     (let advsimd = advsimd in
     (let index1 = index1 in
     (let esize = esize in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let t = (Word.uint Rt) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let l__262 = esize in
     if (((l__262 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         index1 t
     else if (((l__262 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 t
     else if (((l__262 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 t
     else assert_exp False (''src/instrs32.sail:29227.26-29227.27'') \<then> exit0 () ))))))))))))))))
   else return () )))\<close> 
  for  "opc1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "opc2"  :: "(2)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_s_Op_A_txt : integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_s_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_s_Op_A_txt n t to_arm_register = (
   CheckVFPEnabled True \<then>
   (if to_arm_register then (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  R_set t w__0))
   else (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) .  S_set n w__1))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "to_arm_register"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_s_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_s_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_s_A1enc_A_txt cond op1 Vn Rt N = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29265.29-29265.30'') \<then>
     ((let (to_arm_register :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VMOV_s_Op_A_txt n t to_arm_register))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_s_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_s_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_s_T1enc_A_txt op1 Vn Rt N = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (to_arm_register :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VMOV_s_Op_A_txt n t to_arm_register)))
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_sr_Op_A_txt : forall 'esize. Size 'esize => bool -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_sr_Op_A_txt  :: \<open> bool \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd esize index1 n t is_unsigned = (
   (let esize = (size_itself_int esize) in
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if is_unsigned then
     (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (Elem_read w__0 index1 esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
     R_set t ((zero_extend w__1 (( 32 :: int)::ii)  ::  32 Word.word))))))
   else
     (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (Elem_read w__2 index1 esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
     R_set t ((sign_extend w__3 (( 32 :: int)::ii)  ::  32 Word.word)))))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_sr_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty2 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_sr_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_sr_A1enc_A_txt cond U opc1 Vn Rt N opc2 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29336.29-29336.30'') \<then>
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (advsimd :: bool) . 
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let b__0 = ((concat_vec ((concat_vec U opc1  ::  3 Word.word)) opc2  ::  5 Word.word)) in
     (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 8 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word) opc2  ::  3 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
      then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 16 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)
                (vec_of_bits [access_vec_dec opc2 (( 1 :: int)::ii)]  ::  1 Word.word)
               ::  2 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
      then
        (let (advsimd :: bool) = False in
        (let (esize :: int) = ((( 32 :: int)::ii)) in
        (let (index1 :: ii) = (Word.uint (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)) in
        return (advsimd, esize, index1))))
      else
        (if ((((((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
         then
           throw (Error_Undefined () )
         else throw (Error_Undefined () )) \<then>
        return (advsimd, esize, index1)) \<bind> ((\<lambda> varstup .  (let ((advsimd :: bool), (esize :: int), (index1 ::
       ii)) = varstup in
     (let advsimd = advsimd in
     (let index1 = index1 in
     (let esize = esize in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let l__259 = esize in
     if (((l__259 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1
         n t is_unsigned
     else if (((l__259 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 n t is_unsigned
     else if (((l__259 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 n t is_unsigned
     else assert_exp False (''src/instrs32.sail:29383.26-29383.27'') \<then> exit0 () )))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "opc1"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "opc2"  :: "(2)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_sr_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty2 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_sr_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_sr_T1enc_A_txt U opc1 Vn Rt N opc2 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (advsimd :: bool) . 
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let b__0 = ((concat_vec ((concat_vec U opc1  ::  3 Word.word)) opc2  ::  5 Word.word)) in
     (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 8 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word) opc2  ::  3 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
      then
        (let (advsimd :: bool) = True in
        (let (esize :: int) = ((( 16 :: int)::ii)) in
        (let (index1 :: ii) =
          (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)
                (vec_of_bits [access_vec_dec opc2 (( 1 :: int)::ii)]  ::  1 Word.word)
               ::  2 Word.word))) in
        return (advsimd, esize, index1))))
      else if ((((((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
      then
        (let (advsimd :: bool) = False in
        (let (esize :: int) = ((( 32 :: int)::ii)) in
        (let (index1 :: ii) = (Word.uint (vec_of_bits [access_vec_dec opc1 (( 0 :: int)::ii)]  ::  1 Word.word)) in
        return (advsimd, esize, index1))))
      else
        (if ((((((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec b__0 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
         then
           throw (Error_Undefined () )
         else throw (Error_Undefined () )) \<then>
        return (advsimd, esize, index1)) \<bind> ((\<lambda> varstup .  (let ((advsimd :: bool), (esize :: int), (index1 ::
       ii)) = varstup in
     (let advsimd = advsimd in
     (let index1 = index1 in
     (let esize = esize in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let l__256 = esize in
     if (((l__256 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1
         n t is_unsigned
     else if (((l__256 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 n t is_unsigned
     else if (((l__256 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 n t is_unsigned
     else assert_exp False (''src/instrs32.sail:29456.26-29456.27'') \<then> exit0 () )))))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "opc1"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "opc2"  :: "(2)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMOV_ss_Op_A_txt : integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMOV_ss_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMOV_ss_Op_A_txt m t t2 to_arm_registers = (
   CheckVFPEnabled True \<then>
   (if to_arm_registers then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (R_set t w__0 \<then>
     (S_read ((m + (( 1 :: int)::ii)))  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  32 Word.word) .  R_set t2 w__1))))
   else
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
     (S_set m w__2 \<then>
     (R_read t2  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  32 Word.word) .  S_set ((m + (( 1 :: int)::ii))) w__3))))))\<close> 
  for  "m"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int " 
  and  "to_arm_registers"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_ss_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_ss_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_ss_A1enc_A_txt cond op1 Rt2 Rt M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29497.29-29497.30'') \<then>
     ((let (to_arm_registers :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     ((if (((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((m = (( 31 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((to_arm_registers \<and> (((t = t2)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMOV_ss_Op_A_txt m t t2 to_arm_registers)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMOV_ss_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMOV_ss_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMOV_ss_T1enc_A_txt op1 Rt2 Rt M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (to_arm_registers :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     ((if (((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((m = (( 31 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((to_arm_registers \<and> (((t = t2)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMOV_ss_Op_A_txt m t t2 to_arm_registers))))
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMUL_f_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMUL_f_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMUL_f_Op_A_txt advsimd d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
       ((\<lambda> r unit_var . 
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
           ((\<lambda> e unit_var . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
             (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             (FPMul w__2 w__4 w__5  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
             (Elem_set w__0 e esize w__6  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
             D_set ((d + r)) w__7))))))))))))))))))))))))))
   else
     (let l__253 = esize in
     if (((l__253 = (( 16 :: int)::ii)))) then
       (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
       (FPMul ((subrange_vec_dec w__8 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ((subrange_vec_dec w__9 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__10
         :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__11  ::  32 Word.word))))))))))
     else if (((l__253 = (( 32 :: int)::ii)))) then
       (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
       (FPMul w__12 w__13 w__14  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) .  S_set d w__15))))))))
     else if (((l__253 = (( 64 :: int)::ii)))) then
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
       (FPMul w__16 w__17 w__18  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) .  D_set d w__19))))))))
     else return () )))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_f_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_f_Op_A_txt True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMUL_f_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_f_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_f_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_f_A2enc_A_txt cond D Vn Vd b__0 N M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29633.29-29633.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       (if (((True \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29633.29-29633.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
          return (((((slice w__5 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
          return (((((slice w__6 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__7 ::
         bool) . 
       (if w__7 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29633.29-29633.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
          return (((((slice w__9 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          return (((((slice w__10 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__11 ::
         bool) . 
       (if w__11 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs))))))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   if w__12 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:29633.29-29633.30'') \<then>
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return (((((slice w__13 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
        return (((((slice w__14 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__15 ::
       bool) . 
     (((if w__15 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs))))))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_f_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_f_Op_A_txt True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 :: bool) . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMUL_f_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n regs)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_f_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_f_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_f_T2enc_A_txt D Vn Vd b__0 N M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       and_boolM (return True) ((InITBlock () )) \<bind> ((\<lambda> (w__2 :: bool) . 
       ((if w__2 then throw (Error_Unpredictable () )
        else return () ) \<then>
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
          return (((((slice w__3 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
          return (((((slice w__4 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__5 ::
         bool) . 
       (if w__5 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs))))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
          return (((((slice w__7 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
          return (((((slice w__8 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__9 ::
         bool) . 
       (if w__9 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs))))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
          return (((((slice w__11 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return (((((slice w__12 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
         bool) . 
       (if w__13 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs))))))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
   if w__14 then
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () )) \<bind> ((\<lambda> (w__16 :: bool) . 
     ((if w__16 then throw (Error_Unpredictable () )
      else return () ) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
        return (((((slice w__17 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
        return (((((slice w__18 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__19 ::
       bool) . 
     ((if w__19 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMUL_f_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs))))))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMUL_i_Op_A_txt : integer -> integer -> integer -> bool -> integer -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMUL_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMUL_i_Op_A_txt d__arg elements l__250 long_destination m n polynomial regs is_unsigned = (
   if (((l__250 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op1 :: 8 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op2 :: 8 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2val :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
       ((\<lambda> r varstup .  (let (op1, op1val, op2, op2val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
           ((\<lambda> e varstup .  (let (op1, op1val, op2, op2val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
             (let op1 = w__1 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
             (let op2 = w__3 in
             (let (op2val :: ii) = (asl_Int op2 is_unsigned) in
             (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (product :: 16 bits) . 
             (let (product ::  16 Word.word) =
               (if polynomial then (PolynomialMult op1 op2  ::  16 Word.word)
               else (integer_subrange ((op1val * op2val)) (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__4 ::  128 Word.word) . 
                (Elem_set w__4 e (( 16 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__5))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
                (Elem_set w__6 e (( 8 :: int)::ii) ((subrange_vec_dec product (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
                D_set ((d + r)) w__7))))) \<then>
             return (op1, op1val, op2, op2val)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::  8 Word.word), (op1val ::
       ii), (op2 ::  8 Word.word), (op2val :: ii)) = varstup in
     return () )))))))))))))))
   else if (((l__250 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op1 :: 16 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op2 :: 16 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2val :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
       ((\<lambda> r varstup .  (let (op1, op1val, op2, op2val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
           ((\<lambda> e varstup .  (let (op1, op1val, op2, op2val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
             (Elem_read w__8 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__9 ::  16 Word.word) . 
             (let op1 = w__9 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
             (Elem_read w__10 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
             (let op2 = w__11 in
             (let (op2val :: ii) = (asl_Int op2 is_unsigned) in
             (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (product :: 32 bits) . 
             (let (product ::  32 Word.word) =
               (if polynomial then (PolynomialMult op1 op2  ::  32 Word.word)
               else (integer_subrange ((op1val * op2val)) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
                (Elem_set w__12 e (( 32 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__13 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__13))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
                (Elem_set w__14 e (( 16 :: int)::ii) ((subrange_vec_dec product (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
                D_set ((d + r)) w__15))))) \<then>
             return (op1, op1val, op2, op2val)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::  16 Word.word), (op1val ::
       ii), (op2 ::  16 Word.word), (op2val :: ii)) = varstup in
     return () )))))))))))))))
   else if (((l__250 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op2 :: 32 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2val :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
       ((\<lambda> r varstup .  (let (op1, op1val, op2, op2val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
           ((\<lambda> e varstup .  (let (op1, op1val, op2, op2val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
             (Elem_read w__16 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
             (let op1 = w__17 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
             (Elem_read w__18 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
             (let op2 = w__19 in
             (let (op2val :: ii) = (asl_Int op2 is_unsigned) in
             (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (product :: 64 bits) . 
             (let (product ::  64 Word.word) =
               (if polynomial then (PolynomialMult op1 op2  ::  64 Word.word)
               else (integer_subrange ((op1val * op2val)) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__20 ::  128 Word.word) . 
                (Elem_set w__20 e (( 64 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__21))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
                (Elem_set w__22 e (( 32 :: int)::ii) ((subrange_vec_dec product (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
                D_set ((d + r)) w__23))))) \<then>
             return (op1, op1val, op2, op2val)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::  32 Word.word), (op1val ::
       ii), (op2 ::  32 Word.word), (op2val :: ii)) = varstup in
     return () )))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op1 :: 64 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op2 :: 64 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2val :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
       ((\<lambda> r varstup .  (let (op1, op1val, op2, op2val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op1val, op2, op2val)
           ((\<lambda> e varstup .  (let (op1, op1val, op2, op2val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
             (Elem_read w__24 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__25 ::  64 Word.word) . 
             (let op1 = w__25 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
             (Elem_read w__26 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
             (let op2 = w__27 in
             (let (op2val :: ii) = (asl_Int op2 is_unsigned) in
             (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (product :: 128 bits) . 
             (let (product ::  128 Word.word) =
               (if polynomial then (PolynomialMult op1 op2  ::  128 Word.word)
               else (integer_subrange ((op1val * op2val)) (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word)) in
             (if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__28 ::  128 Word.word) . 
                (Elem_set w__28 e (( 128 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__29 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__29))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
                (Elem_set w__30 e (( 64 :: int)::ii) ((subrange_vec_dec product (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
                D_set ((d + r)) w__31))))) \<then>
             return (op1, op1val, op2, op2val)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::  64 Word.word), (op1val ::
       ii), (op2 ::  64 Word.word), (op2val :: ii)) = varstup in
     return () ))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__250"  :: " int " 
  and  "long_destination"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "polynomial"  :: " bool " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_i_A1enc_A_txt op1 D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if (((False \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((( 0b00 ::  2 Word.word) \<noteq> ( 0b00 ::  2 Word.word)))))))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (polynomial :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n polynomial regs False))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if (((False \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((( 0b01 ::  2 Word.word) \<noteq> ( 0b00 ::  2 Word.word)))))))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (polynomial :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n polynomial regs False))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((False \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((( 0b10 ::  2 Word.word) \<noteq> ( 0b00 ::  2 Word.word)))))))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (polynomial :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n polynomial regs False))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_i_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_i_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_i_A2enc_A_txt U D b__0 Vn Vd b__1 N M Vm = (
   if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: ii) = ((( 8 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n False (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: ii) = ((( 8 :: int)::ii)) in
       ((if ((((((U = ( 0b1 ::  1 Word.word)))) \<or> False))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n True (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n False (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       throw (Error_Undefined () ))))
     else return () ))
   else if ((((((b__0 = ( 0b10 ::  2 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n False (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
     if w__5 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       ((if ((((((U = ( 0b1 ::  1 Word.word)))) \<or> False))) then throw (Error_Undefined () )
        else return () ) \<then>
       HaveBit128PMULLExt () ) \<bind> ((\<lambda> (w__6 :: bool) . 
       (if ((\<not> w__6)) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (elements :: ii) = ((( 1 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 1 :: int)::ii) (( 64 :: int)::ii) True m n True (( 1 :: int)::ii) is_unsigned))))))))))))
     else return () ))
   else if (((b__1 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__7 :: bool) . 
     if w__7 then throw (Error_See (''Related encodings''))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
   if w__8 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_i_T1enc_A_txt op1 D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if (((False \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((( 0b00 ::  2 Word.word) \<noteq> ( 0b00 ::  2 Word.word)))))))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (polynomial :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) False m n polynomial regs False))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if (((False \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((( 0b01 ::  2 Word.word) \<noteq> ( 0b00 ::  2 Word.word)))))))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (polynomial :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False m n polynomial regs False))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((False \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> (((( 0b10 ::  2 Word.word) \<noteq> ( 0b00 ::  2 Word.word)))))))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (polynomial :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False m n polynomial regs False))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_i_T2enc_A_txt U D b__0 Vn Vd b__1 N M Vm = (
   if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: ii) = ((( 8 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n False (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: ii) = ((( 8 :: int)::ii)) in
       ((if ((((((U = ( 0b1 ::  1 Word.word)))) \<or> False))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) True m n True (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) True m n False (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       throw (Error_Undefined () ))))
     else return () ))
   else if ((((((b__0 = ( 0b10 ::  2 Word.word)))) \<and> (((b__1 = ( 0b0 ::  1 Word.word))))))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) True m n False (( 1 :: int)::ii) is_unsigned)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
     if w__5 then
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       ((if ((((((U = ( 0b1 ::  1 Word.word)))) \<or> False))) then throw (Error_Undefined () )
        else return () ) \<then>
       InITBlock () ) \<bind> ((\<lambda> (w__6 :: bool) . 
       ((if w__6 then throw (Error_Unpredictable () )
        else return () ) \<then>
       HaveBit128PMULLExt () ) \<bind> ((\<lambda> (w__7 :: bool) . 
       (if ((\<not> w__7)) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (elements :: ii) = ((( 1 :: int)::ii)) in
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VMUL_i_Op_A_txt d (( 1 :: int)::ii) (( 64 :: int)::ii) True m n True (( 1 :: int)::ii) is_unsigned))))))))))))))
     else return () ))
   else if (((b__1 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then throw (Error_See (''Related encodings''))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__9 :: bool) . 
   if w__9 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMUL_s_Op_A_txt : integer -> integer -> integer -> bool -> integer -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMUL_s_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMUL_s_Op_A_txt d__arg elements l__249 floating_point index1 long_destination m n regs is_unsigned = (
   if (((l__249 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op1 :: 16 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (CheckAdvSIMDEnabled ()  \<then>
     (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (Elem_read w__0 index1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op2 :: 16 bits) . 
     (let op2val = (asl_Int op2 is_unsigned) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op1val)
       ((\<lambda> r varstup .  (let (op1, op1val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op1val)
           ((\<lambda> e varstup .  (let (op1, op1val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Elem_read w__1 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
             (let op1 = w__2 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (if floating_point then
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
                (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
                (FPMul op1 op2 w__4  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
                (Elem_set w__3 e (( 16 :: int)::ii) w__5  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
                D_set ((d + r)) w__6))))))))
              else if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
                (Elem_set w__7 e (( 32 :: int)::ii)
                   ((integer_subrange ((op1val * op2val)) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__8))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
                (Elem_set w__9 e (( 16 :: int)::ii)
                   ((integer_subrange ((op1val * op2val)) (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
                D_set ((d + r)) w__10))))) \<then>
             return (op1, op1val))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::  16 Word.word), (op1val :: ii)) = varstup in
     return () )))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 32 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1val :: ii) . 
     (CheckAdvSIMDEnabled ()  \<then>
     (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
     (Elem_read w__11 index1 (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op2 :: 32 bits) . 
     (let op2val = (asl_Int op2 is_unsigned) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op1val)
       ((\<lambda> r varstup .  (let (op1, op1val) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op1val)
           ((\<lambda> e varstup .  (let (op1, op1val) = varstup in
             (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
             (Elem_read w__12 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
             (let op1 = w__13 in
             (let (op1val :: ii) = (asl_Int op1 is_unsigned) in
             (if floating_point then
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
                (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
                (FPMul op1 op2 w__15  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
                (Elem_set w__14 e (( 32 :: int)::ii) w__16  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
                D_set ((d + r)) w__17))))))))
              else if long_destination then
                (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
                (Elem_set w__18 e (( 64 :: int)::ii)
                   ((integer_subrange ((op1val * op2val)) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
                  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
                Q_set ((shr_int d (( 1 :: int)::ii))) w__19))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
                (Elem_set w__20 e (( 32 :: int)::ii)
                   ((integer_subrange ((op1val * op2val)) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
                D_set ((d + r)) w__21))))) \<then>
             return (op1, op1val))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::  32 Word.word), (op1val :: ii)) = varstup in
     return () ))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__249"  :: " int " 
  and  "floating_point"  :: " bool " 
  and  "index1"  :: " int " 
  and  "long_destination"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_s_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_s_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_s_A1enc_A_txt Q D b__0 Vn Vd F N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30097.72-30097.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) floating_point index1 False m n regs
         False)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30097.72-30097.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) floating_point index1 False m n regs
         False)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_s_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_s_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_s_A2enc_A_txt U D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30153.72-30153.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30153.72-30153.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_s_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_s_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_s_T1enc_A_txt Q D b__0 Vn Vd F N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30214.72-30214.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) floating_point index1 False m n regs
         False)))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30214.72-30214.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) floating_point index1 False m n regs
         False)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMUL_s_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMUL_s_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMUL_s_T2enc_A_txt U D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30270.72-30270.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))) (''src/instrs32.sail:30270.72-30270.73'') \<then>
       execute_aarch32_instrs_VMUL_s_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) False index1 True m n (( 1 :: int)::ii)
         is_unsigned))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMVN_i_Op_A_txt : integer -> mword ty64 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMVN_i_Op_A_txt  :: \<open> int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var .  D_set ((d + r)) ((not_vec imm64  ::  64 Word.word)))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm64"  :: "(64)Word.word " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_i_A1enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((((((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_i_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_i_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_i_A2enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((((((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_i_A3enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_i_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_i_A3enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((((((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_i_T1enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((((((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_i_T2enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((((((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_i_T3enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_i_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_i_T3enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((((((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))))))
      then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b1 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMVN_r_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMVN_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMVN_r_Op_A_txt d m regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       D_set ((d + r)) ((not_vec w__0  ::  64 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_r_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_r_A1enc_A_txt D size1 Vd Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_r_Op_A_txt d m regs))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMVN_r_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMVN_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMVN_r_T1enc_A_txt D size1 Vd Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMVN_r_Op_A_txt d m regs))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VNEG_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VNEG_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VNEG_Op_A_txt advsimd d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
       ((\<lambda> r result . 
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
           ((\<lambda> e result . 
             if floating_point then
               (assert_exp (((((((((((id0 esize)) = (( 16 :: int)::ii)))) \<or> (((((id0 esize)) = (( 32 :: int)::ii))))))) \<or> (((((id0 esize)) = (( 64 :: int)::ii))))))) (''src/instrs32.sail:30561.61-30561.62'') \<then>
               (D_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
               (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
               (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
               (FPNeg w__2  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
               (Elem_set w__0 e esize w__3  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
               D_set ((d + r)) w__4 \<then> return result))))))))))
             else
               (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
               (Elem_read w__5 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
               (let result = (- ((Word.sint w__6))) in
               (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
               (Elem_set w__7 e esize
                  ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
                 :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
               D_set ((d + r)) w__8 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))
   else
     (let l__246 = esize in
     if (((l__246 = (( 16 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
       (FPNeg ((subrange_vec_dec w__9 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__10 ::
          16 Word.word) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__10  ::  32 Word.word))))))
     else if (((l__246 = (( 32 :: int)::ii)))) then
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
       (FPNeg w__11  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) .  S_set d w__12))))
     else if (((l__246 = (( 64 :: int)::ii)))) then
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
       (FPNeg w__13  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) .  D_set d w__14))))
     else return () )))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNEG_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNEG_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNEG_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VNEG_Op_A_txt True d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VNEG_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VNEG_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNEG_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNEG_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNEG_A2enc_A_txt cond D Vd b__0 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:30626.29-30626.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       ((if (((True \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then throw (Error_Unpredictable () )
        else return () ) \<then>
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       (if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VNEG_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:30626.29-30626.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
          return (((((slice w__5 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
          return (((((slice w__6 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__7 ::
         bool) . 
       (if w__7 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VNEG_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:30626.29-30626.30'') \<then>
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
          return (((((slice w__9 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          return (((((slice w__10 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__11 ::
         bool) . 
       (if w__11 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VNEG_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   if w__12 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:30626.29-30626.30'') \<then>
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (((if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return (((((slice w__13 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
        return (((((slice w__14 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__15 ::
       bool) . 
     (if w__15 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VNEG_Op_A_txt False d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNEG_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNEG_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNEG_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VNEG_Op_A_txt True d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself))
         floating_point m regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       and_boolM (return ((((((F = ( 0b1 ::  1 Word.word)))) \<and> True)))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VNEG_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VNEG_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNEG_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNEG_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNEG_T2enc_A_txt D Vd b__0 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       and_boolM (return True) ((InITBlock () )) \<bind> ((\<lambda> (w__2 :: bool) . 
       ((if w__2 then throw (Error_Unpredictable () )
        else return () ) \<then>
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
          return (((((slice w__3 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
          return (((((slice w__4 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__5 ::
         bool) . 
       (if w__5 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VNEG_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) floating_point m regs))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
          return (((((slice w__7 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
          return (((((slice w__8 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__9 ::
         bool) . 
       (if w__9 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VNEG_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
          return (((((slice w__11 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return (((((slice w__12 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
         bool) . 
       (if w__13 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let floating_point = floating_point in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VNEG_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) floating_point m regs))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
   if w__14 then
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (floating_point :: bool) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     ((if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__16 :: bool) . 
     ((if w__16 then throw (Error_Unpredictable () )
      else return () ) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
        return (((((slice w__17 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
        return (((((slice w__18 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__19 ::
       bool) . 
     (if w__19 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let floating_point = floating_point in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VNEG_Op_A_txt False d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VNMLA_Op_A_txt : integer -> integer -> integer -> integer -> VFPNegMul -> M unit\<close>\<close>

definition execute_aarch32_instrs_VNMLA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> VFPNegMul \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (product16 :: 16 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (product32 :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (product64 :: 64 bits) . 
   CheckVFPEnabled True \<then>
   ((let l__243 = esize in
   if (((l__243 = (( 16 :: int)::ii)))) then
     (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (FPMul ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
        ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__2
       :: ( 16 Word.word) M) \<bind> ((\<lambda> (product16 :: 16 bits) . 
     (case  vtype of
       VFPNegMul_VNMLA =>
        (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
        (FPNeg ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__4 ::
           16 Word.word) . 
        (FPNeg product16  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
        (FPAdd w__4 w__5 w__6  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::  16 Word.word) . 
        S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__7  ::  32 Word.word))))))))))))
     | VFPNegMul_VNMLS =>
        (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
        (FPNeg ((subrange_vec_dec w__8 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__9 ::
           16 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
        (FPAdd w__9 product16 w__10  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
        S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__11  ::  32 Word.word))))))))))
     | VFPNegMul_VNMUL =>
        (FPNeg product16  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__12 ::  16 Word.word) . 
        S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__12  ::  32 Word.word))))
     )))))))))
   else if (((l__243 = (( 32 :: int)::ii)))) then
     (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
     (FPMul w__13 w__14 w__15  :: ( 32 Word.word) M) \<bind> ((\<lambda> (product32 :: 32 bits) . 
     (case  vtype of
       VFPNegMul_VNMLA =>
        (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
        (FPNeg w__16  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
        (FPNeg product32  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) . 
        (FPAdd w__17 w__18 w__19  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__20 ::  32 Word.word) .  S_set d w__20))))))))))
     | VFPNegMul_VNMLS =>
        (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
        (FPNeg w__21  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__22 ::  32 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
        (FPAdd w__22 product32 w__23  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__24 ::  32 Word.word) . 
        S_set d w__24))))))))
     | VFPNegMul_VNMUL =>
        (FPNeg product32  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) .  S_set d w__25))
     )))))))))
   else if (((l__243 = (( 64 :: int)::ii)))) then
     (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
     (FPMul w__26 w__27 w__28  :: ( 64 Word.word) M) \<bind> ((\<lambda> (product64 :: 64 bits) . 
     (case  vtype of
       VFPNegMul_VNMLA =>
        (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
        (FPNeg w__29  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
        (FPNeg product64  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
        (FPAdd w__30 w__31 w__32  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__33 ::  64 Word.word) .  D_set d w__33))))))))))
     | VFPNegMul_VNMLS =>
        (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__34 ::  64 Word.word) . 
        (FPNeg w__34  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
        (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
        (FPAdd w__35 product64 w__36  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__37 ::  64 Word.word) . 
        D_set d w__37))))))))
     | VFPNegMul_VNMUL =>
        (FPNeg product64  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__38 ::  64 Word.word) .  D_set d w__38))
     )))))))))
   else return () )))))))))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "vtype"  :: " VFPNegMul "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNMLA_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNMLA_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNMLA_A1enc_A_txt cond D Vn Vd size1 N op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:30842.29-30842.30'') \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (vtype :: VFPNegMul) =
       (if (((op1 = ( 0b1 ::  1 Word.word)))) then VFPNegMul_VNMLA
       else VFPNegMul_VNMLS) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNMLA_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNMLA_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNMLA_A2enc_A_txt cond D Vn Vd size1 N M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:30906.29-30906.30'') \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () ))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (vtype :: VFPNegMul) = VFPNegMul_VNMUL in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype)))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNMLA_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNMLA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNMLA_T1enc_A_txt D Vn Vd size1 N op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
     (if w__5 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (vtype :: VFPNegMul) =
       (if (((op1 = ( 0b1 ::  1 Word.word)))) then VFPNegMul_VNMLA
       else VFPNegMul_VNMLS) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype)))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VNMLA_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VNMLA_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VNMLA_T2enc_A_txt D Vn Vd size1 N M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (((if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () ))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
     (if w__5 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (vtype :: VFPNegMul) = VFPNegMul_VNMUL in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m, n)))))
       else
         (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m, n)))))
           else
             (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m, n)))))
               else (d, esize, m, n)) in
             (d, esize, m, n))) in
         (d, esize, m, n))) in
     (let n = n in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype)))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VORN_r_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VORN_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VORN_r_Op_A_txt d m n regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       D_set ((d + r)) ((or_vec w__0 ((not_vec w__1  ::  64 Word.word))  ::  64 Word.word)))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORN_r_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORN_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORN_r_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORN_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORN_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORN_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORN_r_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORN_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VORR_i_Op_A_txt : integer -> mword ty64 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VORR_i_Op_A_txt  :: \<open> int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       D_set ((d + r)) ((or_vec w__0 imm64  ::  64 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "imm64"  :: "(64)Word.word " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORR_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORR_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORR_i_A1enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VMOV (immediate)''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b0 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORR_i_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORR_i_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORR_i_A2enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VMOV (immediate)''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b0 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORR_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORR_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORR_i_T1enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VMOV (immediate)''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b0 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORR_i_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORR_i_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORR_i_T2enc_A_txt i D imm3 Vd cmode Q imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((vec_of_bits [access_vec_dec cmode (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<or> (((((subrange_vec_dec cmode (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        throw (Error_See (''VMOV (immediate)''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (AdvSIMDExpandImm ( 0b0 ::  1 Word.word) cmode
        ((concat_vec ((concat_vec i imm3  ::  4 Word.word)) imm4  ::  8 Word.word))
       :: ( 64 Word.word) M)) \<bind> ((\<lambda> (imm64 :: 64 bits) . 
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))))
   else return () )))\<close> 
  for  "i"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm3"  :: "(3)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "cmode"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VORR_r_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VORR_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VORR_r_Op_A_txt d m n regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       D_set ((d + r)) ((or_vec w__0 w__1  ::  64 Word.word)))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORR_r_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORR_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORR_r_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORR_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VORR_r_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VORR_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VORR_r_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VORR_r_Op_A_txt d m n regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VPADAL_Op_A_txt : integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VPADAL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VPADAL_Op_A_txt d__arg elements l__240 m regs is_unsigned = (
   if (((l__240 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op1 :: 8 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op2 :: 8 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 (((( 2 :: int)::ii) * e)) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::
                8 Word.word) . 
             (let op1 = w__1 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::
                8 Word.word) . 
             (let op2 = w__3 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             (Elem_read w__5 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::  16 Word.word) . 
             (Elem_set w__4 e (( 16 :: int)::ii) ((add_vec_int w__6 result  ::  16 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::
                64 Word.word) . 
             D_set ((d + r)) w__7 \<then> return (op1, op2, result)))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        8 Word.word), (op2 ::  8 Word.word), (result :: ii)) = varstup in
     return () ))))))))))))))
   else if (((l__240 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op1 :: 16 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op2 :: 16 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
             (Elem_read w__8 (((( 2 :: int)::ii) * e)) (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__9 ::
                16 Word.word) . 
             (let op1 = w__9 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
             (Elem_read w__10 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 16 :: int)::ii)
               :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
             (let op2 = w__11 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
             (Elem_read w__13 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
             (Elem_set w__12 e (( 32 :: int)::ii) ((add_vec_int w__14 result  ::  32 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::
                64 Word.word) . 
             D_set ((d + r)) w__15 \<then> return (op1, op2, result)))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        16 Word.word), (op2 ::  16 Word.word), (result :: ii)) = varstup in
     return () ))))))))))))))
   else if (((l__240 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op2 :: 32 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
             (Elem_read w__16 (((( 2 :: int)::ii) * e)) (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::
                32 Word.word) . 
             (let op1 = w__17 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
             (Elem_read w__18 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 32 :: int)::ii)
               :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
             (let op2 = w__19 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
             (Elem_read w__21 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
             (Elem_set w__20 e (( 64 :: int)::ii) ((add_vec_int w__22 result  ::  64 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::
                64 Word.word) . 
             D_set ((d + r)) w__23 \<then> return (op1, op2, result)))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        32 Word.word), (op2 ::  32 Word.word), (result :: ii)) = varstup in
     return () ))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op1 :: 64 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op2 :: 64 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
             (Elem_read w__24 (((( 2 :: int)::ii) * e)) (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__25 ::
                64 Word.word) . 
             (let op1 = w__25 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
             (Elem_read w__26 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 64 :: int)::ii)
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
             (let op2 = w__27 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
             (Elem_read w__29 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__30 ::  128 Word.word) . 
             (Elem_set w__28 e (( 128 :: int)::ii) ((add_vec_int w__30 result  ::  128 Word.word))
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
             D_set ((d + r)) w__31 \<then> return (op1, op2, result)))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        64 Word.word), (op2 ::  64 Word.word), (result :: ii)) = varstup in
     return () )))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__240"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADAL_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADAL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADAL_A1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADAL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADAL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADAL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADAL_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADAL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADAL_T1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADAL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADAL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADAL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VPADD_f_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VPADD_f_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VPADD_f_Op_A_txt d elements esize m n = (
   (let esize = (size_itself_int esize) in
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (dest :: 64 bits) . 
   (let h = (elements div (( 2 :: int)::ii)) in
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = (h - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) dest
     ((\<lambda> e dest . 
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (Elem_read w__0 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 ::
         ( 'esize::len)Word.word) . 
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (Elem_read w__2 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 ::
         ( 'esize::len)Word.word) . 
       (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
       (FPAdd w__1 w__3 w__4  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
       (Elem_set dest e esize w__5  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
       (let dest = w__6 in
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
       (Elem_read w__7 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__8 ::
         ( 'esize::len)Word.word) . 
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
       (Elem_read w__9 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__10 ::
         ( 'esize::len)Word.word) . 
       (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
       (FPAdd w__8 w__10 w__11  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__12 :: ( 'esize::len)Word.word) . 
       (Elem_set dest ((e + h)) esize w__12  :: ( 64 Word.word) M))))))))))))))))))))))))))))))) \<bind> ((\<lambda> (dest ::  64 Word.word) . 
   D_set d dest)))))))))\<close> 
  for  "d"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADD_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADD_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADD_f_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((Q = ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if (((Q = ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VPADD_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADD_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADD_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADD_f_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((Q = ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if (((Q = ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VPADD_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VPADD_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VPADD_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VPADD_i_Op_A_txt d elements esize m n = (
   (let esize = (size_itself_int esize) in
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (dest :: 64 bits) . 
   (let h = (elements div (( 2 :: int)::ii)) in
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = (h - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) dest
     ((\<lambda> e dest . 
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (Elem_read w__0 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 ::
         ( 'esize::len)Word.word) . 
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (Elem_read w__2 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 ::
         ( 'esize::len)Word.word) . 
       (Elem_set dest e esize ((add_vec w__1 w__3  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::
          64 Word.word) . 
       (let dest = w__4 in
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
       (Elem_read w__5 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 ::
         ( 'esize::len)Word.word) . 
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
       (Elem_read w__7 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__8 ::
         ( 'esize::len)Word.word) . 
       (Elem_set dest ((e + h)) esize ((add_vec w__6 w__8  :: ( 'esize::len)Word.word))
         :: ( 64 Word.word) M))))))))))))))))))))))) \<bind> ((\<lambda> (dest ::  64 Word.word) . 
   D_set d dest)))))))))\<close> 
  for  "d"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADD_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADD_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADD_i_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((False \<or> (((Q = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> (((Q = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> (((Q = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADD_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADD_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADD_i_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((False \<or> (((Q = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> (((Q = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> (((Q = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPADD_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VPADDL_Op_A_txt : integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VPADDL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VPADDL_Op_A_txt d__arg elements l__237 m regs is_unsigned = (
   if (((l__237 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op1 :: 8 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (op2 :: 8 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 (((( 2 :: int)::ii) * e)) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::
                8 Word.word) . 
             (let op1 = w__1 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::
                8 Word.word) . 
             (let op2 = w__3 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
             (Elem_set w__4 e (( 16 :: int)::ii) ((integer_subrange result (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             D_set ((d + r)) w__5 \<then> return (op1, op2, result)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        8 Word.word), (op2 ::  8 Word.word), (result :: ii)) = varstup in
     return () ))))))))))))))
   else if (((l__237 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op1 :: 16 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (op2 :: 16 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
             (Elem_read w__6 (((( 2 :: int)::ii) * e)) (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__7 ::
                16 Word.word) . 
             (let op1 = w__7 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
             (Elem_read w__8 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 16 :: int)::ii)
               :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__9 ::  16 Word.word) . 
             (let op2 = w__9 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
             (Elem_set w__10 e (( 32 :: int)::ii) ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
             D_set ((d + r)) w__11 \<then> return (op1, op2, result)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        16 Word.word), (op2 ::  16 Word.word), (result :: ii)) = varstup in
     return () ))))))))))))))
   else if (((l__237 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op2 :: 32 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
             (Elem_read w__12 (((( 2 :: int)::ii) * e)) (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::
                32 Word.word) . 
             (let op1 = w__13 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
             (Elem_read w__14 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 32 :: int)::ii)
               :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
             (let op2 = w__15 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
             (Elem_set w__16 e (( 64 :: int)::ii) ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
             D_set ((d + r)) w__17 \<then> return (op1, op2, result)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        32 Word.word), (op2 ::  32 Word.word), (result :: ii)) = varstup in
     return () ))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op1 :: 64 bits) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (op2 :: 64 bits) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let h = (elements div (( 2 :: int)::ii)) in
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
       ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
           ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
             (Elem_read w__18 (((( 2 :: int)::ii) * e)) (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::
                64 Word.word) . 
             (let op1 = w__19 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
             (Elem_read w__20 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 64 :: int)::ii)
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
             (let op2 = w__21 in
             (let (result :: ii) = (((asl_Int op1 is_unsigned)) + ((asl_Int op2 is_unsigned))) in
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
             (Elem_set w__22 e (( 128 :: int)::ii) ((integer_subrange result (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word))
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
             D_set ((d + r)) w__23 \<then> return (op1, op2, result)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
        64 Word.word), (op2 ::  64 Word.word), (result :: ii)) = varstup in
     return () )))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__237"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADDL_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADDL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADDL_A1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADDL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADDL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADDL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPADDL_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPADDL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPADDL_T1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADDL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADDL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VPADDL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m regs is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VPMAX_f_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VPMAX_f_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VPMAX_f_Op_A_txt d elements esize m maximum n = (
   (let esize = (size_itself_int esize) in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (dest :: 64 bits) . 
   (let h = (elements div (( 2 :: int)::ii)) in
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = (h - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (dest, op1, op2)
     ((\<lambda> e varstup .  (let (dest, op1, op2) = varstup in
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (Elem_read w__0 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 ::
         ( 'esize::len)Word.word) . 
       (let op1 = w__1 in
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (Elem_read w__2 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 ::
         ( 'esize::len)Word.word) . 
       (let op2 = w__3 in
       (if maximum then
          (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
          (FPMax op1 op2 w__4  :: (( 'esize::len)Word.word) M)))
        else
          (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
          (FPMin op1 op2 w__6  :: (( 'esize::len)Word.word) M)))) \<bind> ((\<lambda> (w__8 :: ( 'esize::len)Word.word) . 
       (Elem_set dest e esize w__8  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
       (let dest = w__9 in
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
       (Elem_read w__10 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__11 ::
         ( 'esize::len)Word.word) . 
       (let op1 = w__11 in
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
       (Elem_read w__12 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__13 ::
         ( 'esize::len)Word.word) . 
       (let op2 = w__13 in
       (if maximum then
          (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
          (FPMax op1 op2 w__14  :: (( 'esize::len)Word.word) M)))
        else
          (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
          (FPMin op1 op2 w__16  :: (( 'esize::len)Word.word) M)))) \<bind> ((\<lambda> (w__18 :: ( 'esize::len)Word.word) . 
       (Elem_set dest ((e + h)) esize w__18  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) . 
       (let dest = w__19 in
       return (dest, op1, op2))))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((dest ::  64 Word.word), (op1 :: ( 'esize::len)Word.word), (op2 ::
     ( 'esize::len)Word.word)) = varstup in
   D_set d dest))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "maximum"  :: " bool " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPMAX_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPMAX_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPMAX_f_A1enc_A_txt D op1 b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VPMAX_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       maximum n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPMAX_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPMAX_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPMAX_f_T1enc_A_txt D op1 b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_f_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () )) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VPMAX_f_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
       maximum n)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VPMAX_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VPMAX_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VPMAX_i_Op_A_txt d elements esize m maximum n is_unsigned = (
   (let esize = (size_itself_int esize) in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (dest :: 64 bits) . 
   (let h = (elements div (( 2 :: int)::ii)) in
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = (h - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (dest, op1, op2, result)
     ((\<lambda> e varstup .  (let (dest, op1, op2, result) = varstup in
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (Elem_read w__0 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 ::
         ( 'esize::len)Word.word) . 
       (let op1 = (asl_Int w__1 is_unsigned) in
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (Elem_read w__2 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 ::
         ( 'esize::len)Word.word) . 
       (let op2 = (asl_Int w__3 is_unsigned) in
       (let (result :: ii) = (if maximum then max_int op1 op2 else min_int op1 op2) in
       (Elem_set dest e esize
          ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
         :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
       (let dest = w__4 in
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
       (Elem_read w__5 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 ::
         ( 'esize::len)Word.word) . 
       (let op1 = (asl_Int w__6 is_unsigned) in
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
       (Elem_read w__7 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__8 ::
         ( 'esize::len)Word.word) . 
       (let op2 = (asl_Int w__8 is_unsigned) in
       (let (result :: ii) = (if maximum then max_int op1 op2 else min_int op1 op2) in
       (Elem_set dest ((e + h)) esize
          ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
         :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
       (let dest = w__9 in
       return (dest, op1, op2, result))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((dest ::  64 Word.word), (op1 :: ii), (op2 ::
     ii), (result :: ii)) = varstup in
   D_set d dest))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "maximum"  :: " bool " 
  and  "n"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPMAX_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPMAX_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPMAX_i_A1enc_A_txt U D b__0 Vn Vd N M op1 Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         maximum n is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         maximum n is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VPMAX_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VPMAX_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VPMAX_i_T1enc_A_txt U D b__0 Vn Vd N M op1 Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         maximum n is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         maximum n is_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VPMAX_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         maximum n is_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQABS_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQABS_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQABS_Op_A_txt d__arg elements esize m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
     ((\<lambda> r result . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let result = (abs ((Word.sint w__1))) in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
           (SignedSatQ result esize  :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 ::
             ( 'esize::len)Word.word), (tup_10 :: bool)) = varstup in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_set w__2 e esize tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           D_set ((d + r)) w__3 \<then>
           ((let (sat :: bool) = tup_10 in
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__4 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () ) \<then>
           return result)))))))))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
   return () ))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQABS_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQABS_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQABS_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQABS_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQABS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQABS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQABS_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQABS_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQABS_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQABS_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQABS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQABS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQADD_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQADD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQADD_Op_A_txt d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sum1 :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) sum1
     ((\<lambda> r sum1 . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) sum1
         ((\<lambda> e sum1 . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let sum1 = (((asl_Int w__1 is_unsigned)) + ((asl_Int w__3 is_unsigned))) in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
           (SatQ sum1 esize is_unsigned  :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 ::
             ( 'esize::len)Word.word), (tup_10 :: bool)) = varstup in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then>
           ((let (sat :: bool) = tup_10 in
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__6 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () ) \<then>
           return sum1)))))))))))))))))))))))))))) \<bind> ((\<lambda> (sum1 :: ii) . 
   return () ))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQADD_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQADD_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQADD_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQADD_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQADD_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQADD_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQADD_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQADD_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQADD_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQADD_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQADD_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQADD_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQADD_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQADD_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQDMLAL_Op_A_txt : bool -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQDMLAL_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQDMLAL_Op_A_txt add d__arg elements l__234 index1 m n scalar_form = (
   if (((l__234 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (product :: 16 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
        (Elem_read w__0 index1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
        (let op2 = (Word.sint w__1) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
            (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
            (let op2 = (Word.sint w__3) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_read w__4 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
         (let op1 = (Word.sint w__5) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 16 :: int)::ii)
           :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> (w__6 :: ( 16 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__6 in
         (let (product :: 16 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
            (Elem_read w__7 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__8 ::  16 Word.word) . 
            (let result = (((Word.sint w__8)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__9 ::  128 Word.word) . 
            (Elem_read w__9 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__10 ::  16 Word.word) . 
            (let result = (((Word.sint w__10)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 16 :: int)::ii)  :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 16
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__11 ::  128 Word.word) . 
         (Elem_set w__11 e (( 16 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__12 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__13 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        16 Word.word), (sat1 :: bool)) = varstup in
     return () ))))))))))))))))
   else if (((l__234 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (product :: 32 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
        (Elem_read w__14 index1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__15 ::  16 Word.word) . 
        (let op2 = (Word.sint w__15) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
            (Elem_read w__16 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__17 ::  16 Word.word) . 
            (let op2 = (Word.sint w__17) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
         (Elem_read w__18 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__19 ::  16 Word.word) . 
         (let op1 = (Word.sint w__19) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 32 :: int)::ii)
           :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> (w__20 :: ( 32 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__20 in
         (let (product :: 32 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
            (Elem_read w__21 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__22 ::  32 Word.word) . 
            (let result = (((Word.sint w__22)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__23 ::  128 Word.word) . 
            (Elem_read w__23 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__24 ::  32 Word.word) . 
            (let result = (((Word.sint w__24)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 32
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__25 ::  128 Word.word) . 
         (Elem_set w__25 e (( 32 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__26 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__26 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__27 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__27 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        32 Word.word), (sat1 :: bool)) = varstup in
     return () ))))))))))))))))
   else if (((l__234 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (product :: 64 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
        (Elem_read w__28 index1 (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__29 ::  32 Word.word) . 
        (let op2 = (Word.sint w__29) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
            (Elem_read w__30 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__31 ::  32 Word.word) . 
            (let op2 = (Word.sint w__31) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
         (Elem_read w__32 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__33 ::  32 Word.word) . 
         (let op1 = (Word.sint w__33) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 64 :: int)::ii)
           :: (( 64 Word.word * bool)) M) \<bind> ((\<lambda> (w__34 :: ( 64 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__34 in
         (let (product :: 64 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__35 ::  128 Word.word) . 
            (Elem_read w__35 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
            (let result = (((Word.sint w__36)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__37 ::  128 Word.word) . 
            (Elem_read w__37 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__38 ::  64 Word.word) . 
            (let result = (((Word.sint w__38)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 64 :: int)::ii)  :: (( 64 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 64
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__39 ::  128 Word.word) . 
         (Elem_set w__39 e (( 64 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__40 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__40 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__41 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__41 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        64 Word.word), (sat1 :: bool)) = varstup in
     return () ))))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (product :: 128 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__42 ::  64 Word.word) . 
        (Elem_read w__42 index1 (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__43 ::  64 Word.word) . 
        (let op2 = (Word.sint w__43) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__44 ::  64 Word.word) . 
            (Elem_read w__44 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::  64 Word.word) . 
            (let op2 = (Word.sint w__45) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__46 ::  64 Word.word) . 
         (Elem_read w__46 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__47 ::  64 Word.word) . 
         (let op1 = (Word.sint w__47) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 128 :: int)::ii)
           :: (( 128 Word.word * bool)) M) \<bind> ((\<lambda> (w__48 :: ( 128 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__48 in
         (let (product :: 128 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__49 ::  128 Word.word) . 
            (Elem_read w__49 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__50 ::  128 Word.word) . 
            (let result = (((Word.sint w__50)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__51 ::  128 Word.word) . 
            (Elem_read w__51 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__52 ::  128 Word.word) . 
            (let result = (((Word.sint w__52)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 128 :: int)::ii)  :: (( 128 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 128
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__53 ::  128 Word.word) . 
         (Elem_set w__53 e (( 128 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__54 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__54 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__55 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__55 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        128 Word.word), (sat1 :: bool)) = varstup in
     return () )))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__234"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "scalar_form"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLAL_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLAL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLAL_A1enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_See (''Related encodings''))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLAL_A2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLAL_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLAL_A2enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32209.47-32209.48'') \<then>
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32209.47-32209.48'') \<then>
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLAL_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLAL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLAL_T1enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_See (''Related encodings''))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLAL_T2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLAL_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLAL_T2enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32299.47-32299.48'') \<then>
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32299.47-32299.48'') \<then>
       execute_aarch32_instrs_VQDMLAL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQDMLSL_Op_A_txt : bool -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQDMLSL_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQDMLSL_Op_A_txt add d__arg elements l__231 index1 m n scalar_form = (
   if (((l__231 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (product :: 16 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
        (Elem_read w__0 index1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
        (let op2 = (Word.sint w__1) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
            (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
            (let op2 = (Word.sint w__3) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_read w__4 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
         (let op1 = (Word.sint w__5) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 16 :: int)::ii)
           :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> (w__6 :: ( 16 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__6 in
         (let (product :: 16 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
            (Elem_read w__7 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__8 ::  16 Word.word) . 
            (let result = (((Word.sint w__8)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__9 ::  128 Word.word) . 
            (Elem_read w__9 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__10 ::  16 Word.word) . 
            (let result = (((Word.sint w__10)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 16 :: int)::ii)  :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 16
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__11 ::  128 Word.word) . 
         (Elem_set w__11 e (( 16 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__12 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__13 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        16 Word.word), (sat1 :: bool)) = varstup in
     return () ))))))))))))))))
   else if (((l__231 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (product :: 32 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
        (Elem_read w__14 index1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__15 ::  16 Word.word) . 
        (let op2 = (Word.sint w__15) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
            (Elem_read w__16 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__17 ::  16 Word.word) . 
            (let op2 = (Word.sint w__17) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
         (Elem_read w__18 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__19 ::  16 Word.word) . 
         (let op1 = (Word.sint w__19) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 32 :: int)::ii)
           :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> (w__20 :: ( 32 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__20 in
         (let (product :: 32 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
            (Elem_read w__21 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__22 ::  32 Word.word) . 
            (let result = (((Word.sint w__22)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__23 ::  128 Word.word) . 
            (Elem_read w__23 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__24 ::  32 Word.word) . 
            (let result = (((Word.sint w__24)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 32 :: int)::ii)  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 32
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__25 ::  128 Word.word) . 
         (Elem_set w__25 e (( 32 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__26 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__26 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__27 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__27 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        32 Word.word), (sat1 :: bool)) = varstup in
     return () ))))))))))))))))
   else if (((l__231 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (product :: 64 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
        (Elem_read w__28 index1 (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__29 ::  32 Word.word) . 
        (let op2 = (Word.sint w__29) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
            (Elem_read w__30 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__31 ::  32 Word.word) . 
            (let op2 = (Word.sint w__31) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
         (Elem_read w__32 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__33 ::  32 Word.word) . 
         (let op1 = (Word.sint w__33) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 64 :: int)::ii)
           :: (( 64 Word.word * bool)) M) \<bind> ((\<lambda> (w__34 :: ( 64 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__34 in
         (let (product :: 64 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__35 ::  128 Word.word) . 
            (Elem_read w__35 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
            (let result = (((Word.sint w__36)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__37 ::  128 Word.word) . 
            (Elem_read w__37 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__38 ::  64 Word.word) . 
            (let result = (((Word.sint w__38)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 64 :: int)::ii)  :: (( 64 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 64
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__39 ::  128 Word.word) . 
         (Elem_set w__39 e (( 64 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__40 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__40 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__41 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__41 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        64 Word.word), (sat1 :: bool)) = varstup in
     return () ))))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (product :: 128 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat1 :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__42 ::  64 Word.word) . 
        (Elem_read w__42 index1 (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__43 ::  64 Word.word) . 
        (let op2 = (Word.sint w__43) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat1)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat1) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__44 ::  64 Word.word) . 
            (Elem_read w__44 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::  64 Word.word) . 
            (let op2 = (Word.sint w__45) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__46 ::  64 Word.word) . 
         (Elem_read w__46 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__47 ::  64 Word.word) . 
         (let op1 = (Word.sint w__47) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 128 :: int)::ii)
           :: (( 128 Word.word * bool)) M) \<bind> ((\<lambda> (w__48 :: ( 128 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__48 in
         (let (product :: 128 bits) = tup__0 in
         (let (sat1 :: bool) = tup__1 in
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
         (if add then
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__49 ::  128 Word.word) . 
            (Elem_read w__49 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__50 ::  128 Word.word) . 
            (let result = (((Word.sint w__50)) + ((Word.sint product))) in
            return result)))))
          else
            (Qin_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__51 ::  128 Word.word) . 
            (Elem_read w__51 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__52 ::  128 Word.word) . 
            (let result = (((Word.sint w__52)) - ((Word.sint product))) in
            return result)))))) \<bind> ((\<lambda> (result :: ii) . 
         (let result = result in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat2 :: bool) . 
         (SignedSatQ result (( 128 :: int)::ii)  :: (( 128 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 128
           bits), (tup_10 :: bool)) = varstup in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__53 ::  128 Word.word) . 
         (Elem_set w__53 e (( 128 :: int)::ii) tup_00  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__54 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__54 \<then>
         ((let (sat2 :: bool) = tup_10 in
         (if (((sat1 \<or> sat2))) then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__55 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__55 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return (op1, op2, product, sat1))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        128 Word.word), (sat1 :: bool)) = varstup in
     return () )))))))))))))))))\<close> 
  for  "add"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__231"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "scalar_form"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLSL_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLSL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLSL_A1enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_See (''Related encodings''))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLSL_A2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLSL_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLSL_A2enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32431.47-32431.48'') \<then>
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32431.47-32431.48'') \<then>
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLSL_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLSL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLSL_T1enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_See (''Related encodings''))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMLSL_T2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMLSL_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMLSL_T2enc_A_txt D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32521.47-32521.48'') \<then>
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (add :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32521.47-32521.48'') \<then>
       execute_aarch32_instrs_VQDMLSL_Op_A_txt add d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQDMULH_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQDMULH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQDMULH_Op_A_txt d__arg elements esize index1 m n regs scalar_form = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   (CheckAdvSIMDEnabled ()  \<then>
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
   (if scalar_form then
      (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (Elem_read w__0 index1 esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
      (let op2 = (Word.sint w__1) in
      return op2)))))
    else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result, sat)
     ((\<lambda> r varstup .  (let (op1, op2, result, sat) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result, sat)
         ((\<lambda> e varstup .  (let (op1, op2, result, sat) = varstup in
           (if ((\<not> scalar_form)) then
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
              (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
              (let op2 = (Word.sint w__3) in
              return op2)))))
            else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
           (let op1 = (Word.sint w__5) in
           (SignedSatQ ((shr_int (((((( 2 :: int)::ii) * op1)) * op2)) esize)) esize
             :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__6 :: (( 'esize::len)Word.word * bool)) . 
           (let (tup__0, tup__1) = w__6 in
           (let (result :: ( 'esize::len)Word.word) = tup__0 in
           (let (sat :: bool) = tup__1 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           (Elem_set w__7 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
           (D_set ((d + r)) w__8 \<then>
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__9 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () )) \<then>
           return (op1, op2, result, sat))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (result ::
     ( 'esize::len)Word.word), (sat :: bool)) = varstup in
   return () ))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "scalar_form"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULH_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULH_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULH_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULH_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULH_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULH_A2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32644.47-32644.48'') \<then>
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32644.47-32644.48'') \<then>
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULH_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULH_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULH_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULH_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULH_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULH_T2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32737.47-32737.48'') \<then>
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32737.47-32737.48'') \<then>
       execute_aarch32_instrs_VQDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQDMULL_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQDMULL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQDMULL_Op_A_txt d__arg elements l__228 index1 m n scalar_form = (
   if (((l__228 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (product :: 16 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
        (Elem_read w__0 index1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
        (let op2 = (Word.sint w__1) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
            (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
            (let op2 = (Word.sint w__3) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_read w__4 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
         (let op1 = (Word.sint w__5) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 16 :: int)::ii)
           :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> (w__6 :: ( 16 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__6 in
         (let (product :: 16 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
         (Elem_set w__7 e (( 16 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
         (Q_set ((shr_int d (( 1 :: int)::ii))) w__8 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__9 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (op1, op2, product, sat))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        16 Word.word), (sat :: bool)) = varstup in
     return () ))))))))))))))))
   else if (((l__228 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (product :: 32 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
        (Elem_read w__10 index1 (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
        (let op2 = (Word.sint w__11) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
            (Elem_read w__12 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__13 ::  16 Word.word) . 
            (let op2 = (Word.sint w__13) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
         (Elem_read w__14 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__15 ::  16 Word.word) . 
         (let op1 = (Word.sint w__15) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 32 :: int)::ii)
           :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> (w__16 :: ( 32 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__16 in
         (let (product :: 32 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__17 ::  128 Word.word) . 
         (Elem_set w__17 e (( 32 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
         (Q_set ((shr_int d (( 1 :: int)::ii))) w__18 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__19 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (op1, op2, product, sat))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        32 Word.word), (sat :: bool)) = varstup in
     return () ))))))))))))))))
   else if (((l__228 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (product :: 64 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
        (Elem_read w__20 index1 (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
        (let op2 = (Word.sint w__21) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
            (Elem_read w__22 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
            (let op2 = (Word.sint w__23) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
         (Elem_read w__24 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
         (let op1 = (Word.sint w__25) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 64 :: int)::ii)
           :: (( 64 Word.word * bool)) M) \<bind> ((\<lambda> (w__26 :: ( 64 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__26 in
         (let (product :: 64 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__27 ::  128 Word.word) . 
         (Elem_set w__27 e (( 64 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__28 ::  128 Word.word) . 
         (Q_set ((shr_int d (( 1 :: int)::ii))) w__28 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__29 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__29 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (op1, op2, product, sat))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        64 Word.word), (sat :: bool)) = varstup in
     return () ))))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (product :: 128 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     (CheckAdvSIMDEnabled ()  \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op2 :: ii) . 
     (if scalar_form then
        (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
        (Elem_read w__30 index1 (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
        (let op2 = (Word.sint w__31) in
        return op2)))))
      else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, product, sat)
       ((\<lambda> e varstup .  (let (op1, op2, product, sat) = varstup in
         (if ((\<not> scalar_form)) then
            (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
            (Elem_read w__32 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__33 ::  64 Word.word) . 
            (let op2 = (Word.sint w__33) in
            return op2)))))
          else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
         (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__34 ::  64 Word.word) . 
         (Elem_read w__34 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
         (let op1 = (Word.sint w__35) in
         (SignedSatQ (((((( 2 :: int)::ii) * op1)) * op2)) (( 128 :: int)::ii)
           :: (( 128 Word.word * bool)) M) \<bind> ((\<lambda> (w__36 :: ( 128 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__36 in
         (let (product :: 128 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__37 ::  128 Word.word) . 
         (Elem_set w__37 e (( 128 :: int)::ii) product  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__38 ::  128 Word.word) . 
         (Q_set ((shr_int d (( 1 :: int)::ii))) w__38 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__39 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__39 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (op1, op2, product, sat))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (product ::
        128 Word.word), (sat :: bool)) = varstup in
     return () )))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__228"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "scalar_form"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULL_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULL_A1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n False)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n False)))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_See (''Related encodings''))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULL_A2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULL_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULL_A2enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32852.47-32852.48'') \<then>
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n True))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32852.47-32852.48'') \<then>
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n True))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULL_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULL_T1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n False)))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n False)))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) .  throw (Error_See (''Related encodings''))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQDMULL_T2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQDMULL_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQDMULL_T2enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32938.47-32938.48'') \<then>
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) index1 m n True))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:32938.47-32938.48'') \<then>
       execute_aarch32_instrs_VQDMULL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) index1 m n True))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQMOVN_Op_A_txt : integer -> bool -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQMOVN_Op_A_txt  :: \<open> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQMOVN_Op_A_txt d__arg dest_unsigned elements l__225 m src_unsigned = (
   if (((l__225 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) operand
       ((\<lambda> e operand . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (let operand = (asl_Int w__1 src_unsigned) in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
         (SatQ operand (( 8 :: int)::ii) dest_unsigned  :: (( 8 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 8
           bits), (tup_10 :: bool)) = varstup in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
         (Elem_set w__2 e (( 8 :: int)::ii) tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         D_set d w__3 \<then>
         ((let (sat :: bool) = tup_10 in
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__4 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return operand))))))))))))))))))) \<bind> ((\<lambda> (operand :: ii) . 
     return () ))))))))
   else if (((l__225 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) operand
       ((\<lambda> e operand . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
         (Elem_read w__5 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
         (let operand = (asl_Int w__6 src_unsigned) in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
         (SatQ operand (( 16 :: int)::ii) dest_unsigned  :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 16
           bits), (tup_10 :: bool)) = varstup in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
         (Elem_set w__7 e (( 16 :: int)::ii) tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
         D_set d w__8 \<then>
         ((let (sat :: bool) = tup_10 in
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__9 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return operand))))))))))))))))))) \<bind> ((\<lambda> (operand :: ii) . 
     return () ))))))))
   else if (((l__225 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) operand
       ((\<lambda> e operand . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__10 ::  128 Word.word) . 
         (Elem_read w__10 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         (let operand = (asl_Int w__11 src_unsigned) in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
         (SatQ operand (( 32 :: int)::ii) dest_unsigned  :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 32
           bits), (tup_10 :: bool)) = varstup in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
         (Elem_set w__12 e (( 32 :: int)::ii) tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         D_set d w__13 \<then>
         ((let (sat :: bool) = tup_10 in
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__14 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return operand))))))))))))))))))) \<bind> ((\<lambda> (operand :: ii) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) operand
       ((\<lambda> e operand . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__15 ::  128 Word.word) . 
         (Elem_read w__15 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__16 ::  128 Word.word) . 
         (let operand = (asl_Int w__16 src_unsigned) in
         undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
         (SatQ operand (( 64 :: int)::ii) dest_unsigned  :: (( 64 Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 :: 64
           bits), (tup_10 :: bool)) = varstup in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
         (Elem_set w__17 e (( 64 :: int)::ii) tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
         D_set d w__18 \<then>
         ((let (sat :: bool) = tup_10 in
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__19 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () ) \<then>
         return operand))))))))))))))))))) \<bind> ((\<lambda> (operand :: ii) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "dest_unsigned"  :: " bool " 
  and  "elements"  :: " int " 
  and  "l__225"  :: " int " 
  and  "m"  :: " int " 
  and  "src_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQMOVN_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQMOVN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQMOVN_A1enc_A_txt D b__0 Vd op1 M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
        else return () ) \<then>
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (src_unsigned :: bool) = (op1 = ( 0b11 ::  2 Word.word)) in
       (let (dest_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned (( 8 :: int)::ii) (( 8 :: int)::ii) m src_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
        else return () ) \<then>
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (src_unsigned :: bool) = (op1 = ( 0b11 ::  2 Word.word)) in
       (let (dest_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned (( 4 :: int)::ii) (( 16 :: int)::ii) m src_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
        else return () ) \<then>
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (src_unsigned :: bool) = (op1 = ( 0b11 ::  2 Word.word)) in
       (let (dest_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 32 :: int)::ii) m src_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQMOVN_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQMOVN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQMOVN_T1enc_A_txt D b__0 Vd op1 M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
        else return () ) \<then>
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (src_unsigned :: bool) = (op1 = ( 0b11 ::  2 Word.word)) in
       (let (dest_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned (( 8 :: int)::ii) (( 8 :: int)::ii) m src_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
        else return () ) \<then>
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (src_unsigned :: bool) = (op1 = ( 0b11 ::  2 Word.word)) in
       (let (dest_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned (( 4 :: int)::ii) (( 16 :: int)::ii) m src_unsigned)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
        else return () ) \<then>
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (src_unsigned :: bool) = (op1 = ( 0b11 ::  2 Word.word)) in
       (let (dest_unsigned :: bool) =
         ((vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 32 :: int)::ii) m src_unsigned)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if (((op1 = ( 0b00 ::  2 Word.word)))) then throw (Error_See (''VMOVN''))
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQNEG_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQNEG_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQNEG_Op_A_txt d__arg elements esize m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
     ((\<lambda> r result . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let result = (- ((Word.sint w__1))) in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
           (SignedSatQ result esize  :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 ::
             ( 'esize::len)Word.word), (tup_10 :: bool)) = varstup in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_set w__2 e esize tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           D_set ((d + r)) w__3 \<then>
           ((let (sat :: bool) = tup_10 in
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__4 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () ) \<then>
           return result)))))))))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
   return () ))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQNEG_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQNEG_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQNEG_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQNEG_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQNEG_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQNEG_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQNEG_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQNEG_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQNEG_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQNEG_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQNEG_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQNEG_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQRDMULH_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQRDMULH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQRDMULH_Op_A_txt d__arg elements esize index1 m n regs scalar_form = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let round_const = (shl_int (( 1 :: int)::ii) ((esize - (( 1 :: int)::ii)))) in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2 :: ii) . 
   (if scalar_form then
      (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (Elem_read w__0 index1 esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
      (let op2 = (Word.sint w__1) in
      return op2)))))
    else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result, sat)
     ((\<lambda> r varstup .  (let (op1, op2, result, sat) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result, sat)
         ((\<lambda> e varstup .  (let (op1, op2, result, sat) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op1 = (Word.sint w__3) in
           (if ((\<not> scalar_form)) then
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
              (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let op2 = (Word.sint w__5) in
              return op2)))))
            else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
           (SignedSatQ
              ((shr_int (((((((( 2 :: int)::ii) * op1)) * op2)) + round_const))
                  esize)) esize
             :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__6 :: (( 'esize::len)Word.word * bool)) . 
           (let (tup__0, tup__1) = w__6 in
           (let (result :: ( 'esize::len)Word.word) = tup__0 in
           (let (sat :: bool) = tup__1 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           (Elem_set w__7 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
           (D_set ((d + r)) w__8 \<then>
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__9 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () )) \<then>
           return (op1, op2, result, sat))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (result ::
     ( 'esize::len)Word.word), (sat :: bool)) = varstup in
   return () ))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "scalar_form"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMULH_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMULH_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMULH_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMULH_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMULH_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMULH_A2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33239.47-33239.48'') \<then>
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33239.47-33239.48'') \<then>
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMULH_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMULH_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMULH_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       throw (Error_Undefined () )))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs False))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let index1 = index1 in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs False))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMULH_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMULH_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMULH_T2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then throw (Error_Undefined () )
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: ii) = ((( 4 :: int)::ii)) in
       (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
       (let (index1 :: ii) =
         (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33332.47-33332.48'') \<then>
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: ii) = ((( 2 :: int)::ii)) in
       (let (m :: ii) = (Word.uint Vm) in
       (let (index1 :: ii) = (Word.uint M) in
       (let m = m in
       (let index1 = index1 in
       assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33332.47-33332.48'') \<then>
       execute_aarch32_instrs_VQRDMULH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         index1 m n regs True)))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQRDMLAH_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQRDMLAH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQRDMLAH_Op_A_txt d__arg elements esize index1 m n regs scalar_form = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op3 :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let round_const = (shl_int (( 1 :: int)::ii) ((esize - (( 1 :: int)::ii)))) in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2 :: ii) . 
   (if scalar_form then
      (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (Elem_read w__0 index1 esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
      (let op2 = (Word.sint w__1) in
      return op2)))))
    else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, op3, result, sat)
     ((\<lambda> r varstup .  (let (op1, op2, op3, result, sat) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, op3, result, sat)
         ((\<lambda> e varstup .  (let (op1, op2, op3, result, sat) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op1 = (Word.sint w__3) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
           (let op3 = (shl_int ((Word.sint w__5)) esize) in
           (if ((\<not> scalar_form)) then
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
              (Elem_read w__6 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
              (let op2 = (Word.sint w__7) in
              return op2)))))
            else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
           (SignedSatQ
              ((shr_int
                  ((((op3 + (((( 2 :: int)::ii) * ((op1 * op2)))))) +
                      round_const)) esize)) esize
             :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__8 :: (( 'esize::len)Word.word * bool)) . 
           (let (tup__0, tup__1) = w__8 in
           (let (result :: ( 'esize::len)Word.word) = tup__0 in
           (let (sat :: bool) = tup__1 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
           (Elem_set w__9 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
           (D_set ((d + r)) w__10 \<then>
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__11 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () )) \<then>
           return (op1, op2, op3, result, sat)))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (op3 ::
     ii), (result :: ( 'esize::len)Word.word), (sat :: bool)) = varstup in
   return () ))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "scalar_form"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLAH_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLAH_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLAH_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let index1 = index1 in
     (let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs False)))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let index1 = index1 in
     (let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs False)))))))))
   else
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () ))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLAH_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLAH_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLAH_A2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 4 :: int)::ii)) in
     (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
     (let (index1 :: ii) =
       (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33462.43-33462.44'') \<then>
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs True))))))))))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 2 :: int)::ii)) in
     (let (m :: ii) = (Word.uint Vm) in
     (let (index1 :: ii) = (Word.uint M) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33462.43-33462.44'') \<then>
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs True))))))))))))))))))
   else throw (Error_See (''Related encodings'')))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLAH_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLAH_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLAH_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     ((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     throw (Error_Undefined () )))))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let index1 = index1 in
     (let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs False)))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     ((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let index1 = index1 in
     (let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs False)))))))))))
   else
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     throw (Error_Undefined () ))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLAH_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLAH_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLAH_T2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then throw (Error_Unpredictable () ) else return () ) \<then> throw (Error_Undefined () )))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 4 :: int)::ii)) in
     (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
     (let (index1 :: ii) =
       (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33563.43-33563.44'') \<then>
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs True))))))))))))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     ((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let add = True in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 2 :: int)::ii)) in
     (let (m :: ii) = (Word.uint Vm) in
     (let (index1 :: ii) = (Word.uint M) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33563.43-33563.44'') \<then>
     execute_aarch32_instrs_VQRDMLAH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs True))))))))))))))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     throw (Error_See (''Related encodings'')))))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQRDMLSH_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQRDMLSH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQRDMLSH_Op_A_txt d__arg elements esize index1 m n regs scalar_form = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op3 :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let round_const = (shl_int (( 1 :: int)::ii) ((esize - (( 1 :: int)::ii)))) in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2 :: ii) . 
   (if scalar_form then
      (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (Elem_read w__0 index1 esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
      (let op2 = (Word.sint w__1) in
      return op2)))))
    else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, op3, result, sat)
     ((\<lambda> r varstup .  (let (op1, op2, op3, result, sat) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, op3, result, sat)
         ((\<lambda> e varstup .  (let (op1, op2, op3, result, sat) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op1 = (Word.sint w__3) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
           (let op3 = (shl_int ((Word.sint w__5)) esize) in
           (if ((\<not> scalar_form)) then
              (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
              (Elem_read w__6 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
              (let op2 = (Word.sint w__7) in
              return op2)))))
            else return op2) \<bind> ((\<lambda> (op2 :: ii) . 
           (SignedSatQ
              ((shr_int
                  ((((op3 - (((( 2 :: int)::ii) * ((op1 * op2)))))) +
                      round_const)) esize)) esize
             :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__8 :: (( 'esize::len)Word.word * bool)) . 
           (let (tup__0, tup__1) = w__8 in
           (let (result :: ( 'esize::len)Word.word) = tup__0 in
           (let (sat :: bool) = tup__1 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
           (Elem_set w__9 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
           (D_set ((d + r)) w__10 \<then>
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__11 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () )) \<then>
           return (op1, op2, op3, result, sat)))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ii), (op2 :: ii), (op3 ::
     ii), (result :: ( 'esize::len)Word.word), (sat :: bool)) = varstup in
   return () ))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "scalar_form"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLSH_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLSH_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLSH_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let index1 = index1 in
     (let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs False)))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let index1 = index1 in
     (let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs False)))))))))
   else
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () ))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLSH_A2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLSH_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLSH_A2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 4 :: int)::ii)) in
     (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
     (let (index1 :: ii) =
       (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33691.43-33691.44'') \<then>
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs True))))))))))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 2 :: int)::ii)) in
     (let (m :: ii) = (Word.uint Vm) in
     (let (index1 :: ii) = (Word.uint M) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33691.43-33691.44'') \<then>
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs True))))))))))))))))))
   else throw (Error_See (''Related encodings'')))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLSH_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLSH_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLSH_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     ((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     throw (Error_Undefined () )))))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let index1 = index1 in
     (let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs False)))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     ((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let index1 = index1 in
     (let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs False)))))))))))
   else
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     throw (Error_Undefined () ))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRDMLSH_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRDMLSH_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRDMLSH_T2enc_A_txt Q D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then throw (Error_Unpredictable () ) else return () ) \<then> throw (Error_Undefined () )))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 4 :: int)::ii)) in
     (let (m :: ii) = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
     (let (index1 :: ii) =
       (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33792.43-33792.44'') \<then>
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs True))))))))))))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     ((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let add = False in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 8 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 2 :: int)::ii)) in
     (let (m :: ii) = (Word.uint Vm) in
     (let (index1 :: ii) = (Word.uint M) in
     (let m = m in
     (let index1 = index1 in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))) (''src/instrs32.sail:33792.43-33792.44'') \<then>
     execute_aarch32_instrs_VQRDMLSH_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       index1 m n regs True))))))))))))))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     throw (Error_See (''Related encodings'')))))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQRSHL_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQRSHL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQRSHL_Op_A_txt d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (round_const :: ii) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand, result, round_const, sat, shift)
     ((\<lambda> r varstup .  (let (operand, result, round_const, sat, shift) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand,
                                                                result,
                                                                round_const,
                                                                sat,
                                                                shift)
         ((\<lambda> e varstup .  (let (operand, result, round_const, sat, shift) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let shift = (Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
           (let (round_const :: ii) =
             (shl_int_general (( 1 :: int)::ii) ((((- (( 1 :: int)::ii))) - shift))) in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let operand = (asl_Int w__3 is_unsigned) in
           (SatQ ((shl_int_general ((operand + round_const)) shift)) esize is_unsigned
             :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__4 :: (( 'esize::len)Word.word * bool)) . 
           (let (tup__0, tup__1) = w__4 in
           (let (result :: ( 'esize::len)Word.word) = tup__0 in
           (let (sat :: bool) = tup__1 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           (Elem_set w__5 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (D_set ((d + r)) w__6 \<then>
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__7 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () )) \<then>
           return (operand, result, round_const, sat, shift))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand ::
     ii), (result :: ( 'esize::len)Word.word), (round_const :: ii), (sat :: bool), (shift :: ii)) = varstup in
   return () )))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRSHL_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRSHL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRSHL_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRSHL_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRSHL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRSHL_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQRSHL_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQRSHRN_Op_A_txt : integer -> bool -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQRSHRN_Op_A_txt  :: \<open> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQRSHRN_Op_A_txt d__arg dest_unsigned elements l__223 m shift_amount src_unsigned = (
   if (((l__223 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (result :: 8 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat)
       ((\<lambda> e varstup .  (let (operand, result, sat) = varstup in
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (let operand = (asl_Int w__1 src_unsigned) in
         (SatQ ((shr_int_general ((operand + round_const)) shift_amount)) (( 8 :: int)::ii)
            dest_unsigned
           :: (( 8 Word.word * bool)) M) \<bind> ((\<lambda> (w__2 :: ( 8 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__2 in
         (let (result :: 8 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         (Elem_set w__3 e (( 8 :: int)::ii) result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (D_set d w__4 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__5 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (operand, result, sat))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::  8 Word.word), (sat ::
       bool)) = varstup in
     return () ))))))))))))))
   else if (((l__223 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat)
       ((\<lambda> e varstup .  (let (operand, result, sat) = varstup in
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_read w__6 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (let operand = (asl_Int w__7 src_unsigned) in
         (SatQ ((shr_int_general ((operand + round_const)) shift_amount)) (( 16 :: int)::ii)
            dest_unsigned
           :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> (w__8 :: ( 16 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__8 in
         (let (result :: 16 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
         (Elem_set w__9 e (( 16 :: int)::ii) result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (D_set d w__10 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__11 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (operand, result, sat))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::
        16 Word.word), (sat :: bool)) = varstup in
     return () ))))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 32 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat)
       ((\<lambda> e varstup .  (let (operand, result, sat) = varstup in
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         (Elem_read w__12 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         (let operand = (asl_Int w__13 src_unsigned) in
         (SatQ ((shr_int_general ((operand + round_const)) shift_amount)) (( 32 :: int)::ii)
            dest_unsigned
           :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> (w__14 :: ( 32 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__14 in
         (let (result :: 32 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         (Elem_set w__15 e (( 32 :: int)::ii) result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
         (D_set d w__16 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__17 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (operand, result, sat))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::
        32 Word.word), (sat :: bool)) = varstup in
     return () )))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "dest_unsigned"  :: " bool " 
  and  "elements"  :: " int " 
  and  "l__223"  :: " int " 
  and  "m"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "src_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRSHRN_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRSHRN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRSHRN_A1enc_A_txt U D imm6 Vd op1 M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VRSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VRSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VRSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VRSHRN''))
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let (src_unsigned :: bool) =
       ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
     (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount
       src_unsigned))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQRSHRN_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQRSHRN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQRSHRN_T1enc_A_txt U D imm6 Vd op1 M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VRSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VRSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VRSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VRSHRN''))
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let (src_unsigned :: bool) =
       ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
     (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount
       src_unsigned))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQSHL_i_Op_A_txt : forall 'esize. Size 'esize => integer -> bool -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQSHL_i_Op_A_txt  :: \<open> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQSHL_i_Op_A_txt d__arg dest_unsigned elements esize m regs shift_amount src_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand, result, sat)
     ((\<lambda> r varstup .  (let (operand, result, sat) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat)
         ((\<lambda> e varstup .  (let (operand, result, sat) = varstup in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let operand = (asl_Int w__1 src_unsigned) in
           (SatQ ((shl_int_general operand shift_amount)) esize dest_unsigned
             :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__2 :: (( 'esize::len)Word.word * bool)) . 
           (let (tup__0, tup__1) = w__2 in
           (let (result :: ( 'esize::len)Word.word) = tup__0 in
           (let (sat :: bool) = tup__1 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_set w__3 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (D_set ((d + r)) w__4 \<then>
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__5 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () )) \<then>
           return (operand, result, sat))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::
     ( 'esize::len)Word.word), (sat :: bool)) = varstup in
   return () )))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "dest_unsigned"  :: " bool " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "src_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSHL_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSHL_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSHL_i_A1enc_A_txt U D imm6 Vd op1 L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = (Word.uint imm6) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (src_unsigned :: bool) =
       ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
     (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__219 = esize in
     if (((l__219 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs shift_amount src_unsigned
     else if (((l__219 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m regs shift_amount src_unsigned
     else if (((l__219 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m regs shift_amount src_unsigned
     else if (((l__219 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m regs shift_amount src_unsigned
     else assert_exp False (''src/instrs32.sail:34133.26-34133.27'') \<then> exit0 () ))))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSHL_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSHL_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSHL_i_T1enc_A_txt U D imm6 Vd op1 L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = (Word.uint imm6) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (src_unsigned :: bool) =
       ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
     (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__215 = esize in
     if (((l__215 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs shift_amount src_unsigned
     else if (((l__215 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m regs shift_amount src_unsigned
     else if (((l__215 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m regs shift_amount src_unsigned
     else if (((l__215 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m regs shift_amount src_unsigned
     else assert_exp False (''src/instrs32.sail:34218.26-34218.27'') \<then> exit0 () ))))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQSHL_r_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQSHL_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQSHL_r_Op_A_txt d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand, result, sat, shift)
     ((\<lambda> r varstup .  (let (operand, result, sat, shift) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat, shift)
         ((\<lambda> e varstup .  (let (operand, result, sat, shift) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let shift = (Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let operand = (asl_Int w__3 is_unsigned) in
           (SatQ ((shl_int_general operand shift)) esize is_unsigned  :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> (w__4 ::
             (( 'esize::len)Word.word * bool)) . 
           (let (tup__0, tup__1) = w__4 in
           (let (result :: ( 'esize::len)Word.word) = tup__0 in
           (let (sat :: bool) = tup__1 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           (Elem_set w__5 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           (D_set ((d + r)) w__6 \<then>
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__7 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () )) \<then>
           return (operand, result, sat, shift)))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::
     ( 'esize::len)Word.word), (sat :: bool), (shift :: ii)) = varstup in
   return () )))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSHL_r_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSHL_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSHL_r_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSHL_r_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSHL_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSHL_r_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         n regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQSHL_r_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQSHRN_Op_A_txt : integer -> bool -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQSHRN_Op_A_txt  :: \<open> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQSHRN_Op_A_txt d__arg dest_unsigned elements l__213 m shift_amount src_unsigned = (
   if (((l__213 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (result :: 8 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat)
       ((\<lambda> e varstup .  (let (operand, result, sat) = varstup in
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (let operand = (asl_Int w__1 src_unsigned) in
         (SatQ ((shr_int_general operand shift_amount)) (( 8 :: int)::ii) dest_unsigned
           :: (( 8 Word.word * bool)) M) \<bind> ((\<lambda> (w__2 :: ( 8 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__2 in
         (let (result :: 8 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         (Elem_set w__3 e (( 8 :: int)::ii) result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (D_set d w__4 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__5 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (operand, result, sat))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::  8 Word.word), (sat ::
       bool)) = varstup in
     return () )))))))))))))
   else if (((l__213 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat)
       ((\<lambda> e varstup .  (let (operand, result, sat) = varstup in
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_read w__6 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (let operand = (asl_Int w__7 src_unsigned) in
         (SatQ ((shr_int_general operand shift_amount)) (( 16 :: int)::ii) dest_unsigned
           :: (( 16 Word.word * bool)) M) \<bind> ((\<lambda> (w__8 :: ( 16 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__8 in
         (let (result :: 16 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
         (Elem_set w__9 e (( 16 :: int)::ii) result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (D_set d w__10 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__11 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (operand, result, sat))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::
        16 Word.word), (sat :: bool)) = varstup in
     return () )))))))))))))
   else
     \<comment> \<open>\<open> 'esize == 32 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (operand :: ii) . 
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (operand, result, sat)
       ((\<lambda> e varstup .  (let (operand, result, sat) = varstup in
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         (Elem_read w__12 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         (let operand = (asl_Int w__13 src_unsigned) in
         (SatQ ((shr_int_general operand shift_amount)) (( 32 :: int)::ii) dest_unsigned
           :: (( 32 Word.word * bool)) M) \<bind> ((\<lambda> (w__14 :: ( 32 Word.word * bool)) . 
         (let (tup__0, tup__1) = w__14 in
         (let (result :: 32 bits) = tup__0 in
         (let (sat :: bool) = tup__1 in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         (Elem_set w__15 e (( 32 :: int)::ii) result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
         (D_set d w__16 \<then>
         (if sat then
            (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
            FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__17 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
          else return () )) \<then>
         return (operand, result, sat))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand :: ii), (result ::
        32 Word.word), (sat :: bool)) = varstup in
     return () ))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "dest_unsigned"  :: " bool " 
  and  "elements"  :: " int " 
  and  "l__213"  :: " int " 
  and  "m"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "src_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSHRN_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSHRN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSHRN_A1enc_A_txt U D imm6 Vd op1 M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VSHRN''))
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let (src_unsigned :: bool) =
       ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
     (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount
       src_unsigned))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSHRN_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSHRN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSHRN_T1enc_A_txt U D imm6 Vd op1 M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
          throw (Error_See (''VSHRN''))
        else return () )) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let (src_unsigned :: bool) =
         ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
       (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount
         src_unsigned)))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((U = ( 0b0 ::  1 Word.word)))) \<and> (((op1 = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VSHRN''))
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let (src_unsigned :: bool) =
       ((((U = ( 0b1 ::  1 Word.word)))) \<and> (((op1 = ( 0b1 ::  1 Word.word))))) in
     (let (dest_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount
       src_unsigned))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VQSUB_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VQSUB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VQSUB_Op_A_txt d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (diff :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) diff
     ((\<lambda> r diff . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) diff
         ((\<lambda> e diff . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let diff = (((asl_Int w__1 is_unsigned)) - ((asl_Int w__3 is_unsigned))) in
           undefined_bool 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sat :: bool) . 
           (SatQ diff esize is_unsigned  :: ((( 'esize::len)Word.word * bool)) M) \<bind> ((\<lambda> varstup .  (let ((tup_00 ::
             ( 'esize::len)Word.word), (tup_10 :: bool)) = varstup in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize tup_00  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then>
           ((let (sat :: bool) = tup_10 in
           (if sat then
              (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
              FPSCR_write ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__6 (( 27 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word))))
            else return () ) \<then>
           return diff)))))))))))))))))))))))))))) \<bind> ((\<lambda> (diff :: ii) . 
   return () ))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSUB_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSUB_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSUB_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSUB_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSUB_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSUB_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQSUB_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VQSUB_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VQSUB_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VQSUB_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSUB_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSUB_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VQSUB_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VQSUB_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRADDHN_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRADDHN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRADDHN_Op_A_txt d__arg elements l__210 m n = (
   if (((l__210 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::  128 Word.word) . 
         (Elem_read w__2 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
         (let result = ((add_vec_int ((add_vec w__1 w__3  ::  16 Word.word)) (( 128 :: int)::ii)  ::  16 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_set w__4 e (( 8 :: int)::ii) ((subrange_vec_dec result (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
         D_set d w__5 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  16 Word.word) . 
     return () ))))))))
   else if (((l__210 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_read w__6 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
         (Elem_read w__8 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (let result = ((add_vec_int ((add_vec w__7 w__9  ::  32 Word.word)) (( 32768 :: int)::ii)  ::  32 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (Elem_set w__10 e (( 16 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  32 Word.word) . 
     return () ))))))))
   else if (((l__210 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         (Elem_read w__12 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_read w__14 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         (let result =
           ((add_vec_int ((add_vec w__13 w__15  ::  64 Word.word)) (( 2147483648 :: int)::ii)  ::  64 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
         (Elem_set w__16 e (( 32 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
         D_set d w__17 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (result :: 128 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
         (Elem_read w__18 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__20 ::  128 Word.word) . 
         (Elem_read w__20 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
         (let result =
           ((add_vec_int ((add_vec w__19 w__21  ::  128 Word.word)) (( 9223372036854775808 :: int)::ii)
             ::  128 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
         (Elem_set w__22 e (( 64 :: int)::ii) ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
         D_set d w__23 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  128 Word.word) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__210"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRADDHN_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRADDHN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRADDHN_A1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRADDHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRADDHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRADDHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRADDHN_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRADDHN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRADDHN_T1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRADDHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRADDHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRADDHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRECPE_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRECPE_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRECPE_Op_A_txt d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           if floating_point then
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
             (FPRecipEstimate w__2 w__3  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
             (Elem_set w__0 e esize w__4  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             D_set ((d + r)) w__5))))))))))))
           else
             (assert_exp (((((id0 esize)) = (( 32 :: int)::ii)))) (''src/instrs32.sail:34657.47-34657.48'') \<then>
             (D_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
             (Elem_read w__7 e esize  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
             (UnsignedRecipEstimate w__8  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
             (Elem_set w__6 e esize w__9  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
             D_set ((d + r)) w__10))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRECPE_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRECPE_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRECPE_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((True \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> False))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRECPE_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRECPE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
   if w__2 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRECPE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRECPE_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRECPE_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRECPE_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((True \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> False))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       and_boolM (return True) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
       (if w__2 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRECPE_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRECPE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
   if w__4 then
     (((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__6 :: bool) . 
     (if w__6 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRECPE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRECPS_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRECPS_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRECPS_Op_A_txt d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (FPRecipStep w__2 w__4  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize w__5  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           D_set ((d + r)) w__6))))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRECPS_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRECPS_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRECPS_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRECPS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRECPS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRECPS_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRECPS_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRECPS_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRECPS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRECPS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VREV16_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VREV16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container esize m regs = (
   (let esize = (size_itself_int esize) in
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (result :: 64 bits) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (rev_element :: ii) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (element, result, rev_element)
     ((\<lambda> r varstup .  (let (element, result, rev_element) = varstup in
       (let (element :: ii) = ((( 0 :: int)::ii)) in
       (let loop_c_lower = ((( 0 :: int)::ii)) in
       (let loop_c_upper = (containers - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_c_lower loop_c_upper (( 1 :: int)::ii)) (element, result, rev_element)
         ((\<lambda> c varstup .  (let (element, result, rev_element) = varstup in
           (let (rev_element :: ii) =
             (((element + elements_per_container)) - (( 1 :: int)::ii)) in
           (let loop_e_lower = ((( 0 :: int)::ii)) in
           (let loop_e_upper = (elements_per_container - (( 1 :: int)::ii)) in
           (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (element, result, rev_element)
             ((\<lambda> e varstup .  (let (element, result, rev_element) = varstup in
               (let rev_element = rev_element in
               (let element = element in
               (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
               (Elem_read w__0 element esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
               (Elem_set result rev_element esize w__1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
               (let result = w__2 in
               (let (element :: ii) = (element + (( 1 :: int)::ii)) in
               (let (rev_element :: ii) = (rev_element - (( 1 :: int)::ii)) in
               return (element, result, rev_element))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element :: ii), (result ::
          64 Word.word), (rev_element :: ii)) = varstup in
       D_set ((d + r)) result \<then> return (element, result, rev_element))))))))))) \<bind> ((\<lambda> varstup .  (let ((element ::
     ii), (result ::  64 Word.word), (rev_element :: ii)) = varstup in
   return () )))))))))))))\<close> 
  for  "containers"  :: " int " 
  and  "d"  :: " int " 
  and  "elements_per_container"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VREV16_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VREV16_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VREV16_A1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((Word.uint op1)) + (( 0 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (container_size :: int) = ((( 16 :: int)::ii)) in
       (let b__1 = op1 in
       (let (container_size :: int) =
         (if (((b__1 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
         else if (((b__1 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
         else if (((b__1 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
         else container_size) in
       (let container_size = container_size in
       (let containers = ((( 64 :: int)::ii) div container_size) in
       (let elements_per_container = (container_size div (( 8 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
         ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((((((Word.uint op1)) + (( 1 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (container_size :: int) = ((( 16 :: int)::ii)) in
       (let b__5 = op1 in
       (let (container_size :: int) =
         (if (((b__5 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
         else if (((b__5 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
         else if (((b__5 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
         else container_size) in
       (let container_size = container_size in
       (let containers = ((( 64 :: int)::ii) div container_size) in
       (let elements_per_container = (container_size div (( 16 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m regs))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((((((Word.uint op1)) + (( 2 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (container_size :: int) = ((( 16 :: int)::ii)) in
       (let b__9 = op1 in
       (let (container_size :: int) =
         (if (((b__9 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
         else if (((b__9 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
         else if (((b__9 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
         else container_size) in
       (let container_size = container_size in
       (let containers = ((( 64 :: int)::ii) div container_size) in
       (let elements_per_container = (container_size div (( 32 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((((((Word.uint op1)) + (( 3 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (container_size :: int) = ((( 16 :: int)::ii)) in
     (let b__12 = op1 in
     (let (container_size :: int) =
       (if (((b__12 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
       else if (((b__12 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
       else if (((b__12 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
       else container_size) in
     (let container_size = container_size in
     (let containers = ((( 64 :: int)::ii) div container_size) in
     (let elements_per_container = (container_size div (( 64 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m regs))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VREV16_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VREV16_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VREV16_T1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((Word.uint op1)) + (( 0 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (container_size :: int) = ((( 16 :: int)::ii)) in
       (let b__1 = op1 in
       (let (container_size :: int) =
         (if (((b__1 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
         else if (((b__1 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
         else if (((b__1 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
         else container_size) in
       (let container_size = container_size in
       (let containers = ((( 64 :: int)::ii) div container_size) in
       (let elements_per_container = (container_size div (( 8 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
         ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((((((Word.uint op1)) + (( 1 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (container_size :: int) = ((( 16 :: int)::ii)) in
       (let b__5 = op1 in
       (let (container_size :: int) =
         (if (((b__5 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
         else if (((b__5 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
         else if (((b__5 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
         else container_size) in
       (let container_size = container_size in
       (let containers = ((( 64 :: int)::ii) div container_size) in
       (let elements_per_container = (container_size div (( 16 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m regs))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((((((Word.uint op1)) + (( 2 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (container_size :: int) = ((( 16 :: int)::ii)) in
       (let b__9 = op1 in
       (let (container_size :: int) =
         (if (((b__9 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
         else if (((b__9 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
         else if (((b__9 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
         else container_size) in
       (let container_size = container_size in
       (let containers = ((( 64 :: int)::ii) div container_size) in
       (let elements_per_container = (container_size div (( 32 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m regs))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((((((Word.uint op1)) + (( 3 :: int)::ii))) \<ge> (( 3 :: int)::ii))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (container_size :: int) = ((( 16 :: int)::ii)) in
     (let b__12 = op1 in
     (let (container_size :: int) =
       (if (((b__12 = ( 0b10 ::  2 Word.word)))) then (( 16 :: int)::ii)
       else if (((b__12 = ( 0b01 ::  2 Word.word)))) then (( 32 :: int)::ii)
       else if (((b__12 = ( 0b00 ::  2 Word.word)))) then (( 64 :: int)::ii)
       else container_size) in
     (let container_size = container_size in
     (let containers = ((( 64 :: int)::ii) div container_size) in
     (let elements_per_container = (container_size div (( 64 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m regs))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(2)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRHADD_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRHADD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRHADD_Op_A_txt d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2, result)
     ((\<lambda> r varstup .  (let (op1, op2, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2, result)
         ((\<lambda> e varstup .  (let (op1, op2, result) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = (asl_Int w__1 is_unsigned) in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let op2 = (asl_Int w__3 is_unsigned) in
           (let (result :: ii) = (((op1 + op2)) + (( 1 :: int)::ii)) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize ((integer_subrange result esize (( 1 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (op1, op2, result)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ii), (op2 :: ii), (result :: ii)) = varstup in
   return () )))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRHADD_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRHADD_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRHADD_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRHADD_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRHADD_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRHADD_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRHADD_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRHADD_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRHADD_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRHADD_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRHADD_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRHADD_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRSHL_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRSHL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRSHL_Op_A_txt d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (round_const :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (result, round_const, shift)
     ((\<lambda> r varstup .  (let (result, round_const, shift) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (result, round_const, shift)
         ((\<lambda> e varstup .  (let (result, round_const, shift) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let shift = (Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
           (let (round_const :: ii) =
             (shl_int_general (( 1 :: int)::ii) ((((- shift)) - (( 1 :: int)::ii)))) in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let result =
             (shl_int_general ((((asl_Int w__3 is_unsigned)) + round_const)) shift) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize
              ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (result, round_const, shift)))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((result ::
     ii), (round_const :: ii), (shift :: ii)) = varstup in
   return () )))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSHL_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSHL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSHL_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSHL_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSHL_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSHL_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRSHL_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSHL_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSHL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSHL_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSHL_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSHL_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSHL_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRSHL_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRSHR_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRSHR_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRSHR_Op_A_txt d__arg elements esize m regs shift_amount is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
     ((\<lambda> r result . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let result =
             (shr_int_general ((((asl_Int w__1 is_unsigned)) + round_const)) shift_amount) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_set w__2 e esize
              ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           D_set ((d + r)) w__3 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
   return () )))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSHR_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSHR_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSHR_A1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__206 = esize in
     if (((l__206 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__206 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__206 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__206 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:35244.26-35244.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSHR_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSHR_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSHR_T1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__202 = esize in
     if (((l__202 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__202 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__202 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__202 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VRSHR_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:35324.26-35324.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRSHRN_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRSHRN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRSHRN_Op_A_txt d__arg elements l__200 m shift_amount = (
   if (((l__200 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (let result =
           ((shiftr ((add_vec_int w__1 round_const  ::  16 Word.word)) shift_amount  ::  16 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
         (Elem_set w__2 e (( 8 :: int)::ii) ((subrange_vec_dec result (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         D_set d w__3 \<then> return result)))))))))))) \<bind> ((\<lambda> (result ::  16 Word.word) . 
     return () )))))))))
   else if (((l__200 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__4 ::  128 Word.word) . 
         (Elem_read w__4 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
         (let result =
           ((shiftr ((add_vec_int w__5 round_const  ::  32 Word.word)) shift_amount  ::  32 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
         (Elem_set w__6 e (( 16 :: int)::ii) ((subrange_vec_dec result (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
         D_set d w__7 \<then> return result)))))))))))) \<bind> ((\<lambda> (result ::  32 Word.word) . 
     return () )))))))))
   else
     \<comment> \<open>\<open> 'esize == 32 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
         (Elem_read w__8 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
         (let result =
           ((shiftr ((add_vec_int w__9 round_const  ::  64 Word.word)) shift_amount  ::  64 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (Elem_set w__10 e (( 32 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11 \<then> return result)))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
     return () ))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__200"  :: " int " 
  and  "m"  :: " int " 
  and  "shift_amount"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSHRN_A1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSHRN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSHRN_A1enc_A_txt D imm6 Vd M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSHRN_T1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSHRN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSHRN_T1enc_A_txt D imm6 Vd M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VRSHRN_Op_A_txt d (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRSQRTE_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRSQRTE_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRSQRTE_Op_A_txt d__arg elements esize floating_point m regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           if floating_point then
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
             (FPRSqrtEstimate w__2 w__3  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
             (Elem_set w__0 e esize w__4  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             D_set ((d + r)) w__5))))))))))))
           else
             (assert_exp (((((id0 esize)) = (( 32 :: int)::ii)))) (''src/instrs32.sail:35479.47-35479.48'') \<then>
             (D_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
             (Elem_read w__7 e esize  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
             (UnsignedRSqrtEstimate w__8  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
             (Elem_set w__6 e esize w__9  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
             D_set ((d + r)) w__10))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "floating_point"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSQRTE_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSQRTE_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSQRTE_A1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((True \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> False))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSQRTE_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSQRTE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
   if w__2 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRSQRTE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSQRTE_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSQRTE_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSQRTE_T1enc_A_txt D b__0 Vd F Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((True \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> False))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       and_boolM (return True) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
       (if w__2 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSQRTE_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
         floating_point m regs)))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSQRTE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
         floating_point m regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
   if w__4 then
     (((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((False \<or> (((F = ( 0b0 ::  1 Word.word)))))))))) \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__6 :: bool) . 
     (if w__6 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (floating_point :: bool) = (F = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRSQRTE_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       floating_point m regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRSQRTS_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRSQRTS_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRSQRTS_Op_A_txt d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (FPRSqrtStep w__2 w__4  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize w__5  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
           D_set ((d + r)) w__6))))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSQRTS_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSQRTS_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSQRTS_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSQRTS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRSQRTS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSQRTS_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSQRTS_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSQRTS_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VRSQRTS_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRSQRTS_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRSRA_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRSRA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRSRA_Op_A_txt d__arg elements esize m regs shift_amount is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let round_const = (shl_int_general (( 1 :: int)::ii) ((shift_amount - (( 1 :: int)::ii)))) in
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
     ((\<lambda> r result . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let result =
             (shr_int_general ((((asl_Int w__1 is_unsigned)) + round_const)) shift_amount) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (Elem_set w__2 e esize ((add_vec_int w__4 result  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::
              64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return result))))))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
   return () )))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSRA_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSRA_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSRA_A1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__196 = esize in
     if (((l__196 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__196 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__196 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__196 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:35767.26-35767.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSRA_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSRA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSRA_T1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__192 = esize in
     if (((l__192 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__192 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__192 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__192 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VRSRA_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:35847.26-35847.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRSUBHN_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRSUBHN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRSUBHN_Op_A_txt d__arg elements l__189 m n = (
   if (((l__189 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::  128 Word.word) . 
         (Elem_read w__2 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
         (let result = ((add_vec_int ((sub_vec w__1 w__3  ::  16 Word.word)) (( 128 :: int)::ii)  ::  16 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_set w__4 e (( 8 :: int)::ii) ((subrange_vec_dec result (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
         D_set d w__5 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  16 Word.word) . 
     return () ))))))))
   else if (((l__189 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_read w__6 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
         (Elem_read w__8 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (let result = ((add_vec_int ((sub_vec w__7 w__9  ::  32 Word.word)) (( 32768 :: int)::ii)  ::  32 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (Elem_set w__10 e (( 16 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  32 Word.word) . 
     return () ))))))))
   else if (((l__189 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         (Elem_read w__12 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_read w__14 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         (let result =
           ((add_vec_int ((sub_vec w__13 w__15  ::  64 Word.word)) (( 2147483648 :: int)::ii)  ::  64 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
         (Elem_set w__16 e (( 32 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
         D_set d w__17 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (result :: 128 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
         (Elem_read w__18 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__20 ::  128 Word.word) . 
         (Elem_read w__20 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
         (let result =
           ((add_vec_int ((sub_vec w__19 w__21  ::  128 Word.word)) (( 9223372036854775808 :: int)::ii)
             ::  128 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
         (Elem_set w__22 e (( 64 :: int)::ii) ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
         D_set d w__23 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  128 Word.word) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__189"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSUBHN_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSUBHN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSUBHN_A1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSUBHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSUBHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSUBHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRSUBHN_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRSUBHN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRSUBHN_T1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSUBHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSUBHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VRSUBHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSHL_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSHL_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSHL_i_Op_A_txt d__arg elements esize m regs shift_amount = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize ((shiftl w__2 shift_amount  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::
              64 Word.word) . 
           D_set ((d + r)) w__3))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHL_i_A1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHL_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHL_i_A1enc_A_txt D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = (Word.uint imm6) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__185 = esize in
     if (((l__185 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount
     else if (((l__185 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount
     else if (((l__185 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount
     else if (((l__185 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount
     else assert_exp False (''src/instrs32.sail:36019.26-36019.27'') \<then> exit0 () ))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHL_i_T1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHL_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHL_i_T1enc_A_txt D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = (Word.uint imm6) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__181 = esize in
     if (((l__181 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount
     else if (((l__181 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount
     else if (((l__181 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount
     else if (((l__181 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSHL_i_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount
     else assert_exp False (''src/instrs32.sail:36097.26-36097.27'') \<then> exit0 () ))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSHLL_Op_A_txt : integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSHLL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSHLL_Op_A_txt d__arg elements l__178 m shift_amount is_unsigned = (
   if (((l__178 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
         (Elem_read w__0 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
         (let result = (shl_int_general ((asl_Int w__1 is_unsigned)) shift_amount) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::  128 Word.word) . 
         (Elem_set w__2 e (( 16 :: int)::ii) ((integer_subrange result (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__3 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__3 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__178 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_read w__4 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
         (let result = (shl_int_general ((asl_Int w__5 is_unsigned)) shift_amount) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_set w__6 e (( 32 :: int)::ii) ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__7 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__178 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
         (Elem_read w__8 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (let result = (shl_int_general ((asl_Int w__9 is_unsigned)) shift_amount) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__10 ::  128 Word.word) . 
         (Elem_set w__10 e (( 64 :: int)::ii) ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__11 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__11 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
         (Elem_read w__12 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         (let result = (shl_int_general ((asl_Int w__13 is_unsigned)) shift_amount) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_set w__14 e (( 128 :: int)::ii) ((integer_subrange result (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__15 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__15 \<then> return result)))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__178"  :: " int " 
  and  "m"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHLL_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHLL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHLL_A1enc_A_txt U D imm6 Vd M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
       (let shift_amount = shift_amount in
       (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
        else return () ) \<then>
       ((let shift_amount = shift_amount in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount is_unsigned))))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
       (let shift_amount = shift_amount in
       (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
        else return () ) \<then>
       ((let shift_amount = shift_amount in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount is_unsigned))))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
       (let shift_amount = shift_amount in
       (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
        else return () ) \<then>
       ((let shift_amount = shift_amount in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount is_unsigned))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
      else return () ) \<then>
     ((let shift_amount = shift_amount in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VSHLL_Op_A_txt d (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount is_unsigned)))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHLL_A2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHLL_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHLL_A2enc_A_txt D b__0 Vd M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m (( 8 :: int)::ii) False)))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m (( 16 :: int)::ii) False)))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m (( 32 :: int)::ii) False)))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHLL_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHLL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHLL_T1enc_A_txt U D imm6 Vd M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
       (let shift_amount = shift_amount in
       (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
        else return () ) \<then>
       ((let shift_amount = shift_amount in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount is_unsigned))))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
       (let shift_amount = shift_amount in
       (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
        else return () ) \<then>
       ((let shift_amount = shift_amount in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount is_unsigned))))))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
       (let shift_amount = shift_amount in
       (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
        else return () ) \<then>
       ((let shift_amount = shift_amount in
       (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount is_unsigned))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (if (((shift_amount = (( 0 :: int)::ii)))) then throw (Error_See (''VMOVL''))
      else return () ) \<then>
     ((let shift_amount = shift_amount in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VSHLL_Op_A_txt d (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount is_unsigned)))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHLL_T2enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHLL_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHLL_T2enc_A_txt D b__0 Vd M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m (( 8 :: int)::ii) False)))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m (( 16 :: int)::ii) False)))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((False \<or> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHLL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m (( 32 :: int)::ii) False)))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSHL_r_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSHL_r_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSHL_r_Op_A_txt d__arg elements esize m n regs is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (result, shift)
     ((\<lambda> r varstup .  (let (result, shift) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (result, shift)
         ((\<lambda> e varstup .  (let (result, shift) = varstup in
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let shift = (Word.sint ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let result = (shl_int_general ((asl_Int w__3 is_unsigned)) shift) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize
              ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (result, shift))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((result ::
     ii), (shift :: ii)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHL_r_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHL_r_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHL_r_A1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHL_r_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHL_r_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHL_r_T1enc_A_txt U D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSHL_r_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs is_unsigned))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSHR_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSHR_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSHR_Op_A_txt d__arg elements esize m regs shift_amount is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
     ((\<lambda> r result . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let result = (shr_int_general ((asl_Int w__1 is_unsigned)) shift_amount) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_set w__2 e esize
              ((integer_subrange result ((esize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           D_set ((d + r)) w__3 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
   return () ))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHR_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHR_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHR_A1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__174 = esize in
     if (((l__174 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__174 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__174 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__174 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:36466.26-36466.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHR_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHR_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHR_T1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__170 = esize in
     if (((l__170 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__170 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__170 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__170 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSHR_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:36546.26-36546.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSHRN_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSHRN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSHRN_Op_A_txt d__arg elements l__168 m shift_amount = (
   if (((l__168 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (let result = ((shiftr w__1 shift_amount  ::  16 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
         (Elem_set w__2 e (( 8 :: int)::ii) ((subrange_vec_dec result (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         D_set d w__3 \<then> return result)))))))))))) \<bind> ((\<lambda> (result ::  16 Word.word) . 
     return () ))))))))
   else if (((l__168 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__4 ::  128 Word.word) . 
         (Elem_read w__4 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
         (let result = ((shiftr w__5 shift_amount  ::  32 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
         (Elem_set w__6 e (( 16 :: int)::ii) ((subrange_vec_dec result (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
         D_set d w__7 \<then> return result)))))))))))) \<bind> ((\<lambda> (result ::  32 Word.word) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 32 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
         (Elem_read w__8 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
         (let result = ((shiftr w__9 shift_amount  ::  64 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (Elem_set w__10 e (( 32 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11 \<then> return result)))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__168"  :: " int " 
  and  "m"  :: " int " 
  and  "shift_amount"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHRN_A1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHRN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHRN_A1enc_A_txt D imm6 Vd M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHRN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHRN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHRN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VSHRN_Op_A_txt d (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSHRN_T1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSHRN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSHRN_T1enc_A_txt D imm6 Vd M Vm = (
   if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       ((if ((let b__0 = imm6 in
          if (((((subrange_vec_dec b__0 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 8 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHRN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ((if ((let b__1 = imm6 in
          if (((((subrange_vec_dec b__1 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 4 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHRN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else if (((((subrange_vec_dec imm6 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if ((let b__2 = imm6 in
          if (((((subrange_vec_dec b__2 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
          then
            True
          else False)) then
          throw (Error_See (''Related encodings''))
        else return () ) \<then>
       (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (esize :: int) = ((( 8 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
       (let shift_amount = shift_amount in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSHRN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m shift_amount)))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     ((if ((let b__3 = imm6 in
        if (((((subrange_vec_dec b__3 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let shift_amount = shift_amount in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_VSHRN_Op_A_txt d (( 2 :: int)::ii) (( 8 :: int)::ii) m shift_amount))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSLI_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSLI_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSLI_Op_A_txt d__arg elements esize m regs shift_amount = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (shifted_op :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let (mask1 :: ( 'esize::len)Word.word) = ((shiftl ((Ones esize  :: ( 'esize::len)Word.word)) shift_amount  :: ( 'esize::len)Word.word)) in
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) shifted_op
     ((\<lambda> r shifted_op . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) shifted_op
         ((\<lambda> e shifted_op . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let shifted_op = ((shiftl w__1 shift_amount  :: ( 'esize::len)Word.word)) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (Elem_set w__2 e esize
              ((or_vec ((and_vec w__4 ((not_vec mask1  :: ( 'esize::len)Word.word))  :: ( 'esize::len)Word.word)) shifted_op
                 :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return shifted_op))))))))))))))))))))) \<bind> ((\<lambda> (shifted_op :: ( 'esize::len)Word.word) . 
   return () )))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSLI_A1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSLI_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSLI_A1enc_A_txt D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = (Word.uint imm6) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__164 = esize in
     if (((l__164 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount
     else if (((l__164 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount
     else if (((l__164 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount
     else if (((l__164 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount
     else assert_exp False (''src/instrs32.sail:36764.26-36764.27'') \<then> exit0 () ))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSLI_T1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSLI_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSLI_T1enc_A_txt D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 8 :: int)::ii)) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 16 :: int)::ii)) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = (((Word.uint imm6)) - (( 32 :: int)::ii)) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = (Word.uint imm6) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__160 = esize in
     if (((l__160 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount
     else if (((l__160 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount
     else if (((l__160 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount
     else if (((l__160 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSLI_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount
     else assert_exp False (''src/instrs32.sail:36842.26-36842.27'') \<then> exit0 () ))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSQRT_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSQRT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSQRT_Op_A_txt d esize m = (
   CheckVFPEnabled True \<then>
   ((let l__157 = esize in
   if (((l__157 = (( 16 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (FPSqrt ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::
        16 Word.word) . 
     S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__2  ::  32 Word.word))))))))
   else if (((l__157 = (( 32 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     (FPSqrt w__3 w__4  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) .  S_set d w__5))))))
   else if (((l__157 = (( 64 :: int)::ii)))) then
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     (FPSqrt w__6 w__7  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) .  D_set d w__8))))))
   else return () )))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSQRT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSQRT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSQRT_A1enc_A_txt cond D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:36885.29-36885.30'') \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
        return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
        return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VSQRT_Op_A_txt d esize m)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSQRT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSQRT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSQRT_T1enc_A_txt D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     ((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
        return (((((slice w__3 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
        return (((((slice w__4 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__5 ::
       bool) . 
     (if w__5 then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VSQRT_Op_A_txt d esize m)))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSRA_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSRA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSRA_Op_A_txt d__arg elements esize m regs shift_amount is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) result
     ((\<lambda> r result . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let result = (shr_int_general ((asl_Int w__1 is_unsigned)) shift_amount) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (Elem_set w__2 e esize ((add_vec_int w__4 result  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::
              64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return result))))))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
   return () ))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSRA_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSRA_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSRA_A1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__153 = esize in
     if (((l__153 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__153 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__153 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__153 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:37063.26-37063.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSRA_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSRA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSRA_T1enc_A_txt U D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__149 = esize in
     if (((l__149 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount is_unsigned
     else if (((l__149 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount is_unsigned
     else if (((l__149 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount is_unsigned
     else if (((l__149 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSRA_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount is_unsigned
     else assert_exp False (''src/instrs32.sail:37143.26-37143.27'') \<then> exit0 () )))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSRI_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSRI_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSRI_Op_A_txt d__arg elements esize m regs shift_amount = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (shifted_op :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let (mask1 :: ( 'esize::len)Word.word) = ((shiftr ((Ones esize  :: ( 'esize::len)Word.word)) shift_amount  :: ( 'esize::len)Word.word)) in
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) shifted_op
     ((\<lambda> r shifted_op . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) shifted_op
         ((\<lambda> e shifted_op . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let shifted_op = ((shiftr w__1 shift_amount  :: ( 'esize::len)Word.word)) in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (Elem_set w__2 e esize
              ((or_vec ((and_vec w__4 ((not_vec mask1  :: ( 'esize::len)Word.word))  :: ( 'esize::len)Word.word)) shifted_op
                 :: ( 'esize::len)Word.word))
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return shifted_op))))))))))))))))))))) \<bind> ((\<lambda> (shifted_op :: ( 'esize::len)Word.word) . 
   return () )))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "shift_amount"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSRI_A1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSRI_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSRI_A1enc_A_txt D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__145 = esize in
     if (((l__145 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount
     else if (((l__145 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount
     else if (((l__145 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount
     else if (((l__145 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount
     else assert_exp False (''src/instrs32.sail:37239.26-37239.27'') \<then> exit0 () ))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSRI_T1enc_A_txt : mword ty1 -> mword ty6 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSRI_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSRI_T1enc_A_txt D imm6 Vd L Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((let b__0 = ((concat_vec L imm6  ::  7 Word.word)) in
        if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) then
          True
        else False)) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 8 :: int)::ii)) in
     (let (elements :: int) = ((( 1 :: int)::ii)) in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (shift_amount :: ii) . 
     (let b__1 = ((concat_vec L imm6  ::  7 Word.word)) in
     (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
       (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = ( 0x1 ::  4 Word.word)))) then
         (let (esize :: int) = ((( 8 :: int)::ii)) in
         (let (elements :: int) = ((( 8 :: int)::ii)) in
         (let (shift_amount :: ii) = ((( 16 :: int)::ii) - ((Word.uint imm6))) in
         (elements, esize, shift_amount))))
       else
         (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
           (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word))))
           then
             (let (esize :: int) = ((( 16 :: int)::ii)) in
             (let (elements :: int) = ((( 4 :: int)::ii)) in
             (let (shift_amount :: ii) = ((( 32 :: int)::ii) - ((Word.uint imm6))) in
             (elements, esize, shift_amount))))
           else
             (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
               (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
               then
                 (let (esize :: int) = ((( 32 :: int)::ii)) in
                 (let (elements :: int) = ((( 2 :: int)::ii)) in
                 (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                 (elements, esize, shift_amount))))
               else
                 (let ((elements :: int), (esize :: int), (shift_amount :: ii)) =
                   (if (((((subrange_vec_dec b__1 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     (let (esize :: int) = ((( 64 :: int)::ii)) in
                     (let (elements :: int) = ((( 1 :: int)::ii)) in
                     (let (shift_amount :: ii) = ((( 64 :: int)::ii) - ((Word.uint imm6))) in
                     (elements, esize, shift_amount))))
                   else (elements, esize, shift_amount)) in
                 (elements, esize, shift_amount))) in
             (elements, esize, shift_amount))) in
         (elements, esize, shift_amount))) in
     (let shift_amount = shift_amount in
     (let esize = esize in
     (let elements = elements in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let l__141 = esize in
     if (((l__141 = (( 8 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         regs shift_amount
     else if (((l__141 = (( 16 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs shift_amount
     else if (((l__141 = (( 32 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs shift_amount
     else if (((l__141 = (( 64 :: int)::ii)))) then
       execute_aarch32_instrs_VSRI_Op_A_txt d elements ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m
         regs shift_amount
     else assert_exp False (''src/instrs32.sail:37317.26-37317.27'') \<then> exit0 () ))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "imm6"  :: "(6)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "L"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST1_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST1_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST1_1_Op_A_txt alignment d l__139 index1 m n register_index wback = (
   if (((l__139 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__0 :: 64 Word.word) . 
                     (Elem_read__1 (( 8 :: int):: ii) w__0 index1 :: ( 8 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        MemU_set address (( 1 :: int):: ii) w__1 \<then>
                          (
                          if wback then
                            if register_index then
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__2 :: 32 Word.word) . 
                                 (R_read m :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__3 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec w__2 w__3 :: 32 Word.word))))))
                            else
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__4 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec_int w__4 (( 1 :: int):: ii) :: 32 Word.word))))
                          else return () )))))
                  )))))
   else if (((l__139 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__5 :: 64 Word.word) . 
                     (Elem_read__1 (( 16 :: int):: ii) w__5 index1 :: ( 16 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__6 :: 16 Word.word) . 
                        MemU_set address (( 2 :: int):: ii) w__6 \<then>
                          (
                          if wback then
                            if register_index then
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__7 :: 32 Word.word) . 
                                 (R_read m :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__8 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec w__7 w__8 :: 32 Word.word))))))
                            else
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__9 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec_int w__9 (( 2 :: int):: ii) :: 32 Word.word))))
                          else return () )))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__10 :: 64 Word.word) . 
                     (Elem_read__1 (( 32 :: int):: ii) w__10 index1 :: ( 32 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__11 :: 32 Word.word) . 
                        MemU_set address (( 4 :: int):: ii) w__11 \<then>
                          (
                          if wback then
                            if register_index then
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__12 :: 32 Word.word) . 
                                 (R_read m :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__13 :: 32 Word.word) . 
                                    R_set n
                                      ((add_vec w__12 w__13 :: 32 Word.word))))))
                            else
                              (R_read n :: ( 32 Word.word) M) \<bind>
                                ((\<lambda> (w__14 :: 32 Word.word) . 
                                 R_set n
                                   ((add_vec_int w__14 (( 4 :: int):: ii) :: 32 Word.word))))
                          else return () )))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "l__139"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let alignment = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let alignment = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b11 ::  2 Word.word))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index1 m n register_index wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST1_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST1_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST1_m_Op_A_txt alignment d l__136 elements m n register_index regs wback = (
   if (((l__136 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__0 :: 64 Word.word) . 
                             (Elem_read__1 (( 8 :: int):: ii) w__0 e :: ( 8 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__1 :: 8 Word.word) . 
                                MemU_set address (( 1 :: int):: ii) w__1
                                  \<then>
                                  ((let (address :: 32 bits) = ((add_vec_int
                                                                   address
                                                                   ((
                                                                     1 :: int):: ii) :: 32 Word.word)) in
                                   return address)))))))))))))) \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__2 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__3 :: 32 Word.word) . 
                               R_set n ((add_vec w__2 w__3 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__4 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__4
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__136 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__5 :: 64 Word.word) . 
                             (Elem_read__1 (( 16 :: int):: ii) w__5 e :: ( 16 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__6 :: 16 Word.word) . 
                                MemU_set address (( 2 :: int):: ii) w__6
                                  \<then>
                                  ((let (address :: 32 bits) = ((add_vec_int
                                                                   address
                                                                   ((
                                                                     2 :: int):: ii) :: 32 Word.word)) in
                                   return address)))))))))))))) \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__7 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__8 :: 32 Word.word) . 
                               R_set n ((add_vec w__7 w__8 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__9 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__9
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__136 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__10 :: 64 Word.word) . 
                             (Elem_read__1 (( 32 :: int):: ii) w__10 e :: ( 32 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__11 :: 32 Word.word) . 
                                MemU_set address (( 4 :: int):: ii) w__11
                                  \<then>
                                  ((let (address :: 32 bits) = ((add_vec_int
                                                                   address
                                                                   ((
                                                                     4 :: int):: ii) :: 32 Word.word)) in
                                   return address)))))))))))))) \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__12 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__13 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__12 w__13 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__14 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__14
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (regs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          AArch32_CheckAlignment address (( 8 :: int):: ii)
                            AccType_NORMAL True \<bind>
                            ((\<lambda>x .  (case  x of
                                                _ =>
                                            (D_read ((d + r)) :: ( 64 Word.word) M)
                                              \<bind>
                                              ((\<lambda> (w__15 :: 64 Word.word) . 
                                               (Elem_read__1
                                                  (( 64 :: int):: ii) 
                                                w__15 e :: ( 64 Word.word) M)
                                                 \<bind>
                                                 ((\<lambda> (data :: 64 bits) . 
                                                  BigEndian AccType_NORMAL
                                                    \<bind>
                                                    ((\<lambda> (w__16 :: bool) . 
                                                     (let (w__17 :: 32 Word.word) =
                                                          (
                                                          if w__16 then
                                                            (subrange_vec_dec
                                                               data
                                                               (( 63 :: int):: ii)
                                                               (( 32 :: int):: ii) :: 32 Word.word)
                                                          else
                                                            (subrange_vec_dec
                                                               data
                                                               (( 31 :: int):: ii)
                                                               (( 0 :: int):: ii) :: 32 Word.word)) in
                                                     (MemU_set address
                                                        (( 4 :: int):: ii)
                                                        w__17 \<then>
                                                        BigEndian
                                                          AccType_NORMAL)
                                                       \<bind>
                                                       ((\<lambda> (w__18 :: bool) . 
                                                        (let (w__19 :: 32 Word.word) =
                                                             (
                                                             if w__18 then
                                                               (subrange_vec_dec
                                                                  data
                                                                  (( 31 :: int):: ii)
                                                                  (( 0 :: int):: ii) :: 32 Word.word)
                                                             else
                                                               (subrange_vec_dec
                                                                  data
                                                                  (( 63 :: int):: ii)
                                                                  (( 32 :: int):: ii) :: 32 Word.word)) in
                                                        MemU_set
                                                          ((add_vec_int
                                                              address
                                                              (( 4 :: int):: ii) :: 32 Word.word))
                                                          (( 4 :: int):: ii)
                                                          w__19 \<then>
                                                          ((let (address :: 32 bits) = 
                                                                ((add_vec_int
                                                                    address
                                                                    (
                                                                    (
                                                                     8 :: int):: ii) :: 32 Word.word)) in
                                                           return address))))))))))))
                                            ))))))))))) \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__20 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__21 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__20 w__21 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__22 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__22
                                  (((( 8 :: int):: ii) * regs)) :: 32 Word.word))))
                     else return () ))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "l__136"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "regs"  :: " int " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37646.58-37646.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_A2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 2 :: int)::ii)) in
     (if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37683.58-37683.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_A3enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37720.58-37720.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_A4enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_A4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_A4enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 4 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37754.58-37754.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37791.58-37791.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_T2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 2 :: int)::ii)) in
     (if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37828.58-37828.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_T3enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37865.58-37865.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST1_m_T4enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST1_m_T4enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST1_m_T4enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let regs = ((( 4 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:37899.58-37899.59'')) \<then>
     execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
       wback)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST2_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST2_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 l__134 index1 m n register_index wback = (
   if (((l__134 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__0 :: 64 Word.word) . 
                     (Elem_read__1 (( 8 :: int):: ii) w__0 index1 :: ( 8 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        (MemU_set address (( 1 :: int):: ii) w__1 \<then>
                           (D_read d2 :: ( 64 Word.word) M)) \<bind>
                          ((\<lambda> (w__2 :: 64 Word.word) . 
                           (Elem_read__1 (( 8 :: int):: ii) w__2 index1 :: ( 8 Word.word) M)
                             \<bind>
                             ((\<lambda> (w__3 :: 8 Word.word) . 
                              MemU_set
                                ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                (( 1 :: int):: ii) w__3 \<then>
                                (
                                if wback then
                                  if register_index then
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__4 :: 32 Word.word) . 
                                       (R_read m :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__5 :: 32 Word.word) . 
                                          R_set n
                                            ((add_vec w__4 w__5 :: 32 Word.word))))))
                                  else
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__6 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec_int w__6
                                             (( 2 :: int):: ii) :: 32 Word.word))))
                                else return () )))))))))
                  )))))
   else if (((l__134 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__7 :: 64 Word.word) . 
                     (Elem_read__1 (( 16 :: int):: ii) w__7 index1 :: ( 16 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__8 :: 16 Word.word) . 
                        (MemU_set address (( 2 :: int):: ii) w__8 \<then>
                           (D_read d2 :: ( 64 Word.word) M)) \<bind>
                          ((\<lambda> (w__9 :: 64 Word.word) . 
                           (Elem_read__1 (( 16 :: int):: ii) w__9 index1 :: ( 16 Word.word) M)
                             \<bind>
                             ((\<lambda> (w__10 :: 16 Word.word) . 
                              MemU_set
                                ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                (( 2 :: int):: ii) w__10 \<then>
                                (
                                if wback then
                                  if register_index then
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__11 :: 32 Word.word) . 
                                       (R_read m :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__12 :: 32 Word.word) . 
                                          R_set n
                                            ((add_vec w__11 w__12 :: 32 Word.word))))))
                                  else
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__13 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec_int w__13
                                             (( 4 :: int):: ii) :: 32 Word.word))))
                                else return () )))))))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__14 :: 64 Word.word) . 
                     (Elem_read__1 (( 32 :: int):: ii) w__14 index1 :: ( 32 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__15 :: 32 Word.word) . 
                        (MemU_set address (( 4 :: int):: ii) w__15 \<then>
                           (D_read d2 :: ( 64 Word.word) M)) \<bind>
                          ((\<lambda> (w__16 :: 64 Word.word) . 
                           (Elem_read__1 (( 32 :: int):: ii) w__16 index1 :: ( 32 Word.word) M)
                             \<bind>
                             ((\<lambda> (w__17 :: 32 Word.word) . 
                              MemU_set
                                ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                (( 4 :: int):: ii) w__17 \<then>
                                (
                                if wback then
                                  if register_index then
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__18 :: 32 Word.word) . 
                                       (R_read m :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__19 :: 32 Word.word) . 
                                          R_set n
                                            ((add_vec w__18 w__19 :: 32 Word.word))))))
                                  else
                                    (R_read n :: ( 32 Word.word) M) \<bind>
                                      ((\<lambda> (w__20 :: 32 Word.word) . 
                                       R_set n
                                         ((add_vec_int w__20
                                             (( 8 :: int):: ii) :: 32 Word.word))))
                                else return () )))))))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "l__134"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d2 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST2_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST2_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 l__131 elements m n pairs register_index wback = (
   if (((l__131 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__0 :: 64 Word.word) . 
                             (Elem_read__1 (( 8 :: int):: ii) w__0 e :: ( 8 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__1 :: 8 Word.word) . 
                                (MemU_set address (( 1 :: int):: ii) w__1
                                   \<then>
                                   (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                  \<bind>
                                  ((\<lambda> (w__2 :: 64 Word.word) . 
                                   (Elem_read__1 (( 8 :: int):: ii) w__2 e :: ( 8 Word.word) M)
                                     \<bind>
                                     ((\<lambda> (w__3 :: 8 Word.word) . 
                                      MemU_set
                                        ((add_vec_int address
                                            (( 1 :: int):: ii) :: 32 Word.word))
                                        (( 1 :: int):: ii) w__3 \<then>
                                        ((let (address :: 32 bits) = 
                                              ((add_vec_int address
                                                  (( 2 :: int):: ii) :: 32 Word.word)) in
                                         return address))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__4 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__5 :: 32 Word.word) . 
                               R_set n ((add_vec w__4 w__5 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__6 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__6
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__131 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__7 :: 64 Word.word) . 
                             (Elem_read__1 (( 16 :: int):: ii) w__7 e :: ( 16 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__8 :: 16 Word.word) . 
                                (MemU_set address (( 2 :: int):: ii) w__8
                                   \<then>
                                   (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                  \<bind>
                                  ((\<lambda> (w__9 :: 64 Word.word) . 
                                   (Elem_read__1 (( 16 :: int):: ii) w__9 e :: ( 16 Word.word) M)
                                     \<bind>
                                     ((\<lambda> (w__10 :: 16 Word.word) . 
                                      MemU_set
                                        ((add_vec_int address
                                            (( 2 :: int):: ii) :: 32 Word.word))
                                        (( 2 :: int):: ii) w__10 \<then>
                                        ((let (address :: 32 bits) = 
                                              ((add_vec_int address
                                                  (( 4 :: int):: ii) :: 32 Word.word)) in
                                         return address))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__11 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__12 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__11 w__12 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__13 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__13
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__131 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__14 :: 64 Word.word) . 
                             (Elem_read__1 (( 32 :: int):: ii) w__14 e :: ( 32 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__15 :: 32 Word.word) . 
                                (MemU_set address (( 4 :: int):: ii) w__15
                                   \<then>
                                   (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                  \<bind>
                                  ((\<lambda> (w__16 :: 64 Word.word) . 
                                   (Elem_read__1 (( 32 :: int):: ii) w__16 e :: ( 32 Word.word) M)
                                     \<bind>
                                     ((\<lambda> (w__17 :: 32 Word.word) . 
                                      MemU_set
                                        ((add_vec_int address
                                            (( 4 :: int):: ii) :: 32 Word.word))
                                        (( 4 :: int):: ii) w__17 \<then>
                                        ((let (address :: 32 bits) = 
                                              ((add_vec_int address
                                                  (( 8 :: int):: ii) :: 32 Word.word)) in
                                         return address))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__18 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__19 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__18 w__19 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__20 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__20
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_r_lower = ((( 0 :: int):: ii)) in
                  (let loop_r_upper = (pairs - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_r_lower loop_r_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> r address . 
                      (let loop_e_lower = ((( 0 :: int):: ii)) in
                      (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                      (foreachM
                         (index_list loop_e_lower loop_e_upper
                            (( 1 :: int):: ii)) address
                         ((\<lambda> e address . 
                          (D_read ((d + r)) :: ( 64 Word.word) M) \<bind>
                            ((\<lambda> (w__21 :: 64 Word.word) . 
                             (Elem_read__1 (( 64 :: int):: ii) w__21 e :: ( 64 Word.word) M)
                               \<bind>
                               ((\<lambda> (w__22 :: 64 Word.word) . 
                                (MemU_set address (( 8 :: int):: ii) w__22
                                   \<then>
                                   (D_read ((d2 + r)) :: ( 64 Word.word) M))
                                  \<bind>
                                  ((\<lambda> (w__23 :: 64 Word.word) . 
                                   (Elem_read__1 (( 64 :: int):: ii) w__23 e :: ( 64 Word.word) M)
                                     \<bind>
                                     ((\<lambda> (w__24 :: 64 Word.word) . 
                                      MemU_set
                                        ((add_vec_int address
                                            (( 8 :: int):: ii) :: 32 Word.word))
                                        (( 8 :: int):: ii) w__24 \<then>
                                        ((let (address :: 32 bits) = 
                                              ((add_vec_int address
                                                  (( 16 :: int):: ii) :: 32 Word.word)) in
                                         return address))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__25 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__26 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__25 w__26 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__27 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__27
                                  (((( 16 :: int):: ii) * pairs)) :: 32 Word.word))))
                     else return () ))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "l__131"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "pairs"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 1 :: int)::ii)) in
     ((if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let inc_name = (if (((itype = ( 0x9 ::  4 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:38212.58-38212.59'')) \<then>
     execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_m_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_m_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_m_A2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 2 :: int)::ii)) in
     (let inc_name = ((( 2 :: int)::ii)) in
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:38251.58-38251.59'')) \<then>
     execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 1 :: int)::ii)) in
     ((if (((align = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let inc_name = (if (((itype = ( 0x9 ::  4 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:38293.58-38293.59'')) \<then>
     execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST2_m_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST2_m_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST2_m_T2enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let pairs = ((( 2 :: int)::ii)) in
     (let inc_name = ((( 2 :: int)::ii)) in
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((((d2 + pairs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:38332.58-38332.59'')) \<then>
     execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs register_index
       wback))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST3_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST3_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 l__129 index1 m n register_index wback = (
   if (((l__129 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (Elem_read__1 (( 8 :: int)::ii) w__0 index1  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__1 ::  8 Word.word) . 
     (MemU_set address (( 1 :: int)::ii) w__1 \<then>
     (D_read d2  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (Elem_read__1 (( 8 :: int)::ii) w__2 index1  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
     (MemU_set ((add_vec_int address (( 1 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii) w__3 \<then>
     (D_read d3  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     (Elem_read__1 (( 8 :: int)::ii) w__4 index1  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
     MemU_set ((add_vec_int address (( 2 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii) w__5 \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         R_set n ((add_vec w__6 w__7  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
         R_set n ((add_vec_int w__8 (( 3 :: int)::ii)  ::  32 Word.word))))
     else return () )))))))))))))))
   else if (((l__129 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
     (Elem_read__1 (( 16 :: int)::ii) w__9 index1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__10 ::  16 Word.word) . 
     (MemU_set address (( 2 :: int)::ii) w__10 \<then>
     (D_read d2  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
     (Elem_read__1 (( 16 :: int)::ii) w__11 index1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__12 ::  16 Word.word) . 
     (MemU_set ((add_vec_int address (( 2 :: int)::ii)  ::  32 Word.word)) (( 2 :: int)::ii) w__12 \<then>
     (D_read d3  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
     (Elem_read__1 (( 16 :: int)::ii) w__13 index1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__14 ::  16 Word.word) . 
     MemU_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 2 :: int)::ii) w__14 \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
         R_set n ((add_vec w__15 w__16  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
         R_set n ((add_vec_int w__17 (( 6 :: int)::ii)  ::  32 Word.word))))
     else return () )))))))))))))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
     (Elem_read__1 (( 32 :: int)::ii) w__18 index1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
     (MemU_set address (( 4 :: int)::ii) w__19 \<then>
     (D_read d2  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
     (Elem_read__1 (( 32 :: int)::ii) w__20 index1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
     (MemU_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__21 \<then>
     (D_read d3  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
     (Elem_read__1 (( 32 :: int)::ii) w__22 index1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
     MemU_set ((add_vec_int address (( 8 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__23 \<then>
     (if wback then
       if register_index then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__24 ::  32 Word.word) . 
         (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
         R_set n ((add_vec w__24 w__25  ::  32 Word.word))))))
       else
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__26 ::  32 Word.word) . 
         R_set n ((add_vec_int w__26 (( 12 :: int)::ii)  ::  32 Word.word))))
     else return () ))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "d3"  :: " int " 
  and  "l__129"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> ( 0b0 ::  1 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index1 m n register_index wback)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST3_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST3_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST3_m_Op_A_txt alignment d d2 d3 l__126 elements m n register_index wback = (
   if (((l__126 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__0 :: 64 Word.word) . 
                         (Elem_read__1 (( 8 :: int):: ii) w__0 e :: ( 8 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__1 :: 8 Word.word) . 
                            (MemU_set address (( 1 :: int):: ii) w__1 \<then>
                               (D_read d2 :: ( 64 Word.word) M)) \<bind>
                              ((\<lambda> (w__2 :: 64 Word.word) . 
                               (Elem_read__1 (( 8 :: int):: ii) w__2 e :: ( 8 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__3 :: 8 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                     (( 1 :: int):: ii) w__3 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__4 :: 64 Word.word) . 
                                     (Elem_read__1 (( 8 :: int):: ii) w__4 e :: ( 8 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__5 :: 8 Word.word) . 
                                        MemU_set
                                          ((add_vec_int address
                                              (( 2 :: int):: ii) :: 32 Word.word))
                                          (( 1 :: int):: ii) w__5 \<then>
                                          ((let (address :: 32 bits) = 
                                                ((add_vec_int address
                                                    (( 3 :: int):: ii) :: 32 Word.word)) in
                                           return address)))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__6 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__7 :: 32 Word.word) . 
                               R_set n ((add_vec w__6 w__7 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__8 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__8 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__126 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__9 :: 64 Word.word) . 
                         (Elem_read__1 (( 16 :: int):: ii) w__9 e :: ( 16 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__10 :: 16 Word.word) . 
                            (MemU_set address (( 2 :: int):: ii) w__10
                               \<then> (D_read d2 :: ( 64 Word.word) M))
                              \<bind>
                              ((\<lambda> (w__11 :: 64 Word.word) . 
                               (Elem_read__1 (( 16 :: int):: ii) w__11 e :: ( 16 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__12 :: 16 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                     (( 2 :: int):: ii) w__12 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__13 :: 64 Word.word) . 
                                     (Elem_read__1 (( 16 :: int):: ii) 
                                      w__13 e :: ( 16 Word.word) M) \<bind>
                                       ((\<lambda> (w__14 :: 16 Word.word) . 
                                        MemU_set
                                          ((add_vec_int address
                                              (( 4 :: int):: ii) :: 32 Word.word))
                                          (( 2 :: int):: ii) w__14 \<then>
                                          ((let (address :: 32 bits) = 
                                                ((add_vec_int address
                                                    (( 6 :: int):: ii) :: 32 Word.word)) in
                                           return address)))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__15 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__16 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__15 w__16 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__17 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__17 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__126 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__18 :: 64 Word.word) . 
                         (Elem_read__1 (( 32 :: int):: ii) w__18 e :: ( 32 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__19 :: 32 Word.word) . 
                            (MemU_set address (( 4 :: int):: ii) w__19
                               \<then> (D_read d2 :: ( 64 Word.word) M))
                              \<bind>
                              ((\<lambda> (w__20 :: 64 Word.word) . 
                               (Elem_read__1 (( 32 :: int):: ii) w__20 e :: ( 32 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__21 :: 32 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                     (( 4 :: int):: ii) w__21 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__22 :: 64 Word.word) . 
                                     (Elem_read__1 (( 32 :: int):: ii) 
                                      w__22 e :: ( 32 Word.word) M) \<bind>
                                       ((\<lambda> (w__23 :: 32 Word.word) . 
                                        MemU_set
                                          ((add_vec_int address
                                              (( 8 :: int):: ii) :: 32 Word.word))
                                          (( 4 :: int):: ii) w__23 \<then>
                                          ((let (address :: 32 bits) = 
                                                ((add_vec_int address
                                                    (( 12 :: int):: ii) :: 32 Word.word)) in
                                           return address)))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__24 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__25 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__24 w__25 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__26 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__26 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__27 :: 64 Word.word) . 
                         (Elem_read__1 (( 64 :: int):: ii) w__27 e :: ( 64 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__28 :: 64 Word.word) . 
                            (MemU_set address (( 8 :: int):: ii) w__28
                               \<then> (D_read d2 :: ( 64 Word.word) M))
                              \<bind>
                              ((\<lambda> (w__29 :: 64 Word.word) . 
                               (Elem_read__1 (( 64 :: int):: ii) w__29 e :: ( 64 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__30 :: 64 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 8 :: int):: ii) :: 32 Word.word))
                                     (( 8 :: int):: ii) w__30 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__31 :: 64 Word.word) . 
                                     (Elem_read__1 (( 64 :: int):: ii) 
                                      w__31 e :: ( 64 Word.word) M) \<bind>
                                       ((\<lambda> (w__32 :: 64 Word.word) . 
                                        MemU_set
                                          ((add_vec_int address
                                              (( 16 :: int):: ii) :: 32 Word.word))
                                          (( 8 :: int):: ii) w__32 \<then>
                                          ((let (address :: 32 bits) = 
                                                ((add_vec_int address
                                                    (( 24 :: int):: ii) :: 32 Word.word)) in
                                           return address)))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__33 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__34 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__33 w__34 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__35 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__35 (( 24 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "d3"  :: " int " 
  and  "l__126"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x4 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x5 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
       wback))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST3_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST3_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST3_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if ((((((size1 = ( 0b11 ::  2 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x4 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x5 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d3 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
       wback))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST4_1_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST4_1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 l__124 index1 m n register_index wback = (
   if (((l__124 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__0 :: 64 Word.word) . 
                     (Elem_read__1 (( 8 :: int):: ii) w__0 index1 :: ( 8 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__1 :: 8 Word.word) . 
                        (MemU_set address (( 1 :: int):: ii) w__1 \<then>
                           (D_read d2 :: ( 64 Word.word) M)) \<bind>
                          ((\<lambda> (w__2 :: 64 Word.word) . 
                           (Elem_read__1 (( 8 :: int):: ii) w__2 index1 :: ( 8 Word.word) M)
                             \<bind>
                             ((\<lambda> (w__3 :: 8 Word.word) . 
                              (MemU_set
                                 ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                 (( 1 :: int):: ii) w__3 \<then>
                                 (D_read d3 :: ( 64 Word.word) M)) \<bind>
                                ((\<lambda> (w__4 :: 64 Word.word) . 
                                 (Elem_read__1 (( 8 :: int):: ii) w__4 index1 :: ( 8 Word.word) M)
                                   \<bind>
                                   ((\<lambda> (w__5 :: 8 Word.word) . 
                                    (MemU_set
                                       ((add_vec_int address
                                           (( 2 :: int):: ii) :: 32 Word.word))
                                       (( 1 :: int):: ii) w__5 \<then>
                                       (D_read d4 :: ( 64 Word.word) M))
                                      \<bind>
                                      ((\<lambda> (w__6 :: 64 Word.word) . 
                                       (Elem_read__1 (( 8 :: int):: ii) 
                                        w__6 index1 :: ( 8 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__7 :: 8 Word.word) . 
                                          MemU_set
                                            ((add_vec_int address
                                                (( 3 :: int):: ii) :: 32 Word.word))
                                            (( 1 :: int):: ii) w__7 \<then>
                                            (
                                            if wback then
                                              if register_index then
                                                (R_read n :: ( 32 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__8 :: 32 Word.word) . 
                                                   (R_read m :: ( 32 Word.word) M)
                                                     \<bind>
                                                     ((\<lambda> (w__9 :: 32 Word.word) . 
                                                      R_set n
                                                        ((add_vec w__8 w__9 :: 32 Word.word))))))
                                              else
                                                (R_read n :: ( 32 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__10 :: 32 Word.word) . 
                                                   R_set n
                                                     ((add_vec_int w__10
                                                         (( 4 :: int):: ii) :: 32 Word.word))))
                                            else return () )))))))))))))))))
                  )))))
   else if (((l__124 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__11 :: 64 Word.word) . 
                     (Elem_read__1 (( 16 :: int):: ii) w__11 index1 :: ( 16 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__12 :: 16 Word.word) . 
                        (MemU_set address (( 2 :: int):: ii) w__12 \<then>
                           (D_read d2 :: ( 64 Word.word) M)) \<bind>
                          ((\<lambda> (w__13 :: 64 Word.word) . 
                           (Elem_read__1 (( 16 :: int):: ii) w__13 index1 :: ( 16 Word.word) M)
                             \<bind>
                             ((\<lambda> (w__14 :: 16 Word.word) . 
                              (MemU_set
                                 ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                 (( 2 :: int):: ii) w__14 \<then>
                                 (D_read d3 :: ( 64 Word.word) M)) \<bind>
                                ((\<lambda> (w__15 :: 64 Word.word) . 
                                 (Elem_read__1 (( 16 :: int):: ii) w__15
                                    index1 :: ( 16 Word.word) M) \<bind>
                                   ((\<lambda> (w__16 :: 16 Word.word) . 
                                    (MemU_set
                                       ((add_vec_int address
                                           (( 4 :: int):: ii) :: 32 Word.word))
                                       (( 2 :: int):: ii) w__16 \<then>
                                       (D_read d4 :: ( 64 Word.word) M))
                                      \<bind>
                                      ((\<lambda> (w__17 :: 64 Word.word) . 
                                       (Elem_read__1 (( 16 :: int):: ii)
                                          w__17 index1 :: ( 16 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__18 :: 16 Word.word) . 
                                          MemU_set
                                            ((add_vec_int address
                                                (( 6 :: int):: ii) :: 32 Word.word))
                                            (( 2 :: int):: ii) w__18 \<then>
                                            (
                                            if wback then
                                              if register_index then
                                                (R_read n :: ( 32 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__19 :: 32 Word.word) . 
                                                   (R_read m :: ( 32 Word.word) M)
                                                     \<bind>
                                                     ((\<lambda> (w__20 :: 32 Word.word) . 
                                                      R_set n
                                                        ((add_vec w__19 w__20 :: 32 Word.word))))))
                                              else
                                                (R_read n :: ( 32 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__21 :: 32 Word.word) . 
                                                   R_set n
                                                     ((add_vec_int w__21
                                                         (( 8 :: int):: ii) :: 32 Word.word))))
                                            else return () )))))))))))))))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 4 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (D_read d :: ( 64 Word.word) M) \<bind>
                    ((\<lambda> (w__22 :: 64 Word.word) . 
                     (Elem_read__1 (( 32 :: int):: ii) w__22 index1 :: ( 32 Word.word) M)
                       \<bind>
                       ((\<lambda> (w__23 :: 32 Word.word) . 
                        (MemU_set address (( 4 :: int):: ii) w__23 \<then>
                           (D_read d2 :: ( 64 Word.word) M)) \<bind>
                          ((\<lambda> (w__24 :: 64 Word.word) . 
                           (Elem_read__1 (( 32 :: int):: ii) w__24 index1 :: ( 32 Word.word) M)
                             \<bind>
                             ((\<lambda> (w__25 :: 32 Word.word) . 
                              (MemU_set
                                 ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                 (( 4 :: int):: ii) w__25 \<then>
                                 (D_read d3 :: ( 64 Word.word) M)) \<bind>
                                ((\<lambda> (w__26 :: 64 Word.word) . 
                                 (Elem_read__1 (( 32 :: int):: ii) w__26
                                    index1 :: ( 32 Word.word) M) \<bind>
                                   ((\<lambda> (w__27 :: 32 Word.word) . 
                                    (MemU_set
                                       ((add_vec_int address
                                           (( 8 :: int):: ii) :: 32 Word.word))
                                       (( 4 :: int):: ii) w__27 \<then>
                                       (D_read d4 :: ( 64 Word.word) M))
                                      \<bind>
                                      ((\<lambda> (w__28 :: 64 Word.word) . 
                                       (Elem_read__1 (( 32 :: int):: ii)
                                          w__28 index1 :: ( 32 Word.word) M)
                                         \<bind>
                                         ((\<lambda> (w__29 :: 32 Word.word) . 
                                          MemU_set
                                            ((add_vec_int address
                                                (( 12 :: int):: ii) :: 32 Word.word))
                                            (( 4 :: int):: ii) w__29 \<then>
                                            (
                                            if wback then
                                              if register_index then
                                                (R_read n :: ( 32 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__30 :: 32 Word.word) . 
                                                   (R_read m :: ( 32 Word.word) M)
                                                     \<bind>
                                                     ((\<lambda> (w__31 :: 32 Word.word) . 
                                                      R_set n
                                                        ((add_vec w__30 w__31 :: 32 Word.word))))))
                                              else
                                                (R_read n :: ( 32 Word.word) M)
                                                  \<bind>
                                                  ((\<lambda> (w__32 :: 32 Word.word) . 
                                                   R_set n
                                                     ((add_vec_int w__32
                                                         (( 16 :: int):: ii) :: 32 Word.word))))
                                            else return () )))))))))))))))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "d3"  :: " int " 
  and  "d4"  :: " int " 
  and  "l__124"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_1_A1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_See (''Related encodings''))
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_1_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_1_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_1_A2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b01 ::  2 Word.word)))) then throw (Error_See (''Related encodings''))
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_1_A3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_1_A3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_1_A3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint ((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:38865.58-38865.59'')) \<then>
     execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_1_T1enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_See (''Related encodings''))
      else return () )) \<then>
     ((let ebytes = ((( 1 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word))) in
     (let inc_name = ((( 1 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_1_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_1_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_1_T2enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b01 ::  2 Word.word)))) then throw (Error_See (''Related encodings''))
      else return () )) \<then>
     ((let ebytes = ((( 2 :: int)::ii)) in
     (let index1 = (Word.uint ((subrange_vec_dec index_align (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if ((((vec_of_bits [access_vec_dec index_align (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 8 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_1_T3enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_1_T3enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_1_T3enc_A_txt D Rn Vd size1 index_align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let ebytes = ((( 4 :: int)::ii)) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec index_align (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let inc_name =
       (if ((((vec_of_bits [access_vec_dec index_align (( 2 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word))))
       then
         (( 1 :: int)::ii)
       else (( 2 :: int)::ii)) in
     (let alignment =
       (if (((((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))
       then
         (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint ((subrange_vec_dec index_align (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))))) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:38993.58-38993.59'')) \<then>
     execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index1 m n register_index
       wback)))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "index_align"  :: "(4)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VST4_m_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VST4_m_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VST4_m_Op_A_txt alignment d d2 d3 d4 l__121 elements m n register_index wback = (
   if (((l__121 = (( 1 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__0 :: 64 Word.word) . 
                         (Elem_read__1 (( 8 :: int):: ii) w__0 e :: ( 8 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__1 :: 8 Word.word) . 
                            (MemU_set address (( 1 :: int):: ii) w__1 \<then>
                               (D_read d2 :: ( 64 Word.word) M)) \<bind>
                              ((\<lambda> (w__2 :: 64 Word.word) . 
                               (Elem_read__1 (( 8 :: int):: ii) w__2 e :: ( 8 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__3 :: 8 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 1 :: int):: ii) :: 32 Word.word))
                                     (( 1 :: int):: ii) w__3 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__4 :: 64 Word.word) . 
                                     (Elem_read__1 (( 8 :: int):: ii) w__4 e :: ( 8 Word.word) M)
                                       \<bind>
                                       ((\<lambda> (w__5 :: 8 Word.word) . 
                                        (MemU_set
                                           ((add_vec_int address
                                               (( 2 :: int):: ii) :: 32 Word.word))
                                           (( 1 :: int):: ii) w__5 \<then>
                                           (D_read d4 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__6 :: 64 Word.word) . 
                                           (Elem_read__1 (( 8 :: int):: ii)
                                              w__6 e :: ( 8 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__7 :: 8 Word.word) . 
                                              MemU_set
                                                ((add_vec_int address
                                                    (( 3 :: int):: ii) :: 32 Word.word))
                                                (( 1 :: int):: ii) w__7
                                                \<then>
                                                ((let (address :: 32 bits) = 
                                                      ((add_vec_int address
                                                          (( 4 :: int):: ii) :: 32 Word.word)) in
                                                 return address)))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__8 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__9 :: 32 Word.word) . 
                               R_set n ((add_vec w__8 w__9 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__10 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__10 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__121 = (( 2 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__11 :: 64 Word.word) . 
                         (Elem_read__1 (( 16 :: int):: ii) w__11 e :: ( 16 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__12 :: 16 Word.word) . 
                            (MemU_set address (( 2 :: int):: ii) w__12
                               \<then> (D_read d2 :: ( 64 Word.word) M))
                              \<bind>
                              ((\<lambda> (w__13 :: 64 Word.word) . 
                               (Elem_read__1 (( 16 :: int):: ii) w__13 e :: ( 16 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__14 :: 16 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 2 :: int):: ii) :: 32 Word.word))
                                     (( 2 :: int):: ii) w__14 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__15 :: 64 Word.word) . 
                                     (Elem_read__1 (( 16 :: int):: ii) 
                                      w__15 e :: ( 16 Word.word) M) \<bind>
                                       ((\<lambda> (w__16 :: 16 Word.word) . 
                                        (MemU_set
                                           ((add_vec_int address
                                               (( 4 :: int):: ii) :: 32 Word.word))
                                           (( 2 :: int):: ii) w__16 \<then>
                                           (D_read d4 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__17 :: 64 Word.word) . 
                                           (Elem_read__1 (( 16 :: int):: ii)
                                              w__17 e :: ( 16 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__18 :: 16 Word.word) . 
                                              MemU_set
                                                ((add_vec_int address
                                                    (( 6 :: int):: ii) :: 32 Word.word))
                                                (( 2 :: int):: ii) w__18
                                                \<then>
                                                ((let (address :: 32 bits) = 
                                                      ((add_vec_int address
                                                          (( 8 :: int):: ii) :: 32 Word.word)) in
                                                 return address)))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__19 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__20 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__19 w__20 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__21 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__21 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else if (((l__121 = (( 4 :: int)::ii)))) then
     (CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__22 :: 64 Word.word) . 
                         (Elem_read__1 (( 32 :: int):: ii) w__22 e :: ( 32 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__23 :: 32 Word.word) . 
                            (MemU_set address (( 4 :: int):: ii) w__23
                               \<then> (D_read d2 :: ( 64 Word.word) M))
                              \<bind>
                              ((\<lambda> (w__24 :: 64 Word.word) . 
                               (Elem_read__1 (( 32 :: int):: ii) w__24 e :: ( 32 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__25 :: 32 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 4 :: int):: ii) :: 32 Word.word))
                                     (( 4 :: int):: ii) w__25 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__26 :: 64 Word.word) . 
                                     (Elem_read__1 (( 32 :: int):: ii) 
                                      w__26 e :: ( 32 Word.word) M) \<bind>
                                       ((\<lambda> (w__27 :: 32 Word.word) . 
                                        (MemU_set
                                           ((add_vec_int address
                                               (( 8 :: int):: ii) :: 32 Word.word))
                                           (( 4 :: int):: ii) w__27 \<then>
                                           (D_read d4 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__28 :: 64 Word.word) . 
                                           (Elem_read__1 (( 32 :: int):: ii)
                                              w__28 e :: ( 32 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__29 :: 32 Word.word) . 
                                              MemU_set
                                                ((add_vec_int address
                                                    (( 12 :: int):: ii) :: 32 Word.word))
                                                (( 4 :: int):: ii) w__29
                                                \<then>
                                                ((let (address :: 32 bits) = 
                                                      ((add_vec_int address
                                                          (( 16 :: int):: ii) :: 32 Word.word)) in
                                                 return address)))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__30 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__31 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__30 w__31 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__32 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__32 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  )))))
   else
     (
     \<comment> \<open>\<open> 'ebytes == 8 \<close>\<close>CheckAdvSIMDEnabled ()  \<then>
     (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (address :: 32 bits) . 
     AArch32_CheckAlignment address alignment AccType_VEC True \<bind>  
  ((\<lambda>x .  (case  x of
                      _ =>
                  (let loop_e_lower = ((( 0 :: int):: ii)) in
                  (let loop_e_upper = (elements - (( 1 :: int):: ii)) in
                  (foreachM
                     (index_list loop_e_lower loop_e_upper (( 1 :: int):: ii))
                     address
                     ((\<lambda> e address . 
                      (D_read d :: ( 64 Word.word) M) \<bind>
                        ((\<lambda> (w__33 :: 64 Word.word) . 
                         (Elem_read__1 (( 64 :: int):: ii) w__33 e :: ( 64 Word.word) M)
                           \<bind>
                           ((\<lambda> (w__34 :: 64 Word.word) . 
                            (MemU_set address (( 8 :: int):: ii) w__34
                               \<then> (D_read d2 :: ( 64 Word.word) M))
                              \<bind>
                              ((\<lambda> (w__35 :: 64 Word.word) . 
                               (Elem_read__1 (( 64 :: int):: ii) w__35 e :: ( 64 Word.word) M)
                                 \<bind>
                                 ((\<lambda> (w__36 :: 64 Word.word) . 
                                  (MemU_set
                                     ((add_vec_int address (( 8 :: int):: ii) :: 32 Word.word))
                                     (( 8 :: int):: ii) w__36 \<then>
                                     (D_read d3 :: ( 64 Word.word) M))
                                    \<bind>
                                    ((\<lambda> (w__37 :: 64 Word.word) . 
                                     (Elem_read__1 (( 64 :: int):: ii) 
                                      w__37 e :: ( 64 Word.word) M) \<bind>
                                       ((\<lambda> (w__38 :: 64 Word.word) . 
                                        (MemU_set
                                           ((add_vec_int address
                                               (( 16 :: int):: ii) :: 32 Word.word))
                                           (( 8 :: int):: ii) w__38 \<then>
                                           (D_read d4 :: ( 64 Word.word) M))
                                          \<bind>
                                          ((\<lambda> (w__39 :: 64 Word.word) . 
                                           (Elem_read__1 (( 64 :: int):: ii)
                                              w__39 e :: ( 64 Word.word) M)
                                             \<bind>
                                             ((\<lambda> (w__40 :: 64 Word.word) . 
                                              MemU_set
                                                ((add_vec_int address
                                                    (( 24 :: int):: ii) :: 32 Word.word))
                                                (( 8 :: int):: ii) w__40
                                                \<then>
                                                ((let (address :: 32 bits) = 
                                                      ((add_vec_int address
                                                          (( 32 :: int):: ii) :: 32 Word.word)) in
                                                 return address)))))))))))))))))))))
                    \<bind>
                    ((\<lambda> (address :: 32 Word.word) . 
                     if wback then
                       if register_index then
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__41 :: 32 Word.word) . 
                            (R_read m :: ( 32 Word.word) M) \<bind>
                              ((\<lambda> (w__42 :: 32 Word.word) . 
                               R_set n
                                 ((add_vec w__41 w__42 :: 32 Word.word))))))
                       else
                         (R_read n :: ( 32 Word.word) M) \<bind>
                           ((\<lambda> (w__43 :: 32 Word.word) . 
                            R_set n
                              ((add_vec_int w__43 (( 32 :: int):: ii) :: 32 Word.word))))
                     else return () ))))
                  ))))))\<close> 
  for  "alignment"  :: " int " 
  and  "d"  :: " int " 
  and  "d2"  :: " int " 
  and  "d3"  :: " int " 
  and  "d4"  :: " int " 
  and  "l__121"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "register_index"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_m_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_m_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_m_A1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x0 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x1 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:39071.58-39071.59'')) \<then>
     execute_aarch32_instrs_VST4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n register_index
       wback)))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VST4_m_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VST4_m_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VST4_m_T1enc_A_txt D Rn Vd itype size1 align Rm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (if (((size1 = ( 0b11 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let (inc_name :: int) = ((( 1 :: int)::ii)) in
     (let b__0 = itype in
     (if (((b__0 = ( 0x0 ::  4 Word.word)))) then return (( 1 :: int)::ii)
      else if (((b__0 = ( 0x1 ::  4 Word.word)))) then return (( 2 :: int)::ii)
      else throw (Error_See (''Related encodings''))) \<bind> ((\<lambda> (inc_name :: int) . 
     (let inc_name = inc_name in
     (let alignment =
       (if (((align = ( 0b00 ::  2 Word.word)))) then (( 1 :: int)::ii)
       else shl_int (( 4 :: int)::ii) ((Word.uint align))) in
     (let ebytes = (shl_int (( 1 :: int)::ii) ((Word.uint size1))) in
     (let elements = ((( 8 :: int)::ii) div ebytes) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let d2 = (d + inc_name) in
     (let d3 = (d2 + inc_name) in
     (let d4 = (d3 + inc_name) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (wback :: bool) = (m \<noteq> (( 15 :: int)::ii)) in
     (let (register_index :: bool) = ((((m \<noteq> (( 15 :: int)::ii)))) \<and> (((m \<noteq> (( 13 :: int)::ii))))) in
     ((if ((((((n = (( 15 :: int)::ii)))) \<or> ((d4 > (( 31 :: int)::ii)))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     assert_exp (((((((((((((((((id0 alignment)) = (( 1 :: int)::ii)))) \<or> (((((id0 alignment)) = (( 4 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 8 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 16 :: int)::ii))))))) \<or> (((((id0 alignment)) = (( 32 :: int)::ii))))))) (''src/instrs32.sail:39123.58-39123.59'')) \<then>
     execute_aarch32_instrs_VST4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n register_index
       wback)))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "itype"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "align"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSTM_Op_A_txt : bool -> integer -> mword ty32 -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSTM_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback = (
   (CheckVFPEnabled True \<then>
   (if add then (R_read n  :: ( 32 Word.word) M)
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word)))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) address
     ((\<lambda> r address . 
       if single_regs then
         (S_read ((d + r))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
         MemA_set address (( 4 :: int)::ii) w__2 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
         return address))))
       else
         BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__3 :: bool) . 
         (if w__3 then
            (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
            return ((subrange_vec_dec w__4 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))
          else
            (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
            return ((subrange_vec_dec w__5 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))) \<bind> ((\<lambda> (w__6 ::
            32 Word.word) . 
         (MemA_set address (( 4 :: int)::ii) w__6 \<then>
         BigEndian AccType_ATOMIC) \<bind> ((\<lambda> (w__7 :: bool) . 
         (if w__7 then
            (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
            return ((subrange_vec_dec w__8 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
          else
            (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
            return ((subrange_vec_dec w__9 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))) \<bind> ((\<lambda> (w__10 ::
            32 Word.word) . 
         MemA_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__10 \<then>
         ((let (address :: 32 bits) = ((add_vec_int address (( 8 :: int)::ii)  ::  32 Word.word)) in
         return address))))))))))))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
   if wback then
     (if add then
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
        return ((add_vec w__11 imm32  ::  32 Word.word))))
      else
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
        return ((sub_vec w__12 imm32  ::  32 Word.word))))) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
     R_set n w__13))
   else return () )))))))\<close> 
  for  "add"  :: " bool " 
  and  "d"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "single_regs"  :: " bool " 
  and  "wback"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSTM_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSTM_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSTM_A1enc_A_txt cond P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:39174.29-39174.30'') \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VSTR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = False in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (((Word.uint imm8)) div (( 2 :: int)::ii)) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     (((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((regs = (( 0 :: int)::ii)))) \<or> ((regs > (( 16 :: int)::ii)))))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec imm8 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> ((((d + regs)) > (( 16 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSTM_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSTM_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSTM_A2enc_A_txt cond P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:39222.29-39222.30'') \<then>
     (if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VSTR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (Word.uint imm8) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((regs = (( 0 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSTM_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSTM_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSTM_T1enc_A_txt P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VSTR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = False in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (((Word.uint imm8)) div (( 2 :: int)::ii)) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     (((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((regs = (( 0 :: int)::ii)))) \<or> ((regs > (( 16 :: int)::ii)))))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec imm8 (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> ((((d + regs)) > (( 16 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSTM_T2enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSTM_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSTM_T2enc_A_txt P U D W Rn Vd imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((if (((((((((P = ( 0b0 ::  1 Word.word)))) \<and> (((U = ( 0b0 ::  1 Word.word))))))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((P = ( 0b1 ::  1 Word.word)))) \<and> (((W = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''VSTR''))
      else return () )) \<then>
     (if ((((((P = U))) \<and> (((W = ( 0b1 ::  1 Word.word))))))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let (single_regs :: bool) = True in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let n = (Word.uint Rn) in
     (let (imm32 :: 32 bits) = ((place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     (let regs = (Word.uint imm8) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (or_boolM (return wback)
          (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32))))))) \<bind> ((\<lambda> w__3 . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((regs = (( 0 :: int)::ii)))) \<or> ((((d + regs)) > (( 32 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))))))))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSTR_Op_A_txt : bool -> integer -> integer -> mword ty32 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSTR_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSTR_Op_A_txt add d esize imm32 n = (
   (CheckVFPEnabled True \<then>
   (if add then
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 imm32  ::  32 Word.word))))
    else
      (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return ((sub_vec w__1 imm32  ::  32 Word.word)))))) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let l__118 = esize in
   if (((l__118 = (( 16 :: int)::ii)))) then
     (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
     MemA_set address (( 2 :: int)::ii) ((subrange_vec_dec w__2 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))
   else if (((l__118 = (( 32 :: int)::ii)))) then
     (S_read d  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) .  MemA_set address (( 4 :: int)::ii) w__3))
   else if (((l__118 = (( 64 :: int)::ii)))) then
     BigEndian AccType_ATOMIC \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then
        (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
        return ((subrange_vec_dec w__5 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))
      else
        (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
        return ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
     (MemA_set address (( 4 :: int)::ii) w__7 \<then>
     BigEndian AccType_ATOMIC) \<bind> ((\<lambda> (w__8 :: bool) . 
     (if w__8 then
        (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
        return ((subrange_vec_dec w__9 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
      else
        (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
        return ((subrange_vec_dec w__10 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
     MemA_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__11))))))))
   else return () ))))\<close> 
  for  "add"  :: " bool " 
  and  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "imm32"  :: "(32)Word.word " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSTR_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSTR_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSTR_A1enc_A_txt cond U D Rn Vd size1 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:39385.29-39385.30'') \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let esize = (shl_int (( 8 :: int)::ii) ((Word.uint size1))) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (imm32 :: 32 bits) =
       (if (((esize = (( 16 :: int)::ii)))) then (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  32 Word.word)
       else (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__0 = size1 in
     (let (d :: int) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b10 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b11 ::  2 Word.word)))) then Word.uint ((concat_vec D Vd  ::  5 Word.word))
       else d) in
     (let d = d in
     (let n = (Word.uint Rn) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (CurrentInstrSet ()  \<bind> ((\<lambda> (w__1 :: InstrSet) .  return (((w__1 \<noteq> InstrSet_A32)))))) \<bind> ((\<lambda> (w__2 ::
       bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let d = d in
     execute_aarch32_instrs_VSTR_Op_A_txt add d esize imm32 n))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSTR_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty8 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSTR_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSTR_T1enc_A_txt U D Rn Vd size1 imm8 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let esize = (shl_int (( 8 :: int)::ii) ((Word.uint size1))) in
     (let (add :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (imm32 :: 32 bits) =
       (if (((esize = (( 16 :: int)::ii)))) then (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  32 Word.word)
       else (place_slice (( 32 :: int)::ii) imm8 (( 0 :: int)::ii) (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  32 Word.word)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     (let b__0 = size1 in
     (let (d :: int) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b10 ::  2 Word.word)))) then Word.uint ((concat_vec Vd D  ::  5 Word.word))
       else if (((b__0 = ( 0b11 ::  2 Word.word)))) then Word.uint ((concat_vec D Vd  ::  5 Word.word))
       else d) in
     (let d = d in
     (let n = (Word.uint Rn) in
     and_boolM (return (((n = (( 15 :: int)::ii)))))
       (CurrentInstrSet ()  \<bind> ((\<lambda> (w__3 :: InstrSet) .  return (((w__3 \<noteq> InstrSet_A32)))))) \<bind> ((\<lambda> (w__4 ::
       bool) . 
     (if w__4 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let d = d in
     execute_aarch32_instrs_VSTR_Op_A_txt add d esize imm32 n))))))))))))))))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "imm8"  :: "(8)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSUB_f_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSUB_f_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSUB_f_Op_A_txt advsimd d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
       ((\<lambda> r unit_var . 
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
           ((\<lambda> e unit_var . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
             (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
             (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             (FPSub w__2 w__4 w__5  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
             (Elem_set w__0 e esize w__6  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
             D_set ((d + r)) w__7))))))))))))))))))))))))))
   else
     (let l__115 = esize in
     if (((l__115 = (( 16 :: int)::ii)))) then
       (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
       (FPSub ((subrange_vec_dec w__8 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ((subrange_vec_dec w__9 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__10
         :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
       S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__11  ::  32 Word.word))))))))))
     else if (((l__115 = (( 32 :: int)::ii)))) then
       (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
       (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
       (FPSub w__12 w__13 w__14  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) .  S_set d w__15))))))))
     else if (((l__115 = (( 64 :: int)::ii)))) then
       (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
       (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
       (FPSub w__16 w__17 w__18  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) .  D_set d w__19))))))))
     else return () )))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUB_f_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUB_f_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUB_f_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_f_Op_A_txt True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSUB_f_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n regs)))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUB_f_A2enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUB_f_A2enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUB_f_A2enc_A_txt cond D Vn Vd b__0 N M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:39563.29-39563.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       (if (((True \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:39563.29-39563.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
          return (((((slice w__5 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
          return (((((slice w__6 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__7 ::
         bool) . 
       (if w__7 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__8 :: bool) . 
     if w__8 then
       (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:39563.29-39563.30'') \<then>
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
          return (((((slice w__9 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
          return (((((slice w__10 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__11 ::
         bool) . 
       (if w__11 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__12 :: bool) . 
   if w__12 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:39563.29-39563.30'') \<then>
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return (((((slice w__13 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
        return (((((slice w__14 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__15 ::
       bool) . 
     (((if w__15 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((b__0 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUB_f_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUB_f_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUB_f_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (elements :: int) = ((( 2 :: int)::ii)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_f_Op_A_txt True d (( 2 :: int)::ii)
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   if w__1 then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((b__0 = ( 0b1 ::  1 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__3 :: bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSUB_f_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m n regs)))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUB_f_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUB_f_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUB_f_T2enc_A_txt D Vn Vd b__0 N M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
          return (((((slice w__1 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
          return (((((slice w__2 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__3 ::
         bool) . 
       ((if w__3 then throw (Error_Undefined () )
        else return () ) \<then>
       and_boolM (return True) ((InITBlock () ))) \<bind> ((\<lambda> (w__5 :: bool) . 
       (if w__5 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
         ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
     if w__6 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
          return (((((slice w__7 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
          return (((((slice w__8 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__9 ::
         bool) . 
       (if w__9 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 32 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
         ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__10 :: bool) . 
     if w__10 then
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
       or_boolM
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
          return (((((slice w__11 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
         ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
          return (((((slice w__12 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__13 ::
         bool) . 
       (if w__13 then throw (Error_Undefined () )
        else return () ) \<then>
       ((let elements = elements in
       (let regs = regs in
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
       undefined_range 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
       (let (esize :: int) = ((( 64 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let n = n in
       (let m = m in
       (let d = d in
       execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n regs)))))))))))))))))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__14 :: bool) . 
   if w__14 then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     or_boolM
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
        return (((((slice w__15 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))
       ((FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
        return (((((slice w__16 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))) \<bind> ((\<lambda> (w__17 ::
       bool) . 
     (((if w__17 then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     and_boolM (return (((b__0 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__19 :: bool) . 
     (if w__19 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VSUB_f_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n regs)))))))))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSUBHN_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSUBHN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSUBHN_Op_A_txt d__arg elements l__112 m n = (
   if (((l__112 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (result :: 16 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
         (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::  128 Word.word) . 
         (Elem_read w__2 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
         (let result = ((sub_vec w__1 w__3  ::  16 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_set w__4 e (( 8 :: int)::ii) ((subrange_vec_dec result (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
         D_set d w__5 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  16 Word.word) . 
     return () ))))))))
   else if (((l__112 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (result :: 32 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_read w__6 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
         (Elem_read w__8 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         (let result = ((sub_vec w__7 w__9  ::  32 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
         (Elem_set w__10 e (( 16 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         D_set d w__11 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  32 Word.word) . 
     return () ))))))))
   else if (((l__112 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__12 ::  128 Word.word) . 
         (Elem_read w__12 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_read w__14 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         (let result = ((sub_vec w__13 w__15  ::  64 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
         (Elem_set w__16 e (( 32 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
         D_set d w__17 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (result :: 128 bits) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__18 ::  128 Word.word) . 
         (Elem_read w__18 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__19 ::  128 Word.word) . 
         (Qin_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__20 ::  128 Word.word) . 
         (Elem_read w__20 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__21 ::  128 Word.word) . 
         (let result = ((sub_vec w__19 w__21  ::  128 Word.word)) in
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
         (Elem_set w__22 e (( 64 :: int)::ii) ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
           :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
         D_set d w__23 \<then> return result)))))))))))))))) \<bind> ((\<lambda> (result ::  128 Word.word) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__112"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUBHN_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUBHN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUBHN_A1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUBHN_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUBHN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUBHN_T1enc_A_txt D b__0 Vn Vd N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBHN_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBHN_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) m n))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBHN_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) m n))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSUB_i_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSUB_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSUB_i_Op_A_txt d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (Elem_read w__3 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 :: ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize ((sub_vec w__2 w__4  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::
              64 Word.word) . 
           D_set ((d + r)) w__5))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUB_i_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUB_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUB_i_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUB_i_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUB_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUB_i_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSUB_i_Op_A_txt d (( 1 :: int)::ii) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m n
       regs)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSUBL_Op_A_txt : integer -> integer -> integer -> bool -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSUBL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSUBL_Op_A_txt d__arg elements l__109 is_vsubw m n is_unsigned = (
   if (((l__109 = (( 8 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vsubw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
            (Elem_read w__0 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::  16 Word.word) . 
            (let op1 = (asl_Int w__1 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
            (Elem_read w__2 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
            (let op1 = (asl_Int w__3 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
         (Elem_read w__4 e (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
         (let result = (op1 - ((asl_Int w__5 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
         (Elem_set w__6 e (( 16 :: int)::ii) ((integer_subrange result (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__7 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__109 = (( 16 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vsubw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
            (Elem_read w__8 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
            (let op1 = (asl_Int w__9 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
            (Elem_read w__10 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__11 ::  16 Word.word) . 
            (let op1 = (asl_Int w__11 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
         (Elem_read w__12 e (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__13 ::  16 Word.word) . 
         (let result = (op1 - ((asl_Int w__13 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__14 ::  128 Word.word) . 
         (Elem_set w__14 e (( 32 :: int)::ii) ((integer_subrange result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__15 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__15 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else if (((l__109 = (( 32 :: int)::ii)))) then
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vsubw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__16 ::  128 Word.word) . 
            (Elem_read w__16 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
            (let op1 = (asl_Int w__17 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
            (Elem_read w__18 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
            (let op1 = (asl_Int w__19 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
         (Elem_read w__20 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
         (let result = (op1 - ((asl_Int w__21 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__22 ::  128 Word.word) . 
         (Elem_set w__22 e (( 64 :: int)::ii) ((integer_subrange result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__23 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__23 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () ))))))))
   else
     \<comment> \<open>\<open> 'esize == 64 \<close>\<close>
     (let (d :: ii) = d__arg in
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (result :: ii) . 
     CheckAdvSIMDEnabled ()  \<then>
     ((let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         undefined_int 
  instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op1 :: ii) . 
         (if is_vsubw then
            (Qin_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__24 ::  128 Word.word) . 
            (Elem_read w__24 e (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__25 ::  128 Word.word) . 
            (let op1 = (asl_Int w__25 is_unsigned) in
            return op1)))))
          else
            (Din_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
            (Elem_read w__26 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
            (let op1 = (asl_Int w__27 is_unsigned) in
            return op1)))))) \<bind> ((\<lambda> (op1 :: ii) . 
         (let op1 = op1 in
         (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
         (Elem_read w__28 e (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
         (let result = (op1 - ((asl_Int w__29 is_unsigned))) in
         (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__30 ::  128 Word.word) . 
         (Elem_set w__30 e (( 128 :: int)::ii) ((integer_subrange result (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word))
           :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__31 ::  128 Word.word) . 
         Q_set ((shr_int d (( 1 :: int)::ii))) w__31 \<then> return result))))))))))))))))) \<bind> ((\<lambda> (result :: ii) . 
     return () )))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "l__109"  :: " int " 
  and  "is_vsubw"  :: " bool " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUBL_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUBL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUBL_A1enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vsubw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) is_vsubw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vsubw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) is_vsubw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vsubw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) is_vsubw m n is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSUBL_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSUBL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSUBL_T1enc_A_txt U D b__0 Vn Vd op1 N M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vsubw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBL_Op_A_txt d (( 8 :: int)::ii) (( 8 :: int)::ii) is_vsubw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vsubw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBL_Op_A_txt d (( 4 :: int)::ii) (( 16 :: int)::ii) is_vsubw m n is_unsigned))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((((op1 = ( 0b1 ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (is_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
       (let (is_vsubw :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VSUBL_Op_A_txt d (( 2 :: int)::ii) (( 32 :: int)::ii) is_vsubw m n is_unsigned))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_See (''Related encodings''))
   else return () )))\<close> 
  for  "U"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSWP_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSWP_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSWP_Op_A_txt d m regs = (
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       if (((d = m))) then
         (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
         D_set ((d + r)) w__0))
       else
         (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
         (D_set ((d + r)) w__1 \<then>
         (Din_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
         D_set ((m + r)) w__2)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSWP_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSWP_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSWP_A1enc_A_txt D size1 Vd Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSWP_Op_A_txt d m regs))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSWP_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSWP_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSWP_T1enc_A_txt D size1 Vd Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VSWP_Op_A_txt d m regs))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VTBL_Op_A_txt : integer -> bool -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VTBL_Op_A_txt  :: \<open> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VTBL_Op_A_txt d__arg is_vtbl length1 m n = (
   (let (d :: ii) = d__arg in
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (index1 :: ii) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (if (((length1 = (( 4 :: int)::ii)))) then (D_read ((n + (( 3 :: int)::ii)))  :: ( 64 Word.word) M)
    else return ((Zeros (( 64 :: int)::ii)  ::  64 Word.word)))) \<bind> ((\<lambda> (table3 :: 64 bits) . 
   (if ((length1 \<ge> (( 3 :: int)::ii))) then (D_read ((n + (( 2 :: int)::ii)))  :: ( 64 Word.word) M)
    else return ((Zeros (( 64 :: int)::ii)  ::  64 Word.word))) \<bind> ((\<lambda> (table2 :: 64 bits) . 
   (if ((length1 \<ge> (( 2 :: int)::ii))) then (D_read ((n + (( 1 :: int)::ii)))  :: ( 64 Word.word) M)
    else return ((Zeros (( 64 :: int)::ii)  ::  64 Word.word))) \<bind> ((\<lambda> (table1 :: 64 bits) . 
   (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
   (let (table :: 256 bits) =
     ((concat_vec ((concat_vec ((concat_vec table3 table2  ::  128 Word.word)) table1  ::  192 Word.word))
        w__3
       ::  256 Word.word)) in
   (let loop_i_lower = ((( 0 :: int)::ii)) in
   (let loop_i_upper = ((( 7 :: int)::ii)) in
   (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) index1
     ((\<lambda> i index1 . 
       (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
       (Elem_read w__4 i (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
       (let index1 = (Word.uint w__5) in
       (let index1 = index1 in
       (if ((index1 < (((( 8 :: int)::ii) * length1)))) then
          (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
          (Elem_read table index1 (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__7 ::  8 Word.word) . 
          (Elem_set w__6 i (( 8 :: int)::ii) w__7  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
          D_set d w__8))))))
        else if is_vtbl then
          (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
          (Elem_set w__9 i (( 8 :: int)::ii) ((Zeros (( 8 :: int)::ii)  ::  8 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::
             64 Word.word) . 
          D_set d w__10))))
        else return () ) \<then>
       return index1))))))))) \<bind> ((\<lambda> (index1 :: ii) . 
   return () )))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "is_vtbl"  :: " bool " 
  and  "length1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VTBL_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VTBL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VTBL_A1enc_A_txt D Vn Vd len N op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (is_vtbl :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let length1 = (((Word.uint len)) + (( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (if ((((n + length1)) > (( 32 :: int)::ii))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VTBL_Op_A_txt d is_vtbl length1 m n)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "len"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VTBL_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VTBL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VTBL_T1enc_A_txt D Vn Vd len N op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (is_vtbl :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let length1 = (((Word.uint len)) + (( 1 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (if ((((n + length1)) > (( 32 :: int)::ii))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VTBL_Op_A_txt d is_vtbl length1 m n)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "len"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VTRN_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VTRN_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VTRN_Op_A_txt d__arg elements esize m__arg regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (let (m :: ii) = m__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let h = (elements div (( 2 :: int)::ii)) in
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       if (((d = m))) then
         (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
         D_set ((d + r)) w__0))
       else
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (h - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
           ((\<lambda> e unit_var . 
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
             (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 ::
               ( 'esize::len)Word.word) . 
             (Elem_set w__1 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize w__3
               :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
             (D_set ((d + r)) w__4 \<then>
             (D_read ((m + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
             (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
             (Elem_read w__6 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize
               :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
             (Elem_set w__5 (((( 2 :: int)::ii) * e)) esize w__7  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::
                64 Word.word) . 
             D_set ((m + r)) w__8))))))))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m__arg"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VTRN_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VTRN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VTRN_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTRN_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTRN_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTRN_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VTRN_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VTRN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VTRN_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTRN_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m regs))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTRN_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         regs))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTRN_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         regs))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VTST_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VTST_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VTST_Op_A_txt d__arg elements esize m n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           if ((\<not> ((IsZero ((and_vec w__1 w__3  :: ( 'esize::len)Word.word)))))) then
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
             (Elem_set w__4 e esize ((Ones esize  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::
                64 Word.word) . 
             D_set ((d + r)) w__5))))
           else
             (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
             (Elem_set w__6 e esize ((Zeros esize  :: ( 'esize::len)Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::
                64 Word.word) . 
             D_set ((d + r)) w__7))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VTST_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VTST_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VTST_A1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTST_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTST_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTST_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VTST_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VTST_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VTST_T1enc_A_txt D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTST_Op_A_txt d (( 8 :: int)::ii) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTST_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
         regs)))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
       execute_aarch32_instrs_VTST_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
         regs)))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VUZP_Op_A_txt : forall 'esize. Size 'esize => integer -> itself 'esize -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VUZP_Op_A_txt  :: \<open> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VUZP_Op_A_txt d__arg esize m__arg quadword_operation = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (let (m :: ii) = m__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (zipped_d :: 128 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 256 :: int)::ii)  :: ( 256 Word.word) M) \<bind> ((\<lambda> (zipped_q :: 256 bits) . 
   CheckAdvSIMDEnabled ()  \<then>
   (if quadword_operation then
     if (((d = m))) then
       (UNKNOWN_bits (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
       Q_set ((shr_int d (( 1 :: int)::ii))) w__0))
     else
       (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__1 ::  128 Word.word) . 
       (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::  128 Word.word) . 
       (let (zipped_q :: 256 bits) = ((concat_vec w__1 w__2  ::  256 Word.word)) in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((((( 128 :: int)::ii) div esize)) - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__3 ::  128 Word.word) . 
           (Elem_read zipped_q (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 ::
             ( 'esize::len)Word.word) . 
           (Elem_set w__3 e esize w__4  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__5 ::  128 Word.word) . 
           (Q_set ((shr_int d (( 1 :: int)::ii))) w__5 \<then>
           (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  128 Word.word) . 
           (Elem_read zipped_q (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize
             :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
           (Elem_set w__6 e esize w__7  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__8 ::  128 Word.word) . 
           Q_set ((shr_int m (( 1 :: int)::ii))) w__8))))))))))))))))))))))
   else if (((d = m))) then
     (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) .  D_set d w__9))
   else
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
     (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
     (let (zipped_d :: 128 bits) = ((concat_vec w__10 w__11  ::  128 Word.word)) in
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = ((((( 64 :: int)::ii) div esize)) - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
       ((\<lambda> e unit_var . 
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
         (Elem_read zipped_d (((( 2 :: int)::ii) * e)) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__13 ::
           ( 'esize::len)Word.word) . 
         (Elem_set w__12 e esize w__13  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
         (D_set d w__14 \<then>
         (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
         (Elem_read zipped_d (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize
           :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__16 :: ( 'esize::len)Word.word) . 
         (Elem_set w__15 e esize w__16  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
         D_set m w__17)))))))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m__arg"  :: " int " 
  and  "quadword_operation"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VUZP_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VUZP_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VUZP_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VUZP_Op_A_txt d ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VUZP_Op_A_txt d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((False \<or> ((((((Q = ( 0b0 ::  1 Word.word)))) \<and> True)))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VUZP_Op_A_txt d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         quadword_operation))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VUZP_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VUZP_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VUZP_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VUZP_Op_A_txt d ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VUZP_Op_A_txt d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((False \<or> ((((((Q = ( 0b0 ::  1 Word.word)))) \<and> True)))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VUZP_Op_A_txt d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         quadword_operation))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VZIP_Op_A_txt : forall 'esize. Size 'esize => integer -> itself 'esize -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VZIP_Op_A_txt  :: \<open> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VZIP_Op_A_txt d esize m quadword_operation = (
   (let esize = (size_itself_int esize) in
   CheckAdvSIMDEnabled ()  \<then>
   (if quadword_operation then
     if (((d = m))) then
       (UNKNOWN_bits (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
       Q_set ((shr_int d (( 1 :: int)::ii))) w__0))
     else
       (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 256 :: int)::ii)  :: ( 256 Word.word) M) \<bind> ((\<lambda> (zipped_q :: 256 bits) . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((((( 128 :: int)::ii) div esize)) - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) zipped_q
         ((\<lambda> e zipped_q . 
           (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__1 ::  128 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (Elem_set zipped_q (((( 2 :: int)::ii) * e)) esize w__2  :: ( 256 Word.word) M) \<bind> ((\<lambda> (w__3 ::
              256 Word.word) . 
           (let zipped_q = w__3 in
           (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__4 ::  128 Word.word) . 
           (Elem_read w__4 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
           (Elem_set zipped_q (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize w__5
             :: ( 256 Word.word) M))))))))))))))) \<bind> ((\<lambda> (zipped_q ::  256 Word.word) . 
       Q_set ((shr_int d (( 1 :: int)::ii))) ((subrange_vec_dec zipped_q (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word)) \<then>
       Q_set ((shr_int m (( 1 :: int)::ii))) ((subrange_vec_dec zipped_q (( 255 :: int)::ii) (( 128 :: int)::ii)  ::  128 Word.word))))))))
   else if (((d = m))) then
     (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) .  D_set d w__7))
   else
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (zipped_d :: 128 bits) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = ((((( 64 :: int)::ii) div esize)) - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) zipped_d
       ((\<lambda> e zipped_d . 
         (D_read d  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
         (Elem_read w__8 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__9 :: ( 'esize::len)Word.word) . 
         (Elem_set zipped_d (((( 2 :: int)::ii) * e)) esize w__9  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__10 ::
            128 Word.word) . 
         (let zipped_d = w__10 in
         (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
         (Elem_read w__11 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__12 :: ( 'esize::len)Word.word) . 
         (Elem_set zipped_d (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) esize w__12
           :: ( 128 Word.word) M))))))))))))))) \<bind> ((\<lambda> (zipped_d ::  128 Word.word) . 
     D_set d ((subrange_vec_dec zipped_d (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) \<then>
     D_set m ((subrange_vec_dec zipped_d (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "quadword_operation"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VZIP_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VZIP_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VZIP_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VZIP_Op_A_txt d ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VZIP_Op_A_txt d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((False \<or> ((((((Q = ( 0b0 ::  1 Word.word)))) \<and> True)))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VZIP_Op_A_txt d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         quadword_operation))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VZIP_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VZIP_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VZIP_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VZIP_Op_A_txt d ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () ) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VZIP_Op_A_txt d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m
         quadword_operation))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       ((if (((False \<or> ((((((Q = ( 0b0 ::  1 Word.word)))) \<and> True)))))) then
          throw (Error_Undefined () )
        else return () ) \<then>
       (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
        then
          throw (Error_Undefined () )
        else return () )) \<then>
       ((let (quadword_operation :: bool) = (Q = ( 0b1 ::  1 Word.word)) in
       (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
       (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
       execute_aarch32_instrs_VZIP_Op_A_txt d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m
         quadword_operation))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Undefined () )
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_WFE_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_WFE_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_WFE_Op_A_txt _ = (
   IsEventRegisterSet ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then ClearEventRegister () 
   else
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     ((if ((((ProcState_EL   w__1) = EL0))) then AArch32_CheckForWFxTrap EL1 WFxType_WFE
      else return () ) \<then>
     and_boolM
       (and_boolM
          (or_boolM
             (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
              return ((((ProcState_EL   w__2) = EL0))))))
             (read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
              return ((((ProcState_EL   w__3) = EL1))))))) ((EL2Enabled () )))
       (IsInHost ()  \<bind> ((\<lambda> (w__7 :: bool) .  return ((\<not> w__7)))))) \<bind> ((\<lambda> (w__8 :: bool) . 
     ((if w__8 then AArch32_CheckForWFxTrap EL2 WFxType_WFE
      else return () ) \<then>
     and_boolM (return ((HaveEL EL3)))
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
        return ((((ProcState_M   w__9) \<noteq> M32_Monitor))))))) \<bind> ((\<lambda> (w__10 :: bool) . 
     (if w__10 then AArch32_CheckForWFxTrap EL3 WFxType_WFE
      else return () ) \<then>
     ((let localtimeout = (shl_int (( 1 :: int)::ii) (( 64 :: int)::ii)) in
     WaitForEvent localtimeout)))))))))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_WFE_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_WFE_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_WFE_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:40528.29-40528.30'') \<then>
     execute_aarch32_instrs_WFE_Op_A_txt () 
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_WFE_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_WFE_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_WFE_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_WFE_Op_A_txt () 
   else return () )))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_WFE_T2enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_WFE_T2enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_WFE_T2enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_WFE_Op_A_txt () 
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_WFI_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_WFI_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_WFI_Op_A_txt _ = (
   InterruptPending ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     ((if ((((ProcState_EL   w__1) = EL0))) then AArch32_CheckForWFxTrap EL1 WFxType_WFI
      else return () ) \<then>
     and_boolM
       (and_boolM
          (or_boolM
             (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
              return ((((ProcState_EL   w__2) = EL0))))))
             (read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
              return ((((ProcState_EL   w__3) = EL1))))))) ((EL2Enabled () )))
       (IsInHost ()  \<bind> ((\<lambda> (w__7 :: bool) .  return ((\<not> w__7)))))) \<bind> ((\<lambda> (w__8 :: bool) . 
     ((if w__8 then AArch32_CheckForWFxTrap EL2 WFxType_WFI
      else return () ) \<then>
     and_boolM (return ((HaveEL EL3)))
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
        return ((((ProcState_M   w__9) \<noteq> M32_Monitor))))))) \<bind> ((\<lambda> (w__10 :: bool) . 
     (if w__10 then AArch32_CheckForWFxTrap EL3 WFxType_WFI
      else return () ) \<then>
     ((let localtimeout = (shl_int (( 1 :: int)::ii) (( 64 :: int)::ii)) in
     WaitForInterrupt localtimeout))))))))
   else return () )))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_WFI_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_WFI_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_WFI_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:40599.29-40599.30'') \<then>
     execute_aarch32_instrs_WFI_Op_A_txt () 
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_WFI_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_WFI_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_WFI_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_WFI_Op_A_txt () 
   else return () )))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_WFI_T2enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_WFI_T2enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_WFI_T2enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_WFI_Op_A_txt () 
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_YIELD_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_YIELD_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_YIELD_Op_A_txt _ = ( Hint_Yield ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_YIELD_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_YIELD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_YIELD_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:40657.29-40657.30'') \<then>
     return ((execute_aarch32_instrs_YIELD_Op_A_txt () ))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_YIELD_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_YIELD_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_YIELD_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_YIELD_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_YIELD_T2enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_YIELD_T2enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_YIELD_T2enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_YIELD_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_CPS_OpT_AS_txt : bool -> bool -> bool -> bool -> bool -> bool -> mword ty5 -> M unit\<close>\<close>

definition execute_aarch32_instrs_CPS_OpT_AS_txt  :: \<open> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CPS_OpT_AS_txt affectA affectF affectI changemode disable enable mode = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) \<noteq> EL0))) then
     ((if enable then
        ((if affectA then
           read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
           write_reg PSTATE_ref ( w__1 (| ProcState_A := (( 0b0 ::  1 Word.word)) |))))
         else return () ) \<then>
        (if affectI then
           read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
           write_reg PSTATE_ref ( w__2 (| ProcState_I := (( 0b0 ::  1 Word.word)) |))))
         else return () )) \<then>
        (if affectF then
          read_reg PSTATE_ref \<bind> ((\<lambda> (w__3 :: ProcState) . 
          write_reg PSTATE_ref ( w__3 (| ProcState_F := (( 0b0 ::  1 Word.word)) |))))
        else return () )
      else return () ) \<then>
     (if disable then
        ((if affectA then
           read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
           write_reg PSTATE_ref ( w__4 (| ProcState_A := (( 0b1 ::  1 Word.word)) |))))
         else return () ) \<then>
        (if affectI then
           read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
           write_reg PSTATE_ref ( w__5 (| ProcState_I := (( 0b1 ::  1 Word.word)) |))))
         else return () )) \<then>
        (if affectF then
          read_reg PSTATE_ref \<bind> ((\<lambda> (w__6 :: ProcState) . 
          write_reg PSTATE_ref ( w__6 (| ProcState_F := (( 0b1 ::  1 Word.word)) |))))
        else return () )
      else return () )) \<then>
     (if changemode then AArch32_WriteModeByInstr mode
     else return () )
   else return () )))\<close> 
  for  "affectA"  :: " bool " 
  and  "affectF"  :: " bool " 
  and  "affectI"  :: " bool " 
  and  "changemode"  :: " bool " 
  and  "disable"  :: " bool " 
  and  "enable"  :: " bool " 
  and  "mode"  :: "(5)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CPS_A1enc_AS_txt : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CPS_A1enc_AS_txt  :: \<open>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CPS_A1enc_AS_txt imod M A I F mode = (
   ((if ((((((mode \<noteq> ( 0b00000 ::  5 Word.word)))) \<and> (((M = ( 0b0 ::  1 Word.word))))))) then
      throw (Error_Unpredictable () )
    else return () ) \<then>
   (if ((((((((((vec_of_bits [access_vec_dec imod (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec ((concat_vec A I  ::  2 Word.word)) F  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))))) \<or> (((((((vec_of_bits [access_vec_dec imod (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<and> (((((concat_vec ((concat_vec A I  ::  2 Word.word)) F  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))))) then
      throw (Error_Unpredictable () )
    else return () )) \<then>
   ((let (enable :: bool) = (imod = ( 0b10 ::  2 Word.word)) in
   (let (disable :: bool) = (imod = ( 0b11 ::  2 Word.word)) in
   (let (changemode :: bool) = (M = ( 0b1 ::  1 Word.word)) in
   (let (affectA :: bool) = (A = ( 0b1 ::  1 Word.word)) in
   (let (affectI :: bool) = (I = ( 0b1 ::  1 Word.word)) in
   (let (affectF :: bool) = (F = ( 0b1 ::  1 Word.word)) in
   (if (((((((((imod = ( 0b00 ::  2 Word.word)))) \<and> (((M = ( 0b0 ::  1 Word.word))))))) \<or> (((imod = ( 0b01 ::  2 Word.word))))))) then
      throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_CPS_OpT_AS_txt affectA affectF affectI changemode disable enable mode))))))))\<close> 
  for  "imod"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "A"  :: "(1)Word.word " 
  and  "I"  :: "(1)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "mode"  :: "(5)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CPS_T1enc_AS_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CPS_T1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CPS_T1enc_AS_txt im A I F = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> ((\<lambda> (mode :: 5 bits) . 
   (if (((((concat_vec ((concat_vec A I  ::  2 Word.word)) F  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
    then
      throw (Error_Unpredictable () )
    else return () ) \<then>
   ((let mode = mode in
   (let (enable :: bool) = (im = ( 0b0 ::  1 Word.word)) in
   (let (disable :: bool) = (im = ( 0b1 ::  1 Word.word)) in
   (let (changemode :: bool) = False in
   (let (affectA :: bool) = (A = ( 0b1 ::  1 Word.word)) in
   (let (affectI :: bool) = (I = ( 0b1 ::  1 Word.word)) in
   (let (affectF :: bool) = (F = ( 0b1 ::  1 Word.word)) in
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_CPS_OpT_AS_txt affectA affectF affectI changemode disable enable mode)))))))))))))\<close> 
  for  "im"  :: "(1)Word.word " 
  and  "A"  :: "(1)Word.word " 
  and  "I"  :: "(1)Word.word " 
  and  "F"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CPS_T2enc_AS_txt : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CPS_T2enc_AS_txt  :: \<open>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CPS_T2enc_AS_txt imod M A I F mode = (
   (((if ((((((imod = ( 0b00 ::  2 Word.word)))) \<and> (((M = ( 0b0 ::  1 Word.word))))))) then
      throw (Error_See (''Hint instructions''))
    else return () ) \<then>
   (if ((((((mode \<noteq> ( 0b00000 ::  5 Word.word)))) \<and> (((M = ( 0b0 ::  1 Word.word))))))) then
      throw (Error_Unpredictable () )
    else return () )) \<then>
   (if ((((((((((vec_of_bits [access_vec_dec imod (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<and> (((((concat_vec ((concat_vec A I  ::  2 Word.word)) F  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))))) \<or> (((((((vec_of_bits [access_vec_dec imod (( 1 :: int)::ii)]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))) \<and> (((((concat_vec ((concat_vec A I  ::  2 Word.word)) F  ::  3 Word.word)) \<noteq> ( 0b000 ::  3 Word.word)))))))))) then
      throw (Error_Unpredictable () )
    else return () )) \<then>
   ((let (enable :: bool) = (imod = ( 0b10 ::  2 Word.word)) in
   (let (disable :: bool) = (imod = ( 0b11 ::  2 Word.word)) in
   (let (changemode :: bool) = (M = ( 0b1 ::  1 Word.word)) in
   (let (affectA :: bool) = (A = ( 0b1 ::  1 Word.word)) in
   (let (affectI :: bool) = (I = ( 0b1 ::  1 Word.word)) in
   (let (affectF :: bool) = (F = ( 0b1 ::  1 Word.word)) in
   or_boolM (return (((imod = ( 0b01 ::  2 Word.word))))) ((InITBlock () )) \<bind> ((\<lambda> (w__1 :: bool) . 
   (if w__1 then throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_CPS_OpT_AS_txt affectA affectF affectI changemode disable enable mode))))))))))\<close> 
  for  "imod"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "A"  :: "(1)Word.word " 
  and  "I"  :: "(1)Word.word " 
  and  "F"  :: "(1)Word.word " 
  and  "mode"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ERET_Op_AS_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_ERET_Op_AS_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ERET_Op_AS_txt _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (new_pc_value :: 32 bits) . 
   Halted ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then
     or_boolM
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
        return ((((ProcState_M   w__1) = M32_User))))))
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
        return ((((ProcState_M   w__2) = M32_System)))))) \<bind> ((\<lambda> (w__3 :: bool) . 
     if w__3 then throw (Error_Unpredictable () )
     else
       read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
       (if ((((ProcState_EL   w__4) = EL2))) then (ELR_hyp_read ()   :: ( 32 Word.word) M)
        else (R_read (( 14 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (new_pc_value :: 32 bits) . 
       (SPSR_read (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
       AArch32_ExceptionReturn new_pc_value w__7))))))))
   else
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__8 :: ProcState) . 
   if ((((ProcState_M   w__8) = M32_User))) then throw (Error_Undefined () )
   else
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   if ((((ProcState_M   w__9) = M32_System))) then throw (Error_Unpredictable () )
   else
     (let (_ :: unit) = (SynchronizeContext () ) in
     DebugRestorePSR () ))))))))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_ERET_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ERET_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ERET_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:40876.29-40876.30'') \<then>
     execute_aarch32_instrs_ERET_Op_AS_txt () 
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ERET_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_ERET_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ERET_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ERET_Op_AS_txt () ))
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_HVC_Op_AS_txt : mword ty16 -> M unit\<close>\<close>

definition execute_aarch32_instrs_HVC_Op_AS_txt  :: \<open>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_HVC_Op_AS_txt imm16 = (
   or_boolM
     (or_boolM (return ((\<not> ((HaveEL EL2)))))
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL0)))))))
     (and_boolM ((IsSecure () )) (IsSecureEL2Enabled ()  \<bind> ((\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))) \<bind> ((\<lambda> (w__5 ::
     bool) . 
   ((if w__5 then throw (Error_Undefined () )
    else return () ) \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> ((\<lambda> (hvc_enable :: 1 bits) . 
   (if ((HaveEL EL3)) then
      and_boolM
        (and_boolM ((ELUsingAArch32 EL3))
           ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
            return (((((slice w__7 (( 8 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))))))))
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) .  return ((((ProcState_EL   w__9) = EL2)))))) \<bind> ((\<lambda> (w__10 ::
        bool) . 
      if w__10 then throw (Error_Unpredictable () )
      else
        (SCR_GEN_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
        (let hvc_enable = ((vec_of_bits [access_vec_dec w__11 (( 8 :: int)::ii)]  ::  1 Word.word)) in
        return hvc_enable)))))
    else
      ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__12 :: bool) . 
      if w__12 then
        (HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
        return ((not_vec ((slice w__13 (( 29 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))  ::  1 Word.word))))
      else
        (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
        return ((not_vec ((slice w__14 (( 29 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))  ::  1 Word.word))))))) \<bind> ((\<lambda> (hvc_enable ::
      1 Word.word) . 
   if (((hvc_enable = ( 0b0 ::  1 Word.word)))) then throw (Error_Undefined () )
   else AArch32_CallHypervisor imm16)))))))\<close> 
  for  "imm16"  :: "(16)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_HVC_A1enc_A_txt : mword ty4 -> mword ty12 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_HVC_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_HVC_A1enc_A_txt cond imm12 imm4 = (
   (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:40942.25-40942.26'') \<then>
   (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
    else return () )) \<then>
   ((let (imm16 :: 16 bits) = ((concat_vec imm12 imm4  ::  16 Word.word)) in
   execute_aarch32_instrs_HVC_Op_AS_txt imm16)))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_HVC_T1enc_A_txt : mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_HVC_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_HVC_T1enc_A_txt imm4 imm12 = (
   (let (imm16 :: 16 bits) = ((concat_vec imm4 imm12  ::  16 Word.word)) in
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   execute_aarch32_instrs_HVC_Op_AS_txt imm16))))\<close> 
  for  "imm4"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDM_e_Op_AS_txt : bool -> integer -> mword ty15 -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDM_e_Op_AS_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>(15)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDM_e_Op_AS_txt increment_name n registers1 wback wordhigher = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (length1 :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (new_pc_value :: 32 bits) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Undefined () )
   else
   or_boolM
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) .  return ((((ProcState_M   w__1) = M32_User))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      return ((((ProcState_M   w__2) = M32_System)))))) \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Unpredictable () )
   else
     (let length1 = ((((( 4 :: int)::ii) * ((BitCount registers1)))) + (( 4 :: int)::ii)) in
     (if increment_name then (R_read n  :: ( 32 Word.word) M)
      else
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
        return ((sub_vec_int w__5 length1  ::  32 Word.word))))) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
     (let (address :: 32 bits) = w__6 in
     (let (address ::  32 Word.word) =
       (if wordhigher then (add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)
       else address) in
     (let loop_i_lower = ((( 0 :: int)::ii)) in
     (let loop_i_upper = ((( 14 :: int)::ii)) in
     (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
       ((\<lambda> i address . 
         if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
         then
           (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
           R_set i w__7 \<then>
           ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
           return address))))
         else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
     (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (new_pc_value :: 32 bits) . 
     (((assert_exp ((((id0 n)) < (( 15 :: int)::ii))) (''src/instrs32.sail:41002.34-41002.35'') \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b0 ::  1 Word.word)))))))
      then
        (if increment_name then
           (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
           return ((add_vec_int w__8 length1  ::  32 Word.word))))
         else
           (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
           return ((sub_vec_int w__9 length1  ::  32 Word.word))))) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
        R_set n w__10))
      else return () )) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) .  R_set n w__11))
      else return () )) \<then>
     (SPSR_read (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
     AArch32_ExceptionReturn new_pc_value w__12))))))))))))))))))))))))\<close> 
  for  "increment_name"  :: " bool " 
  and  "n"  :: " int " 
  and  "registers1"  :: "(15)Word.word " 
  and  "wback"  :: " bool " 
  and  "wordhigher"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDM_e_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty15 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDM_e_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(15)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDM_e_A1enc_AS_txt cond P U W Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41018.29-41018.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 15 bits) = register_list in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (increment_name :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wordhigher :: bool) = (P = U) in
     ((if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((wback \<and> ((((vec_of_bits [access_vec_dec registers1 n]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_LDM_e_Op_AS_txt increment_name n registers1 wback wordhigher))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(15)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDM_u_Op_AS_txt : bool -> integer -> mword ty15 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDM_u_Op_AS_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>(15)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDM_u_Op_AS_txt increment_name n registers1 wordhigher = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (length1 :: ii) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Undefined () )
   else
   or_boolM
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) .  return ((((ProcState_M   w__1) = M32_User))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      return ((((ProcState_M   w__2) = M32_System)))))) \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Unpredictable () )
   else
     (let length1 = ((( 4 :: int)::ii) * ((BitCount registers1))) in
     (if increment_name then (R_read n  :: ( 32 Word.word) M)
      else
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
        return ((sub_vec_int w__5 length1  ::  32 Word.word))))) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
     (let (address :: 32 bits) = w__6 in
     (let (address ::  32 Word.word) =
       (if wordhigher then (add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)
       else address) in
     (let loop_i_lower = ((( 0 :: int)::ii)) in
     (let loop_i_upper = ((( 14 :: int)::ii)) in
     (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
       ((\<lambda> i address . 
         if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
         then
           (MemS_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
           Rmode_set i M32_User w__7 \<then>
           ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
           return address))))
         else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
     return () ))))))))))))))))))\<close> 
  for  "increment_name"  :: " bool " 
  and  "n"  :: " int " 
  and  "registers1"  :: "(15)Word.word " 
  and  "wordhigher"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDM_u_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty15 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDM_u_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(15)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDM_u_A1enc_AS_txt cond P U Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41078.29-41078.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 15 bits) = register_list in
     (let (increment_name :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wordhigher :: bool) = (P = U) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDM_u_Op_AS_txt increment_name n registers1 wordhigher)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(15)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MRS_Op_AS_txt : integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MRS_Op_AS_txt  :: \<open> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MRS_Op_AS_txt d read_spsr = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (psr_val :: 32 bits) . 
   if read_spsr then
     or_boolM
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
        return ((((ProcState_M   w__0) = M32_User))))))
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
        return ((((ProcState_M   w__1) = M32_System)))))) \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then throw (Error_Unpredictable () )
     else (SPSR_read (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) .  R_set d w__3))))
   else
     (let (mask1 :: 32 bits) = (( 0xF8EF03DF ::  32 Word.word)) in
     (GetPSRFromPSTATE (( 32 :: int)::ii) AArch32_NonDebugState  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     (let (psr_val :: 32 bits) = ((and_vec w__4 mask1  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__5 :: ProcState) . 
     (if ((((ProcState_EL   w__5) = EL0))) then
        (UNKNOWN_bits (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (w__6 ::  1 Word.word) . 
        (let psr_val = ((update_vec_dec psr_val (( 22 :: int)::ii) ((Bit w__6))  ::  32 Word.word)) in
        (UNKNOWN_bits (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> ((\<lambda> (w__7 ::  4 Word.word) . 
        (let psr_val = ((update_subrange_vec_dec psr_val (( 9 :: int)::ii) (( 6 :: int)::ii) w__7  ::  32 Word.word)) in
        (UNKNOWN_bits (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> ((\<lambda> (w__8 ::  5 Word.word) . 
        (let psr_val = ((update_subrange_vec_dec psr_val (( 4 :: int)::ii) (( 0 :: int)::ii) w__8  ::  32 Word.word)) in
        return psr_val)))))))))
      else return psr_val) \<bind> ((\<lambda> (psr_val ::  32 Word.word) . 
     R_set d psr_val)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "read_spsr"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRS_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRS_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRS_A1enc_AS_txt cond R Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41132.29-41132.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let (read_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MRS_Op_AS_txt d read_spsr)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRS_T1enc_AS_txt : mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRS_T1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRS_T1enc_AS_txt R Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (read_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MRS_Op_AS_txt d read_spsr))
   else return () )))\<close> 
  for  "R"  :: "(1)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MRS_br_Op_AS_txt : mword ty5 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MRS_br_Op_AS_txt  :: \<open>(5)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MRS_br_Op_AS_txt SYSm d read_spsr = (
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> ((\<lambda> (mode :: 5 bits) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) = EL0))) then throw (Error_Unpredictable () )
   else
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (let (mode :: 5 bits) = ((ProcState_M   w__1)) in
     if read_spsr then
       SPSRaccessValid SYSm mode \<then>
       ((let b__9 = SYSm in
       if (((b__9 = ( 0b01110 ::  5 Word.word)))) then
         (read_reg SPSR_fiq_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
         R_set d ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
       else if (((b__9 = ( 0b10000 ::  5 Word.word)))) then
         (read_reg SPSR_irq_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
         R_set d ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
       else if (((b__9 = ( 0b10010 ::  5 Word.word)))) then
         (SPSR_svc_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
         R_set d ((subrange_vec_dec w__4 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
       else if (((b__9 = ( 0b10100 ::  5 Word.word)))) then
         (read_reg SPSR_abt_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
         R_set d ((subrange_vec_dec w__5 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
       else if (((b__9 = ( 0b10110 ::  5 Word.word)))) then
         (read_reg SPSR_und_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
         R_set d ((subrange_vec_dec w__6 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
       else if (((b__9 = ( 0b11100 ::  5 Word.word)))) then
         ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__7 :: bool) . 
         ((if ((\<not> w__7)) then AArch64_MonitorModeTrap () 
          else return () ) \<then>
         (read_reg SPSR_mon_ref  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__8 ::  32 Word.word) .  R_set d w__8))))
       else if (((b__9 = ( 0b11110 ::  5 Word.word)))) then
         (SPSR_hyp_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
         R_set d ((subrange_vec_dec w__9 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))
       else return () ))
     else
       BankedRegisterAccessValid SYSm mode \<then>
       ((let b__0 = SYSm in
       if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
         (let m = (((Word.uint ((subrange_vec_dec SYSm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)))) + (( 8 :: int)::ii)) in
         (Rmode_read m M32_User  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) .  R_set d w__10)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
       then
         (let m = (((Word.uint ((subrange_vec_dec SYSm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)))) + (( 8 :: int)::ii)) in
         (Rmode_read m M32_FIQ  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) .  R_set d w__11)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (Rmode_read m M32_IRQ  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) .  R_set d w__12)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0x9 ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (Rmode_read m M32_Svc  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) .  R_set d w__13)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0xA ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (Rmode_read m M32_Abort  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) .  R_set d w__14)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0xB ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (Rmode_read m M32_Undef  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) .  R_set d w__15)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0xE ::  4 Word.word))))
       then
         ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__16 :: bool) . 
         (if ((\<not> w__16)) then AArch64_MonitorModeTrap () 
          else return () ) \<then>
         ((let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (Rmode_read m M32_Monitor  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) .  R_set d w__17))))))
       else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then
         (ELR_hyp_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) .  R_set d w__18))
       else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then
         (Rmode_read (( 13 :: int)::ii) M32_Hyp  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
         R_set d w__19))
       else return () ))))))))))))\<close> 
  for  "SYSm"  :: "(5)Word.word " 
  and  "d"  :: " int " 
  and  "read_spsr"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRS_br_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRS_br_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRS_br_A1enc_AS_txt cond R M1 Rd M = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41269.29-41269.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let (read_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (SYSm :: 5 bits) = ((concat_vec M M1  ::  5 Word.word)) in
     execute_aarch32_instrs_MRS_br_Op_AS_txt SYSm d read_spsr)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "M1"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MRS_br_T1enc_AS_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MRS_br_T1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MRS_br_T1enc_AS_txt R M1 Rd M = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let (read_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((d = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (SYSm :: 5 bits) = ((concat_vec M M1  ::  5 Word.word)) in
     execute_aarch32_instrs_MRS_br_Op_AS_txt SYSm d read_spsr))))
   else return () )))\<close> 
  for  "R"  :: "(1)Word.word " 
  and  "M1"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MSR_br_Op_AS_txt : mword ty5 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MSR_br_Op_AS_txt  :: \<open>(5)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MSR_br_Op_AS_txt SYSm n write_spsr = (
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (m :: ii) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> ((\<lambda> (mode :: 5 bits) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) = EL0))) then throw (Error_Unpredictable () )
   else
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     (let (mode :: 5 bits) = ((ProcState_M   w__1)) in
     if write_spsr then
       SPSRaccessValid SYSm mode \<then>
       ((let b__9 = SYSm in
       if (((b__9 = ( 0b01110 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
         write_reg SPSR_fiq_ref ((ZeroExtend1 (( 64 :: int)::ii) w__2  ::  64 Word.word))))
       else if (((b__9 = ( 0b10000 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
         write_reg SPSR_irq_ref ((ZeroExtend1 (( 64 :: int)::ii) w__3  ::  64 Word.word))))
       else if (((b__9 = ( 0b10010 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
         SPSR_svc_write ((ZeroExtend1 (( 32 :: int)::ii) w__4  ::  32 Word.word))))
       else if (((b__9 = ( 0b10100 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
         write_reg SPSR_abt_ref ((ZeroExtend1 (( 64 :: int)::ii) w__5  ::  64 Word.word))))
       else if (((b__9 = ( 0b10110 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
         write_reg SPSR_und_ref ((ZeroExtend1 (( 64 :: int)::ii) w__6  ::  64 Word.word))))
       else if (((b__9 = ( 0b11100 ::  5 Word.word)))) then
         ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__7 :: bool) . 
         ((if ((\<not> w__7)) then AArch64_MonitorModeTrap () 
          else return () ) \<then>
         (R_read n  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__8 ::  32 Word.word) .  write_reg SPSR_mon_ref w__8))))
       else if (((b__9 = ( 0b11110 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) .  SPSR_hyp_write w__9))
       else return () ))
     else
       BankedRegisterAccessValid SYSm mode \<then>
       ((let b__0 = SYSm in
       if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
         (let m = (((Word.uint ((subrange_vec_dec SYSm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)))) + (( 8 :: int)::ii)) in
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) .  Rmode_set m M32_User w__10)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))
       then
         (let m = (((Word.uint ((subrange_vec_dec SYSm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)))) + (( 8 :: int)::ii)) in
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) .  Rmode_set m M32_FIQ w__11)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) .  Rmode_set m M32_IRQ w__12)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0x9 ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) .  Rmode_set m M32_Svc w__13)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0xA ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) .  Rmode_set m M32_Abort w__14)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0xB ::  4 Word.word))))
       then
         (let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) .  Rmode_set m M32_Undef w__15)))
       else if (((((subrange_vec_dec b__0 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) = ( 0xE ::  4 Word.word))))
       then
         ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__16 :: bool) . 
         (if ((\<not> w__16)) then AArch64_MonitorModeTrap () 
          else return () ) \<then>
         ((let m =
           ((( 14 :: int)::ii) - ((Word.uint (vec_of_bits [access_vec_dec SYSm (( 0 :: int)::ii)]  ::  1 Word.word)))) in
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) .  Rmode_set m M32_Monitor w__17))))))
       else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__18 ::  32 Word.word) .  ELR_hyp_write w__18))
       else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then
         (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
         Rmode_set (( 13 :: int)::ii) M32_Hyp w__19))
       else return () ))))))))))))\<close> 
  for  "SYSm"  :: "(5)Word.word " 
  and  "n"  :: " int " 
  and  "write_spsr"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MSR_br_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MSR_br_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MSR_br_A1enc_AS_txt cond R M1 M Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41413.29-41413.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (write_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (SYSm :: 5 bits) = ((concat_vec M M1  ::  5 Word.word)) in
     execute_aarch32_instrs_MSR_br_Op_AS_txt SYSm n write_spsr)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "M1"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MSR_br_T1enc_AS_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MSR_br_T1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MSR_br_T1enc_AS_txt R Rn M1 M = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (write_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (SYSm :: 5 bits) = ((concat_vec M M1  ::  5 Word.word)) in
     execute_aarch32_instrs_MSR_br_Op_AS_txt SYSm n write_spsr))))
   else return () )))\<close> 
  for  "R"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "M1"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MSR_i_Op_AS_txt : mword ty32 -> mword ty4 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MSR_i_Op_AS_txt  :: \<open>(32)Word.word \<Rightarrow>(4)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MSR_i_Op_AS_txt imm32 mask1 write_spsr = (
   if write_spsr then
     or_boolM
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
        return ((((ProcState_M   w__0) = M32_User))))))
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
        return ((((ProcState_M   w__1) = M32_System)))))) \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then throw (Error_Unpredictable () )
     else SPSRWriteByInstr imm32 mask1))
   else CPSRWriteByInstr imm32 mask1 )\<close> 
  for  "imm32"  :: "(32)Word.word " 
  and  "mask1"  :: "(4)Word.word " 
  and  "write_spsr"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MSR_i_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty12 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MSR_i_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MSR_i_A1enc_AS_txt cond R mask1 imm12 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41486.29-41486.30'') \<then>
     (if ((((((mask1 = ( 0x0 ::  4 Word.word)))) \<and> (((R = ( 0b0 ::  1 Word.word))))))) then
        throw (Error_See (''Related encodings''))
      else return () )) \<then>
     (A32ExpandImm imm12  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (imm32 :: 32 bits) . 
     (let (write_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     (if (((mask1 = ( 0x0 ::  4 Word.word)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_MSR_i_Op_AS_txt imm32 mask1 write_spsr)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "mask1"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MSR_r_Op_AS_txt : mword ty4 -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MSR_r_Op_AS_txt  :: \<open>(4)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MSR_r_Op_AS_txt mask1 n write_spsr = (
   if write_spsr then
     or_boolM
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
        return ((((ProcState_M   w__0) = M32_User))))))
       (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
        return ((((ProcState_M   w__1) = M32_System)))))) \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then throw (Error_Unpredictable () )
     else (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) .  SPSRWriteByInstr w__3 mask1))))
   else (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) .  CPSRWriteByInstr w__4 mask1)))\<close> 
  for  "mask1"  :: "(4)Word.word " 
  and  "n"  :: " int " 
  and  "write_spsr"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MSR_r_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MSR_r_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MSR_r_A1enc_AS_txt cond R mask1 Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41533.29-41533.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (write_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     ((if (((mask1 = ( 0x0 ::  4 Word.word)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_MSR_r_Op_AS_txt mask1 n write_spsr)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "R"  :: "(1)Word.word " 
  and  "mask1"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MSR_r_T1enc_AS_txt : mword ty1 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MSR_r_T1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MSR_r_T1enc_AS_txt R Rn mask1 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (write_spsr :: bool) = (R = ( 0b1 ::  1 Word.word)) in
     ((if (((mask1 = ( 0x0 ::  4 Word.word)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_MSR_r_Op_AS_txt mask1 n write_spsr))
   else return () )))\<close> 
  for  "R"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "mask1"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_RFE_Op_AS_txt : bool -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_RFE_Op_AS_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_RFE_Op_AS_txt increment_name n wback wordhigher = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (new_pc_value :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (spsr :: 32 bits) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Undefined () )
   else
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   if ((((ProcState_EL   w__1) = EL0))) then throw (Error_Unpredictable () )
   else
     (if increment_name then (R_read n  :: ( 32 Word.word) M)
      else
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
        return ((sub_vec_int w__3 (( 8 :: int)::ii)  ::  32 Word.word))))) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     (let (address :: 32 bits) = w__4 in
     (let (address ::  32 Word.word) =
       (if wordhigher then (add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)
       else address) in
     (MemA_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (new_pc_value :: 32 bits) . 
     (MemA_read ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (spsr :: 32
       bits) . 
     (if wback then
        (if increment_name then
           (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
           return ((add_vec_int w__5 (( 8 :: int)::ii)  ::  32 Word.word))))
         else
           (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
           return ((sub_vec_int w__6 (( 8 :: int)::ii)  ::  32 Word.word))))) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
        R_set n w__7))
      else return () ) \<then>
     AArch32_ExceptionReturn new_pc_value spsr)))))))))))))))))))\<close> 
  for  "increment_name"  :: " bool " 
  and  "n"  :: " int " 
  and  "wback"  :: " bool " 
  and  "wordhigher"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_RFE_A1enc_AS_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RFE_A1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RFE_A1enc_AS_txt P U W Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (increment_name :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wordhigher :: bool) = (P = U) in
     (if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RFE_Op_AS_txt increment_name n wback wordhigher))))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_RFE_T1enc_AS_txt : mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RFE_T1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RFE_T1enc_AS_txt W Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (increment_name :: bool) = False in
     (let (wordhigher :: bool) = False in
     ((if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RFE_Op_AS_txt increment_name n wback wordhigher))))))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_RFE_T2enc_AS_txt : mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_RFE_T2enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_RFE_T2enc_AS_txt W Rn = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let n = (Word.uint Rn) in
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (increment_name :: bool) = True in
     (let (wordhigher :: bool) = False in
     ((if (((n = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_RFE_Op_AS_txt increment_name n wback wordhigher))))))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SMC_Op_AS_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_SMC_Op_AS_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SMC_Op_AS_txt _ = (
   undefined_Constraint ()  \<bind> ((\<lambda> (c :: Constraint) . 
   (AArch32_CheckForSMCUndefOrTrap ()  \<then>
   ELUsingAArch32 EL3) \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then
      (read_reg SCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      if (((((slice w__1 (( 7 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
        throw (Error_Undefined () )
      else return () ))
    else
    (read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
    if (((((slice w__2 (( 7 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
      IsSecure ()  \<bind> ((\<lambda> (w__3 :: bool) . 
      (if w__3 then
         ConstrainUnpredictable Unpredictable_SMD \<bind> ((\<lambda> (c :: Constraint) . 
         assert_exp ((((((c = Constraint_NOP))) \<or> (((c = Constraint_UNDEF)))))) (''src/instrs32.sail:41718.66-41718.67'') \<then>
         (if (((c = Constraint_NOP))) then EndOfInstruction () 
         else return () )))
       else return () ) \<then>
      throw (Error_Undefined () )))
    else return () ))) \<then>
   ELUsingAArch32 EL3) \<bind> ((\<lambda> (w__4 :: bool) . 
   if ((\<not> w__4)) then AArch64_CallSecureMonitor ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))
   else AArch32_TakeSMCException () )))))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SMC_A1enc_AS_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMC_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMC_A1enc_AS_txt cond imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41739.29-41739.30'') \<then>
     execute_aarch32_instrs_SMC_Op_AS_txt () 
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SMC_T1enc_AS_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SMC_T1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SMC_T1enc_AS_txt imm4 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     and_boolM ((InITBlock () )) (LastInITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> ((\<lambda> (w__3 ::
       bool) . 
     (if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_SMC_Op_AS_txt () ))
   else return () )))\<close> 
  for  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SRS_OpA_AS_txt : bool -> mword ty5 -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SRS_OpA_AS_txt  :: \<open> bool \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SRS_OpA_AS_txt increment_name mode wback wordhigher = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   ((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Undefined () )
    else return () ) \<then>
   or_boolM
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) .  return ((((ProcState_M   w__1) = M32_User))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      return ((((ProcState_M   w__2) = M32_System))))))) \<bind> ((\<lambda> (w__3 :: bool) . 
   ((if w__3 then throw (Error_Unpredictable () )
    else if (((mode = M32_Hyp))) then throw (Error_Unpredictable () )
    else if (((mode = M32_Monitor))) then
      or_boolM (return ((\<not> ((HaveEL EL3)))))
        (IsSecure ()  \<bind> ((\<lambda> (w__4 :: bool) .  return ((\<not> w__4))))) \<bind> ((\<lambda> (w__5 :: bool) . 
      if w__5 then throw (Error_Unpredictable () )
      else
      ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__6 :: bool) . 
      if ((\<not> w__6)) then AArch64_MonitorModeTrap () 
      else return () ))))
    else
    BadMode mode \<bind> ((\<lambda> (w__7 :: bool) .  if w__7 then throw (Error_Unpredictable () ) else return () ))) \<then>
   (Rmode_read (( 13 :: int)::ii) mode  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if increment_name then base
     else (sub_vec_int base (( 8 :: int)::ii)  ::  32 Word.word)) in
   (let (address ::  32 Word.word) =
     (if wordhigher then (add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)
     else address) in
   (LR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (MemA_set address (( 4 :: int)::ii) w__8 \<then>
   (SPSR_read (((( 8 :: int)::ii) * (( 4 :: int)::ii)))  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   MemA_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__9 \<then>
   (if wback then
     Rmode_set (( 13 :: int)::ii) mode
       (if increment_name then (add_vec_int base (( 8 :: int)::ii)  ::  32 Word.word)
        else (sub_vec_int base (( 8 :: int)::ii)  ::  32 Word.word))
   else return () ))))))))))))))\<close> 
  for  "increment_name"  :: " bool " 
  and  "mode"  :: "(5)Word.word " 
  and  "wback"  :: " bool " 
  and  "wordhigher"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SRS_A1enc_AS_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SRS_A1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SRS_A1enc_AS_txt P U W mode = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (increment_name :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wordhigher :: bool) = (P = U) in
     execute_aarch32_instrs_SRS_OpA_AS_txt increment_name mode wback wordhigher)))
   else return () )))\<close> 
  for  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "W"  :: "(1)Word.word " 
  and  "mode"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SRS_OpT_AS_txt : bool -> mword ty5 -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_SRS_OpT_AS_txt  :: \<open> bool \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SRS_OpT_AS_txt increment_name mode wback wordhigher = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   ((if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Undefined () )
    else return () ) \<then>
   or_boolM
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) .  return ((((ProcState_M   w__1) = M32_User))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      return ((((ProcState_M   w__2) = M32_System))))))) \<bind> ((\<lambda> (w__3 :: bool) . 
   ((if w__3 then throw (Error_Unpredictable () )
    else if (((mode = M32_Hyp))) then throw (Error_Unpredictable () )
    else if (((mode = M32_Monitor))) then
      or_boolM (return ((\<not> ((HaveEL EL3)))))
        (IsSecure ()  \<bind> ((\<lambda> (w__4 :: bool) .  return ((\<not> w__4))))) \<bind> ((\<lambda> (w__5 :: bool) . 
      if w__5 then throw (Error_Unpredictable () )
      else
      ELUsingAArch32 EL3 \<bind> ((\<lambda> (w__6 :: bool) . 
      if ((\<not> w__6)) then AArch64_MonitorModeTrap () 
      else return () ))))
    else
    BadMode mode \<bind> ((\<lambda> (w__7 :: bool) .  if w__7 then throw (Error_Unpredictable () ) else return () ))) \<then>
   (Rmode_read (( 13 :: int)::ii) mode  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (base :: 32 bits) . 
   (let (address :: 32 bits) =
     (if increment_name then base
     else (sub_vec_int base (( 8 :: int)::ii)  ::  32 Word.word)) in
   (let (address ::  32 Word.word) =
     (if wordhigher then (add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)
     else address) in
   (LR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
   (MemA_set address (( 4 :: int)::ii) w__8 \<then>
   (SPSR_read (((( 8 :: int)::ii) * (( 4 :: int)::ii)))  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
   MemA_set ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) (( 4 :: int)::ii) w__9 \<then>
   (if wback then
     Rmode_set (( 13 :: int)::ii) mode
       (if increment_name then (add_vec_int base (( 8 :: int)::ii)  ::  32 Word.word)
        else (sub_vec_int base (( 8 :: int)::ii)  ::  32 Word.word))
   else return () ))))))))))))))\<close> 
  for  "increment_name"  :: " bool " 
  and  "mode"  :: "(5)Word.word " 
  and  "wback"  :: " bool " 
  and  "wordhigher"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_SRS_T1enc_AS_txt : mword ty1 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SRS_T1enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SRS_T1enc_AS_txt W mode = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (increment_name :: bool) = False in
     (let (wordhigher :: bool) = False in
     execute_aarch32_instrs_SRS_OpT_AS_txt increment_name mode wback wordhigher)))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "mode"  :: "(5)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SRS_T2enc_AS_txt : mword ty1 -> mword ty5 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SRS_T2enc_AS_txt  :: \<open>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SRS_T2enc_AS_txt W mode = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (wback :: bool) = (W = ( 0b1 ::  1 Word.word)) in
     (let (increment_name :: bool) = True in
     (let (wordhigher :: bool) = False in
     execute_aarch32_instrs_SRS_OpT_AS_txt increment_name mode wback wordhigher)))
   else return () )))\<close> 
  for  "W"  :: "(1)Word.word " 
  and  "mode"  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STM_u_Op_AS_txt : bool -> integer -> mword ty16 -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_STM_u_Op_AS_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STM_u_Op_AS_txt increment_name n registers1 wordhigher = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (length1 :: ii) . 
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) = EL2))) then throw (Error_Undefined () )
   else
   or_boolM
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) .  return ((((ProcState_M   w__1) = M32_User))))))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) . 
      return ((((ProcState_M   w__2) = M32_System)))))) \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then throw (Error_Unpredictable () )
   else
     (let length1 = ((( 4 :: int)::ii) * ((BitCount registers1))) in
     (if increment_name then (R_read n  :: ( 32 Word.word) M)
      else
        (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
        return ((sub_vec_int w__5 length1  ::  32 Word.word))))) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
     (let (address :: 32 bits) = w__6 in
     (let (address ::  32 Word.word) =
       (if wordhigher then (add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)
       else address) in
     (let loop_i_lower = ((( 0 :: int)::ii)) in
     (let loop_i_upper = ((( 14 :: int)::ii)) in
     (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) address
       ((\<lambda> i address . 
         if ((((vec_of_bits [access_vec_dec registers1 i]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
         then
           (Rmode_read i M32_User  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
           MemS_set address (( 4 :: int)::ii) w__7 \<then>
           ((let (address :: 32 bits) = ((add_vec_int address (( 4 :: int)::ii)  ::  32 Word.word)) in
           return address))))
         else return address))) \<bind> ((\<lambda> (address ::  32 Word.word) . 
     if ((((vec_of_bits [access_vec_dec registers1 (( 15 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))
     then
       (PCStoreValue ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
       MemS_set address (( 4 :: int)::ii) w__8))
     else return () ))))))))))))))))))\<close> 
  for  "increment_name"  :: " bool " 
  and  "n"  :: " int " 
  and  "registers1"  :: "(16)Word.word " 
  and  "wordhigher"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_STM_u_A1enc_AS_txt : mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty16 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STM_u_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STM_u_A1enc_AS_txt cond P U Rn register_list = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:41951.29-41951.30'') \<then>
     ((let n = (Word.uint Rn) in
     (let (registers1 :: 16 bits) = register_list in
     (let (increment_name :: bool) = (U = ( 0b1 ::  1 Word.word)) in
     (let (wordhigher :: bool) = (P = U) in
     (if ((((((n = (( 15 :: int)::ii)))) \<or> ((((BitCount registers1)) < (( 1 :: int)::ii)))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STM_u_Op_AS_txt increment_name n registers1 wordhigher)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "P"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "register_list"  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMRS_Op_AS_txt : mword ty4 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMRS_Op_AS_txt  :: \<open>(4)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMRS_Op_AS_txt reg t = (
   if (((reg = ( 0x1 ::  4 Word.word)))) then
     CheckVFPEnabled True \<then>
     (if (((t = (( 15 :: int)::ii)))) then
       (read_reg FPSR_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (read_reg FPSR_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (read_reg FPSR_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (read_reg FPSR_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
       (let split_vec =
         ((concat_vec ((slice w__0 (( 31 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
            ((concat_vec ((slice w__1 (( 30 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                ((concat_vec ((slice w__2 (( 29 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                    ((slice w__3 (( 28 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))
                   ::  2 Word.word))
               ::  3 Word.word))
           ::  4 Word.word)) in
       read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
       (write_reg
         PSTATE_ref
         ( w__4 (| ProcState_N := ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) |)) \<then>
       read_reg PSTATE_ref) \<bind> ((\<lambda> (w__5 :: ProcState) . 
       (write_reg
         PSTATE_ref
         ( w__5 (| ProcState_Z := ((subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) |)) \<then>
       read_reg PSTATE_ref) \<bind> ((\<lambda> (w__6 :: ProcState) . 
       (write_reg
         PSTATE_ref
         ( w__6 (| ProcState_C := ((subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
       read_reg PSTATE_ref) \<bind> ((\<lambda> (w__7 :: ProcState) . 
       write_reg
         PSTATE_ref
         ( w__7 (| ProcState_V := ((subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) |)))))))))))))))))))
     else (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) .  R_set t w__8)))
   else
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__9 :: ProcState) . 
   if ((((ProcState_EL   w__9) = EL0))) then throw (Error_Undefined () )
   else
     (CheckVFPEnabled False \<then>
     AArch32_CheckAdvSIMDOrFPRegisterTraps reg) \<then>
     ((let b__0 = reg in
     if (((b__0 = ( 0x0 ::  4 Word.word)))) then
       (read_reg FPSID_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) .  R_set t w__10))
     else if (((b__0 = ( 0x5 ::  4 Word.word)))) then
       (MVFR2_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) .  R_set t w__11))
     else if (((b__0 = ( 0x6 ::  4 Word.word)))) then
       (MVFR1_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) .  R_set t w__12))
     else if (((b__0 = ( 0x7 ::  4 Word.word)))) then
       (MVFR0_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) .  R_set t w__13))
     else if (((b__0 = ( 0x8 ::  4 Word.word)))) then
       (FPEXC_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) .  R_set t w__14))
     else Unreachable () )))))\<close> 
  for  "reg"  :: "(4)Word.word " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMRS_A1enc_AS_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMRS_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMRS_A1enc_AS_txt cond reg Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42021.29-42021.30'') \<then>
     ((let t = (Word.uint Rt) in
     ((if ((let b__0 = reg in
        \<not> (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
           then
             True
           else if (((b__0 = ( 0x5 ::  4 Word.word)))) then True
           else if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word))))
           then
             True
           else if (((b__0 = ( 0x8 ::  4 Word.word)))) then True
           else False))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((t = (( 15 :: int)::ii)))) \<and> (((reg \<noteq> ( 0x1 ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMRS_Op_AS_txt reg t))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "reg"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMRS_T1enc_AS_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMRS_T1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMRS_T1enc_AS_txt reg Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     ((if ((let b__0 = reg in
        \<not> (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
           then
             True
           else if (((b__0 = ( 0x5 ::  4 Word.word)))) then True
           else if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word))))
           then
             True
           else if (((b__0 = ( 0x8 ::  4 Word.word)))) then True
           else False))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((t = (( 15 :: int)::ii)))) \<and> (((reg \<noteq> ( 0x1 ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMRS_Op_AS_txt reg t)
   else return () )))\<close> 
  for  "reg"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMSR_Op_AS_txt : mword ty4 -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMSR_Op_AS_txt  :: \<open>(4)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMSR_Op_AS_txt reg t = (
   if (((reg = ( 0x1 ::  4 Word.word)))) then
     (CheckVFPEnabled True \<then>
     (R_read t  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  FPSCR_write w__0))
   else
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
   if ((((ProcState_EL   w__1) = EL0))) then throw (Error_Undefined () )
   else
     CheckVFPEnabled False \<then>
     ((let b__0 = reg in
     if (((b__0 = ( 0x0 ::  4 Word.word)))) then return () 
     else if (((b__0 = ( 0x8 ::  4 Word.word)))) then
       (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) .  FPEXC_write w__2))
     else Unreachable () )))))\<close> 
  for  "reg"  :: "(4)Word.word " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMSR_A1enc_AS_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMSR_A1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMSR_A1enc_AS_txt cond reg Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42112.29-42112.30'') \<then>
     ((let t = (Word.uint Rt) in
     ((if (((((let b__0 = reg in
             \<not> (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
                then
                  True
                else False))) \<and> (((reg \<noteq> ( 0x8 ::  4 Word.word))))))) then
        ConstrainUnpredictable Unpredictable_VMSR \<bind> ((\<lambda> (c :: Constraint) . 
        assert_exp ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP)))))) (''src/instrs32.sail:42119.62-42119.63'') \<then>
        (case  c of
          Constraint_UNDEF => throw (Error_Undefined () )
        | Constraint_NOP => EndOfInstruction () 
        | _ => return () 
        )))
      else return () ) \<then>
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMSR_Op_AS_txt reg t))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "reg"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMSR_T1enc_AS_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMSR_T1enc_AS_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMSR_T1enc_AS_txt reg Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     ((if (((((let b__0 = reg in
             \<not> (if (((((subrange_vec_dec b__0 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))))
                then
                  True
                else False))) \<and> (((reg \<noteq> ( 0x8 ::  4 Word.word))))))) then
        ConstrainUnpredictable Unpredictable_VMSR \<bind> ((\<lambda> (c :: Constraint) . 
        assert_exp ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP)))))) (''src/instrs32.sail:42160.62-42160.63'') \<then>
        (case  c of
          Constraint_UNDEF => throw (Error_Undefined () )
        | Constraint_NOP => EndOfInstruction () 
        | _ => return () 
        )))
      else return () ) \<then>
     (if (((t = (( 15 :: int)::ii)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_VMSR_Op_AS_txt reg t)
   else return () )))\<close> 
  for  "reg"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_AESD_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_AESD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_AESD_Op_A_txt d m = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (op1 :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (op2 :: 128 bits) . 
   (AESInvSubBytes ((AESInvShiftRows ((xor_vec op1 op2  ::  128 Word.word))  ::  128 Word.word))
     :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__0)))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESD_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESD_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESD_A1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveAESExt ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESD_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESD_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESD_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESD_T1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveAESExt () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESD_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_AESE_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_AESE_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_AESE_Op_A_txt d m = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (op1 :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (op2 :: 128 bits) . 
   (AESSubBytes ((AESShiftRows ((xor_vec op1 op2  ::  128 Word.word))  ::  128 Word.word))
     :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__0)))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESE_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESE_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESE_A1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveAESExt ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESE_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESE_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESE_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESE_T1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveAESExt () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESE_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_AESIMC_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_AESIMC_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_AESIMC_Op_A_txt d m = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   (AESInvMixColumns w__0  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__1 ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__1)))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESIMC_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESIMC_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESIMC_A1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveAESExt ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESIMC_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESIMC_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESIMC_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESIMC_T1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveAESExt () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESIMC_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_AESMC_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_AESMC_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_AESMC_Op_A_txt d m = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   (AESMixColumns w__0  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__1 ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__1)))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESMC_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESMC_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESMC_A1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveAESExt ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESMC_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_AESMC_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_AESMC_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_AESMC_T1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveAESExt () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b00 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_AESMC_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_CRC32_Op_A_txt : bool -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_CRC32_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n l__106 = (
   if (((l__106 = (( 8 :: int)::ii)))) then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (acc1 :: 32 bits) . 
     assert_exp True (''src/instrs32.sail:42488.37-42488.38'') \<then>
     ((let (poly :: 32 bits) =
       ((integer_subrange (if crc32c then (( 517762881 :: int)::ii) else (( 79764919 :: int)::ii)) (( 31 :: int)::ii) (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (BitReverse acc1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (let (tempacc :: 40 bits) = ((concat_vec w__0 ( 0x00 ::  8 Word.word)  ::  40 Word.word)) in
     (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     (BitReverse ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__2 ::
        8 Word.word) . 
     (let (tempval :: 40 bits) = ((concat_vec w__2 ( 0x00000000 ::  32 Word.word)  ::  40 Word.word)) in
     (BitReverse ((Poly32Mod2 ((xor_vec tempacc tempval  ::  40 Word.word)) poly  ::  32 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     R_set d w__3))))))))))))))
   else if (((l__106 = (( 16 :: int)::ii)))) then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (acc1 :: 32 bits) . 
     assert_exp True (''src/instrs32.sail:42488.37-42488.38'') \<then>
     ((let (poly :: 32 bits) =
       ((integer_subrange (if crc32c then (( 517762881 :: int)::ii) else (( 79764919 :: int)::ii)) (( 31 :: int)::ii) (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (BitReverse acc1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     (let (tempacc :: 48 bits) = ((concat_vec w__4 ( 0x0000 ::  16 Word.word)  ::  48 Word.word)) in
     (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
     (BitReverse ((subrange_vec_dec w__5 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::
        16 Word.word) . 
     (let (tempval :: 48 bits) = ((concat_vec w__6 ( 0x00000000 ::  32 Word.word)  ::  48 Word.word)) in
     (BitReverse ((Poly32Mod2 ((xor_vec tempacc tempval  ::  48 Word.word)) poly  ::  32 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
     R_set d w__7))))))))))))))
   else if (((l__106 = (( 32 :: int)::ii)))) then
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (acc1 :: 32 bits) . 
     assert_exp True (''src/instrs32.sail:42488.37-42488.38'') \<then>
     ((let (poly :: 32 bits) =
       ((integer_subrange (if crc32c then (( 517762881 :: int)::ii) else (( 79764919 :: int)::ii)) (( 31 :: int)::ii) (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (BitReverse acc1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
     (let (tempacc :: 64 bits) = ((concat_vec w__8 ( 0x00000000 ::  32 Word.word)  ::  64 Word.word)) in
     (R_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
     (BitReverse ((subrange_vec_dec w__9 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::
        32 Word.word) . 
     (let (tempval :: 64 bits) = ((concat_vec w__10 ( 0x00000000 ::  32 Word.word)  ::  64 Word.word)) in
     (BitReverse ((Poly32Mod2 ((xor_vec tempacc tempval  ::  64 Word.word)) poly  ::  32 Word.word))
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
     R_set d w__11))))))))))))))
   else
     \<comment> \<open>\<open> 'size == 64 \<close>\<close>
     (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (acc1 :: 32 bits) . 
     assert_exp False (''src/instrs32.sail:42488.37-42488.38'') \<then> exit0 () )))\<close> 
  for  "crc32c"  :: " bool " 
  and  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "l__106"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_CRC32_A1enc_A_txt : mword ty4 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CRC32_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CRC32_A1enc_A_txt cond b__0 Rn Rd C Rm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42500.29-42500.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (let m = (Word.uint Rm) in
       (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
       ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
          throw (Error_Unpredictable () )
        else return () ) \<then>
       (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n (( 8 :: int)::ii))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42500.29-42500.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (let m = (Word.uint Rm) in
       (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
       ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
          throw (Error_Unpredictable () )
        else return () ) \<then>
       (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n (( 16 :: int)::ii))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42500.29-42500.30'') \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (let m = (Word.uint Rm) in
       (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
       ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
          throw (Error_Unpredictable () )
        else return () ) \<then>
       (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
        else return () )) \<then>
       execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n (( 32 :: int)::ii))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   if w__3 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42500.29-42500.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     throw (Error_Unpredictable () ))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "C"  :: "(1)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CRC32_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CRC32_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CRC32_T1enc_A_txt C Rn Rd b__0 Rm = (
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     if w__0 then
       InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
       (if w__1 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (let m = (Word.uint Rm) in
       (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
       (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
          throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n (( 8 :: int)::ii))))))))
     else return () ))
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       InITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) . 
       (if w__3 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (let m = (Word.uint Rm) in
       (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
       (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
          throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n (( 16 :: int)::ii))))))))
     else return () ))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ConditionPassed ()  \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       InITBlock ()  \<bind> ((\<lambda> (w__5 :: bool) . 
       (if w__5 then throw (Error_Unpredictable () )
        else return () ) \<then>
       ((let d = (Word.uint Rd) in
       (let n = (Word.uint Rn) in
       (let m = (Word.uint Rm) in
       (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
       (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
          throw (Error_Unpredictable () )
        else return () ) \<then>
       execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n (( 32 :: int)::ii))))))))
     else return () ))
   else
   ConditionPassed ()  \<bind> ((\<lambda> (w__6 :: bool) . 
   if w__6 then
     InITBlock ()  \<bind> ((\<lambda> (w__7 :: bool) . 
     (if w__7 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let d = (Word.uint Rd) in
     (let n = (Word.uint Rn) in
     (let m = (Word.uint Rm) in
     (let (crc32c :: bool) = (C = ( 0b1 ::  1 Word.word)) in
     (if (((((((((d = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) \<or> (((m = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     throw (Error_Unpredictable () ))))))))
   else return () )))\<close> 
  for  "C"  :: "(1)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Rm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_DCPS1_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_DCPS1_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_DCPS1_Op_A_txt _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (LR_svc :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (tge :: 1 bits) . 
   Halted ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   and_boolM ((EL2Enabled () ))
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL0))))))) \<bind> ((\<lambda> (w__3 ::
     bool) . 
   ((if w__3 then
      ELUsingAArch32 EL2 \<bind> ((\<lambda> (w__4 :: bool) . 
      (if w__4 then
         (HCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
         return ((slice w__5 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))))
       else
         (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
         return ((slice w__6 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))))) \<bind> ((\<lambda> (tge :: 1 bits) . 
      if (((tge = ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () ))))
    else return () ) \<then>
   or_boolM
     (read_reg PSTATE_ref \<bind> ((\<lambda> (w__7 :: ProcState) .  return ((((ProcState_EL   w__7) \<noteq> EL0))))))
     ((ELUsingAArch32 EL1))) \<bind> ((\<lambda> (w__9 :: bool) . 
   (if w__9 then
      read_reg PSTATE_ref \<bind> ((\<lambda> (w__10 :: ProcState) . 
      ((if ((((ProcState_M   w__10) = M32_Monitor))) then
         (read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
         write_reg SCR_ref ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__11 (( 0 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))))
       else return () ) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__12 :: ProcState) . 
      ((if ((((ProcState_EL   w__12) \<noteq> EL2))) then
         (AArch32_WriteMode M32_Svc \<then>
         read_reg PSTATE_ref) \<bind> ((\<lambda> (w__13 :: ProcState) . 
         (SCTLR_read__2 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__14 ::  32 Word.word) . 
         (write_reg
           PSTATE_ref
           ( w__13 (| ProcState_E := ((slice w__14 (( 25 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
         and_boolM (return ((HavePANExt () )))
           ((SCTLR_read__2 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__15 ::  32 Word.word) . 
            return (((((slice w__15 (( 23 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))))))) \<bind> ((\<lambda> (w__16 ::
           bool) . 
         ((if w__16 then
            read_reg PSTATE_ref \<bind> ((\<lambda> (w__17 :: ProcState) . 
            write_reg PSTATE_ref ( w__17 (| ProcState_PAN := (( 0b1 ::  1 Word.word)) |))))
          else return () ) \<then>
         (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__18 ::  32 Word.word) . 
         (let LR_svc = w__18 in
         (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__19 ::  32 Word.word) . 
         SPSR_svc_write w__19)))))))))))
       else
         read_reg PSTATE_ref \<bind> ((\<lambda> (w__20 :: ProcState) . 
         (HSCTLR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
         (write_reg
           PSTATE_ref
           ( w__20 (| ProcState_E := ((slice w__21 (( 25 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
         (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__22 ::  32 Word.word) . 
         (ELR_hyp_write w__22 \<then>
         (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
         (HSR_write w__23 \<then>
         (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__24 ::  32 Word.word) . 
         SPSR_hyp_write w__24))))))))))) \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
      (DLR_write w__25 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__26 ::  32 Word.word) .  DSPSR_write w__26))))))))
    else
      ((AArch64_MaybeZeroRegisterUppers ()  \<then>
      MaybeZeroSVEUppers EL1) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__27 :: ProcState) . 
      (write_reg PSTATE_ref ( w__27 (| ProcState_nRW := (( 0b0 ::  1 Word.word)) |)) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__28 :: ProcState) . 
      (write_reg PSTATE_ref ( w__28 (| ProcState_SP := (( 0b1 ::  1 Word.word)) |)) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__29 :: ProcState) . 
      (write_reg PSTATE_ref ( w__29 (| ProcState_EL := EL1 |)) \<then>
      and_boolM (return ((HavePANExt () )))
        ((read_reg SCTLR_EL1_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
         return (((((slice w__30 (( 23 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))))))) \<bind> ((\<lambda> (w__31 ::
        bool) . 
      (((if w__31 then
         read_reg PSTATE_ref \<bind> ((\<lambda> (w__32 :: ProcState) . 
         write_reg PSTATE_ref ( w__32 (| ProcState_PAN := (( 0b1 ::  1 Word.word)) |))))
       else return () ) \<then>
      (if ((HaveUAOExt () )) then
         read_reg PSTATE_ref \<bind> ((\<lambda> (w__33 :: ProcState) . 
         write_reg PSTATE_ref ( w__33 (| ProcState_UAO := (( 0b0 ::  1 Word.word)) |))))
       else return () )) \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__34 ::  64 Word.word) . 
      (write_reg ELR_EL1_ref w__34 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
      (write_reg ESR_EL1_ref w__35 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
      (write_reg SPSR_EL1_ref w__36 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__37 ::  64 Word.word) . 
      (write_reg DLR_EL0_ref w__37 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__38 ::  64 Word.word) . 
      (write_reg DSPSR_EL0_ref w__38 \<then>
      and_boolM
        (and_boolM ((HaveIESB () ))
           ((read_reg SCTLR_EL1_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__40 ::  64 Word.word) . 
            return (((((slice w__40 (( 21 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))
        (ConstrainUnpredictableBool Unpredictable_IESBinDebug \<bind> ((\<lambda> (w__42 :: bool) . 
         return ((\<not> w__42)))))) \<bind> ((\<lambda> (w__43 :: bool) . 
      (let (_ :: unit) = (if w__43 then SynchronizeErrors ()  else () ) in
      return () )))))))))))))))))))))) \<then>
   UpdateEDSCRFields () )))))))))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_DCPS1_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_DCPS1_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DCPS1_T1enc_A_txt _ = ( execute_aarch32_instrs_DCPS1_Op_A_txt ()  )\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_DCPS2_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_DCPS2_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_DCPS2_Op_A_txt _ = (
   or_boolM (Halted ()  \<bind> ((\<lambda> (w__0 :: bool) .  return ((\<not> w__0))))) ((IsSecure () )) \<bind> ((\<lambda> (w__2 ::
     bool) . 
   ((if w__2 then throw (Error_Undefined () )
    else return () ) \<then>
   ELUsingAArch32 EL2) \<bind> ((\<lambda> (w__3 :: bool) . 
   (if w__3 then
      (AArch32_WriteMode M32_Hyp \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__4 :: ProcState) . 
      (HSCTLR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
      (write_reg PSTATE_ref ( w__4 (| ProcState_E := ((slice w__5 (( 25 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
      (ELR_hyp_write w__6 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
      (HSR_write w__7 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
      (SPSR_hyp_write w__8 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
      (DLR_write w__9 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__10 ::  32 Word.word) .  DSPSR_write w__10))))))))))))))
    else
      ((AArch64_MaybeZeroRegisterUppers ()  \<then>
      MaybeZeroSVEUppers EL2) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__11 :: ProcState) . 
      (write_reg PSTATE_ref ( w__11 (| ProcState_nRW := (( 0b0 ::  1 Word.word)) |)) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__12 :: ProcState) . 
      (write_reg PSTATE_ref ( w__12 (| ProcState_SP := (( 0b1 ::  1 Word.word)) |)) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__13 :: ProcState) . 
      (write_reg PSTATE_ref ( w__13 (| ProcState_EL := EL2 |)) \<then>
      and_boolM
        (and_boolM
           (and_boolM (return ((HavePANExt () )))
              ((read_reg SCTLR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
               return (((((slice w__14 (( 23 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))))))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
            return (((((slice w__16 (( 34 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
         return (((((slice w__18 (( 27 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))) \<bind> ((\<lambda> (w__19 ::
        bool) . 
      (((if w__19 then
         read_reg PSTATE_ref \<bind> ((\<lambda> (w__20 :: ProcState) . 
         write_reg PSTATE_ref ( w__20 (| ProcState_PAN := (( 0b1 ::  1 Word.word)) |))))
       else return () ) \<then>
      (if ((HaveUAOExt () )) then
         read_reg PSTATE_ref \<bind> ((\<lambda> (w__21 :: ProcState) . 
         write_reg PSTATE_ref ( w__21 (| ProcState_UAO := (( 0b0 ::  1 Word.word)) |))))
       else return () )) \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
      (write_reg ELR_EL2_ref w__22 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
      (write_reg ESR_EL2_ref w__23 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
      (write_reg SPSR_EL2_ref w__24 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__25 ::  64 Word.word) . 
      (write_reg DLR_EL0_ref w__25 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
      (write_reg DSPSR_EL0_ref w__26 \<then>
      and_boolM
        (and_boolM ((HaveIESB () ))
           ((read_reg SCTLR_EL2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
            return (((((slice w__28 (( 21 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))
        (ConstrainUnpredictableBool Unpredictable_IESBinDebug \<bind> ((\<lambda> (w__30 :: bool) . 
         return ((\<not> w__30)))))) \<bind> ((\<lambda> (w__31 :: bool) . 
      (let (_ :: unit) = (if w__31 then SynchronizeErrors ()  else () ) in
      return () )))))))))))))))))))))) \<then>
   UpdateEDSCRFields () )))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_DCPS2_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_DCPS2_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DCPS2_T1enc_A_txt _ = (
   (if ((\<not> ((HaveEL EL2)))) then throw (Error_Undefined () )
    else return () ) \<then>
   execute_aarch32_instrs_DCPS2_Op_A_txt ()  )\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_DCPS3_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_DCPS3_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_DCPS3_Op_A_txt _ = (
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (from_secure :: bool) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (sync_errors :: bool) . 
   or_boolM (Halted ()  \<bind> ((\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     ((EDSCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      return (((((slice w__1 (( 16 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__2 ::
     bool) . 
   ((if w__2 then throw (Error_Undefined () )
    else return () ) \<then>
   ELUsingAArch32 EL3) \<bind> ((\<lambda> (w__3 :: bool) . 
   (if w__3 then
      IsSecure ()  \<bind> ((\<lambda> (from_secure :: bool) . 
      read_reg PSTATE_ref \<bind> ((\<lambda> (w__4 :: ProcState) . 
      ((((if ((((ProcState_M   w__4) = M32_Monitor))) then
         (read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
         write_reg SCR_ref ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__5 (( 0 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))))
       else return () ) \<then>
      AArch32_WriteMode M32_Monitor) \<then>
      (if ((HavePANExt () )) then
         if ((\<not> from_secure)) then
           read_reg PSTATE_ref \<bind> ((\<lambda> (w__6 :: ProcState) . 
           write_reg PSTATE_ref ( w__6 (| ProcState_PAN := (( 0b0 ::  1 Word.word)) |))))
         else
         (SCTLR_read__2 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
         if (((((slice w__7 (( 23 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
           read_reg PSTATE_ref \<bind> ((\<lambda> (w__8 :: ProcState) . 
           write_reg PSTATE_ref ( w__8 (| ProcState_PAN := (( 0b1 ::  1 Word.word)) |))))
         else return () ))
       else return () )) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__9 :: ProcState) . 
      (SCTLR_read__2 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
      (write_reg PSTATE_ref ( w__9 (| ProcState_E := ((slice w__10 (( 25 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) |)) \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  32 Word.word) . 
      (write_reg LR_mon_ref w__11 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
      (write_reg SPSR_mon_ref w__12 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
      (DLR_write w__13 \<then>
      (UNKNOWN_bits (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__14 ::  32 Word.word) .  DSPSR_write w__14))))))))))))))))
    else
      ((AArch64_MaybeZeroRegisterUppers ()  \<then>
      MaybeZeroSVEUppers EL3) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__15 :: ProcState) . 
      (write_reg PSTATE_ref ( w__15 (| ProcState_nRW := (( 0b0 ::  1 Word.word)) |)) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__16 :: ProcState) . 
      (write_reg PSTATE_ref ( w__16 (| ProcState_SP := (( 0b1 ::  1 Word.word)) |)) \<then>
      read_reg PSTATE_ref) \<bind> ((\<lambda> (w__17 :: ProcState) . 
      ((write_reg PSTATE_ref ( w__17 (| ProcState_EL := EL3 |)) \<then>
      (if ((HaveUAOExt () )) then
         read_reg PSTATE_ref \<bind> ((\<lambda> (w__18 :: ProcState) . 
         write_reg PSTATE_ref ( w__18 (| ProcState_UAO := (( 0b0 ::  1 Word.word)) |))))
       else return () )) \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__19 ::  64 Word.word) . 
      (write_reg ELR_EL3_ref w__19 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
      (write_reg ESR_EL3_ref w__20 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
      (write_reg SPSR_EL3_ref w__21 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
      (write_reg DLR_EL0_ref w__22 \<then>
      (UNKNOWN_bits (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__23 ::  64 Word.word) . 
      (write_reg DSPSR_EL0_ref w__23 \<then>
      and_boolM ((HaveIESB () ))
        ((read_reg SCTLR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__25 ::  64 Word.word) . 
         return (((((slice w__25 (( 21 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))) \<bind> ((\<lambda> (w__26 ::
        bool) . 
      (let (sync_errors :: bool) = w__26 in
      and_boolM
        (and_boolM ((HaveDoubleFaultExt () ))
           ((read_reg SCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
            return (((((slice w__28 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))
        ((read_reg SCR_EL3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
         return (((((slice w__30 (( 20 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__31 ::
        bool) . 
      (let (sync_errors :: bool) = (if w__31 then True else sync_errors) in
      ConstrainUnpredictableBool Unpredictable_IESBinDebug \<bind> ((\<lambda> (w__32 :: bool) . 
      (let (sync_errors :: bool) = (if ((\<not> w__32)) then False else sync_errors) in
      (let (_ :: unit) = (if sync_errors then SynchronizeErrors ()  else () ) in
      return () ))))))))))))))))))))))))))) \<then>
   UpdateEDSCRFields () )))))))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_DCPS3_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_DCPS3_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DCPS3_T1enc_A_txt _ = (
   (if ((\<not> ((HaveEL EL3)))) then throw (Error_Undefined () )
    else return () ) \<then>
   execute_aarch32_instrs_DCPS3_Op_A_txt ()  )\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_HLT_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_HLT_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_HLT_Op_A_txt _ = ( Halt DebugHalt_HaltInstruction )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_HLT_A1enc_A_txt : mword ty4 -> mword ty12 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_HLT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_HLT_A1enc_A_txt cond imm12 imm4 = (
   (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42778.25-42778.26'') \<then>
   or_boolM
     ((EDSCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return (((((slice w__0 (( 14 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))))))
     (HaltingAllowed ()  \<bind> ((\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))) \<bind> ((\<lambda> (w__2 :: bool) . 
   ((if w__2 then throw (Error_Undefined () )
    else return () ) \<then>
   (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
    else return () )) \<then>
   execute_aarch32_instrs_HLT_Op_A_txt () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "imm12"  :: "(12)Word.word " 
  and  "imm4"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_HLT_T1enc_A_txt : mword ty6 -> M unit\<close>\<close>

definition decode_aarch32_instrs_HLT_T1enc_A_txt  :: \<open>(6)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_HLT_T1enc_A_txt imm6 = (
   or_boolM
     ((EDSCR_read ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      return (((((slice w__0 (( 14 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))))))
     (HaltingAllowed ()  \<bind> ((\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))) \<bind> ((\<lambda> (w__2 :: bool) . 
   (if w__2 then throw (Error_Undefined () )
    else return () ) \<then>
   execute_aarch32_instrs_HLT_Op_A_txt () )))\<close> 
  for  "imm6"  :: "(6)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDA_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDA_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t True) in
   (MemO_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  R_set t w__0))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDA_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDA_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDA_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42825.29-42825.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDA_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDA_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDA_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDA_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDA_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDAB_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDAB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDAB_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t True) in
   (MemO_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__0 ::  8 Word.word) . 
   R_set t ((zero_extend w__0 (( 32 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAB_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42887.29-42887.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAB_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAB_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAB_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAB_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDAEX_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDAEX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDAEX_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_SetExclusiveMonitors address (( 4 :: int)::ii) \<then>
   ((let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t True) in
   (MemO_read address (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  R_set t w__0)))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEX_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:42950.29-42950.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEX_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEX_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEX_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEX_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDAEXB_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDAEXB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDAEXB_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_SetExclusiveMonitors address (( 1 :: int)::ii) \<then>
   ((let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t True) in
   (MemO_read address (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__0 ::  8 Word.word) . 
   R_set t ((zero_extend w__0 (( 32 :: int)::ii)  ::  32 Word.word)))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEXB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEXB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEXB_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:43013.29-43013.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEXB_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEXB_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEXB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEXB_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEXB_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDAEXD_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDAEXD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDAEXD_Op_A_txt n t t2 = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_SetExclusiveMonitors address (( 8 :: int)::ii) \<then>
   ((let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 8 :: int)::ii) False t True) in
   (MemO_read address (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (value_name :: 64 bits) . 
   BigEndian AccType_ORDERED \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (w__1 ::  32 Word.word) =
     (if w__0 then (subrange_vec_dec value_name (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)
     else (subrange_vec_dec value_name (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (R_set t w__1 \<then>
   BigEndian AccType_ORDERED) \<bind> ((\<lambda> (w__2 :: bool) . 
   (let (w__3 ::  32 Word.word) =
     (if w__2 then (subrange_vec_dec value_name (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)
     else (subrange_vec_dec value_name (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) in
   R_set t2 w__3)))))))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEXD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEXD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEXD_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:43080.29-43080.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     (if ((((((((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEXD_Op_A_txt n t t2))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEXD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEXD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEXD_T1enc_A_txt Rn Rt Rt2 = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let n = (Word.uint Rn) in
     (if ((((((((((((t = (( 15 :: int)::ii)))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((t = t2)))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEXD_Op_A_txt n t t2)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDAEXH_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDAEXH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDAEXH_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_SetExclusiveMonitors address (( 2 :: int)::ii) \<then>
   ((let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t True) in
   (MemO_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__0 ::  16 Word.word) . 
   R_set t ((zero_extend w__0 (( 32 :: int)::ii)  ::  32 Word.word)))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEXH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEXH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEXH_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:43146.29-43146.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEXH_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAEXH_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAEXH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAEXH_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAEXH_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_LDAH_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_LDAH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_LDAH_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t True) in
   (MemO_read address (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__0 ::  16 Word.word) . 
   R_set t ((zero_extend w__0 (( 32 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAH_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:43208.29-43208.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAH_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_LDAH_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_LDAH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_LDAH_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_LDAH_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SEVL_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_SEVL_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SEVL_Op_A_txt _ = ( SendEventLocal ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SEVL_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEVL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEVL_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:43266.29-43266.30'') \<then>
     execute_aarch32_instrs_SEVL_Op_A_txt () 
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SEVL_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEVL_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEVL_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_SEVL_Op_A_txt () 
   else return () )))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SEVL_T2enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SEVL_T2enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SEVL_T2enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then execute_aarch32_instrs_SEVL_Op_A_txt () 
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA1C_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA1C_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA1C_Op_A_txt d m n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (t :: 32 bits) . 
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   (let (Y :: 32 bits) = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (W :: 128 bits) . 
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = ((( 3 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (X, Y, t)
     ((\<lambda> e varstup .  (let (X, Y, t) = varstup in
       (let (t :: 32 bits) =
         ((SHAchoose ((subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec X (( 95 :: int)::ii) (( 64 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec X (( 127 :: int)::ii) (( 96 :: int)::ii)  ::  32 Word.word))
           ::  32 Word.word)) in
       (ROL ((subrange_vec_dec X (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) (( 5 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::
          32 Word.word) . 
       (Elem_read W e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
       (let Y =
         ((add_vec ((add_vec ((add_vec Y w__1  ::  32 Word.word)) t  ::  32 Word.word)) w__2  ::  32 Word.word)) in
       (ROL ((subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) (( 30 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::
          32 Word.word) . 
       (let X = ((update_subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii) w__3  ::  128 Word.word)) in
       (ROL ((concat_vec Y X  ::  160 Word.word)) (( 32 :: int)::ii)  :: ( 160 Word.word) M) \<bind> ((\<lambda> split_vec . 
       (let (Y :: 32 bits) = ((subrange_vec_dec split_vec (( 159 :: int)::ii) (( 128 :: int)::ii)  ::  32 Word.word)) in
       (let (X :: 128 bits) = ((subrange_vec_dec split_vec (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word)) in
       return (X, Y, t)))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((X ::  128 Word.word), (Y ::  32 Word.word), (t ::
      32 Word.word)) = varstup in
   Q_set ((shr_int d (( 1 :: int)::ii))) X)))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1C_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1C_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1C_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA1Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1C_Op_A_txt d m n))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1C_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1C_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1C_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA1Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1C_Op_A_txt d m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA1H_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA1H_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA1H_Op_A_txt d m = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   (ROL ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) (( 30 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::
      32 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) ((zero_extend w__1 (( 128 :: int)::ii)  ::  128 Word.word)))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1H_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1H_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1H_A1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA1Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1H_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1H_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1H_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1H_T1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA1Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1H_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA1M_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA1M_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA1M_Op_A_txt d m n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (t :: 32 bits) . 
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   (let (Y :: 32 bits) = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (W :: 128 bits) . 
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = ((( 3 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (X, Y, t)
     ((\<lambda> e varstup .  (let (X, Y, t) = varstup in
       (let (t :: 32 bits) =
         ((SHAmajority ((subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec X (( 95 :: int)::ii) (( 64 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec X (( 127 :: int)::ii) (( 96 :: int)::ii)  ::  32 Word.word))
           ::  32 Word.word)) in
       (ROL ((subrange_vec_dec X (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) (( 5 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::
          32 Word.word) . 
       (Elem_read W e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
       (let Y =
         ((add_vec ((add_vec ((add_vec Y w__1  ::  32 Word.word)) t  ::  32 Word.word)) w__2  ::  32 Word.word)) in
       (ROL ((subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) (( 30 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::
          32 Word.word) . 
       (let X = ((update_subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii) w__3  ::  128 Word.word)) in
       (ROL ((concat_vec Y X  ::  160 Word.word)) (( 32 :: int)::ii)  :: ( 160 Word.word) M) \<bind> ((\<lambda> split_vec . 
       (let (Y :: 32 bits) = ((subrange_vec_dec split_vec (( 159 :: int)::ii) (( 128 :: int)::ii)  ::  32 Word.word)) in
       (let (X :: 128 bits) = ((subrange_vec_dec split_vec (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word)) in
       return (X, Y, t)))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((X ::  128 Word.word), (Y ::  32 Word.word), (t ::
      32 Word.word)) = varstup in
   Q_set ((shr_int d (( 1 :: int)::ii))) X)))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1M_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1M_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1M_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA1Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1M_Op_A_txt d m n))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1M_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1M_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1M_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA1Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1M_Op_A_txt d m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA1P_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA1P_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA1P_Op_A_txt d m n = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (t :: 32 bits) . 
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   (let (Y :: 32 bits) = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (W :: 128 bits) . 
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = ((( 3 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (X, Y, t)
     ((\<lambda> e varstup .  (let (X, Y, t) = varstup in
       (let (t :: 32 bits) =
         ((SHAparity ((subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec X (( 95 :: int)::ii) (( 64 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec X (( 127 :: int)::ii) (( 96 :: int)::ii)  ::  32 Word.word))
           ::  32 Word.word)) in
       (ROL ((subrange_vec_dec X (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) (( 5 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::
          32 Word.word) . 
       (Elem_read W e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
       (let Y =
         ((add_vec ((add_vec ((add_vec Y w__1  ::  32 Word.word)) t  ::  32 Word.word)) w__2  ::  32 Word.word)) in
       (ROL ((subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) (( 30 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::
          32 Word.word) . 
       (let X = ((update_subrange_vec_dec X (( 63 :: int)::ii) (( 32 :: int)::ii) w__3  ::  128 Word.word)) in
       (ROL ((concat_vec Y X  ::  160 Word.word)) (( 32 :: int)::ii)  :: ( 160 Word.word) M) \<bind> ((\<lambda> split_vec . 
       (let (Y :: 32 bits) = ((subrange_vec_dec split_vec (( 159 :: int)::ii) (( 128 :: int)::ii)  ::  32 Word.word)) in
       (let (X :: 128 bits) = ((subrange_vec_dec split_vec (( 127 :: int)::ii) (( 0 :: int)::ii)  ::  128 Word.word)) in
       return (X, Y, t)))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((X ::  128 Word.word), (Y ::  32 Word.word), (t ::
      32 Word.word)) = varstup in
   Q_set ((shr_int d (( 1 :: int)::ii))) X)))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1P_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1P_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1P_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA1Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1P_Op_A_txt d m n))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1P_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1P_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1P_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA1Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1P_Op_A_txt d m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA1SU0_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA1SU0_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA1SU0_Op_A_txt d m n = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (op1 :: 128 bits) . 
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (op2 :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (op3 :: 128 bits) . 
   (let (op2 :: 128 bits) =
     ((concat_vec ((subrange_vec_dec op2 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
        ((subrange_vec_dec op1 (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   Q_set ((shr_int d (( 1 :: int)::ii))) ((xor_vec ((xor_vec op1 op2  ::  128 Word.word)) op3  ::  128 Word.word))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1SU0_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1SU0_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1SU0_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA1Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1SU0_Op_A_txt d m n))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1SU0_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1SU0_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1SU0_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA1Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1SU0_Op_A_txt d m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA1SU1_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA1SU1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA1SU1_Op_A_txt d m = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (Y :: 128 bits) . 
   (let (T :: 128 bits) = ((xor_vec X ((shiftr Y (( 32 :: int)::ii)  ::  128 Word.word))  ::  128 Word.word)) in
   (ROL ((subrange_vec_dec T (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (W0 :: 32
     bits) . 
   (ROL ((subrange_vec_dec T (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (W1 :: 32
     bits) . 
   (ROL ((subrange_vec_dec T (( 95 :: int)::ii) (( 64 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (W2 :: 32
     bits) . 
   (ROL ((subrange_vec_dec T (( 127 :: int)::ii) (( 96 :: int)::ii)  ::  32 Word.word)) (( 1 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   (ROL ((subrange_vec_dec T (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) (( 2 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::
      32 Word.word) . 
   (let (W3 :: 32 bits) = ((xor_vec w__0 w__1  ::  32 Word.word)) in
   Q_set ((shr_int d (( 1 :: int)::ii)))
     ((concat_vec ((concat_vec ((concat_vec W3 W2  ::  64 Word.word)) W1  ::  96 Word.word)) W0
        ::  128 Word.word)))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1SU1_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1SU1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1SU1_A1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA1Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1SU1_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA1SU1_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA1SU1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA1SU1_T1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA1Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA1SU1_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA256H_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA256H_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA256H_Op_A_txt d m n = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (Y :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (W :: 128 bits) . 
   (let (part1 :: bool) = True in
   (SHA256hash X Y W part1  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__0))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256H_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256H_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256H_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA256Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256H_Op_A_txt d m n))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256H_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256H_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256H_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA256Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256H_Op_A_txt d m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA256H2_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA256H2_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA256H2_Op_A_txt d m n = (
   (CheckCryptoEnabled32 ()  \<then>
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (Y :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (W :: 128 bits) . 
   (let (part1 :: bool) = False in
   (SHA256hash X Y W part1  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__0))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256H2_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256H2_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256H2_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA256Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256H2_Op_A_txt d m n))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256H2_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256H2_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256H2_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA256Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256H2_Op_A_txt d m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA256SU0_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA256SU0_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA256SU0_Op_A_txt d m = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (elt :: 32 bits) . 
   (CheckCryptoEnabled32 ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (result :: 128 bits) . 
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (Y :: 128 bits) . 
   (let (T :: 128 bits) =
     ((concat_vec ((subrange_vec_dec Y (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ((subrange_vec_dec X (( 127 :: int)::ii) (( 32 :: int)::ii)  ::  96 Word.word))
       ::  128 Word.word)) in
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = ((( 3 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (elt, result)
     ((\<lambda> e varstup .  (let (elt, result) = varstup in
       (Elem_read T e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
       (let elt = w__0 in
       (let (elt :: 32 bits) =
         ((xor_vec
            ((xor_vec ((ROR elt (( 7 :: int)::ii)  ::  32 Word.word)) ((ROR elt (( 18 :: int)::ii)  ::  32 Word.word))
               ::  32 Word.word)) ((shiftr elt (( 3 :: int)::ii)  ::  32 Word.word))
           ::  32 Word.word)) in
       (Elem_read X e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
       (Elem_set result e (( 32 :: int)::ii) ((add_vec elt w__1  ::  32 Word.word))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__2 ::
          128 Word.word) . 
       (let result = w__2 in
       return (elt, result)))))))))))))) \<bind> ((\<lambda> varstup .  (let ((elt ::  32 Word.word), (result ::  128 Word.word)) = varstup in
   Q_set ((shr_int d (( 1 :: int)::ii))) result)))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256SU0_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256SU0_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256SU0_A1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA256Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256SU0_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256SU0_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256SU0_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256SU0_T1enc_A_txt D size1 Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA256Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((size1 \<noteq> ( 0b10 ::  2 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256SU0_Op_A_txt d m)))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SHA256SU1_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_SHA256SU1_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SHA256SU1_Op_A_txt d m n = (
   (CheckCryptoEnabled32 ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (elt :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (result :: 128 bits) . 
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (X :: 128 bits) . 
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (Y :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (Z :: 128 bits) . 
   (let (T0 :: 128 bits) =
     ((concat_vec ((subrange_vec_dec Z (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ((subrange_vec_dec Y (( 127 :: int)::ii) (( 32 :: int)::ii)  ::  96 Word.word))
       ::  128 Word.word)) in
   (let (T1 :: 64 bits) = ((subrange_vec_dec Z (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) in
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = ((( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (elt, result)
     ((\<lambda> e varstup .  (let (elt, result) = varstup in
       (Elem_read T1 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
       (let elt = w__0 in
       (let (elt :: 32 bits) =
         ((xor_vec
            ((xor_vec ((ROR elt (( 17 :: int)::ii)  ::  32 Word.word)) ((ROR elt (( 19 :: int)::ii)  ::  32 Word.word))
               ::  32 Word.word)) ((shiftr elt (( 10 :: int)::ii)  ::  32 Word.word))
           ::  32 Word.word)) in
       (Elem_read X e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
       (Elem_read T0 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
       (let elt = ((add_vec ((add_vec elt w__1  ::  32 Word.word)) w__2  ::  32 Word.word)) in
       (Elem_set result e (( 32 :: int)::ii) elt  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__3 ::  128 Word.word) . 
       (let result = w__3 in
       return (elt, result))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((elt ::  32 Word.word), (result ::  128 Word.word)) = varstup in
   (let (T1 :: 64 bits) = ((subrange_vec_dec result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) in
   (let loop_e_lower = ((( 2 :: int)::ii)) in
   (let loop_e_upper = ((( 3 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (elt, result)
     ((\<lambda> e varstup .  (let (elt, result) = varstup in
       (Elem_read T1 ((e - (( 2 :: int)::ii))) (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
       (let elt = w__4 in
       (let (elt :: 32 bits) =
         ((xor_vec
            ((xor_vec ((ROR elt (( 17 :: int)::ii)  ::  32 Word.word)) ((ROR elt (( 19 :: int)::ii)  ::  32 Word.word))
               ::  32 Word.word)) ((shiftr elt (( 10 :: int)::ii)  ::  32 Word.word))
           ::  32 Word.word)) in
       (Elem_read X e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
       (Elem_read T0 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
       (let elt = ((add_vec ((add_vec elt w__5  ::  32 Word.word)) w__6  ::  32 Word.word)) in
       (Elem_set result e (( 32 :: int)::ii) elt  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__7 ::  128 Word.word) . 
       (let result = w__7 in
       return (elt, result))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((elt ::  32 Word.word), (result ::  128 Word.word)) = varstup in
   Q_set ((shr_int d (( 1 :: int)::ii))) result))))))))))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256SU1_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256SU1_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256SU1_A1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveSHA256Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256SU1_Op_A_txt d m n))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SHA256SU1_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SHA256SU1_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SHA256SU1_T1enc_A_txt D Vn Vd N Q M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     HaveSHA256Ext () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (((if ((\<not> w__2)) then throw (Error_Undefined () )
      else return () ) \<then>
     (if (((Q \<noteq> ( 0b1 ::  1 Word.word)))) then throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     execute_aarch32_instrs_SHA256SU1_Op_A_txt d m n))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STL_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STL_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STL_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t True) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) .  MemO_set address (( 4 :: int)::ii) w__0))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STL_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STL_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STL_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:44169.29-44169.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STL_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STL_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STL_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STL_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STL_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STLB_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STLB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STLB_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t True) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   MemO_set address (( 1 :: int)::ii) ((subrange_vec_dec w__0 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLB_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:44231.29-44231.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STLB_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLB_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLB_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STLB_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STLEX_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STLEX_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STLEX_Op_A_txt d n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_ExclusiveMonitorsPass address (( 4 :: int)::ii) \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 4 :: int)::ii) False t True) in
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     MemO_set address (( 4 :: int)::ii) w__1 \<then> R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word)))))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word)))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEX_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEX_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEX_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:44298.29-44298.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEX_Op_A_txt d n t))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEX_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEX_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEX_T1enc_A_txt Rn Rt Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEX_Op_A_txt d n t)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STLEXB_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STLEXB_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STLEXB_Op_A_txt d n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_ExclusiveMonitorsPass address (( 1 :: int)::ii) \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 1 :: int)::ii) False t True) in
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     MemO_set address (( 1 :: int)::ii) ((subrange_vec_dec w__1 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
     R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word)))))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word)))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEXB_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEXB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEXB_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:44375.29-44375.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEXB_Op_A_txt d n t))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEXB_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEXB_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEXB_T1enc_A_txt Rn Rt Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEXB_Op_A_txt d n t)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STLEXD_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STLEXD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STLEXD_Op_A_txt d n t t2 = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   BigEndian AccType_ORDERED \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then
      (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
      return ((concat_vec w__1 w__2  ::  64 Word.word))))))
    else
      (R_read t2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
      (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
      return ((concat_vec w__3 w__4  ::  64 Word.word))))))) \<bind> ((\<lambda> (value_name :: 64 bits) . 
   AArch32_ExclusiveMonitorsPass address (( 8 :: int)::ii) \<bind> ((\<lambda> (w__5 :: bool) . 
   if w__5 then
     (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 8 :: int)::ii) False t True) in
     MemO_set address (( 8 :: int)::ii) value_name \<then>
     R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word)))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int " 
  and  "t2"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEXD_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEXD_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEXD_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:44456.29-44456.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let t2 = (t + (( 1 :: int)::ii)) in
     (let n = (Word.uint Rn) in
     ((if ((((((((((((d = (( 15 :: int)::ii)))) \<or> ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((d = n))) \<or> (((d = t)))))) \<or> (((d = t2)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEXD_Op_A_txt d n t t2)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEXD_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEXD_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEXD_T1enc_A_txt Rn Rt Rt2 Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let t2 = (Word.uint Rt2) in
     (let n = (Word.uint Rn) in
     ((if ((((((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((t2 = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((((((((d = n))) \<or> (((d = t)))))) \<or> (((d = t2)))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEXD_Op_A_txt d n t t2))))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rt2"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STLEXH_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STLEXH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STLEXH_Op_A_txt d n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   AArch32_ExclusiveMonitorsPass address (( 2 :: int)::ii) \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t True) in
     (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     MemO_set address (( 2 :: int)::ii) ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) \<then>
     R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word)))))
   else R_set d ((ZeroExtend1 (( 32 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  32 Word.word)))))))\<close> 
  for  "d"  :: " int " 
  and  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEXH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEXH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEXH_A1enc_A_txt cond Rn Rd Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:44532.29-44532.30'') \<then>
     ((let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEXH_Op_A_txt d n t))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLEXH_T1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLEXH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLEXH_T1enc_A_txt Rn Rt Rd = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let d = (Word.uint Rd) in
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     ((if (((((((((d = (( 15 :: int)::ii)))) \<or> (((t = (( 15 :: int)::ii))))))) \<or> (((n = (( 15 :: int)::ii))))))) then
        throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((d = n))) \<or> (((d = t)))))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_STLEXH_Op_A_txt d n t)))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word " 
  and  "Rd"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_STLH_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_STLH_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_STLH_Op_A_txt n t = (
   (R_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (address :: 32 bits) . 
   (let (_ :: unit) = (AArch32_SetLSInstructionSyndrome (( 2 :: int)::ii) False t True) in
   (R_read t  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   MemO_set address (( 2 :: int)::ii) ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  "n"  :: " int " 
  and  "t"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLH_A1enc_A_txt : mword ty4 -> mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLH_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLH_A1enc_A_txt cond Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:44604.29-44604.30'') \<then>
     ((let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STLH_Op_A_txt n t)))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_STLH_T1enc_A_txt : mword ty4 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_STLH_T1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_STLH_T1enc_A_txt Rn Rt = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let t = (Word.uint Rt) in
     (let n = (Word.uint Rn) in
     (if ((((((t = (( 15 :: int)::ii)))) \<or> (((n = (( 15 :: int)::ii))))))) then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_STLH_Op_A_txt n t))
   else return () )))\<close> 
  for  "Rn"  :: "(4)Word.word " 
  and  "Rt"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVTA_asimd_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> FPRounding -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVTA_asimd_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d__arg elements esize m regs rounding is_unsigned = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M)) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) () 
     ((\<lambda> r unit_var . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) () 
         ((\<lambda> e unit_var . 
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
           (Elem_read w__1 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
           (FPToFixed esize w__2 (( 0 :: int)::ii) is_unsigned w__3 rounding  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 ::
             ( 'esize::len)Word.word) . 
           (Elem_set w__0 e esize w__4  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5)))))))))))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "rounding"  :: " FPRounding " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTA_asimd_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTA_asimd_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTA_asimd_A1enc_A_txt D b__0 Vd RM op1 Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m regs rounding is_unsigned))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       m regs rounding is_unsigned))))))))))
   else
     (((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m regs rounding is_unsigned)))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "RM"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTA_asimd_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTA_asimd_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTA_asimd_T1enc_A_txt D b__0 Vd RM op1 Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m regs rounding is_unsigned))))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       m regs rounding is_unsigned))))))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     ((((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (is_unsigned :: bool) = (op1 = ( 0b1 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m regs rounding is_unsigned)))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "RM"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVTA_vfp_Op_A_txt : integer -> integer -> integer -> FPRounding -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVTA_vfp_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVTA_vfp_Op_A_txt d esize m rounding is_unsigned = (
   CheckVFPEnabled True \<then>
   ((let l__103 = esize in
   if (((l__103 = (( 16 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (FPToFixed (( 32 :: int)::ii) ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) (( 0 :: int)::ii) is_unsigned
        w__1 rounding
       :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
     S_set d w__2))))))
   else if (((l__103 = (( 32 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     (FPToFixed (( 32 :: int)::ii) w__3 (( 0 :: int)::ii) is_unsigned w__4 rounding  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::
        32 Word.word) . 
     S_set d w__5))))))
   else if (((l__103 = (( 64 :: int)::ii)))) then
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     (FPToFixed (( 32 :: int)::ii) w__6 (( 0 :: int)::ii) is_unsigned w__7 rounding  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::
        32 Word.word) . 
     S_set d w__8))))))
   else return () )))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "rounding"  :: " FPRounding " 
  and  "is_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTA_vfp_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTA_vfp_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTA_vfp_A1enc_A_txt D RM Vd size1 op1 M Vm = (
   ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
      throw (Error_Undefined () )
    else return () ) \<then>
   FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
   (let (is_unsigned :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
   (let (esize :: int) = ((( 16 :: int)::ii)) in
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
   (let b__0 = size1 in
   (let ((esize :: int), (m :: int)) =
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (esize, m)))
     else
       (let ((esize :: int), (m :: int)) =
         (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
           (let (esize :: int) = ((( 32 :: int)::ii)) in
           (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
           (esize, m)))
         else
           (let ((esize :: int), (m :: int)) =
             (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
               (let (esize :: int) = ((( 64 :: int)::ii)) in
               (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
               (esize, m)))
             else (esize, m)) in
           (esize, m))) in
       (esize, m))) in
   (let m = m in
   (let esize = esize in
   execute_aarch32_instrs_VCVTA_vfp_Op_A_txt d esize m rounding is_unsigned))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "RM"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTA_vfp_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTA_vfp_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTA_vfp_T1enc_A_txt D RM Vd size1 op1 M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
   (let (is_unsigned :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
   (let (esize :: int) = ((( 16 :: int)::ii)) in
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
   (let b__0 = size1 in
   (let ((esize :: int), (m :: int)) =
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (esize, m)))
     else
       (let ((esize :: int), (m :: int)) =
         (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
           (let (esize :: int) = ((( 32 :: int)::ii)) in
           (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
           (esize, m)))
         else
           (let ((esize :: int), (m :: int)) =
             (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
               (let (esize :: int) = ((( 64 :: int)::ii)) in
               (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
               (esize, m)))
             else (esize, m)) in
           (esize, m))) in
       (esize, m))) in
   (let m = m in
   (let esize = esize in
   execute_aarch32_instrs_VCVTA_vfp_Op_A_txt d esize m rounding is_unsigned))))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "RM"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMAXNM_Op_A_txt : forall 'esize. Size 'esize => bool -> integer -> integer -> itself 'esize -> integer -> bool -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMAXNM_Op_A_txt  :: \<open> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMAXNM_Op_A_txt advsimd d__arg elements esize m maximum n regs = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDOrVFPEnabled True advsimd \<then>
   (if advsimd then
     (let loop_r_lower = ((( 0 :: int)::ii)) in
     (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
     (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, op2)
       ((\<lambda> r varstup .  (let (op1, op2) = varstup in
         (let loop_e_lower = ((( 0 :: int)::ii)) in
         (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
         (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, op2)
           ((\<lambda> e varstup .  (let (op1, op2) = varstup in
             (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
             (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
             (let op1 = w__1 in
             (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
             (Elem_read w__2 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
             (let op2 = w__3 in
             (if maximum then
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
                (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
                (FPMaxNum op1 op2 w__5  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 :: ( 'esize::len)Word.word) . 
                (Elem_set w__4 e esize w__6  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
                D_set ((d + r)) w__7))))))))
              else
                (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
                (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
                (FPMinNum op1 op2 w__9  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__10 :: ( 'esize::len)Word.word) . 
                (Elem_set w__8 e esize w__10  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
                D_set ((d + r)) w__11))))))))) \<then>
             return (op1, op2))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 :: ( 'esize::len)Word.word), (op2 :: ( 'esize::len)Word.word)) = varstup in
     return () )))))
   else
     (let l__100 = esize in
     if (((l__100 = (( 16 :: int)::ii)))) then
       if maximum then
         (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__12 ::  32 Word.word) . 
         (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__13 ::  32 Word.word) . 
         (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
         (FPMaxNum ((subrange_vec_dec w__12 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
            ((subrange_vec_dec w__13 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__14
           :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__15 ::  16 Word.word) . 
         S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__15  ::  32 Word.word))))))))))
       else
         (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__16 ::  32 Word.word) . 
         (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__17 ::  32 Word.word) . 
         (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
         (FPMinNum ((subrange_vec_dec w__16 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
            ((subrange_vec_dec w__17 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__18
           :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__19 ::  16 Word.word) . 
         S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__19  ::  32 Word.word))))))))))
     else if (((l__100 = (( 32 :: int)::ii)))) then
       if maximum then
         (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__20 ::  32 Word.word) . 
         (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__21 ::  32 Word.word) . 
         (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__22 ::  64 Word.word) . 
         (FPMaxNum w__20 w__21 w__22  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__23 ::  32 Word.word) . 
         S_set d w__23))))))))
       else
         (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__24 ::  32 Word.word) . 
         (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__25 ::  32 Word.word) . 
         (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__26 ::  64 Word.word) . 
         (FPMinNum w__24 w__25 w__26  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__27 ::  32 Word.word) . 
         S_set d w__27))))))))
     else if (((l__100 = (( 64 :: int)::ii)))) then
       if maximum then
         (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
         (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
         (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
         (FPMaxNum w__28 w__29 w__30  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
         D_set d w__31))))))))
       else
         (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
         (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__33 ::  64 Word.word) . 
         (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__34 ::  64 Word.word) . 
         (FPMinNum w__32 w__33 w__34  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
         D_set d w__35))))))))
     else return () )))))))))\<close> 
  for  "advsimd"  :: " bool " 
  and  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "maximum"  :: " bool " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAXNM_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAXNM_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAXNM_A1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMAXNM_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       m maximum n regs))))))))))
   else
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMAXNM_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m maximum n regs)))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAXNM_A2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAXNM_A2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAXNM_A2enc_A_txt D Vn Vd b__0 N op1 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m maximum n regs)))))))))))))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m maximum n regs)))))))))))))))))))))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (esize :: int) = ((( 64 :: int)::ii)) in
     (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m maximum n regs)))))))))))))))))))))
   else
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m maximum n regs)))))))))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAXNM_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAXNM_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAXNM_T1enc_A_txt D op1 b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     ((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMAXNM_Op_A_txt True d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       m maximum n regs))))))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VMAXNM_Op_A_txt True d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       m maximum n regs)))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMAXNM_T2enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMAXNM_T2enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMAXNM_T2enc_A_txt D Vn Vd b__0 N op1 M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m maximum n regs))))))))))))))))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m maximum n regs))))))))))))))))))))))))
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let (esize :: int) = ((( 64 :: int)::ii)) in
     (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m maximum n regs))))))))))))))))))))))))
   else
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (regs :: ii) . 
     undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (elements :: ii) . 
     InITBlock ()  \<bind> ((\<lambda> (w__3 :: bool) . 
     ((if w__3 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> False))) then throw (Error_Undefined () )
      else return () )) \<then>
     ((let elements = elements in
     (let regs = regs in
     (let (maximum :: bool) = (op1 = ( 0b0 ::  1 Word.word)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let n = n in
     (let m = m in
     (let d = d in
     execute_aarch32_instrs_VMAXNM_Op_A_txt False d elements
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m maximum n regs)))))))))))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRINTA_asimd_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> FPRounding -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRINTA_asimd_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d__arg elements esize exact m regs rounding = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, result)
     ((\<lambda> r varstup .  (let (op1, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, result)
         ((\<lambda> e varstup .  (let (op1, result) = varstup in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (FPRoundInt op1 w__2 rounding exact  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let result = w__3 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (op1, result))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (result :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "exact"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "rounding"  :: " FPRounding "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTA_asimd_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty3 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTA_asimd_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTA_asimd_A1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     (((if ((((vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word)))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM
       ((concat_vec (vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word)
           ((not_vec (vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
          ::  2 Word.word))) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs rounding)))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     (((if ((((vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word)))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM
       ((concat_vec (vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word)
           ((not_vec (vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
          ::  2 Word.word))) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       False m regs rounding)))))))))
   else
     ((((if ((((vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word)))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM
       ((concat_vec (vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word)
           ((not_vec (vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
          ::  2 Word.word))) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs rounding))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(3)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTA_asimd_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty3 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTA_asimd_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTA_asimd_T1enc_A_txt D b__0 Vd op1 Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     ((if ((((vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word)))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     InITBlock () ) \<bind> ((\<lambda> (w__0 :: bool) . 
     (((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM
       ((concat_vec (vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word)
           ((not_vec (vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
          ::  2 Word.word))) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs rounding)))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     ((if ((((vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word)))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     InITBlock () ) \<bind> ((\<lambda> (w__1 :: bool) . 
     (((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM
       ((concat_vec (vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word)
           ((not_vec (vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
          ::  2 Word.word))) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       False m regs rounding)))))))))))
   else
     ((if ((((vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [access_vec_dec op1 (( 0 :: int)::ii)]  ::  1 Word.word)))) then
        throw (Error_See (''Related encodings''))
      else return () ) \<then>
     InITBlock () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     ((((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     FPDecodeRM
       ((concat_vec (vec_of_bits [access_vec_dec op1 (( 2 :: int)::ii)]  ::  1 Word.word)
           ((not_vec (vec_of_bits [access_vec_dec op1 (( 1 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
          ::  2 Word.word))) \<bind> ((\<lambda> (rounding :: FPRounding) . 
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs rounding))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "op1"  :: "(3)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRINTA_vfp_Op_A_txt : integer -> integer -> bool -> integer -> FPRounding -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRINTA_vfp_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRINTA_vfp_Op_A_txt d esize exact m rounding = (
   CheckVFPEnabled True \<then>
   ((let l__97 = esize in
   if (((l__97 = (( 16 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (FPRoundInt ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__1 rounding exact
       :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
     S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__2  ::  32 Word.word))))))))
   else if (((l__97 = (( 32 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     (FPRoundInt w__3 w__4 rounding exact  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
     S_set d w__5))))))
   else if (((l__97 = (( 64 :: int)::ii)))) then
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     (FPRoundInt w__6 w__7 rounding exact  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
     D_set d w__8))))))
   else return () )))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "exact"  :: " bool " 
  and  "m"  :: " int " 
  and  "rounding"  :: " FPRounding "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTA_vfp_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTA_vfp_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTA_vfp_A1enc_A_txt D RM Vd size1 M Vm = (
   ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
      throw (Error_Undefined () )
    else return () ) \<then>
   FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
   (let (exact :: bool) = False in
   (let (esize :: int) = ((( 16 :: int)::ii)) in
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
   (let b__0 = size1 in
   (let ((d :: int), (esize :: int), (m :: int)) =
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (d, esize, m))))
     else
       (let ((d :: int), (esize :: int), (m :: int)) =
         (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
           (let (esize :: int) = ((( 32 :: int)::ii)) in
           (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
           (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
           (d, esize, m))))
         else
           (let ((d :: int), (esize :: int), (m :: int)) =
             (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
               (let (esize :: int) = ((( 64 :: int)::ii)) in
               (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
               (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
               (d, esize, m))))
             else (d, esize, m)) in
           (d, esize, m))) in
       (d, esize, m))) in
   (let m = m in
   (let esize = esize in
   (let d = d in
   execute_aarch32_instrs_VRINTA_vfp_Op_A_txt d esize exact m rounding))))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "RM"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTA_vfp_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTA_vfp_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTA_vfp_T1enc_A_txt D RM Vd size1 M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   FPDecodeRM RM) \<bind> ((\<lambda> (rounding :: FPRounding) . 
   (let (exact :: bool) = False in
   (let (esize :: int) = ((( 16 :: int)::ii)) in
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
   (let b__0 = size1 in
   (let ((d :: int), (esize :: int), (m :: int)) =
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (d, esize, m))))
     else
       (let ((d :: int), (esize :: int), (m :: int)) =
         (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
           (let (esize :: int) = ((( 32 :: int)::ii)) in
           (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
           (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
           (d, esize, m))))
         else
           (let ((d :: int), (esize :: int), (m :: int)) =
             (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
               (let (esize :: int) = ((( 64 :: int)::ii)) in
               (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
               (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
               (d, esize, m))))
             else (d, esize, m)) in
           (d, esize, m))) in
       (d, esize, m))) in
   (let m = m in
   (let esize = esize in
   (let d = d in
   execute_aarch32_instrs_VRINTA_vfp_Op_A_txt d esize exact m rounding))))))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "RM"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRINTX_asimd_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> FPRounding -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRINTX_asimd_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d__arg elements esize exact m regs rounding = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, result)
     ((\<lambda> r varstup .  (let (op1, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, result)
         ((\<lambda> e varstup .  (let (op1, result) = varstup in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (FPRoundInt op1 w__2 rounding exact  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let result = w__3 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (op1, result))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (result :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "exact"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "rounding"  :: " FPRounding "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTX_asimd_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTX_asimd_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTX_asimd_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       True m regs FPRounding_TIEEVEN))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       True m regs FPRounding_TIEEVEN))))))))
   else
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       True m regs FPRounding_TIEEVEN)))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTX_asimd_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTX_asimd_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTX_asimd_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       True m regs FPRounding_TIEEVEN))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       True m regs FPRounding_TIEEVEN))))))))))
   else
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       True m regs FPRounding_TIEEVEN)))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRINTX_vfp_Op_A_txt : integer -> integer -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRINTX_vfp_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRINTX_vfp_Op_A_txt d esize exact m = (
   (CheckVFPEnabled True \<then>
   (FPSCR_read ()   :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   FPRoundingMode w__0 \<bind> ((\<lambda> (rounding :: FPRounding) . 
   (let l__94 = esize in
   if (((l__94 = (( 16 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (FPRoundInt ((subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__2 rounding exact
       :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
     S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__3  ::  32 Word.word))))))))
   else if (((l__94 = (( 32 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
     (FPRoundInt w__4 w__5 rounding exact  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
     S_set d w__6))))))
   else if (((l__94 = (( 64 :: int)::ii)))) then
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
     (FPRoundInt w__7 w__8 rounding exact  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
     D_set d w__9))))))
   else return () ))))))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "exact"  :: " bool " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTX_vfp_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTX_vfp_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTX_vfp_A1enc_A_txt cond D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:45492.29-45492.30'') \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     ((let (exact :: bool) = True in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VRINTX_vfp_Op_A_txt d esize exact m))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTX_vfp_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTX_vfp_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTX_vfp_T1enc_A_txt D Vd size1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let (exact :: bool) = True in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VRINTX_vfp_Op_A_txt d esize exact m))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> bool -> integer -> integer -> FPRounding -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d__arg elements esize exact m regs rounding = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (op1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (op1, result)
     ((\<lambda> r varstup .  (let (op1, result) = varstup in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (op1, result)
         ((\<lambda> e varstup .  (let (op1, result) = varstup in
           (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
           (Elem_read w__0 e esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__1 :: ( 'esize::len)Word.word) . 
           (let op1 = w__1 in
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
           (FPRoundInt op1 w__2 rounding exact  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
           (let result = w__3 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (Elem_set w__4 e esize result  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           D_set ((d + r)) w__5 \<then> return (op1, result))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((op1 ::
     ( 'esize::len)Word.word), (result :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "exact"  :: " bool " 
  and  "m"  :: " int " 
  and  "regs"  :: " int " 
  and  "rounding"  :: " FPRounding "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTZ_asimd_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTZ_asimd_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTZ_asimd_A1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs FPRounding_ZERO))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       False m regs FPRounding_ZERO))))))))
   else
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs FPRounding_ZERO)))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTZ_asimd_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTZ_asimd_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTZ_asimd_T1enc_A_txt D b__0 Vd Q M Vm = (
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 4 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d (( 4 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs FPRounding_ZERO))))))))))
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let (esize :: int) = ((( 32 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       False m regs FPRounding_ZERO))))))))))
   else
     ((if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     (if (((False \<or> ((((((b__0 = ( 0b00 ::  2 Word.word)))) \<or> (((b__0 = ( 0b11 ::  2 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let (esize :: int) = ((( 16 :: int)::ii)) in
     (let (elements :: int) = ((( 2 :: int)::ii)) in
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     InITBlock ()  \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d (( 2 :: int)::ii) ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       False m regs FPRounding_ZERO)))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(2)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt : integer -> integer -> bool -> integer -> FPRounding -> M unit\<close>\<close>

definition execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt d esize exact m rounding = (
   CheckVFPEnabled True \<then>
   ((let l__91 = esize in
   if (((l__91 = (( 16 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (FPRoundInt ((subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) w__1 rounding exact
       :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
     S_set d ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word)) w__2  ::  32 Word.word))))))))
   else if (((l__91 = (( 32 :: int)::ii)))) then
     (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
     (FPRoundInt w__3 w__4 rounding exact  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
     S_set d w__5))))))
   else if (((l__91 = (( 64 :: int)::ii)))) then
     (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     (FPRoundInt w__6 w__7 rounding exact  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
     D_set d w__8))))))
   else return () )))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "exact"  :: " bool " 
  and  "m"  :: " int " 
  and  "rounding"  :: " FPRounding "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTZ_vfp_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTZ_vfp_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTZ_vfp_A1enc_A_txt cond D Vd size1 op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:45721.29-45721.30'') \<then>
     (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () )) \<then>
     (if ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> (((cond \<noteq> ( 0xE ::  4 Word.word))))))) then
        throw (Error_Unpredictable () )
      else return () )) \<then>
     (if (((op1 = ( 0b1 ::  1 Word.word)))) then return FPRounding_ZERO
      else (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  FPRoundingMode w__1)))) \<bind> ((\<lambda> (rounding ::
       FPRounding) . 
     (let (exact :: bool) = False in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt d esize exact m rounding)))))))))))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VRINTZ_vfp_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VRINTZ_vfp_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VRINTZ_vfp_T1enc_A_txt D Vd size1 op1 M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
        throw (Error_Undefined () )
      else return () ) \<then>
     and_boolM (return (((size1 = ( 0b01 ::  2 Word.word))))) ((InITBlock () ))) \<bind> ((\<lambda> (w__2 :: bool) . 
     ((if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((op1 = ( 0b1 ::  1 Word.word)))) then return FPRounding_ZERO
      else (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) .  FPRoundingMode w__3)))) \<bind> ((\<lambda> (rounding ::
       FPRounding) . 
     (let (exact :: bool) = False in
     (let (esize :: int) = ((( 16 :: int)::ii)) in
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
     undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
     (let b__0 = size1 in
     (let ((d :: int), (esize :: int), (m :: int)) =
       (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
         (let (esize :: int) = ((( 16 :: int)::ii)) in
         (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
         (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
         (d, esize, m))))
       else
         (let ((d :: int), (esize :: int), (m :: int)) =
           (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
             (let (esize :: int) = ((( 32 :: int)::ii)) in
             (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
             (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
             (d, esize, m))))
           else
             (let ((d :: int), (esize :: int), (m :: int)) =
               (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
                 (let (esize :: int) = ((( 64 :: int)::ii)) in
                 (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
                 (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
                 (d, esize, m))))
               else (d, esize, m)) in
             (d, esize, m))) in
         (d, esize, m))) in
     (let m = m in
     (let esize = esize in
     (let d = d in
     execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt d esize exact m rounding)))))))))))))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "op1"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VSEL_Op_A_txt : mword ty4 -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VSEL_Op_A_txt  :: \<open>(4)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VSEL_Op_A_txt cond d esize m n = (
   CheckVFPEnabled True \<then>
   ((let l__88 = esize in
   if (((l__88 = (( 16 :: int)::ii)))) then
     ConditionHolds cond \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then (S_read n  :: ( 32 Word.word) M)
      else (S_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
     S_set d
       ((concat_vec ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))
           ((subrange_vec_dec w__3 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ::  32 Word.word))))))
   else if (((l__88 = (( 32 :: int)::ii)))) then
     ConditionHolds cond \<bind> ((\<lambda> (w__4 :: bool) . 
     (if w__4 then (S_read n  :: ( 32 Word.word) M)
      else (S_read m  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
     S_set d w__7))))
   else if (((l__88 = (( 64 :: int)::ii)))) then
     ConditionHolds cond \<bind> ((\<lambda> (w__8 :: bool) . 
     (if w__8 then (D_read n  :: ( 64 Word.word) M)
      else (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
     D_set d w__11))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSEL_A1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSEL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSEL_A1enc_A_txt D cc Vn Vd size1 N M Vm = (
   (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
      throw (Error_Undefined () )
    else return () ) \<then>
   ((let (esize :: int) = ((( 16 :: int)::ii)) in
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
   (let b__0 = size1 in
   (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (d, esize, m, n)))))
     else
       (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
         (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
           (let (esize :: int) = ((( 32 :: int)::ii)) in
           (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
           (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
           (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
           (d, esize, m, n)))))
         else
           (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
             (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
               (let (esize :: int) = ((( 64 :: int)::ii)) in
               (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
               (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
               (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
               (d, esize, m, n)))))
             else (d, esize, m, n)) in
           (d, esize, m, n))) in
       (d, esize, m, n))) in
   (let n = n in
   (let m = m in
   (let esize = esize in
   (let d = d in
   (let (cond :: 4 bits) =
     ((concat_vec
        ((concat_vec cc
            ((xor_vec (vec_of_bits [access_vec_dec cc (( 1 :: int)::ii)]  ::  1 Word.word)
                (vec_of_bits [access_vec_dec cc (( 0 :: int)::ii)]  ::  1 Word.word)
               ::  1 Word.word))
           ::  3 Word.word)) ( 0b0 ::  1 Word.word)
       ::  4 Word.word)) in
   execute_aarch32_instrs_VSEL_Op_A_txt cond d esize m n))))))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "cc"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VSEL_T1enc_A_txt : mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VSEL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VSEL_T1enc_A_txt D cc Vn Vd size1 N M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if ((((((size1 = ( 0b00 ::  2 Word.word)))) \<or> ((((((size1 = ( 0b01 ::  2 Word.word)))) \<and> ((\<not> ((HaveFP16Ext () )))))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let (esize :: int) = ((( 16 :: int)::ii)) in
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (d :: int) . 
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (n :: int) . 
   undefined_range instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 0 :: int)::ii) (( 31 :: int)::ii) \<bind> ((\<lambda> (m :: int) . 
   (let b__0 = size1 in
   (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
     (if (((b__0 = ( 0b01 ::  2 Word.word)))) then
       (let (esize :: int) = ((( 16 :: int)::ii)) in
       (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
       (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
       (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
       (d, esize, m, n)))))
     else
       (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
         (if (((b__0 = ( 0b10 ::  2 Word.word)))) then
           (let (esize :: int) = ((( 32 :: int)::ii)) in
           (let (d :: int) = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
           (let (n :: int) = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
           (let (m :: int) = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
           (d, esize, m, n)))))
         else
           (let ((d :: int), (esize :: int), (m :: int), (n :: int)) =
             (if (((b__0 = ( 0b11 ::  2 Word.word)))) then
               (let (esize :: int) = ((( 64 :: int)::ii)) in
               (let (d :: int) = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
               (let (n :: int) = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
               (let (m :: int) = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
               (d, esize, m, n)))))
             else (d, esize, m, n)) in
           (d, esize, m, n))) in
       (d, esize, m, n))) in
   (let n = n in
   (let m = m in
   (let esize = esize in
   (let d = d in
   (let (cond :: 4 bits) =
     ((concat_vec
        ((concat_vec cc
            ((xor_vec (vec_of_bits [access_vec_dec cc (( 1 :: int)::ii)]  ::  1 Word.word)
                (vec_of_bits [access_vec_dec cc (( 0 :: int)::ii)]  ::  1 Word.word)
               ::  1 Word.word))
           ::  3 Word.word)) ( 0b0 ::  1 Word.word)
       ::  4 Word.word)) in
   execute_aarch32_instrs_VSEL_Op_A_txt cond d esize m n))))))))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "cc"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "size1"  :: "(2)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_SETPAN_Op_A_txt : mword ty1 -> M unit\<close>\<close>

definition execute_aarch32_instrs_SETPAN_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_SETPAN_Op_A_txt value_name = (
   read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) \<noteq> EL0))) then
     read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) . 
     write_reg PSTATE_ref ( w__1 (| ProcState_PAN := value_name |))))
   else return () )))\<close> 
  for  "value_name"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SETPAN_A1enc_A_txt : mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SETPAN_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SETPAN_A1enc_A_txt imm1 = (
   (if ((\<not> ((HavePANExt () )))) then throw (Error_Undefined () )
    else return () ) \<then>
   ((let (value_name :: 1 bits) = imm1 in
   execute_aarch32_instrs_SETPAN_Op_A_txt value_name)))\<close> 
  for  "imm1"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_SETPAN_T1enc_A_txt : mword ty1 -> M unit\<close>\<close>

definition decode_aarch32_instrs_SETPAN_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SETPAN_T1enc_A_txt imm1 = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   (if ((\<not> ((HavePANExt () )))) then throw (Error_Undefined () )
    else return () )) \<then>
   ((let (value_name :: 1 bits) = imm1 in
   execute_aarch32_instrs_SETPAN_Op_A_txt value_name)))))\<close> 
  for  "imm1"  :: "(1)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_ESB_Op_A_txt : unit -> M unit\<close>\<close>

definition execute_aarch32_instrs_ESB_Op_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_ESB_Op_A_txt _ = (
   (let (_ :: unit) = (SynchronizeErrors () ) in
   (AArch32_ESBOperation ()  \<then>
   and_boolM
     (or_boolM
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL0))))))
        (read_reg PSTATE_ref \<bind> ((\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) = EL1)))))))
     ((EL2Enabled () ))) \<bind> ((\<lambda> (w__4 :: bool) . 
   (if w__4 then AArch32_vESBOperation () 
    else return () ) \<then>
   return ((TakeUnmaskedSErrorInterrupts () ))))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_ESB_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_ESB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ESB_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:46020.29-46020.30'') \<then>
     HaveRASExt () ) \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if ((\<not> w__1)) then EndOfInstruction () 
      else return () ) \<then>
     (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     execute_aarch32_instrs_ESB_Op_A_txt () ))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_ESB_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_ESB_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_ESB_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveRASExt ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if ((\<not> w__1)) then EndOfInstruction () 
      else return () ) \<then>
     InITBlock () ) \<bind> ((\<lambda> (w__2 :: bool) . 
     (if w__2 then throw (Error_Unpredictable () )
      else return () ) \<then>
     execute_aarch32_instrs_ESB_Op_A_txt () ))))
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_TSB_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_TSB_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_TSB_Op_A_txt _ = ( TraceSynchronizationBarrier ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_TSB_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_TSB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TSB_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:46076.29-46076.30'') \<then>
     (if ((\<not> ((HaveSelfHostedTrace () )))) then EndOfInstruction () 
      else return () )) \<then>
     (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     return ((execute_aarch32_instrs_TSB_Op_A_txt () ))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_TSB_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_TSB_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_TSB_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ((if ((\<not> ((HaveSelfHostedTrace () )))) then EndOfInstruction () 
      else return () ) \<then>
     InITBlock () ) \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     return ((execute_aarch32_instrs_TSB_Op_A_txt () ))))
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_CSDB_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_CSDB_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_CSDB_Op_A_txt _ = ( ConsumptionOfSpeculativeDataBarrier ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_CSDB_A1enc_A_txt : mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_CSDB_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CSDB_A1enc_A_txt cond = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:46132.29-46132.30'') \<then>
     (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
      else return () )) \<then>
     return ((execute_aarch32_instrs_CSDB_Op_A_txt () ))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_CSDB_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_CSDB_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_CSDB_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     return ((execute_aarch32_instrs_CSDB_Op_A_txt () ))))
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_SSBB_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_SSBB_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_SSBB_Op_A_txt _ = ( SpeculativeStoreBypassBarrierToVA ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SSBB_A1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSBB_A1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSBB_A1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_SSBB_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_SSBB_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_SSBB_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_SSBB_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     return ((execute_aarch32_instrs_SSBB_Op_A_txt () ))))
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_PSSBB_Op_A_txt : unit -> unit\<close>\<close>

definition execute_aarch32_instrs_PSSBB_Op_A_txt  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> execute_aarch32_instrs_PSSBB_Op_A_txt _ = ( SpeculativeStoreBypassBarrierToPA ()  )\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_PSSBB_A1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_PSSBB_A1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PSSBB_A1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (let (_ :: unit) = (if w__0 then execute_aarch32_instrs_PSSBB_Op_A_txt ()  else () ) in
   return () ))))\<close>


\<comment> \<open>\<open>val decode_aarch32_instrs_PSSBB_T1enc_A_txt : unit -> M unit\<close>\<close>

definition decode_aarch32_instrs_PSSBB_T1enc_A_txt  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_PSSBB_T1enc_A_txt _ = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     return ((execute_aarch32_instrs_PSSBB_Op_A_txt () ))))
   else return () )))\<close>


\<comment> \<open>\<open>val execute_aarch32_instrs_VDOT_Op_A_txt : integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VDOT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VDOT_Op_A_txt d esize m n regs is_signed = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand1, operand2, result)
     ((\<lambda> r varstup .  (let (operand1, operand2, result) = varstup in
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let operand2 = w__1 in
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (let result = w__2 in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element1 :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element2 :: ii) . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (element1, element2, result)
         ((\<lambda> e varstup .  (let (element1, element2, result) = varstup in
           (let (res :: ii) = ((( 0 :: int)::ii)) in
           (let loop_i_lower = ((( 0 :: int)::ii)) in
           (let loop_i_upper = ((( 3 :: int)::ii)) in
           (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) (element1, element2, res)
             ((\<lambda> i varstup .  (let (element1, element2, res) = varstup in
               (if is_signed then
                  (Elem_read operand1 (((((( 4 :: int)::ii) * e)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
                  (let element1 = (Word.sint w__3) in
                  (Elem_read operand2 (((((( 4 :: int)::ii) * e)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__4 ::  8 Word.word) . 
                  (let element2 = (Word.sint w__4) in
                  return (element1, element2)))))))
                else
                  (Elem_read operand1 (((((( 4 :: int)::ii) * e)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
                  (let element1 = (Word.uint w__5) in
                  (Elem_read operand2 (((((( 4 :: int)::ii) * e)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__6 ::  8 Word.word) . 
                  (let element2 = (Word.uint w__6) in
                  return (element1, element2)))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
                 ii)) = varstup in
               (let (res :: ii) = (res + ((element1 * element2))) in
               return (element1, element2, res))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
             ii), (res :: ii)) = varstup in
           (let res = res in
           (Elem_read result e esize  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
           (Elem_set result e esize ((add_vec_int w__7 res  ::  32 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::
              64 Word.word) . 
           (let result = w__8 in
           return (element1, element2, result))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
         ii), (result ::  64 Word.word)) = varstup in
       D_set ((d + r)) result \<then> return (operand1, operand2, result))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 ::
      64 Word.word), (operand2 ::  64 Word.word), (result ::  64 Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_signed"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_A1enc_A_txt D Vn Vd N Q M U Vm = (
   HaveDOTPExt ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let (is_signed :: bool) = (U = ( 0b0 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let esize = ((( 32 :: int)::ii)) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_Op_A_txt d esize m n regs is_signed))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_T1enc_A_txt D Vn Vd N Q M U Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveDOTPExt () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let (is_signed :: bool) = (U = ( 0b0 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let esize = ((( 32 :: int)::ii)) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_Op_A_txt d esize m n regs is_signed))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VDOT_s_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VDOT_s_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VDOT_s_Op_A_txt d esize index1 m n regs is_signed = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand1, result)
     ((\<lambda> r varstup .  (let (operand1, result) = varstup in
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let result = w__1 in
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element1 :: ii) . 
       undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element2 :: ii) . 
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (element1, element2, result)
         ((\<lambda> e varstup .  (let (element1, element2, result) = varstup in
           (let (res :: ii) = ((( 0 :: int)::ii)) in
           (let loop_i_lower = ((( 0 :: int)::ii)) in
           (let loop_i_upper = ((( 3 :: int)::ii)) in
           (foreachM (index_list loop_i_lower loop_i_upper (( 1 :: int)::ii)) (element1, element2, res)
             ((\<lambda> i varstup .  (let (element1, element2, res) = varstup in
               (if is_signed then
                  (Elem_read operand1 (((((( 4 :: int)::ii) * e)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__2 ::  8 Word.word) . 
                  (let element1 = (Word.sint w__2) in
                  (Elem_read operand2 (((((( 4 :: int)::ii) * index1)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::  8 Word.word) . 
                  (let element2 = (Word.sint w__3) in
                  return (element1, element2)))))))
                else
                  (Elem_read operand1 (((((( 4 :: int)::ii) * e)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__4 ::  8 Word.word) . 
                  (let element1 = (Word.uint w__4) in
                  (Elem_read operand2 (((((( 4 :: int)::ii) * index1)) + i))
                     ((esize div (( 4 :: int)::ii)))
                    :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__5 ::  8 Word.word) . 
                  (let element2 = (Word.uint w__5) in
                  return (element1, element2)))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
                 ii)) = varstup in
               (let (res :: ii) = (res + ((element1 * element2))) in
               return (element1, element2, res))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
             ii), (res :: ii)) = varstup in
           (let res = res in
           (Elem_read result e esize  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
           (Elem_set result e esize ((add_vec_int w__6 res  ::  32 Word.word))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::
              64 Word.word) . 
           (let result = w__7 in
           return (element1, element2, result))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
         ii), (result ::  64 Word.word)) = varstup in
       D_set ((d + r)) result \<then> return (operand1, result)))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 ::
      64 Word.word), (result ::  64 Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "esize"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "is_signed"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_s_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_s_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_s_A1enc_A_txt op1 D op2 Vn Vd N Q M U Vm = (
   HaveDOTPExt ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let (is_signed :: bool) = (U = ( 0b0 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((subrange_vec_dec Vm (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))) in
   (let index1 = (Word.uint M) in
   (let esize = ((( 32 :: int)::ii)) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_s_Op_A_txt d esize index1 m n regs is_signed)))))))))))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "op2"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_s_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_s_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_s_T1enc_A_txt op1 D op2 Vn Vd N Q M U Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveDOTPExt () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let (is_signed :: bool) = (U = ( 0b0 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((subrange_vec_dec Vm (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))) in
   (let index1 = (Word.uint M) in
   (let esize = ((( 32 :: int)::ii)) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_s_Op_A_txt d esize index1 m n regs is_signed)))))))))))))\<close> 
  for  "op1"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "op2"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VJCVT_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VJCVT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VJCVT_Op_A_txt d m = (
   (CheckVFPEnabled True \<then>
   (D_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (fltval :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (intval :: 32 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> ((\<lambda> (Z :: 1 bits) . 
   (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (FPToFixedJS (( 32 :: int)::ii) fltval w__0 False  :: (( 32 Word.word *  1 Word.word)) M) \<bind> ((\<lambda> (w__1 ::
     ( 32 Word.word *  1 Word.word)) . 
   (let (tup__0, tup__1) = w__1 in
   (let (intval :: 32 bits) = tup__0 in
   (let (Z :: 1 bits) = tup__1 in
   (FPSCR_read__1 ()   :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
   FPSCR_write
     ((update_subrange_vec_dec w__2 (( 31 :: int)::ii) (( 28 :: int)::ii)
         ((concat_vec ((concat_vec ( 0b0 ::  1 Word.word) Z  ::  2 Word.word)) ( 0b00 ::  2 Word.word)
            ::  4 Word.word))
        ::  32 Word.word)) \<then>
   S_set d intval))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VJCVT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VJCVT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VJCVT_A1enc_A_txt cond D Vd M Vm = (
   ((assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:46482.25-46482.26'') \<then>
   (if ((\<not> ((HaveFJCVTZSExt () )))) then throw (Error_Undefined () )
    else return () )) \<then>
   (if (((cond \<noteq> ( 0xE ::  4 Word.word)))) then throw (Error_Unpredictable () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   execute_aarch32_instrs_VJCVT_Op_A_txt d m))))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VJCVT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VJCVT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VJCVT_T1enc_A_txt D Vd M Vm = (
   ((if ((\<not> ((HaveFJCVTZSExt () )))) then throw (Error_Undefined () )
    else return () ) \<then>
   InITBlock () ) \<bind> ((\<lambda> (w__0 :: bool) . 
   (if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   execute_aarch32_instrs_VJCVT_Op_A_txt d m))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCMLA_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> mword ty2 -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCMLA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCMLA_Op_A_txt d__arg elements esize m n regs rot = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand3 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand1,
                                                            operand2,
                                                            operand3,
                                                            result1,
                                                            result2)
     ((\<lambda> r varstup .  (let (operand1, operand2, operand3, result1, result2) = varstup in
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let operand2 = w__1 in
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (let operand3 = w__2 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (((elements div (( 2 :: int)::ii))) - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (result1, result2)
         ((\<lambda> e varstup .  (let (result1, result2) = varstup in
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element1 :: ( 'esize::len)Word.word) . 
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element2 :: ( 'esize::len)Word.word) . 
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element3 :: ( 'esize::len)Word.word) . 
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element4 :: ( 'esize::len)Word.word) . 
           (let b__0 = rot in
           (if (((b__0 = ( 0b00 ::  2 Word.word)))) then
              (Elem_read operand2 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 ::
                ( 'esize::len)Word.word) . 
              (let element1 = w__3 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 ::
                ( 'esize::len)Word.word) . 
              (let element2 = w__4 in
              (Elem_read operand2 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let element3 = w__5 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 ::
                ( 'esize::len)Word.word) . 
              (let element4 = w__6 in
              return (element1, element2, element3, element4)))))))))))))
            else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
              (Elem_read operand2 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
              (FPNeg w__7  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__8 :: ( 'esize::len)Word.word) . 
              (let element1 = w__8 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__9 :: ( 'esize::len)Word.word) . 
              (let element2 = w__9 in
              (Elem_read operand2 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__10 ::
                ( 'esize::len)Word.word) . 
              (let element3 = w__10 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__11 :: ( 'esize::len)Word.word) . 
              (let element4 = w__11 in
              return (element1, element2, element3, element4)))))))))))))))
            else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
              (Elem_read operand2 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__12 ::
                ( 'esize::len)Word.word) . 
              (FPNeg w__12  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__13 :: ( 'esize::len)Word.word) . 
              (let element1 = w__13 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__14 ::
                ( 'esize::len)Word.word) . 
              (let element2 = w__14 in
              (Elem_read operand2 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__15 :: ( 'esize::len)Word.word) . 
              (FPNeg w__15  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__16 :: ( 'esize::len)Word.word) . 
              (let element3 = w__16 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__17 ::
                ( 'esize::len)Word.word) . 
              (let element4 = w__17 in
              return (element1, element2, element3, element4)))))))))))))))))
            else
              (Elem_read operand2 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__18 :: ( 'esize::len)Word.word) . 
              (let element1 = w__18 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__19 :: ( 'esize::len)Word.word) . 
              (let element2 = w__19 in
              (Elem_read operand2 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__20 ::
                ( 'esize::len)Word.word) . 
              (FPNeg w__20  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__21 :: ( 'esize::len)Word.word) . 
              (let element3 = w__21 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__22 :: ( 'esize::len)Word.word) . 
              (let element4 = w__22 in
              return (element1, element2, element3, element4)))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::
             ( 'esize::len)Word.word), (element2 :: ( 'esize::len)Word.word), (element3 :: ( 'esize::len)Word.word), (element4 ::
             ( 'esize::len)Word.word)) = varstup in
           (let element4 = element4 in
           (let element3 = element3 in
           (let element2 = element2 in
           (let element1 = element1 in
           (Elem_read operand3 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__23 ::
             ( 'esize::len)Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
           (FPMulAdd w__23 element2 element1 w__24  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__25 ::
             ( 'esize::len)Word.word) . 
           (let result1 = w__25 in
           (Elem_read operand3 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
             :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__26 :: ( 'esize::len)Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
           (FPMulAdd w__26 element4 element3 w__27  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__28 ::
             ( 'esize::len)Word.word) . 
           (let result2 = w__28 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
           (Elem_set w__29 ((e * (( 2 :: int)::ii))) esize result1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::
              64 Word.word) . 
           (D_set ((d + r)) w__30 \<then>
           (D_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
           (Elem_set w__31 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize result2
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
           D_set ((d + r)) w__32 \<then> return (result1, result2))))))))))))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((result1 ::
         ( 'esize::len)Word.word), (result2 :: ( 'esize::len)Word.word)) = varstup in
       return (operand1, operand2, operand3, result1, result2))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 ::
      64 Word.word), (operand2 ::  64 Word.word), (operand3 ::  64 Word.word), (result1 :: ( 'esize::len)Word.word), (result2 ::
     ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "rot"  :: "(2)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMLA_A1enc_A_txt : mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMLA_A1enc_A_txt  :: \<open>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMLA_A1enc_A_txt rot D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46604.41-46604.42'') \<then>
     execute_aarch32_instrs_VCMLA_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs rot))))))
   else
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46604.41-46604.42'') \<then>
     execute_aarch32_instrs_VCMLA_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
       regs rot)))))))\<close> 
  for  "rot"  :: "(2)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMLA_T1enc_A_txt : mword ty2 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMLA_T1enc_A_txt  :: \<open>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMLA_T1enc_A_txt rot D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     ((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46643.41-46643.42'') \<then>
     execute_aarch32_instrs_VCMLA_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs rot))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46643.41-46643.42'') \<then>
     execute_aarch32_instrs_VCMLA_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
       regs rot)))))))))\<close> 
  for  "rot"  :: "(2)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCMLA_idx_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> integer -> mword ty2 -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCMLA_idx_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCMLA_idx_Op_A_txt d__arg elements esize index1 m n regs rot = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand3 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand1,
                                                            operand2,
                                                            operand3,
                                                            result1,
                                                            result2)
     ((\<lambda> r varstup .  (let (operand1, operand2, operand3, result1, result2) = varstup in
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let operand2 = w__1 in
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (let operand3 = w__2 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (((elements div (( 2 :: int)::ii))) - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (result1, result2)
         ((\<lambda> e varstup .  (let (result1, result2) = varstup in
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element1 :: ( 'esize::len)Word.word) . 
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element2 :: ( 'esize::len)Word.word) . 
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element3 :: ( 'esize::len)Word.word) . 
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element4 :: ( 'esize::len)Word.word) . 
           (let b__0 = rot in
           (if (((b__0 = ( 0b00 ::  2 Word.word)))) then
              (Elem_read operand2 ((index1 * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 ::
                ( 'esize::len)Word.word) . 
              (let element1 = w__3 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 ::
                ( 'esize::len)Word.word) . 
              (let element2 = w__4 in
              (Elem_read operand2 ((((index1 * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let element3 = w__5 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 ::
                ( 'esize::len)Word.word) . 
              (let element4 = w__6 in
              return (element1, element2, element3, element4)))))))))))))
            else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
              (Elem_read operand2 ((((index1 * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
              (FPNeg w__7  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__8 :: ( 'esize::len)Word.word) . 
              (let element1 = w__8 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__9 :: ( 'esize::len)Word.word) . 
              (let element2 = w__9 in
              (Elem_read operand2 ((index1 * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__10 ::
                ( 'esize::len)Word.word) . 
              (let element3 = w__10 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__11 :: ( 'esize::len)Word.word) . 
              (let element4 = w__11 in
              return (element1, element2, element3, element4)))))))))))))))
            else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
              (Elem_read operand2 ((index1 * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__12 ::
                ( 'esize::len)Word.word) . 
              (FPNeg w__12  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__13 :: ( 'esize::len)Word.word) . 
              (let element1 = w__13 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__14 ::
                ( 'esize::len)Word.word) . 
              (let element2 = w__14 in
              (Elem_read operand2 ((((index1 * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__15 :: ( 'esize::len)Word.word) . 
              (FPNeg w__15  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__16 :: ( 'esize::len)Word.word) . 
              (let element3 = w__16 in
              (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__17 ::
                ( 'esize::len)Word.word) . 
              (let element4 = w__17 in
              return (element1, element2, element3, element4)))))))))))))))))
            else
              (Elem_read operand2 ((((index1 * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__18 :: ( 'esize::len)Word.word) . 
              (let element1 = w__18 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__19 :: ( 'esize::len)Word.word) . 
              (let element2 = w__19 in
              (Elem_read operand2 ((index1 * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__20 ::
                ( 'esize::len)Word.word) . 
              (FPNeg w__20  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__21 :: ( 'esize::len)Word.word) . 
              (let element3 = w__21 in
              (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__22 :: ( 'esize::len)Word.word) . 
              (let element4 = w__22 in
              return (element1, element2, element3, element4)))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::
             ( 'esize::len)Word.word), (element2 :: ( 'esize::len)Word.word), (element3 :: ( 'esize::len)Word.word), (element4 ::
             ( 'esize::len)Word.word)) = varstup in
           (let element4 = element4 in
           (let element3 = element3 in
           (let element2 = element2 in
           (let element1 = element1 in
           (Elem_read operand3 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__23 ::
             ( 'esize::len)Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
           (FPMulAdd w__23 element2 element1 w__24  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__25 ::
             ( 'esize::len)Word.word) . 
           (let result1 = w__25 in
           (Elem_read operand3 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
             :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__26 :: ( 'esize::len)Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__27 ::  64 Word.word) . 
           (FPMulAdd w__26 element4 element3 w__27  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__28 ::
             ( 'esize::len)Word.word) . 
           (let result2 = w__28 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
           (Elem_set w__29 ((e * (( 2 :: int)::ii))) esize result1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::
              64 Word.word) . 
           (D_set ((d + r)) w__30 \<then>
           (D_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
           (Elem_set w__31 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize result2
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
           D_set ((d + r)) w__32 \<then> return (result1, result2))))))))))))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((result1 ::
         ( 'esize::len)Word.word), (result2 :: ( 'esize::len)Word.word)) = varstup in
       return (operand1, operand2, operand3, result1, result2))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 ::
      64 Word.word), (operand2 ::  64 Word.word), (operand3 ::  64 Word.word), (result1 :: ( 'esize::len)Word.word), (result2 ::
     ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "rot"  :: "(2)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMLA_idx_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMLA_idx_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMLA_idx_A1enc_A_txt b__0 D rot Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint Vm) in
     (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let index1 = (Word.uint M) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 31 :: int)::ii))) \<and> True)))))) (''src/instrs32.sail:46739.64-46739.65'') \<then>
     execute_aarch32_instrs_VCMLA_idx_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs rot)))))))
   else
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 31 :: int)::ii))) \<and> True)))))) (''src/instrs32.sail:46739.64-46739.65'') \<then>
     execute_aarch32_instrs_VCMLA_idx_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       (( 0 :: int)::ii) m n regs rot)))))))\<close> 
  for  "b__0"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "rot"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCMLA_idx_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty2 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCMLA_idx_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCMLA_idx_T1enc_A_txt b__0 D rot Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     ((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint Vm) in
     (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     (let index1 = (Word.uint M) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 31 :: int)::ii))) \<and> True)))))) (''src/instrs32.sail:46779.64-46779.65'') \<then>
     execute_aarch32_instrs_VCMLA_idx_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       index1 m n regs rot)))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 31 :: int)::ii))) \<and> True)))))) (''src/instrs32.sail:46779.64-46779.65'') \<then>
     execute_aarch32_instrs_VCMLA_idx_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       (( 0 :: int)::ii) m n regs rot)))))))))\<close> 
  for  "b__0"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "rot"  :: "(2)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCADD_Op_A_txt : forall 'esize. Size 'esize => integer -> integer -> itself 'esize -> integer -> integer -> integer -> mword ty1 -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCADD_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCADD_Op_A_txt d__arg elements esize m n regs rot = (
   (let esize = (size_itself_int esize) in
   (let (d :: ii) = d__arg in
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result1 :: ( 'esize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (result2 :: ( 'esize::len)Word.word) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand1, operand2, result1, result2)
     ((\<lambda> r varstup .  (let (operand1, operand2, result1, result2) = varstup in
       (D_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (D_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let operand2 = w__1 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = (((elements div (( 2 :: int)::ii))) - (( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (result1, result2)
         ((\<lambda> e varstup .  (let (result1, result2) = varstup in
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element1 :: ( 'esize::len)Word.word) . 
           (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 esize))  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (element3 :: ( 'esize::len)Word.word) . 
           (let b__0 = rot in
           (if (((b__0 = ( 0b0 ::  1 Word.word)))) then
              (Elem_read operand2 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__2 :: ( 'esize::len)Word.word) . 
              (FPNeg w__2  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
              (let element1 = w__3 in
              (Elem_read operand2 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__4 ::
                ( 'esize::len)Word.word) . 
              (let element3 = w__4 in
              return (element1, element3)))))))))
            else
              (Elem_read operand2 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
                :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__5 :: ( 'esize::len)Word.word) . 
              (let element1 = w__5 in
              (Elem_read operand2 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__6 ::
                ( 'esize::len)Word.word) . 
              (FPNeg w__6  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__7 :: ( 'esize::len)Word.word) . 
              (let element3 = w__7 in
              return (element1, element3)))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ( 'esize::len)Word.word), (element3 ::
             ( 'esize::len)Word.word)) = varstup in
           (let element3 = element3 in
           (let element1 = element1 in
           (Elem_read operand1 ((e * (( 2 :: int)::ii))) esize  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__8 ::
             ( 'esize::len)Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
           (FPAdd w__8 element1 w__9  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__10 :: ( 'esize::len)Word.word) . 
           (let result1 = w__10 in
           (Elem_read operand1 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize
             :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__11 :: ( 'esize::len)Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
           (FPAdd w__11 element3 w__12  :: (( 'esize::len)Word.word) M) \<bind> ((\<lambda> (w__13 :: ( 'esize::len)Word.word) . 
           (let result2 = w__13 in
           (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
           (Elem_set w__14 ((e * (( 2 :: int)::ii))) esize result1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::
              64 Word.word) . 
           (D_set ((d + r)) w__15 \<then>
           (D_read ((d + r))  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
           (Elem_set w__16 ((((e * (( 2 :: int)::ii))) + (( 1 :: int)::ii))) esize result2
             :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
           D_set ((d + r)) w__17 \<then> return (result1, result2))))))))))))))))))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((result1 ::
         ( 'esize::len)Word.word), (result2 :: ( 'esize::len)Word.word)) = varstup in
       return (operand1, operand2, result1, result2)))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 ::
      64 Word.word), (operand2 ::  64 Word.word), (result1 :: ( 'esize::len)Word.word), (result2 :: ( 'esize::len)Word.word)) = varstup in
   return () )))))))))))))))))\<close> 
  for  "d__arg"  :: " int " 
  and  "elements"  :: " int " 
  and  "esize"  :: "('esize::len)itself " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "rot"  :: "(1)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCADD_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCADD_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCADD_A1enc_A_txt rot D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46852.41-46852.42'') \<then>
     execute_aarch32_instrs_VCADD_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs rot))))))
   else
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46852.41-46852.42'') \<then>
     execute_aarch32_instrs_VCADD_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
       regs rot)))))))\<close> 
  for  "rot"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCADD_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCADD_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCADD_T1enc_A_txt rot D b__0 Vn Vd N Q M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     ((if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46891.41-46891.42'') \<then>
     execute_aarch32_instrs_VCADD_Op_A_txt d elements ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m n
       regs rot))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let elements = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     (let regs = (if (((Q = ( 0b0 ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
     assert_exp True (''src/instrs32.sail:46891.41-46891.42'') \<then>
     execute_aarch32_instrs_VCADD_Op_A_txt d elements ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m n
       regs rot)))))))))\<close> 
  for  "rot"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VFMAL_Op_A_txt : forall 'datasize. Size 'datasize => mword ty1 -> integer -> itself 'datasize -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VFMAL_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>('datasize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VFMAL_Op_A_txt Q d datasize esize m n regs sub_op = (
   (let datasize = (size_itself_int datasize) in
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 datasize))  :: (( 'datasize::len)Word.word) M)) \<bind> ((\<lambda> (operand1 ::
     ( 'datasize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 datasize))  :: (( 'datasize::len)Word.word) M) \<bind> ((\<lambda> (operand2 ::
     ( 'datasize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand3 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((((id0 esize)) div (( 2 :: int)::ii)))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (element1 ::
      16 Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((((id0 esize)) div (( 2 :: int)::ii)))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (element2 ::
      16 Word.word) . 
   (if (((Q = ( 0b0 ::  1 Word.word)))) then
      assert_exp ((((((id0 datasize)) - (( 1 :: int)::ii))) < (( 32 :: int)::ii))) (''src/instrs32.sail:46922.45-46922.46'') \<then>
      ((let (operand2 ::  32 Word.word) = ((Word.ucast operand2  ::  32 Word.word)) in
      (let (operand1 ::  32 Word.word) = ((Word.ucast operand1  ::  32 Word.word)) in
      (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (let operand1 = ((slice w__0 (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) in
      (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (let operand2 = ((slice w__1 (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) in
      (let (operand2 :: ( 'datasize::len)Word.word) = ((Word.ucast operand2  :: ( 'datasize::len)Word.word)) in
      (let (operand1 :: ( 'datasize::len)Word.word) = ((Word.ucast operand1  :: ( 'datasize::len)Word.word)) in
      return (operand1, operand2))))))))))))
    else
      (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
      (let operand1 =
        ((subrange_vec_dec w__2 ((datasize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'datasize::len)Word.word)) in
      (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      (let operand2 =
        ((subrange_vec_dec w__3 ((datasize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'datasize::len)Word.word)) in
      return (operand1, operand2)))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 :: ( 'datasize::len)Word.word), (operand2 ::
     ( 'datasize::len)Word.word)) = varstup in
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (element1, element2, operand3, result)
     ((\<lambda> r varstup .  (let (element1, element2, operand3, result) = varstup in
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
       (let operand3 = w__4 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (element1, element2, result)
         ((\<lambda> e varstup .  (let (element1, element2, result) = varstup in
           (Elem_read operand1 (((((( 2 :: int)::ii) * r)) + e)) ((esize div (( 2 :: int)::ii)))
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
           (let element1 = w__5 in
           (Elem_read operand2 (((((( 2 :: int)::ii) * r)) + e)) ((esize div (( 2 :: int)::ii)))
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__6 ::  16 Word.word) . 
           (let element2 = w__6 in
           (if sub_op then (FPNeg element1  :: ( 16 Word.word) M)
            else return element1) \<bind> ((\<lambda> (element1 ::  16 Word.word) . 
           (Elem_read operand3 e esize  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__8 ::  32 Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
           (FPMulAddH w__8 element1 element2 w__9  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__10 ::  32 Word.word) . 
           (Elem_set result e esize w__10  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
           (let result = w__11 in
           return (element1, element2, result)))))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::  16 Word.word), (element2 ::
          16 Word.word), (result ::  64 Word.word)) = varstup in
       D_set ((d + r)) result \<then> return (element1, element2, operand3, result))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::
      16 Word.word), (element2 ::  16 Word.word), (operand3 ::  64 Word.word), (result ::  64 Word.word)) = varstup in
   return () ))))))))))))))))))))))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "datasize"  :: "('datasize::len)itself " 
  and  "esize"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "sub_op"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMAL_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMAL_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMAL_A1enc_A_txt S D Vn Vd N b__0 M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))))))))) (''src/instrs32.sail:46959.64-46959.65'') \<then>
     execute_aarch32_instrs_VFMAL_Op_A_txt ( 0b0 ::  1 Word.word) d
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) (( 32 :: int)::ii) m n (( 1 :: int)::ii) sub_op))))
   else
     (if (((True \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))))))))) (''src/instrs32.sail:46959.64-46959.65'') \<then>
     execute_aarch32_instrs_VFMAL_Op_A_txt ( 0b1 ::  1 Word.word) d
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 32 :: int)::ii) m n (( 2 :: int)::ii) sub_op))))))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMAL_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMAL_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMAL_T1enc_A_txt S D Vn Vd N b__0 M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))))))))) (''src/instrs32.sail:46995.64-46995.65'') \<then>
     execute_aarch32_instrs_VFMAL_Op_A_txt ( 0b0 ::  1 Word.word) d
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) (( 32 :: int)::ii) m n (( 1 :: int)::ii) sub_op)))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((True \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> ((((id0 m)) \<le> (( 31 :: int)::ii)))))))))))) (''src/instrs32.sail:46995.64-46995.65'') \<then>
     execute_aarch32_instrs_VFMAL_Op_A_txt ( 0b1 ::  1 Word.word) d
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 32 :: int)::ii) m n (( 2 :: int)::ii) sub_op))))))))\<close> 
  for  "S"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VFMAL_i_Op_A_txt : forall 'datasize. Size 'datasize => mword ty1 -> integer -> itself 'datasize -> integer -> integer -> integer -> integer -> integer -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_VFMAL_i_Op_A_txt  :: \<open>(1)Word.word \<Rightarrow> int \<Rightarrow>('datasize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VFMAL_i_Op_A_txt Q d datasize esize index1 m n regs sub_op = (
   (let datasize = (size_itself_int datasize) in
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 datasize))  :: (( 'datasize::len)Word.word) M)) \<bind> ((\<lambda> (operand1 ::
     ( 'datasize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((id0 datasize))  :: (( 'datasize::len)Word.word) M) \<bind> ((\<lambda> (operand2 ::
     ( 'datasize::len)Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand3 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ((((id0 esize)) div (( 2 :: int)::ii)))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (element1 ::
      16 Word.word) . 
   (if (((Q = ( 0b0 ::  1 Word.word)))) then
      assert_exp ((((((id0 datasize)) - (( 1 :: int)::ii))) < (( 32 :: int)::ii))) (''src/instrs32.sail:47024.45-47024.46'') \<then>
      ((let (operand2 ::  32 Word.word) = ((Word.ucast operand2  ::  32 Word.word)) in
      (let (operand1 ::  32 Word.word) = ((Word.ucast operand1  ::  32 Word.word)) in
      (S_read n  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
      (let operand1 = ((slice w__0 (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) in
      (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
      (let operand2 = ((slice w__1 (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) in
      (let (operand2 :: ( 'datasize::len)Word.word) = ((Word.ucast operand2  :: ( 'datasize::len)Word.word)) in
      (let (operand1 :: ( 'datasize::len)Word.word) = ((Word.ucast operand1  :: ( 'datasize::len)Word.word)) in
      return (operand1, operand2))))))))))))
    else
      (D_read n  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
      (let operand1 =
        ((subrange_vec_dec w__2 ((datasize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'datasize::len)Word.word)) in
      (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      (let operand2 =
        ((subrange_vec_dec w__3 ((datasize - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'datasize::len)Word.word)) in
      return (operand1, operand2)))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 :: ( 'datasize::len)Word.word), (operand2 ::
     ( 'datasize::len)Word.word)) = varstup in
   (Elem_read operand2 index1 ((esize div (( 2 :: int)::ii)))  :: ( 16 Word.word) M) \<bind> ((\<lambda> (element2 ::
      16 Word.word) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (element1, operand3, result)
     ((\<lambda> r varstup .  (let (element1, operand3, result) = varstup in
       (D_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
       (let operand3 = w__4 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (element1, result)
         ((\<lambda> e varstup .  (let (element1, result) = varstup in
           (Elem_read operand1 (((((( 2 :: int)::ii) * r)) + e)) ((esize div (( 2 :: int)::ii)))
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__5 ::  16 Word.word) . 
           (let element1 = w__5 in
           (if sub_op then (FPNeg element1  :: ( 16 Word.word) M)
            else return element1) \<bind> ((\<lambda> (element1 ::  16 Word.word) . 
           (Elem_read operand3 e esize  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__7 ::  32 Word.word) . 
           (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
           (FPMulAddH w__7 element1 element2 w__8  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__9 ::  32 Word.word) . 
           (Elem_set result e esize w__9  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
           (let result = w__10 in
           return (element1, result))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::  16 Word.word), (result ::
          64 Word.word)) = varstup in
       D_set ((d + r)) result \<then> return (element1, operand3, result))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::
      16 Word.word), (operand3 ::  64 Word.word), (result ::  64 Word.word)) = varstup in
   return () ))))))))))))))))))))))\<close> 
  for  "Q"  :: "(1)Word.word " 
  and  "d"  :: " int " 
  and  "datasize"  :: "('datasize::len)itself " 
  and  "esize"  :: " int " 
  and  "index1"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int " 
  and  "sub_op"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMAL_i_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMAL_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMAL_i_A1enc_A_txt D S Vn Vd N b__0 M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) M  ::  4 Word.word))) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))))))))) (''src/instrs32.sail:47062.89-47062.90'') \<then>
     execute_aarch32_instrs_VFMAL_i_Op_A_txt ( 0b0 ::  1 Word.word) d
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) (( 32 :: int)::ii) index1 m n (( 1 :: int)::ii) sub_op)))))
   else
     (if (((True \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
     (let index1 =
       (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))))))))) (''src/instrs32.sail:47062.89-47062.90'') \<then>
     execute_aarch32_instrs_VFMAL_i_Op_A_txt ( 0b1 ::  1 Word.word) d
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 32 :: int)::ii) index1 m n (( 2 :: int)::ii) sub_op)))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMAL_i_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMAL_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMAL_i_T1enc_A_txt D S Vn Vd N b__0 M Vm = (
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then
     InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
     (if w__0 then throw (Error_Unpredictable () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec Vn N  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) M  ::  4 Word.word))) in
     (let index1 = (Word.uint (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))))))))) (''src/instrs32.sail:47099.89-47099.90'') \<then>
     execute_aarch32_instrs_VFMAL_i_Op_A_txt ( 0b0 ::  1 Word.word) d
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) (( 32 :: int)::ii) index1 m n (( 1 :: int)::ii) sub_op))))))))
   else
     InITBlock ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     ((if w__1 then throw (Error_Unpredictable () )
      else return () ) \<then>
     (if (((True \<and> ((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))))))
      then
        throw (Error_Undefined () )
      else return () )) \<then>
     ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
     (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
     (let m = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
     (let index1 =
       (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
     (let (sub_op :: bool) = (S = ( 0b1 ::  1 Word.word)) in
     assert_exp ((((((( 0 :: int)::ii) \<le> ((id0 n)))) \<and> (((((((id0 n)) \<le> (( 31 :: int)::ii))) \<and> ((((((( 0 :: int)::ii) \<le> ((id0 m)))) \<and> (((((((id0 m)) \<le> (( 15 :: int)::ii))) \<and> ((((((((((((((id0 index1)) = (( 0 :: int)::ii)))) \<or> (((((id0 index1)) = (( 1 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 2 :: int)::ii))))))) \<or> (((((id0 index1)) = (( 3 :: int)::ii))))))))))))))))))) (''src/instrs32.sail:47099.89-47099.90'') \<then>
     execute_aarch32_instrs_VFMAL_i_Op_A_txt ( 0b1 ::  1 Word.word) d
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 32 :: int)::ii) index1 m n (( 2 :: int)::ii) sub_op)))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "S"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "b__0"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VDOT_bf16_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VDOT_bf16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VDOT_bf16_Op_A_txt d m n regs = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   CheckAdvSIMDEnabled ()  \<then>
   ((let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand1, operand2, result)
     ((\<lambda> r varstup .  (let (operand1, operand2, result) = varstup in
       (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let operand2 = w__1 in
       (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (let result = w__2 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (Elem_read operand1 (((((( 2 :: int)::ii) * e)) + (( 0 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt1_a :: 16 bits) . 
           (Elem_read operand1 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt1_b :: 16 bits) . 
           (Elem_read operand2 (((((( 2 :: int)::ii) * e)) + (( 0 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt2_a :: 16 bits) . 
           (Elem_read operand2 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt2_b :: 16 bits) . 
           (BFMul elt1_a elt2_a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
           (BFMul elt1_b elt2_b  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
           (BFAdd w__3 w__4  :: ( 32 Word.word) M) \<bind> ((\<lambda> (sum1 :: 32 bits) . 
           (Elem_read result e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
           (BFAdd w__5 sum1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__6 ::  32 Word.word) . 
           (Elem_set result e (( 32 :: int)::ii) w__6  :: ( 64 Word.word) M)))))))))))))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
       D_set ((d + r)) result \<then> return (operand1, operand2, result)))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 ::
      64 Word.word), (operand2 ::  64 Word.word), (result ::  64 Word.word)) = varstup in
   return () )))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_bf16_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_bf16_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_bf16_A1enc_A_txt D Vn Vd N Q M Vm = (
   HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_bf16_Op_A_txt d m n regs))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_bf16_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_bf16_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_bf16_T1enc_A_txt D Vn Vd N Q M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32BF16Ext () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_bf16_Op_A_txt d m n regs))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt d i m n regs = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (Din_read m  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (operand1, result)
     ((\<lambda> r varstup .  (let (operand1, result) = varstup in
       (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let result = w__1 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
         ((\<lambda> e result . 
           (Elem_read operand1 (((((( 2 :: int)::ii) * e)) + (( 0 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt1_a :: 16 bits) . 
           (Elem_read operand1 (((((( 2 :: int)::ii) * e)) + (( 1 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt1_b :: 16 bits) . 
           (Elem_read operand2 (((((( 2 :: int)::ii) * i)) + (( 0 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt2_a :: 16 bits) . 
           (Elem_read operand2 (((((( 2 :: int)::ii) * i)) + (( 1 :: int)::ii))) (( 16 :: int)::ii)
             :: ( 16 Word.word) M) \<bind> ((\<lambda> (elt2_b :: 16 bits) . 
           (BFMul elt1_a elt2_a  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__2 ::  32 Word.word) . 
           (BFMul elt1_b elt2_b  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
           (BFAdd w__2 w__3  :: ( 32 Word.word) M) \<bind> ((\<lambda> (sum1 :: 32 bits) . 
           (Elem_read result e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__4 ::  32 Word.word) . 
           (BFAdd w__4 sum1  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__5 ::  32 Word.word) . 
           (Elem_set result e (( 32 :: int)::ii) w__5  :: ( 64 Word.word) M)))))))))))))))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
       D_set ((d + r)) result \<then> return (operand1, result))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((operand1 ::
      64 Word.word), (result ::  64 Word.word)) = varstup in
   return () ))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "i"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_bf16_i_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_bf16_i_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_bf16_i_A1enc_A_txt D Vn Vd N Q M Vm = (
   HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint Vm) in
   (let i = (Word.uint M) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt d i m n regs)))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VDOT_bf16_i_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VDOT_bf16_i_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VDOT_bf16_i_T1enc_A_txt D Vn Vd N Q M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32BF16Ext () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint Vm) in
   (let i = (Word.uint M) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt d i m n regs)))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VMMLA_Op_A_txt : integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VMMLA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VMMLA_Op_A_txt d m n = (
   (CheckAdvSIMDEnabled ()  \<then>
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (op1 :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (op2 :: 128 bits) . 
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (acc1 :: 128 bits) . 
   (BFMatMulAdd acc1 op1 op2  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__0)))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMMLA_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMMLA_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMMLA_A1enc_A_txt D Vn Vd N M Vm = (
   HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let regs = ((( 2 :: int)::ii)) in
   execute_aarch32_instrs_VMMLA_Op_A_txt d m n))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VMMLA_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VMMLA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VMMLA_T1enc_A_txt D Vn Vd N M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32BF16Ext () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let regs = ((( 2 :: int)::ii)) in
   execute_aarch32_instrs_VMMLA_Op_A_txt d m n))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVT_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVT_Op_A_txt d m = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (operand :: 128 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (let (_ :: unit) = (EncodingSpecificOperations () ) in
     (CheckAdvSIMDEnabled ()  \<then>
     (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (operand :: 128 bits) . 
     (let loop_e_lower = ((( 0 :: int)::ii)) in
     (let loop_e_upper = ((( 3 :: int)::ii)) in
     (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
       ((\<lambda> e result . 
         (Elem_read operand e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (op1 :: 32 bits) . 
         (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
         (FPConvertBF__1 op1 w__1  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__2 ::  16 Word.word) . 
         (Elem_set result e (( 16 :: int)::ii) w__2  :: ( 64 Word.word) M)))))))))) \<bind> ((\<lambda> (result ::  64 Word.word) . 
     D_set d result)))))))
   else return () )))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_A1enc_A_txt D Vd M Vm = (
   HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   execute_aarch32_instrs_VCVT_Op_A_txt d m))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVT_T1enc_A_txt D Vd M Vm = (
   HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   execute_aarch32_instrs_VCVT_Op_A_txt d m))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVTB_bf16_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVTB_bf16_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVTB_bf16_Op_A_txt d m = (
   (CheckVFPEnabled True \<then>
   (S_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (FPConvertBF__1 w__1 w__2  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
   S_set d ((update_subrange_vec_dec w__0 (( 15 :: int)::ii) (( 0 :: int)::ii) w__3  ::  32 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTB_bf16_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTB_bf16_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTB_bf16_A1enc_A_txt cond D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:47433.29-47433.30'') \<then>
     HaveAArch32BF16Ext () ) \<bind> ((\<lambda> (w__1 :: bool) . 
     (if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VCVTB_bf16_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTB_bf16_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTB_bf16_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTB_bf16_T1enc_A_txt D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VCVTB_bf16_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VCVTT_Op_A_txt : integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VCVTT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VCVTT_Op_A_txt d m = (
   (CheckVFPEnabled True \<then>
   (S_read d  :: ( 32 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
   (S_read m  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__1 ::  32 Word.word) . 
   (FPSCR_read ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (FPConvertBF__1 w__1 w__2  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__3 ::  16 Word.word) . 
   S_set d ((update_subrange_vec_dec w__0 (( 31 :: int)::ii) (( 16 :: int)::ii) w__3  ::  32 Word.word)))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTT_A1enc_A_txt : mword ty4 -> mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTT_A1enc_A_txt  :: \<open>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTT_A1enc_A_txt cond D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (assert_exp (((cond \<noteq> ( 0xF ::  4 Word.word)))) (''src/instrs32.sail:47490.29-47490.30'') \<then>
     HaveAArch32BF16Ext () ) \<bind> ((\<lambda> (w__1 :: bool) . 
     (if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VCVTT_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "cond"  :: "(4)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VCVTT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VCVTT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VCVTT_T1enc_A_txt D Vd M Vm = (
   ConditionPassed ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     (if ((\<not> w__1)) then throw (Error_Undefined () )
      else return () ) \<then>
     ((let d = (Word.uint ((concat_vec Vd D  ::  5 Word.word))) in
     (let m = (Word.uint ((concat_vec Vm M  ::  5 Word.word))) in
     execute_aarch32_instrs_VCVTT_Op_A_txt d m)))))
   else return () )))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VFMA_bf_Op_A_txt : integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VFMA_bf_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VFMA_bf_Op_A_txt d elements m n sel = (
   (CheckAdvSIMDEnabled ()  \<then>
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (operand1 :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (operand2 :: 128 bits) . 
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (operand3 :: 128 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (result :: 128 bits) . 
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
     ((\<lambda> e result . 
       (Elem_read operand1 (((((( 2 :: int)::ii) * e)) + sel)) (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__0 ::
          16 Word.word) . 
       (let (element1 :: 32 bits) = ((concat_vec w__0 ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))  ::  32 Word.word)) in
       (Elem_read operand2 (((((( 2 :: int)::ii) * e)) + sel)) (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::
          16 Word.word) . 
       (let (element2 :: 32 bits) = ((concat_vec w__1 ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))  ::  32 Word.word)) in
       (Elem_read operand3 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (addend :: 32 bits) . 
       (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (FPMulAdd addend element1 element2 w__2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
       (Elem_set result e (( 32 :: int)::ii) w__3  :: ( 128 Word.word) M)))))))))))))))) \<bind> ((\<lambda> (result ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) result)))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "elements"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "sel"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_bf_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_bf_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_bf_A1enc_A_txt D Vn Vd N Q M Vm = (
   HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let elements = ((( 128 :: int)::ii) div (( 32 :: int)::ii)) in
   (let sel = (Word.uint Q) in
   execute_aarch32_instrs_VFMA_bf_Op_A_txt d elements m n sel)))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_bf_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_bf_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_bf_T1enc_A_txt D Vn Vd N Q M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32BF16Ext () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let elements = ((( 128 :: int)::ii) div (( 32 :: int)::ii)) in
   (let sel = (Word.uint Q) in
   execute_aarch32_instrs_VFMA_bf_Op_A_txt d elements m n sel)))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VFMA_bfs_Op_A_txt : integer -> integer -> integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VFMA_bfs_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VFMA_bfs_Op_A_txt d elements i m n sel = (
   (CheckAdvSIMDEnabled ()  \<then>
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (operand1 :: 128 bits) . 
   (D_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (operand3 :: 128 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> ((\<lambda> (result :: 128 bits) . 
   (Elem_read operand2 i (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__0 ::  16 Word.word) . 
   (let (element2 :: 32 bits) = ((concat_vec w__0 ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))  ::  32 Word.word)) in
   (let loop_e_lower = ((( 0 :: int)::ii)) in
   (let loop_e_upper = (elements - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) result
     ((\<lambda> e result . 
       (Elem_read operand1 (((((( 2 :: int)::ii) * e)) + sel)) (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> ((\<lambda> (w__1 ::
          16 Word.word) . 
       (let (element1 :: 32 bits) = ((concat_vec w__1 ((Zeros (( 16 :: int)::ii)  ::  16 Word.word))  ::  32 Word.word)) in
       (Elem_read operand3 e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (addend :: 32 bits) . 
       (StandardFPSCRValue ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (FPMulAdd addend element1 element2 w__2  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__3 ::  32 Word.word) . 
       (Elem_set result e (( 32 :: int)::ii) w__3  :: ( 128 Word.word) M))))))))))))) \<bind> ((\<lambda> (result ::  128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) result))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "elements"  :: " int " 
  and  "i"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "sel"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_bfs_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_bfs_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_bfs_A1enc_A_txt D Vn Vd N Q M Vm = (
   HaveAArch32BF16Ext ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
   (let i = (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
   (let elements = ((( 128 :: int)::ii) div (( 32 :: int)::ii)) in
   (let sel = (Word.uint Q) in
   execute_aarch32_instrs_VFMA_bfs_Op_A_txt d elements i m n sel))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VFMA_bfs_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VFMA_bfs_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VFMA_bfs_T1enc_A_txt D Vn Vd N Q M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32BF16Ext () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((subrange_vec_dec Vm (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))) in
   (let i = (Word.uint ((concat_vec M (vec_of_bits [access_vec_dec Vm (( 3 :: int)::ii)]  ::  1 Word.word)  ::  2 Word.word))) in
   (let elements = ((( 128 :: int)::ii) div (( 32 :: int)::ii)) in
   (let sel = (Word.uint Q) in
   execute_aarch32_instrs_VFMA_bfs_Op_A_txt d elements i m n sel))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_MMLA_Op_A_txt : integer -> integer -> integer -> bool -> bool -> M unit\<close>\<close>

definition execute_aarch32_instrs_MMLA_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_MMLA_Op_A_txt d m n op1_unsigned op2_unsigned = (
   (CheckAdvSIMDEnabled ()  \<then>
   (Q_read ((shr_int n (( 1 :: int)::ii)))  :: ( 128 Word.word) M)) \<bind> ((\<lambda> (operand1 :: 128 bits) . 
   (Q_read ((shr_int m (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (operand2 :: 128 bits) . 
   (Q_read ((shr_int d (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> ((\<lambda> (addend :: 128 bits) . 
   (MatMulAdd addend operand1 operand2 op1_unsigned op2_unsigned  :: ( 128 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      128 Word.word) . 
   Q_set ((shr_int d (( 1 :: int)::ii))) w__0)))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "op1_unsigned"  :: " bool " 
  and  "op2_unsigned"  :: " bool "


\<comment> \<open>\<open>val decode_aarch32_instrs_MMLA_A1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MMLA_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MMLA_A1enc_A_txt B D Vn Vd N M U Vm = (
   HaveAArch32Int8MatMulExt ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op1_unsigned :: bool) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2_unsigned :: bool) . 
   (let b__0 = ((concat_vec B U  ::  2 Word.word)) in
   (if (((b__0 = ( 0b00 ::  2 Word.word)))) then
      (let (op1_unsigned :: bool) = False in
      (let (op2_unsigned :: bool) = False in
      return (op1_unsigned, op2_unsigned)))
    else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
      (let (op1_unsigned :: bool) = True in
      (let (op2_unsigned :: bool) = True in
      return (op1_unsigned, op2_unsigned)))
    else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
      (let (op1_unsigned :: bool) = True in
      (let (op2_unsigned :: bool) = False in
      return (op1_unsigned, op2_unsigned)))
    else throw (Error_Undefined () )) \<bind> ((\<lambda> varstup .  (let ((op1_unsigned :: bool), (op2_unsigned ::
     bool)) = varstup in
   (let op2_unsigned = op2_unsigned in
   (let op1_unsigned = op1_unsigned in
   (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () ) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   execute_aarch32_instrs_MMLA_Op_A_txt d m n op1_unsigned op2_unsigned)))))))))))))))))\<close> 
  for  "B"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_MMLA_T1enc_A_txt : mword ty1 -> mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_MMLA_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_MMLA_T1enc_A_txt B D Vn Vd N M U Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32Int8MatMulExt () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict () ) \<bind> ((\<lambda> (op1_unsigned :: bool) . 
   undefined_bool instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (op2_unsigned :: bool) . 
   (let b__0 = ((concat_vec B U  ::  2 Word.word)) in
   (if (((b__0 = ( 0b00 ::  2 Word.word)))) then
      (let (op1_unsigned :: bool) = False in
      (let (op2_unsigned :: bool) = False in
      return (op1_unsigned, op2_unsigned)))
    else if (((b__0 = ( 0b01 ::  2 Word.word)))) then
      (let (op1_unsigned :: bool) = True in
      (let (op2_unsigned :: bool) = True in
      return (op1_unsigned, op2_unsigned)))
    else if (((b__0 = ( 0b10 ::  2 Word.word)))) then
      (let (op1_unsigned :: bool) = True in
      (let (op2_unsigned :: bool) = False in
      return (op1_unsigned, op2_unsigned)))
    else throw (Error_Undefined () )) \<bind> ((\<lambda> varstup .  (let ((op1_unsigned :: bool), (op2_unsigned ::
     bool)) = varstup in
   (let op2_unsigned = op2_unsigned in
   (let op1_unsigned = op1_unsigned in
   (if ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) then
      throw (Error_Undefined () )
    else return () ) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   execute_aarch32_instrs_MMLA_Op_A_txt d m n op1_unsigned op2_unsigned)))))))))))))))))))\<close> 
  for  "B"  :: "(1)Word.word " 
  and  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_VUSDOT_Op_A_txt : integer -> integer -> integer -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_VUSDOT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_VUSDOT_Op_A_txt d m n regs = (
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element2 :: ii) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (element1,
                                                            element2,
                                                            operand1,
                                                            operand2,
                                                            result)
     ((\<lambda> r varstup .  (let (element1, element2, operand1, operand2, result) = varstup in
       (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (Din_read ((m + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let operand2 = w__1 in
       (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
       (let result = w__2 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (element1, element2, result)
         ((\<lambda> e varstup .  (let (element1, element2, result) = varstup in
           (Elem_read result e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (res :: 32 bits) . 
           (let loop_b_lower = ((( 0 :: int)::ii)) in
           (let loop_b_upper = ((( 3 :: int)::ii)) in
           (foreachM (index_list loop_b_lower loop_b_upper (( 1 :: int)::ii)) (element1, element2, res)
             ((\<lambda> b varstup .  (let (element1, element2, res) = varstup in
               (Elem_read operand1 (((((( 4 :: int)::ii) * e)) + b)) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::
                  8 Word.word) . 
               (let element1 = (Word.uint w__3) in
               (Elem_read operand2 (((((( 4 :: int)::ii) * e)) + b)) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__4 ::
                  8 Word.word) . 
               (let element2 = (Word.sint w__4) in
               (let (res :: 32 bits) =
                 ((add_vec_int res ((element1 * element2))  ::  32 Word.word)) in
               return (element1, element2, res)))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
             ii), (res ::  32 Word.word)) = varstup in
           (Elem_set result e (( 32 :: int)::ii) res  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
           (let result = w__5 in
           return (element1, element2, result))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
         ii), (result ::  64 Word.word)) = varstup in
       D_set ((d + r)) result \<then> return (element1, element2, operand1, operand2, result))))))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::
     ii), (element2 :: ii), (operand1 ::  64 Word.word), (operand2 ::  64 Word.word), (result ::  64 Word.word)) = varstup in
   return () ))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_VUSDOT_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VUSDOT_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VUSDOT_A1enc_A_txt D Vn Vd N Q M Vm = (
   HaveAArch32Int8MatMulExt ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VUSDOT_Op_A_txt d m n regs))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_VUSDOT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_VUSDOT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_VUSDOT_T1enc_A_txt D Vn Vd N Q M Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32Int8MatMulExt () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> ((((((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec Vm (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint ((concat_vec M Vm  ::  5 Word.word))) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_VUSDOT_Op_A_txt d m n regs))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_aarch32_instrs_DOT_Op_A_txt : integer -> integer -> integer -> integer -> bool -> bool -> integer -> M unit\<close>\<close>

definition execute_aarch32_instrs_DOT_Op_A_txt  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> execute_aarch32_instrs_DOT_Op_A_txt d i m n op1_unsigned op2_unsigned regs = (
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element1 :: ii) . 
   undefined_int instance_Sail2_values_Register_Value_Armv9_types_register_value_dict ()  \<bind> ((\<lambda> (element2 :: ii) . 
   (CheckAdvSIMDEnabled ()  \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (operand1 :: 64 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Register_Value_Armv9_types_register_value_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> ((\<lambda> (result :: 64 bits) . 
   (Din_read m  :: ( 64 Word.word) M) \<bind> ((\<lambda> (operand2 :: 64 bits) . 
   (let loop_r_lower = ((( 0 :: int)::ii)) in
   (let loop_r_upper = (regs - (( 1 :: int)::ii)) in
   (foreachM (index_list loop_r_lower loop_r_upper (( 1 :: int)::ii)) (element1, element2, operand1, result)
     ((\<lambda> r varstup .  (let (element1, element2, operand1, result) = varstup in
       (Din_read ((n + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
       (let operand1 = w__0 in
       (Din_read ((d + r))  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
       (let result = w__1 in
       (let loop_e_lower = ((( 0 :: int)::ii)) in
       (let loop_e_upper = ((( 1 :: int)::ii)) in
       (foreachM (index_list loop_e_lower loop_e_upper (( 1 :: int)::ii)) (element1, element2, result)
         ((\<lambda> e varstup .  (let (element1, element2, result) = varstup in
           (Elem_read result e (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> ((\<lambda> (res :: 32 bits) . 
           (let loop_b_lower = ((( 0 :: int)::ii)) in
           (let loop_b_upper = ((( 3 :: int)::ii)) in
           (foreachM (index_list loop_b_lower loop_b_upper (( 1 :: int)::ii)) (element1, element2, res)
             ((\<lambda> b varstup .  (let (element1, element2, res) = varstup in
               (Elem_read operand1 (((((( 4 :: int)::ii) * e)) + b)) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__2 ::
                  8 Word.word) . 
               (let element1 = (asl_Int w__2 op1_unsigned) in
               (Elem_read operand2 (((((( 4 :: int)::ii) * i)) + b)) (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__3 ::
                  8 Word.word) . 
               (let element2 = (asl_Int w__3 op2_unsigned) in
               (let (res :: 32 bits) =
                 ((add_vec_int res ((element1 * element2))  ::  32 Word.word)) in
               return (element1, element2, res)))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
             ii), (res ::  32 Word.word)) = varstup in
           (Elem_set result e (( 32 :: int)::ii) res  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
           (let result = w__4 in
           return (element1, element2, result))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 :: ii), (element2 ::
         ii), (result ::  64 Word.word)) = varstup in
       D_set ((d + r)) result \<then> return (element1, element2, operand1, result)))))))))))))))) \<bind> ((\<lambda> varstup .  (let ((element1 ::
     ii), (element2 :: ii), (operand1 ::  64 Word.word), (result ::  64 Word.word)) = varstup in
   return () ))))))))))))))))\<close> 
  for  "d"  :: " int " 
  and  "i"  :: " int " 
  and  "m"  :: " int " 
  and  "n"  :: " int " 
  and  "op1_unsigned"  :: " bool " 
  and  "op2_unsigned"  :: " bool " 
  and  "regs"  :: " int "


\<comment> \<open>\<open>val decode_aarch32_instrs_DOT_A1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DOT_A1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DOT_A1enc_A_txt D Vn Vd N Q M U Vm = (
   HaveAArch32Int8MatMulExt ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let (op1_unsigned :: bool) = (U = ( 0b0 ::  1 Word.word)) in
   (let (op2_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint Vm) in
   (let i = (Word.uint M) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_DOT_Op_A_txt d i m n op1_unsigned op2_unsigned regs)))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


\<comment> \<open>\<open>val decode_aarch32_instrs_DOT_T1enc_A_txt : mword ty1 -> mword ty4 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty4 -> M unit\<close>\<close>

definition decode_aarch32_instrs_DOT_T1enc_A_txt  :: \<open>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> decode_aarch32_instrs_DOT_T1enc_A_txt D Vn Vd N Q M U Vm = (
   InITBlock ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   ((if w__0 then throw (Error_Unpredictable () )
    else return () ) \<then>
   HaveAArch32Int8MatMulExt () ) \<bind> ((\<lambda> (w__1 :: bool) . 
   ((if ((\<not> w__1)) then throw (Error_Undefined () )
    else return () ) \<then>
   (if ((((((Q = ( 0b1 ::  1 Word.word)))) \<and> (((((((vec_of_bits [access_vec_dec Vd (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec Vn (( 0 :: int)::ii)]  ::  1 Word.word) = ( 0b1 ::  1 Word.word))))))))))
    then
      throw (Error_Undefined () )
    else return () )) \<then>
   ((let (op1_unsigned :: bool) = (U = ( 0b0 ::  1 Word.word)) in
   (let (op2_unsigned :: bool) = (U = ( 0b1 ::  1 Word.word)) in
   (let d = (Word.uint ((concat_vec D Vd  ::  5 Word.word))) in
   (let n = (Word.uint ((concat_vec N Vn  ::  5 Word.word))) in
   (let m = (Word.uint Vm) in
   (let i = (Word.uint M) in
   (let regs = (if (((Q = ( 0b1 ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 1 :: int)::ii)) in
   execute_aarch32_instrs_DOT_Op_A_txt d i m n op1_unsigned op2_unsigned regs)))))))))))))\<close> 
  for  "D"  :: "(1)Word.word " 
  and  "Vn"  :: "(4)Word.word " 
  and  "Vd"  :: "(4)Word.word " 
  and  "N"  :: "(1)Word.word " 
  and  "Q"  :: "(1)Word.word " 
  and  "M"  :: "(1)Word.word " 
  and  "U"  :: "(1)Word.word " 
  and  "Vm"  :: "(4)Word.word "


end

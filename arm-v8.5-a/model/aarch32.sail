/**************************************************************************/
/* BSD 3-clause Clear License                                             */
/*                                                                        */
/* Copyright (c) 2019                                                     */
/*   Arm Limited (or its affiliates),                                     */
/*   Alasdair Armstrong,                                                  */
/*   Alastair Reid,                                                       */
/*   Thomas Bauereiss,                                                    */
/*   Peter Sewell,                                                        */
/*   Kathryn Gray,                                                        */
/*   Anthony Fox                                                          */
/*                                                                        */
/* All rights reserved.                                                   */
/*                                                                        */
/* Redistribution and use in source and binary forms, with or without     */
/* modification, are permitted (subject to the limitations in the         */
/* disclaimer below) provided that the following conditions are met:      */
/*                                                                        */
/* 	* Redistributions of source code must retain the above            */
/*        copyright notice, this list of conditions and the following     */
/* 	  disclaimer.                                                     */
/*      * Redistributions in binary form must reproduce the above         */
/*        copyright notice, this list of conditions and the following     */
/*        disclaimer in the documentation and/or other materials          */
/* 	  provided with the distribution.                                 */
/* 	* Neither the name of ARM Limited nor the names of its            */
/*        contributors may be used to endorse or promote products         */
/*        derived from this software without specific prior written       */
/*        permission.                                                     */
/*                                                                        */
/* NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE        */
/* GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT    */
/* HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED            */
/* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF   */
/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE               */
/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  */
/* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    */
/* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   */
/* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        */
/* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  */
/* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE   */
/* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN */
/* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                          */
/**************************************************************************/

register __conditionPassed : bool

register _Dclone : vector(32, dec, bits(64))

val set_VPIDR : bits(32) -> unit effect {rreg, wreg}

function set_VPIDR val_name = {
    let r : bits(32) = val_name;
    VPIDR_EL2 = __SetSlice_bits(32, 32, VPIDR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_VPIDR : unit -> bits(32) effect {rreg, undef}

function get_VPIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(VPIDR_EL2, 0, 32));
    r
}

val __UNKNOWN_VFPNegMul : unit -> VFPNegMul

function __UNKNOWN_VFPNegMul () = {
    VFPNegMul_VNMLA
}

val __UNKNOWN_VCGTtype : unit -> VCGTtype

function __UNKNOWN_VCGTtype () = {
    VCGTtype_signed
}

val __UNKNOWN_VCGEtype : unit -> VCGEtype

function __UNKNOWN_VCGEtype () = {
    VCGEtype_signed
}

val __ConfigureV81Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV81Features enabled = {
    __v81_implemented = enabled
}

val __ConfigureV82Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV82Features enabled = {
    __v82_implemented = enabled;
    if enabled then {
        __ConfigureV81Features(enabled)
    }
}

val __ConfigureV83Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV83Features enabled = {
    __v83_implemented = enabled;
    if enabled then {
        __ConfigureV82Features(enabled)
    }
}

val __ConfigureV84Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV84Features enabled = {
    __v84_implemented = enabled;
    if enabled then {
        __ConfigureV83Features(enabled)
    }
}

val __ConfigureV85Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV85Features enabled = {
    __v85_implemented = enabled;
    if enabled then {
        __ConfigureV84Features(enabled)
    }
}

val set_HTPIDR : bits(32) -> unit effect {rreg, wreg}

function set_HTPIDR val_name = {
    let r : bits(32) = val_name;
    TPIDR_EL2 = __SetSlice_bits(64, 32, TPIDR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HTPIDR : unit -> bits(32) effect {rreg, undef}

function get_HTPIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TPIDR_EL2, 0, 32));
    r
}

val set_TPIDRPRW_NS : bits(32) -> unit effect {rreg, wreg}

function set_TPIDRPRW_NS val_name = {
    let r : bits(32) = val_name;
    TPIDR_EL1 = __SetSlice_bits(64, 32, TPIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_TPIDRPRW_NS : unit -> bits(32) effect {rreg, undef}

function get_TPIDRPRW_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TPIDR_EL1, 0, 32));
    r
}

val set_TPIDRURW_NS : bits(32) -> unit effect {rreg, wreg}

function set_TPIDRURW_NS val_name = {
    let r : bits(32) = val_name;
    TPIDR_EL0 = __SetSlice_bits(64, 32, TPIDR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_TPIDRURW_NS : unit -> bits(32) effect {rreg, undef}

function get_TPIDRURW_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TPIDR_EL0, 0, 32));
    r
}

register TPIDRURW_S : bits(32)

register TPIDRURO_S : bits(32)

val set_TPIDRURO_NS : bits(32) -> unit effect {rreg, wreg}

function set_TPIDRURO_NS val_name = {
    let r : bits(32) = val_name;
    TPIDRRO_EL0 = __SetSlice_bits(64, 32, TPIDRRO_EL0, 0, slice(r, 0, 32));
    return()
}

val get_TPIDRURO_NS : unit -> bits(32) effect {rreg, undef}

function get_TPIDRURO_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TPIDRRO_EL0, 0, 32));
    r
}

register TPIDRPRW_S : bits(32)

register TCMTR : bits(32)

val __UNKNOWN_SystemAccessType : unit -> SystemAccessType

function __UNKNOWN_SystemAccessType () = {
    SystemAccessType_RT
}

val __UNKNOWN_SRType : unit -> SRType

function __UNKNOWN_SRType () = {
    SRType_LSL
}

val get_REVIDR : unit -> bits(32) effect {rreg, undef}

function get_REVIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(REVIDR_EL1, 0, 32));
    r
}

val set_PMXEVTYPER : bits(32) -> unit effect {rreg, wreg}

function set_PMXEVTYPER val_name = {
    let r : bits(32) = val_name;
    PMXEVTYPER_EL0 = __SetSlice_bits(32, 32, PMXEVTYPER_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMXEVTYPER : unit -> bits(32) effect {rreg, undef}

function get_PMXEVTYPER () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMXEVTYPER_EL0, 0, 32));
    r
}

val set_PMXEVCNTR : bits(32) -> unit effect {rreg, wreg}

function set_PMXEVCNTR val_name = {
    let r : bits(32) = val_name;
    PMXEVCNTR_EL0 = __SetSlice_bits(32, 32, PMXEVCNTR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMXEVCNTR : unit -> bits(32) effect {rreg, undef}

function get_PMXEVCNTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMXEVCNTR_EL0, 0, 32));
    r
}

val set_PMOVSSET : bits(32) -> unit effect {rreg, wreg}

function set_PMOVSSET val_name = {
    let r : bits(32) = val_name;
    PMOVSSET_EL0 = __SetSlice_bits(32, 32, PMOVSSET_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMOVSSET : unit -> bits(32) effect {rreg, undef}

function get_PMOVSSET () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMOVSSET_EL0, 0, 32));
    r
}

val set_PMOVSR : bits(32) -> unit effect {rreg, wreg}

function set_PMOVSR val_name = {
    let r : bits(32) = val_name;
    PMOVSCLR_EL0 = __SetSlice_bits(32, 32, PMOVSCLR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMOVSR : unit -> bits(32) effect {rreg, undef}

function get_PMOVSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMOVSCLR_EL0, 0, 32));
    r
}

val set_PMINTENSET : bits(32) -> unit effect {rreg, wreg}

function set_PMINTENSET val_name = {
    let r : bits(32) = val_name;
    PMINTENSET_EL1 = __SetSlice_bits(32, 32, PMINTENSET_EL1, 0, slice(r, 0, 32));
    return()
}

val get_PMINTENSET : unit -> bits(32) effect {rreg, undef}

function get_PMINTENSET () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMINTENSET_EL1, 0, 32));
    r
}

val set_PMINTENCLR : bits(32) -> unit effect {rreg, wreg}

function set_PMINTENCLR val_name = {
    let r : bits(32) = val_name;
    PMINTENCLR_EL1 = __SetSlice_bits(32, 32, PMINTENCLR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_PMINTENCLR : unit -> bits(32) effect {rreg, undef}

function get_PMINTENCLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMINTENCLR_EL1, 0, 32));
    r
}

register PMEVTYPER : vector(33, dec, bits(32))

register PMEVCNTR : vector(33, dec, bits(32))

val set_PMCNTENSET : bits(32) -> unit effect {rreg, wreg}

function set_PMCNTENSET val_name = {
    let r : bits(32) = val_name;
    PMCNTENSET_EL0 = __SetSlice_bits(32, 32, PMCNTENSET_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMCNTENSET : unit -> bits(32) effect {rreg, undef}

function get_PMCNTENSET () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCNTENSET_EL0, 0, 32));
    r
}

val set_PMCNTENCLR : bits(32) -> unit effect {rreg, wreg}

function set_PMCNTENCLR val_name = {
    let r : bits(32) = val_name;
    PMCNTENCLR_EL0 = __SetSlice_bits(32, 32, PMCNTENCLR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMCNTENCLR : unit -> bits(32) effect {rreg, undef}

function get_PMCNTENCLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCNTENCLR_EL0, 0, 32));
    r
}

val get_PMCEID3 : unit -> bits(32) effect {rreg, undef}

function get_PMCEID3 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCEID1_EL0, 32, 32));
    r
}

val get_PMCEID1 : unit -> bits(32) effect {rreg, undef}

function get_PMCEID1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCEID1_EL0, 0, 32));
    r
}

val get_PMCEID2 : unit -> bits(32) effect {rreg, undef}

function get_PMCEID2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCEID0_EL0, 32, 32));
    r
}

val get_PMCEID0 : unit -> bits(32) effect {rreg, undef}

function get_PMCEID0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCEID0_EL0, 0, 32));
    r
}

val set_PMCCNTR : bits(64) -> unit effect {rreg, wreg}

function set_PMCCNTR val_name = {
    let r : bits(64) = val_name;
    PMCCNTR_EL0 = __SetSlice_bits(64, 64, PMCCNTR_EL0, 0, slice(r, 0, 64));
    return()
}

val get_PMCCNTR : unit -> bits(64) effect {rreg, undef}

function get_PMCCNTR () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(PMCCNTR_EL0, 0, 64));
    r
}

val set_DBGOSLAR : bits(32) -> unit effect {rreg, wreg}

function set_DBGOSLAR val_name = {
    let r : bits(32) = val_name;
    OSLAR_EL1 = __SetSlice_bits(32, 32, OSLAR_EL1, 0, slice(r, 0, 32));
    return()
}

val set_DBGOSECCR : bits(32) -> unit effect {rreg, wreg}

function set_DBGOSECCR val_name = {
    let r : bits(32) = val_name;
    OSECCR_EL1 = __SetSlice_bits(32, 32, OSECCR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGOSECCR : unit -> bits(32) effect {rreg, undef}

function get_DBGOSECCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(OSECCR_EL1, 0, 32));
    r
}

val set_DBGDTRTXext : bits(32) -> unit effect {rreg, wreg}

function set_DBGDTRTXext val_name = {
    let r : bits(32) = val_name;
    OSDTRTX_EL1 = __SetSlice_bits(32, 32, OSDTRTX_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGDTRTXext : unit -> bits(32) effect {rreg, undef}

function get_DBGDTRTXext () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(OSDTRTX_EL1, 0, 32));
    r
}

val set_DBGDTRRXext : bits(32) -> unit effect {rreg, wreg}

function set_DBGDTRRXext val_name = {
    let r : bits(32) = val_name;
    OSDTRRX_EL1 = __SetSlice_bits(32, 32, OSDTRRX_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGDTRRXext : unit -> bits(32) effect {rreg, undef}

function get_DBGDTRRXext () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(OSDTRRX_EL1, 0, 32));
    r
}

val set_HMAIR1 : bits(32) -> unit effect {rreg, wreg}

function set_HMAIR1 val_name = {
    let r : bits(32) = val_name;
    MAIR_EL2 = __SetSlice_bits(64, 32, MAIR_EL2, 32, slice(r, 0, 32));
    return()
}

val set_HMAIR0 : bits(32) -> unit effect {rreg, wreg}

function set_HMAIR0 val_name = {
    let r : bits(32) = val_name;
    MAIR_EL2 = __SetSlice_bits(64, 32, MAIR_EL2, 0, slice(r, 0, 32));
    return()
}

val set_MAIR1_NS : bits(32) -> unit effect {rreg, wreg}

function set_MAIR1_NS val_name = {
    let r : bits(32) = val_name;
    MAIR_EL1 = __SetSlice_bits(64, 32, MAIR_EL1, 32, slice(r, 0, 32));
    return()
}

val set_MAIR0_NS : bits(32) -> unit effect {rreg, wreg}

function set_MAIR0_NS val_name = {
    let r : bits(32) = val_name;
    MAIR_EL1 = __SetSlice_bits(64, 32, MAIR_EL1, 0, slice(r, 0, 32));
    return()
}

register JOSCR : bits(32)

register JMCR : bits(32)

register JIDR : bits(32)

register ICV_AP1R : vector(5, dec, bits(32))

register ICV_AP0R : vector(5, dec, bits(32))

register ICH_LR : vector(9, dec, bits(32))

register ICH_AP1R : vector(5, dec, bits(32))

register ICH_AP0R : vector(5, dec, bits(32))

register ICC_AP1R : vector(5, dec, bits(32))

register ICC_AP0R : vector(5, dec, bits(32))

val Hint_PreloadInstr : bits(32) -> unit

function Hint_PreloadInstr address = {
    return()
}

val Hint_PreloadDataForWrite : bits(32) -> unit

function Hint_PreloadDataForWrite address = {
    return()
}

val Hint_PreloadData : bits(32) -> unit

function Hint_PreloadData address = {
    return()
}

val set_HACR : bits(32) -> unit effect {rreg, wreg}

function set_HACR val_name = {
    let r : bits(32) = val_name;
    HACR_EL2 = __SetSlice_bits(32, 32, HACR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HACR : unit -> bits(32) effect {rreg, undef}

function get_HACR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(HACR_EL2, 0, 32));
    r
}

val FPDecodeRM : bits(2) -> FPRounding

function FPDecodeRM rm = {
    match rm {
      0b00 => {
          return(FPRounding_TIEAWAY)
      },
      0b01 => {
          return(FPRounding_TIEEVEN)
      },
      0b10 => {
          return(FPRounding_POSINF)
      },
      0b11 => {
          return(FPRounding_NEGINF)
      }
    }
}

val get_IFAR_S : unit -> bits(32) effect {rreg, undef}

function get_IFAR_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FAR_EL2, 32, 32));
    r
}

val get_HIFAR : unit -> bits(32) effect {rreg, undef}

function get_HIFAR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FAR_EL2, 32, 32));
    r
}

val get_HDFAR : unit -> bits(32) effect {rreg, undef}

function get_HDFAR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FAR_EL2, 0, 32));
    r
}

val get_DFAR_S : unit -> bits(32) effect {rreg, undef}

function get_DFAR_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FAR_EL2, 0, 32));
    r
}

val get_IFAR_NS : unit -> bits(32) effect {rreg, undef}

function get_IFAR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FAR_EL1, 32, 32));
    r
}

val get_DFAR_NS : unit -> bits(32) effect {rreg, undef}

function get_DFAR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FAR_EL1, 0, 32));
    r
}

val get_HSR : unit -> bits(32) effect {rreg, undef}

function get_HSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ESR_EL2, 0, 32));
    r
}

val get_ELR_hyp : unit -> bits(32) effect {rreg, undef}

function get_ELR_hyp () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ELR_EL2, 0, 32));
    r
}

val PLOfEL : bits(2) -> PrivilegeLevel effect {rreg}

function PLOfEL el = {
    match el {
      ? if ? == EL3 => {
          return(if HighestELUsingAArch32() then PL1 else PL3)
      },
      ? if ? == EL2 => {
          return(PL2)
      },
      ? if ? == EL1 => {
          return(PL1)
      },
      ? if ? == EL0 => {
          return(PL0)
      }
    }
}

val DecodeRegShift : bits(2) -> SRType effect {undef}

function DecodeRegShift typ = {
    shift_t : SRType = undefined : SRType;
    match typ {
      0b00 => {
          shift_t = SRType_LSL
      },
      0b01 => {
          shift_t = SRType_LSR
      },
      0b10 => {
          shift_t = SRType_ASR
      },
      0b11 => {
          shift_t = SRType_ROR
      }
    };
    let shift_t = shift_t;
    shift_t
}

let DebugException_BKPT : bits(4) = 0x3

val DVPRCTX : bits(64) -> unit

function DVPRCTX val_name = {
    return()
}

register DTRTX : bits(32)

register DTRRX : bits(32)

val get_DLR : unit -> bits(32) effect {rreg, undef}

function get_DLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DLR_EL0, 0, 32));
    r
}

val DCCISW : bits(32) -> unit

function DCCISW val_name = {
    return()
}

val set_DBGDTRTXint : bits(32) -> unit effect {rreg, wreg}

function set_DBGDTRTXint val_name = {
    let r : bits(32) = val_name;
    DBGDTRTX_EL0 = __SetSlice_bits(32, 32, DBGDTRTX_EL0, 0, slice(r, 0, 32));
    return()
}

val get_DBGDTRRXint : unit -> bits(32) effect {rreg, undef}

function get_DBGDTRRXint () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGDTRRX_EL0, 0, 32));
    r
}

register DBGDSAR : bits(64)

register DBGDEVID : bits(32)

val set_DACR_NS : bits(32) -> unit effect {rreg, wreg}

function set_DACR_NS val_name = {
    let r : bits(32) = val_name;
    DACR32_EL2 = __SetSlice_bits(32, 32, DACR32_EL2, 0, slice(r, 0, 32));
    return()
}

val CurrentPL : unit -> PrivilegeLevel effect {rreg}

function CurrentPL () = {
    PLOfEL(PSTATE.EL)
}

val CPPRCTX : bits(64) -> unit

function CPPRCTX val_name = {
    return()
}

val CP15ISB : unit -> unit

function CP15ISB () = {
    return()
}

val CP15DSB : unit -> unit

function CP15DSB () = {
    return()
}

val CP15DMB : unit -> unit

function CP15DMB () = {
    return()
}

val set_CNTV_TVAL : bits(32) -> unit effect {rreg, wreg}

function set_CNTV_TVAL val_name = {
    let r : bits(32) = val_name;
    CNTV_TVAL_EL0 = __SetSlice_bits(32, 32, CNTV_TVAL_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CNTV_TVAL : unit -> bits(32) effect {rreg, undef}

function get_CNTV_TVAL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTV_TVAL_EL0, 0, 32));
    r
}

val set_CNTV_CVAL : bits(64) -> unit effect {rreg, wreg}

function set_CNTV_CVAL val_name = {
    let r : bits(64) = val_name;
    CNTV_CVAL_EL0 = __SetSlice_bits(64, 64, CNTV_CVAL_EL0, 0, slice(r, 0, 64));
    return()
}

val get_CNTV_CVAL : unit -> bits(64) effect {rreg, undef}

function get_CNTV_CVAL () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(CNTV_CVAL_EL0, 0, 64));
    r
}

val set_CNTVOFF : bits(64) -> unit effect {rreg, wreg}

function set_CNTVOFF val_name = {
    let r : bits(64) = val_name;
    CNTVOFF_EL2 = __SetSlice_bits(64, 64, CNTVOFF_EL2, 0, slice(r, 0, 64));
    return()
}

val get_CNTVOFF : unit -> bits(64) effect {rreg, undef}

function get_CNTVOFF () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(CNTVOFF_EL2, 0, 64));
    r
}

val get_CNTVCT : unit -> bits(64) effect {rreg, undef}

function get_CNTVCT () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(CNTVCT_EL0, 0, 64));
    r
}

register CNTP_TVAL_S : bits(32)

val set_CNTP_TVAL_NS : bits(32) -> unit effect {rreg, wreg}

function set_CNTP_TVAL_NS val_name = {
    let r : bits(32) = val_name;
    CNTP_TVAL_EL0 = __SetSlice_bits(32, 32, CNTP_TVAL_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CNTP_TVAL_NS : unit -> bits(32) effect {rreg, undef}

function get_CNTP_TVAL_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTP_TVAL_EL0, 0, 32));
    r
}

register CNTP_CVAL_S : bits(64)

val set_CNTP_CVAL_NS : bits(64) -> unit effect {rreg, wreg}

function set_CNTP_CVAL_NS val_name = {
    let r : bits(64) = val_name;
    CNTP_CVAL_EL0 = __SetSlice_bits(64, 64, CNTP_CVAL_EL0, 0, slice(r, 0, 64));
    return()
}

val get_CNTP_CVAL_NS : unit -> bits(64) effect {rreg, undef}

function get_CNTP_CVAL_NS () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(CNTP_CVAL_EL0, 0, 64));
    r
}

val get_CNTPCT : unit -> bits(64) effect {rreg, undef}

function get_CNTPCT () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(CNTPCT_EL0, 0, 64));
    r
}

val set_CNTHV_TVAL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHV_TVAL val_name = {
    let r : bits(32) = val_name;
    CNTHV_TVAL_EL2 = __SetSlice_bits(32, 32, CNTHV_TVAL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHV_TVAL : unit -> bits(32) effect {rreg, undef}

function get_CNTHV_TVAL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHV_TVAL_EL2, 0, 32));
    r
}

val set_CNTHV_CVAL : bits(64) -> unit effect {rreg, wreg}

function set_CNTHV_CVAL val_name = {
    let r : bits(64) = val_name;
    CNTHV_CVAL_EL2 = __SetSlice_bits(64, 64, CNTHV_CVAL_EL2, 0, slice(r, 0, 64));
    return()
}

val get_CNTHV_CVAL : unit -> bits(64) effect {rreg, undef}

function get_CNTHV_CVAL () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(CNTHV_CVAL_EL2, 0, 64));
    r
}

val set_CNTHP_TVAL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHP_TVAL val_name = {
    let r : bits(32) = val_name;
    CNTHP_TVAL_EL2 = __SetSlice_bits(32, 32, CNTHP_TVAL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHP_TVAL : unit -> bits(32) effect {rreg, undef}

function get_CNTHP_TVAL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHP_TVAL_EL2, 0, 32));
    r
}

val set_CNTHP_CVAL : bits(64) -> unit effect {rreg, wreg}

function set_CNTHP_CVAL val_name = {
    let r : bits(64) = val_name;
    CNTHP_CVAL_EL2 = __SetSlice_bits(64, 64, CNTHP_CVAL_EL2, 0, slice(r, 0, 64));
    return()
}

val get_CNTHP_CVAL : unit -> bits(64) effect {rreg, undef}

function get_CNTHP_CVAL () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(CNTHP_CVAL_EL2, 0, 64));
    r
}

val set_CNTFRQ : bits(32) -> unit effect {rreg, wreg}

function set_CNTFRQ val_name = {
    let r : bits(32) = val_name;
    CNTFRQ_EL0 = __SetSlice_bits(32, 32, CNTFRQ_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CNTFRQ : unit -> bits(32) effect {rreg, undef}

function get_CNTFRQ () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTFRQ_EL0, 0, 32));
    r
}

val CFPRCTX : bits(64) -> unit

function CFPRCTX val_name = {
    return()
}

val BPIMVA : bits(32) -> unit

function BPIMVA val_name = {
    return()
}

val BPIALLIS : unit -> unit

function BPIALLIS () = {
    return()
}

val BPIALL : unit -> unit

function BPIALL () = {
    return()
}

val set_HAMAIR1 : bits(32) -> unit effect {rreg, wreg}

function set_HAMAIR1 val_name = {
    let r : bits(32) = val_name;
    AMAIR_EL2 = __SetSlice_bits(64, 32, AMAIR_EL2, 32, slice(r, 0, 32));
    return()
}

val set_HAMAIR0 : bits(32) -> unit effect {rreg, wreg}

function set_HAMAIR0 val_name = {
    let r : bits(32) = val_name;
    AMAIR_EL2 = __SetSlice_bits(64, 32, AMAIR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HAMAIR1 : unit -> bits(32) effect {rreg, undef}

function get_HAMAIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AMAIR_EL2, 32, 32));
    r
}

val get_HAMAIR0 : unit -> bits(32) effect {rreg, undef}

function get_HAMAIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AMAIR_EL2, 0, 32));
    r
}

val set_AMAIR1_NS : bits(32) -> unit effect {rreg, wreg}

function set_AMAIR1_NS val_name = {
    let r : bits(32) = val_name;
    AMAIR_EL1 = __SetSlice_bits(64, 32, AMAIR_EL1, 32, slice(r, 0, 32));
    return()
}

val set_AMAIR0_NS : bits(32) -> unit effect {rreg, wreg}

function set_AMAIR0_NS val_name = {
    let r : bits(32) = val_name;
    AMAIR_EL1 = __SetSlice_bits(64, 32, AMAIR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_AMAIR1_NS : unit -> bits(32) effect {rreg, undef}

function get_AMAIR1_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AMAIR_EL1, 32, 32));
    r
}

val get_AMAIR0_NS : unit -> bits(32) effect {rreg, undef}

function get_AMAIR0_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AMAIR_EL1, 0, 32));
    r
}

register AMAIR1_S : bits(32)

register AMAIR0_S : bits(32)

register AIFSR_S : bits(32)

val get_AIDR : unit -> bits(32) effect {rreg, undef}

function get_AIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AIDR_EL1, 0, 32));
    r
}

val set_HAIFSR : bits(32) -> unit effect {rreg, wreg}

function set_HAIFSR val_name = {
    let r : bits(32) = val_name;
    AFSR1_EL2 = __SetSlice_bits(32, 32, AFSR1_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HAIFSR : unit -> bits(32) effect {rreg, undef}

function get_HAIFSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AFSR1_EL2, 0, 32));
    r
}

val set_AIFSR_NS : bits(32) -> unit effect {rreg, wreg}

function set_AIFSR_NS val_name = {
    let r : bits(32) = val_name;
    AFSR1_EL1 = __SetSlice_bits(32, 32, AFSR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_AIFSR_NS : unit -> bits(32) effect {rreg, undef}

function get_AIFSR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AFSR1_EL1, 0, 32));
    r
}

val set_HADFSR : bits(32) -> unit effect {rreg, wreg}

function set_HADFSR val_name = {
    let r : bits(32) = val_name;
    AFSR0_EL2 = __SetSlice_bits(32, 32, AFSR0_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HADFSR : unit -> bits(32) effect {rreg, undef}

function get_HADFSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AFSR0_EL2, 0, 32));
    r
}

val set_ADFSR_NS : bits(32) -> unit effect {rreg, wreg}

function set_ADFSR_NS val_name = {
    let r : bits(32) = val_name;
    AFSR0_EL1 = __SetSlice_bits(32, 32, AFSR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ADFSR_NS : unit -> bits(32) effect {rreg, undef}

function get_ADFSR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(AFSR0_EL1, 0, 32));
    r
}

register ADFSR_S : bits(32)

register ACTLR_S : bits(32)

val set_HACTLR2 : bits(32) -> unit effect {rreg, wreg}

function set_HACTLR2 val_name = {
    let r : bits(32) = val_name;
    ACTLR_EL2 = __SetSlice_bits(64, 32, ACTLR_EL2, 32, slice(r, 0, 32));
    return()
}

val set_HACTLR : bits(32) -> unit effect {rreg, wreg}

function set_HACTLR val_name = {
    let r : bits(32) = val_name;
    ACTLR_EL2 = __SetSlice_bits(64, 32, ACTLR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HACTLR2 : unit -> bits(32) effect {rreg, undef}

function get_HACTLR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ACTLR_EL2, 32, 32));
    r
}

val get_HACTLR : unit -> bits(32) effect {rreg, undef}

function get_HACTLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ACTLR_EL2, 0, 32));
    r
}

val set_ACTLR_NS : bits(32) -> unit effect {rreg, wreg}

function set_ACTLR_NS val_name = {
    let r : bits(32) = val_name;
    ACTLR_EL1 = __SetSlice_bits(64, 32, ACTLR_EL1, 0, slice(r, 0, 32));
    return()
}

val set_ACTLR2_NS : bits(32) -> unit effect {rreg, wreg}

function set_ACTLR2_NS val_name = {
    let r : bits(32) = val_name;
    ACTLR_EL1 = __SetSlice_bits(64, 32, ACTLR_EL1, 32, slice(r, 0, 32));
    return()
}

val get_ACTLR_NS : unit -> bits(32) effect {rreg, undef}

function get_ACTLR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ACTLR_EL1, 0, 32));
    r
}

val get_ACTLR2_NS : unit -> bits(32) effect {rreg, undef}

function get_ACTLR2_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ACTLR_EL1, 32, 32));
    r
}

register ACTLR2_S : bits(32)

val AArch32_MarkExclusiveVA : forall ('processorid : Int) ('size : Int).
  (bits(32), int('processorid), int('size)) -> unit

function AArch32_MarkExclusiveVA (address, processorid, size) = {
    return()
}

val AArch32_IsExclusiveVA : forall ('processorid : Int) ('size : Int).
  (bits(32), int('processorid), int('size)) -> bool

function AArch32_IsExclusiveVA (address, processorid, size) = {
    true
}

val aset_DBGDTR_EL0 : forall ('N : Int), 'N >= 0.
  bits('N) -> unit effect {escape, rreg, undef, wreg}

function aset_DBGDTR_EL0 value_name__arg = {
    value_name = value_name__arg;
    assert('N == 32 | 'N == 64);
    if [EDSCR[29]] == 0b1 then {
        value_name = undefined : bits('N)
    };
    if 'N == 64 then {
        DTRRX = slice(value_name, 32, 32)
    };
    DTRTX = slice(value_name, 0, 32);
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 29, 0b1);
    return()
}

overload DBGDTR_EL0 = {aset_DBGDTR_EL0}

val aget_DBGDTR_EL0 : forall ('N : Int).
  implicit('N) -> bits('N) effect {escape, rreg, undef, wreg}

function aget_DBGDTR_EL0 N = {
    assert('N == 32 | 'N == 64);
    result : bits('N) = undefined : bits('N);
    if [EDSCR[30]] == 0b0 then {
        result = undefined : bits('N)
    } else {
        if 'N == 64 then {
            result = __SetSlice_bits('N, 32, result, 32, DTRTX)
        };
        result = __SetSlice_bits('N, 32, result, 0, DTRRX)
    };
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 30, 0b0);
    result
}

overload DBGDTR_EL0 = {aget_DBGDTR_EL0}

val __getISET : unit -> int effect {rreg}

function __getISET () = {
    if PSTATE.nRW == 0b0 then {
        return(4)
    } else {
        return(UInt(PSTATE.T))
    }
}

val __PreExecute : forall ('pc : Int) ('len : Int).
  (int('pc), int('len), bits(32)) -> bool effect {rreg, wreg}

function __PreExecute (pc, len, instr) = {
    __currentInstrLength = len;
    __currentInstr = instr;
    __PC_changed = false;
    ShouldAdvanceIT = PSTATE.nRW == 0b1 & PSTATE.T == 0b1;
    true
}

val LastInITBlock : unit -> bool effect {rreg}

function LastInITBlock () = {
    slice(PSTATE.IT, 0, 4) == 0x8
}

val DecodeImmShift : (bits(2), bits(5)) -> (SRType, int) effect {undef}

function DecodeImmShift (typ, imm5) = {
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    match typ {
      0b00 => {
          shift_t = SRType_LSL;
          shift_n = UInt(imm5)
      },
      0b01 => {
          shift_t = SRType_LSR;
          shift_n = if imm5 == 0b00000 then 32 else UInt(imm5)
      },
      0b10 => {
          shift_t = SRType_ASR;
          shift_n = if imm5 == 0b00000 then 32 else UInt(imm5)
      },
      0b11 => {
          if imm5 == 0b00000 then {
              shift_t = SRType_RRX;
              shift_n = 1
          } else {
              shift_t = SRType_ROR;
              shift_n = UInt(imm5)
          }
      }
    };
    return((shift_t, shift_n))
}

val AArch32_PAROuterAttrs : MemoryAttributes -> bits(2) effect {undef}

function AArch32_PAROuterAttrs memattrs = {
    result : bits(2) = undefined : bits(2);
    if memattrs.typ == MemType_Device then {
        result = undefined : bits(2)
    } else {
        let outer : MemAttrHints = memattrs.outer;
        if outer.attrs == MemAttr_NC then {
            result = 0b00
        } else {
            if outer.attrs == MemAttr_WB & [outer.hints[0]] == 0b1 then {
                result = 0b01
            } else {
                if outer.attrs == MemAttr_WT & [outer.hints[0]] == 0b0 then {
                    result = 0b10
                } else {
                    if outer.attrs == MemAttr_WB & [outer.hints[0]] == 0b0 then {
                        result = 0b11
                    }
                }
            }
        }
    };
    result
}

val AArch32_PARInnerAttrs : MemoryAttributes -> bits(3) effect {undef}

function AArch32_PARInnerAttrs memattrs = {
    result : bits(3) = undefined : bits(3);
    if memattrs.typ == MemType_Device then {
        if memattrs.device == DeviceType_nGnRnE then {
            result = 0b001
        } else {
            if memattrs.device == DeviceType_nGnRE then {
                result = 0b011
            }
        }
    } else {
        let inner : MemAttrHints = memattrs.inner;
        if inner.attrs == MemAttr_NC then {
            result = 0b000
        } else {
            if inner.attrs == MemAttr_WB & [inner.hints[0]] == 0b1 then {
                result = 0b101
            } else {
                if inner.attrs == MemAttr_WT then {
                    result = 0b110
                } else {
                    if inner.attrs == MemAttr_WB & [inner.hints[0]] == 0b0 then {
                        result = 0b111
                    }
                }
            }
        }
    };
    result
}

val aget_Q : forall ('n : Int), ('n >= 0 & 'n <= 15).
  int('n) -> bits(128) effect {escape, rreg}

function aget_Q n = {
    assert(n >= 0 & n <= 15);
    _V[n]
}

overload Q = {aget_Q}

val aget_Din : forall ('n : Int), ('n >= 0 & 'n <= 31).
  int('n) -> bits(64) effect {escape, rreg}

function aget_Din n = {
    assert(n >= 0 & n <= 31);
    _Dclone[n]
}

overload Din = {aget_Din}

val __PrintConfig : (string, string, string) -> unit

function __PrintConfig (cfg, ty, value_name) = {
    prerr(cfg ++ " (" ++ ty ++ ") default = " ++ value_name ++ " \n")
}

val __ListConfig : unit -> unit

function __ListConfig () = {
    repeat {
        prerr("cpu.has_arm_v8-1=0 (bool) default = '0'\n        : Implement the ARMv8.1 Extension.\n");
        prerr("cpu.has_arm_v8-2=0 (bool) default = '0'\n        : Implement the ARMv8.2 Extension.\n");
        prerr("cpu.has_arm_v8-3=0 (bool) default = '0'\n        : Implement the ARMv8.3 Extension.\n");
        prerr("cpu.has_arm_v8-4=0 (bool) default = '0'\n        : Implement the ARMv8.4 Extension. This feature is incomplete and under development.\n");
        prerr("cpu.num_loregions=0x0 (int) default = '0x0' \n        : Number of Limited Ordering Regions implemented excluding background region (if ARM v8.1 extensions are implemented) : [0x0..0xFF]\n");
        prerr("cpu.num_loregion_descriptors=0x0 (int) default = '0x0'\n        : Number of Limited Ordering Region descriptors implemented (if ARM v8.1 extensions are implemented) : [0x0..0xFF]\n");
        prerr("cpu.PA_SIZE=0x30 (int) default = '0x30'\n        : Physical address range supported.  For ARMv8.0 and ARMv8.1 this is limited to 48 bits. : [0x20..0x34]\n");
        prerr("counter_addr=0x0 (int) default = '0x0'\n        : Address for memory-mapped system counter block.  0 means the counter is not mapped, otherwise the address must be 4KB aligned.\n");
        prerr("cpu.ext_abort_normal_cacheable_read_is_sync=1 (bool) default = '1' \n        : Synchronous reporting of normal write-back cacheable-read external aborts\n");
        prerr("cpu.ext_abort_normal_noncacheable_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of normal noncacheable-read external aborts\n");
        prerr("cpu.ext_abort_device_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of device-nGnRE read external aborts\n");
        prerr("cpu.ext_abort_so_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of device-nGnRnE read external aborts\n");
        prerr("cpu.ext_abort_so_write_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of device-nGnRnE write external aborts\n");
        prerr("cpu.ext_abort_prefetch_is_sync=1 (bool) default = '1'\n        : Behaviour of external aborts generated by normal writeback cacheable instruction fetches.\n        [0, 1], 0: asynchronous abort,  1: synchronous abort.\n");
        prerr("cpu.ext_abort_ttw_cacheable_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of TTW cacheable read external aborts\n");
        prerr("cpu.ext_abort_ttw_noncacheable_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of TTW noncacheable read external aborts\n");
        prerr("cpu.ext_abort_normal_cacheable_write_is_sync=0 (bool) default = '0'\n        : Synchronous reporting of normal write-back cacheable write external aborts\n");
        prerr("cpu.ext_abort_normal_noncacheable_write_is_sync=0 (bool) default = '0'\n        : Synchronous reporting of normal noncacheable write external aborts\n");
        prerr("cpu.ext_abort_device_write_is_sync=0 (bool) default = '0'\n        : Synchronous reporting of device-nGnRE write external aborts\n");
        prerr("cpu.unpred_tsize_aborts=0 (bool) default = '0'\n        : Behaviour when TSize is out of range.\n        [0, 1], 0: force into range. 1: translation fault, forces unpred_tsize_pamax_aborts to 1.\n");
        prerr("cpu.cpu0.enable_crc32=0x0 (int) default = '0x0'\n        : CRC32 instructions supported.\n        [0, 1], 0: CRC32 not implemented. 1: CRC32 instructions implemented.\n");
        prerr("cpu.has_pstate_pan=0x1 (int) default = '0x1' \n        : Implement the PSTATE.PAN (Privileged Access Never) control from ARMv8.1.\n        [0, 1], 0: not implemented. 1: Implemented\n");
        prerr("cpu.has_16bit_vmids=0x1 (int) default = '0x1'\n        : Implement support for 16-bit VMIDs from ARMv8.1\n        [0, 1], 0: Not enabled, 1: Implemented\n");
        prerr("cpu.has_dot_product=0x1 (int) default = '0x1' \n        : Implement the dot product (UDOT, SDOT) instructions from ARMv8.4\n        [0, 1], 0: Not implemnetd, 1: Implemnetd\n");
        prerr("cpu.has_fp16=0x1 (int) default = '0x1' \n        : Implement the half-precision floating-point data processing instructions from ARMv8.2.\n        [0, 1] 0: feature is not enabled. 1: feature is implemented\n");
        prerr("cpu.has_aarch32_hpd=0 (bool) default = '0'\n        : If true then hierarchical permission disable is supported in AArch32\n");
        prerr("cpu.has_tlb=0x1 (bool) default = '1'\n        : If true then TLB is enabled\n");
        prerr("cpu.has_trickbox=0x1 (bool) default = '1'\n        : If true then Trickbox and abort region checks are enabled\n");
        prerr("cpu.has_mpam=1 (bool) default = 0\n        : Implement the MPAM extension.\n        [0, 1] 0: FALSE, not implemented. 1: TRUE, implemented.\n");
        prerr("cpu.has_mpamhcr=1 (bool) default = 1\n        : If MPAM is implemented, also implement the MPAM virtualization features.\n        [0, 1] 0: FALSE, not implemented.  1: TRUE, implemented.\n");
        prerr("cpu.mpam_partid_max=127 (int) default = 0\n        : [0 .. 65535] Maximum MPAM PARTID supported by the implementation.");
        prerr("cpu.mpam_pmg_max=3 (int) default = 0\n        : [0 .. 255] Maximum MPAM PMG supported by the implementation.\n");
        prerr("cpu.mpam_vpmr_max=2 (int) default = 0\n        : [0 .. 7] Maximum MPAM virtual PARTID mapping register implemented.\n");
        prerr("cpu.cpu0.crypto_aes=0x2 (int) default = '0x2'\n        : AES and 128 bit PMULL instructions supported.\n        [0, 1, 2], 0: AES instruction not implemented. 1: AES instruction implemented. 2: AES plus 128bit PMULL instruction implemented\n");
        prerr("cpu.cpu0.crypto_sha1=0x1 (int) default = '0x1'\n        : SHA1 instructions supported.\n        [0, 1], 0: SHA1 not implemented. 1: SHA1 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sha256=0x1 (int) default = '0x1'\n        : SHA256 instructions supported.\n        [0, 1], 0: SHA256 not implemented. 1: SHA256 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sha512=0x0 (int) default = '0x0'\n        : SHA512 instructions supported.\n        [0, 1], 0: SHA512 not implemented. 1: SHA512 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sha3=0x0 (int) default = '0x0'\n        : SHA3 instructions supported.\n        [0, 1], 0: SHA3 not implemented. 1: SHA3 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sm3=0x0 (int) default = '0x0'\n        : SM3 instructions supported.\n        [0, 1], 0: SM3 not implemented. 1: SM3 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sm4=0x0 (int) default = '0x0'\n        : SM4 instructions supported.\n        [0, 1], 0: SM4 not implemented. 1: SM4 instructions implemented.\n")
    } until true;
    repeat {
        __PrintConfig("__trickbox_base_v8", "bits(52)", "__GetSlice_int(52, 318767104, 0)")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoWrite", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnPrefetch", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormNonCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceWrite", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__v81_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v82_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v83_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v84_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v85_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__support_52bit_pa", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__unpred_tsize_aborts", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__aa32_hpd_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crc32_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__pan_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__vmid16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__dot_product_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__fp16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_aes_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha1_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha256_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha512_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm4_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__block_bbm_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__mpam_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__mpam_has_hcr", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__tlb_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__trickbox_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mte_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mpam_partid_max", "bits(16)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_pmg_max", "bits(8)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_vpmr_max", "bits(3)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("LOG2_TAG_GRANULE", "integer", "LOG2_TAG_GRANULE_DEFAULT")
    } until true;
    repeat {
        __PrintConfig("TAG_GRANULE", "integer", "(1 << LOG2_TAG_GRANULE_DEFAULT)")
    } until true;
    repeat {
        __PrintConfig("TAG_STORE_AREA", "bits(56)", "__GetSlice_int(56, 4503599627370496, 0)")
    } until true;
    repeat {
        __PrintConfig("sp_rel_access_pc", "bits(64)", "Ones(64)")
    } until true;
    repeat {
        __PrintConfig("CFG_RVBAR", "bits(64)", "__GetSlice_int(64, 271581184, 0)")
    } until true;
    repeat {
        __PrintConfig("CFG_RMR_AA64", "bits(1)", "'1'")
    } until true;
    repeat {
        __PrintConfig("semihost_clock", "bits(64)", "__GetSlice_int(64, 0, 0)")
    } until true;
    repeat {
        __PrintConfig("__trickbox_base_v8", "bits(52)", "__GetSlice_int(52, 318767104, 0)")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoWrite", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnPrefetch", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormNonCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceWrite", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__v81_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v82_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v83_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v84_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v85_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__support_52bit_pa", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__unpred_tsize_aborts", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__aa32_hpd_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crc32_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__pan_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__vmid16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__dot_product_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__fp16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_aes_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha1_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha256_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha512_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm4_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__block_bbm_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__mpam_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__mpam_has_hcr", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__tlb_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__trickbox_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mte_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mpam_partid_max", "bits(16)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_pmg_max", "bits(8)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_vpmr_max", "bits(3)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("LOG2_TAG_GRANULE", "integer", "LOG2_TAG_GRANULE_DEFAULT")
    } until true;
    repeat {
        __PrintConfig("TAG_GRANULE", "integer", "(1 << LOG2_TAG_GRANULE_DEFAULT)")
    } until true;
    repeat {
        __PrintConfig("TAG_STORE_AREA", "bits(56)", "__GetSlice_int(56, 4503599627370496, 0)")
    } until true;
    repeat {
        __PrintConfig("sp_rel_access_pc", "bits(64)", "Ones(64)")
    } until true;
    repeat {
        __PrintConfig("CFG_RVBAR", "bits(64)", "__GetSlice_int(64, 271581184, 0)")
    } until true;
    repeat {
        __PrintConfig("CFG_RMR_AA64", "bits(1)", "'1'")
    } until true;
    repeat {
        __PrintConfig("semihost_clock", "bits(64)", "__GetSlice_int(64, 0, 0)")
    } until true;
    return()
}

val __UpdateSystemCounter : unit -> unit effect {rreg, wreg}

function __UpdateSystemCounter () = {
    if [CNTCR[0]] == 0b1 then {
        CNTCV = __GetSlice_int(64, UInt(CNTCV) + 1, 0)
    }
}

val StandardFPSCRValue : unit -> bits(32) effect {rreg}

function StandardFPSCRValue () = {
    (((0b00000 @ [FPSCR[26]]) @ 0b110000) @ [FPSCR[19]]) @ 0b0000000000000000000
}

val RRX_C : forall ('N : Int), ('N >= 0 & 'N - 1 >= 0).
  (bits('N), bits(1)) -> (bits('N), bits(1))

function RRX_C (x, carry_in) = {
    let result : bits('N) = carry_in @ slice(x, 1, 'N - 1);
    let carry_out = [x[0]];
    return((result, carry_out))
}

val AArch32_SetLSInstructionSyndrome : forall 'size 'Rt,
  ('Rt >= 0 & 'Rt <= 14 & 'size in {1, 2, 4, 8}).
  (int('size), bool, int('Rt), bool) -> unit effect {escape, rreg, undef, wreg}

function AArch32_SetLSInstructionSyndrome (size, sign_extend, Rt, acq_rel) = {
    if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
        __LSISyndrome = MakeLSInstructionSyndrome(size, sign_extend, LookUpRIndex(Rt, PSTATE.M), false, acq_rel)
    };
    return()
}

val aset_S : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(32)) -> unit effect {escape, rreg, wreg}

function aset_S (n, value_name) = {
    assert(n >= 0 & n <= 31);
    let base = n % 4 * 32;
    __tc1 : bits(128) = _V[n / 4];
    let __tc1 = __SetSlice_bits(128, 32, __tc1, base, value_name);
    _V[n / 4] = __tc1;
    return()
}

overload S = {aset_S}

val aset_D : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64)) -> unit effect {escape, rreg, wreg}

function aset_D (n, value_name) = {
    assert(n >= 0 & n <= 31);
    let base = n % 2 * 64;
    __tc1 : bits(128) = _V[n / 2];
    let __tc1 = __SetSlice_bits(128, 64, __tc1, base, value_name);
    _V[n / 2] = __tc1;
    return()
}

overload D = {aset_D}

val aget_S : forall ('n : Int), ('n >= 0 & 'n <= 31).
  int('n) -> bits(32) effect {escape, rreg}

function aget_S n = {
    assert(n >= 0 & n <= 31);
    let base : int = n % 4 * 32;
    slice(_V[n / 4], base, 32)
}

overload S = {aget_S}

val aget_Qin : forall ('n : Int), ('n >= 0 & 'n <= 15).
  int('n) -> bits(128) effect {escape, rreg}

function aget_Qin n = {
    assert(n >= 0 & n <= 15);
    Din(2 * n + 1) @ Din(2 * n)
}

overload Qin = {aget_Qin}

val aget_D : forall ('n : Int), ('n >= 0 & 'n <= 31).
  int('n) -> bits(64) effect {escape, rreg}

function aget_D n = {
    assert(n >= 0 & n <= 31);
    let base : int = n % 2 * 64;
    slice(_V[n / 2], base, 64)
}

overload D = {aget_D}

val UnsignedSat : forall ('N : Int) ('i : Int).
  (int('i), int('N)) -> bits('N) effect {undef}

function UnsignedSat (i, N) = {
    __anon1 : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (result, __anon1) = UnsignedSatQ(i, N);
    result
}

val SignedSat : forall ('N : Int) ('i : Int).
  (int('i), int('N)) -> bits('N) effect {undef}

function SignedSat (i, N) = {
    __anon1 : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (result, __anon1) = SignedSatQ(i, N);
    result
}

val TLBIMVALIS : bits(32) -> unit effect {rreg, wreg}

function TLBIMVALIS val_name = {
    _TLB_Invalidate()
}

val TLBIMVALHIS : bits(32) -> unit effect {rreg, wreg}

function TLBIMVALHIS val_name = {
    _TLB_Invalidate()
}

val TLBIMVALH : bits(32) -> unit effect {rreg, wreg}

function TLBIMVALH val_name = {
    _TLB_Invalidate()
}

val TLBIMVAL : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAL val_name = {
    _TLB_Invalidate()
}

val TLBIMVAIS : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAIS val_name = {
    _TLB_Invalidate()
}

val TLBIMVAHIS : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAHIS val_name = {
    _TLB_Invalidate()
}

val TLBIMVAH : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAH val_name = {
    _TLB_Invalidate()
}

val TLBIMVAALIS : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAALIS val_name = {
    _TLB_Invalidate()
}

val TLBIMVAAL : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAAL val_name = {
    _TLB_Invalidate()
}

val TLBIMVAAIS : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAAIS val_name = {
    _TLB_Invalidate()
}

val TLBIMVAA : bits(32) -> unit effect {rreg, wreg}

function TLBIMVAA val_name = {
    _TLB_Invalidate()
}

val TLBIMVA : bits(32) -> unit effect {rreg, wreg}

function TLBIMVA val_name = {
    _TLB_Invalidate()
}

val TLBIIPAS2LIS : bits(32) -> unit effect {rreg, wreg}

function TLBIIPAS2LIS val_name = {
    _TLB_Invalidate()
}

val TLBIIPAS2L : bits(32) -> unit effect {rreg, wreg}

function TLBIIPAS2L val_name = {
    _TLB_Invalidate()
}

val TLBIIPAS2IS : bits(32) -> unit effect {rreg, wreg}

function TLBIIPAS2IS val_name = {
    _TLB_Invalidate()
}

val TLBIIPAS2 : bits(32) -> unit effect {rreg, wreg}

function TLBIIPAS2 val_name = {
    _TLB_Invalidate()
}

val TLBIASIDIS : bits(32) -> unit effect {rreg, wreg}

function TLBIASIDIS val_name = {
    _TLB_Invalidate()
}

val TLBIASID : bits(32) -> unit effect {rreg, wreg}

function TLBIASID val_name = {
    _TLB_Invalidate()
}

val TLBIALLNSNHIS : unit -> unit effect {rreg, wreg}

function TLBIALLNSNHIS () = {
    _TLB_Invalidate()
}

val TLBIALLNSNH : unit -> unit effect {rreg, wreg}

function TLBIALLNSNH () = {
    _TLB_Invalidate()
}

val TLBIALLIS : unit -> unit effect {rreg, wreg}

function TLBIALLIS () = {
    _TLB_Invalidate()
}

val TLBIALLHIS : unit -> unit effect {rreg, wreg}

function TLBIALLHIS () = {
    _TLB_Invalidate()
}

val TLBIALLH : unit -> unit effect {rreg, wreg}

function TLBIALLH () = {
    _TLB_Invalidate()
}

val TLBIALL : unit -> unit effect {rreg, wreg}

function TLBIALL () = {
    _TLB_Invalidate()
}

val ITLBIMVA : bits(32) -> unit effect {rreg, wreg}

function ITLBIMVA val_name = {
    _TLB_Invalidate()
}

val ITLBIASID : bits(32) -> unit effect {rreg, wreg}

function ITLBIASID val_name = {
    _TLB_Invalidate()
}

val ITLBIALL : unit -> unit effect {rreg, wreg}

function ITLBIALL () = {
    _TLB_Invalidate()
}

val DTLBIMVA : bits(32) -> unit effect {rreg, wreg}

function DTLBIMVA val_name = {
    _TLB_Invalidate()
}

val DTLBIASID : bits(32) -> unit effect {rreg, wreg}

function DTLBIASID val_name = {
    _TLB_Invalidate()
}

val DTLBIALL : unit -> unit effect {rreg, wreg}

function DTLBIALL () = {
    _TLB_Invalidate()
}

val ClearLSInstructionSyndrome : unit -> unit effect {wreg}

function ClearLSInstructionSyndrome () = {
    __LSISyndrome = Zeros();
    return()
}

val __EndCycle : unit -> unit effect {configuration, rreg, undef, wreg}

function __EndCycle () = {
    repeat {
        if slice(_ScheduleIRQ, 0, 32) == 0 & ScheduledIRQ then {
            _IRQPending = true;
            ScheduledIRQ = false;
            __WakeupRequest()
        };
        if UInt(slice(_ScheduleIRQ, 0, 32)) > 0 then {
            _ScheduleIRQ = __SetSlice_bits(32, 32, _ScheduleIRQ, 0, slice(_ScheduleIRQ, 0, 32) - 1)
        }
    } until true;
    repeat {
        if slice(_ScheduleFIQ, 0, 32) == 0 & ScheduledFIQ then {
            _FIQPending = true;
            ScheduledFIQ = false;
            __WakeupRequest()
        };
        if UInt(slice(_ScheduleFIQ, 0, 32)) > 0 then {
            _ScheduleFIQ = __SetSlice_bits(32, 32, _ScheduleFIQ, 0, slice(_ScheduleFIQ, 0, 32) - 1)
        }
    } until true;
    repeat {
        ClearLSInstructionSyndrome()
    } until true;
    repeat {
        semihost_clock = semihost_clock + 1
    } until true;
    return()
}

val __CycleEnd : unit -> unit effect {configuration, rreg, undef, wreg}

function __CycleEnd () = {
    __EndCycle()
}

val __SetConfig : (string, int) -> unit effect {configuration, rreg, wreg}

function __SetConfig (arg, value_name) = {
    match () {
      () if arg == "trickbox_base" => {
          __trickbox_base_v8 = __GetSlice_int(52, value_name, 0)
      },
      () if arg == "cpu.has_arm_v8-1" => {
          __ConfigureV81Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-2" => {
          __ConfigureV82Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-3" => {
          __ConfigureV83Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-4" => {
          __ConfigureV84Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-5" => {
          __ConfigureV85Features(value_name == 1)
      },
      () if arg == "cpu.num_loregions" => {
          LORID_EL1 = __SetSlice_bits(32, 8, LORID_EL1, 0, __GetSlice_int(8, value_name, 0))
      },
      () if arg == "cpu.num_loregion_descriptors" => {
          LORID_EL1 = __SetSlice_bits(32, 8, LORID_EL1, 16, __GetSlice_int(8, value_name, 0))
      },
      () if arg == "cpu.has_pstate_pan" => {
          __pan_implemented = value_name != 0
      },
      () if arg == "cpu.has_16bit_vmids" => {
          __vmid16_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.enable_crc32" => {
          __crc32_implemented = value_name == 1
      },
      () if arg == "cpu.has_dot_product" => {
          __dot_product_implemented = value_name != 0
      },
      () if arg == "cpu.has_fp16" => {
          __fp16_implemented = value_name != 0
      },
      () if arg == "cpu.has_aarch32_hpd" => {
          __aa32_hpd_implemented = value_name == 1
      },
      () if arg == "cpu.cpu0.crypto_aes" => {
          __crypto_aes_implemented = value_name
      },
      () if arg == "cpu.cpu0.crypto_sha1" => {
          __crypto_sha1_implemented = value_name == 1
      },
      () if arg == "cpu.cpu0.crypto_sha256" => {
          __crypto_sha256_implemented = value_name == 1
      },
      () if arg == "cpu.cpu0.crypto_sha512" => {
          __crypto_sha512_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.crypto_sha3" => {
          __crypto_sha3_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.crypto_sm3" => {
          __crypto_sm3_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.crypto_sm4" => {
          __crypto_sm4_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.BBM" => {
          __block_bbm_implemented = value_name
      },
      () if arg == "cpu.PA_SIZE" => {
          __support_52bit_pa = value_name == 52
      },
      () if arg == "counter_addr" => {
          __CNTControlBase = __GetSlice_int(52, value_name, 0)
      },
      () if arg == "cpu.ext_abort_normal_cacheable_read_is_sync" => {
          __syncAbortOnReadNormCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_normal_noncacheable_read_is_sync" => {
          __syncAbortOnReadNormNonCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_device_read_is_sync" => {
          __syncAbortOnDeviceRead = value_name == 1
      },
      () if arg == "cpu.ext_abort_so_read_is_sync" => {
          __syncAbortOnSoRead = value_name == 1
      },
      () if arg == "cpu.ext_abort_so_write_is_sync" => {
          __syncAbortOnSoWrite = value_name == 1
      },
      () if arg == "cpu.ext_abort_prefetch_is_sync" => {
          __syncAbortOnPrefetch = value_name == 1
      },
      () if arg == "cpu.ext_abort_ttw_cacheable_read_is_sync" => {
          __syncAbortOnTTWCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_ttw_noncacheable_read_is_sync" => {
          __syncAbortOnTTWNonCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_normal_cacheable_write_is_sync" => {
          __syncAbortOnWriteNormCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_normal_noncacheable_write_is_sync" => {
          __syncAbortOnWriteNormNonCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_device_write_is_sync" => {
          __syncAbortOnDeviceWrite = value_name == 1
      },
      () if arg == "cpu.has_mpam" => {
          __mpam_implemented = value_name == 1
      },
      () if arg == "cpu.has_mpamhcr" => {
          __mpam_has_hcr = value_name == 1
      },
      () if arg == "cpu.mpam_partid_max" => {
          __mpam_partid_max = __GetSlice_int(16, value_name, 0)
      },
      () if arg == "cpu.mpam_pmg_max" => {
          __mpam_pmg_max = __GetSlice_int(8, value_name, 0)
      },
      () if arg == "cpu.mpam_vpmr_max" => {
          __mpam_vpmr_max = __GetSlice_int(3, value_name, 0)
      },
      () if arg == "cpu.unpred_tsize_aborts" => {
          __unpred_tsize_aborts = value_name == 1
      },
      () if arg == "cpu.cpu0.CONFIG64" => {
          CFG_RMR_AA64 = __GetSlice_int(1, value_name, 0)
      },
      () if arg == "cpu.cpu0.RVBAR" => {
          CFG_RVBAR = __GetSlice_int(64, value_name, 0)
      },
      () if arg == "cpu.has_tlb" => {
          __tlb_enabled = value_name == 1
      },
      () if arg == "cpu.has_trickbox" => {
          __trickbox_enabled = value_name == 1
      },
      () if arg == "__trickbox_base_v8" => {
          __trickbox_base_v8 = __raw_GetSlice_int(52, value_name, 0)
      },
      () if arg == "__syncAbortOnReadNormCache" => {
          __syncAbortOnReadNormCache = value_name != 0
      },
      () if arg == "__syncAbortOnReadNormNonCache" => {
          __syncAbortOnReadNormNonCache = value_name != 0
      },
      () if arg == "__syncAbortOnDeviceRead" => {
          __syncAbortOnDeviceRead = value_name != 0
      },
      () if arg == "__syncAbortOnSoRead" => {
          __syncAbortOnSoRead = value_name != 0
      },
      () if arg == "__syncAbortOnSoWrite" => {
          __syncAbortOnSoWrite = value_name != 0
      },
      () if arg == "__syncAbortOnPrefetch" => {
          __syncAbortOnPrefetch = value_name != 0
      },
      () if arg == "__syncAbortOnTTWCache" => {
          __syncAbortOnTTWCache = value_name != 0
      },
      () if arg == "__syncAbortOnTTWNonCache" => {
          __syncAbortOnTTWNonCache = value_name != 0
      },
      () if arg == "__syncAbortOnWriteNormCache" => {
          __syncAbortOnWriteNormCache = value_name != 0
      },
      () if arg == "__syncAbortOnWriteNormNonCache" => {
          __syncAbortOnWriteNormNonCache = value_name != 0
      },
      () if arg == "__syncAbortOnDeviceWrite" => {
          __syncAbortOnDeviceWrite = value_name != 0
      },
      () if arg == "__v81_implemented" => {
          __v81_implemented = value_name != 0
      },
      () if arg == "__v82_implemented" => {
          __v82_implemented = value_name != 0
      },
      () if arg == "__v83_implemented" => {
          __v83_implemented = value_name != 0
      },
      () if arg == "__v84_implemented" => {
          __v84_implemented = value_name != 0
      },
      () if arg == "__v85_implemented" => {
          __v85_implemented = value_name != 0
      },
      () if arg == "__support_52bit_pa" => {
          __support_52bit_pa = value_name != 0
      },
      () if arg == "__unpred_tsize_aborts" => {
          __unpred_tsize_aborts = value_name != 0
      },
      () if arg == "__aa32_hpd_implemented" => {
          __aa32_hpd_implemented = value_name != 0
      },
      () if arg == "__crc32_implemented" => {
          __crc32_implemented = value_name != 0
      },
      () if arg == "__pan_implemented" => {
          __pan_implemented = value_name != 0
      },
      () if arg == "__vmid16_implemented" => {
          __vmid16_implemented = value_name != 0
      },
      () if arg == "__dot_product_implemented" => {
          __dot_product_implemented = value_name != 0
      },
      () if arg == "__fp16_implemented" => {
          __fp16_implemented = value_name != 0
      },
      () if arg == "__crypto_aes_implemented" => {
          __crypto_aes_implemented = value_name
      },
      () if arg == "__crypto_sha1_implemented" => {
          __crypto_sha1_implemented = value_name != 0
      },
      () if arg == "__crypto_sha256_implemented" => {
          __crypto_sha256_implemented = value_name != 0
      },
      () if arg == "__crypto_sha512_implemented" => {
          __crypto_sha512_implemented = value_name != 0
      },
      () if arg == "__crypto_sha3_implemented" => {
          __crypto_sha3_implemented = value_name != 0
      },
      () if arg == "__crypto_sm3_implemented" => {
          __crypto_sm3_implemented = value_name != 0
      },
      () if arg == "__crypto_sm4_implemented" => {
          __crypto_sm4_implemented = value_name != 0
      },
      () if arg == "__block_bbm_implemented" => {
          __block_bbm_implemented = value_name
      },
      () if arg == "__mpam_implemented" => {
          __mpam_implemented = value_name != 0
      },
      () if arg == "__mpam_has_hcr" => {
          __mpam_has_hcr = value_name != 0
      },
      () if arg == "__tlb_enabled" => {
          __tlb_enabled = value_name != 0
      },
      () if arg == "__trickbox_enabled" => {
          __trickbox_enabled = value_name != 0
      },
      () if arg == "__mte_implemented" => {
          __mte_implemented = value_name != 0
      },
      () if arg == "__mpam_partid_max" => {
          __mpam_partid_max = __raw_GetSlice_int(16, value_name, 0)
      },
      () if arg == "__mpam_pmg_max" => {
          __mpam_pmg_max = __raw_GetSlice_int(8, value_name, 0)
      },
      () if arg == "__mpam_vpmr_max" => {
          __mpam_vpmr_max = __raw_GetSlice_int(3, value_name, 0)
      },
      () if arg == "LOG2_TAG_GRANULE" => {
          LOG2_TAG_GRANULE = value_name
      },
      () if arg == "TAG_GRANULE" => {
          TAG_GRANULE = value_name
      },
      () if arg == "TAG_STORE_AREA" => {
          TAG_STORE_AREA = __raw_GetSlice_int(56, value_name, 0)
      },
      () if arg == "sp_rel_access_pc" => {
          sp_rel_access_pc = __raw_GetSlice_int(64, value_name, 0)
      },
      () if arg == "CFG_RVBAR" => {
          CFG_RVBAR = __raw_GetSlice_int(64, value_name, 0)
      },
      () if arg == "CFG_RMR_AA64" => {
          CFG_RMR_AA64 = __raw_GetSlice_int(1, value_name, 0)
      },
      () if arg == "semihost_clock" => {
          semihost_clock = __raw_GetSlice_int(64, value_name, 0)
      },
      _ => {
          prerr("Unrecognized Config '" ++ arg ++ "' = '" ++ DecStr(value_name) ++ "'.\n")
      }
    }
}

val SETPAN_Op_A : bits(1) -> unit effect {rreg, wreg}

function SETPAN_Op_A value_name = {
    if PSTATE.EL != EL0 then {
        PSTATE.PAN = value_name
    }
}

val T32ExpandImm_C : (bits(12), bits(1)) -> (bits(32), bits(1)) effect {escape, undef}

function T32ExpandImm_C (imm12, carry_in) = {
    carry_out : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    unrotated_value : bits(32) = undefined : bits(32);
    if slice(imm12, 10, 2) == 0b00 then {
        match slice(imm12, 8, 2) {
          0b00 => {
              imm32 = ZeroExtend(slice(imm12, 0, 8), 32)
          },
          0b01 => {
              imm32 = ((0x00 @ slice(imm12, 0, 8)) @ 0x00) @ slice(imm12, 0, 8)
          },
          0b10 => {
              imm32 = ((slice(imm12, 0, 8) @ 0x00) @ slice(imm12, 0, 8)) @ 0x00
          },
          0b11 => {
              imm32 = ((slice(imm12, 0, 8) @ slice(imm12, 0, 8)) @ slice(imm12, 0, 8)) @ slice(imm12, 0, 8)
          }
        };
        carry_out = carry_in
    } else {
        unrotated_value = ZeroExtend(0b1 @ slice(imm12, 0, 7), 32);
        (imm32, carry_out) = ROR_C(unrotated_value, UInt(slice(imm12, 7, 5)))
    };
    return((imm32, carry_out))
}

val T32ExpandImm : bits(12) -> bits(32) effect {escape, rreg, undef}

function T32ExpandImm imm12 = {
    __anon1 : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, __anon1) = T32ExpandImm_C(imm12, PSTATE.C);
    imm32
}

val AArch32_PARFaultStatusSD : FaultRecord -> bits(6) effect {escape, undef}

function AArch32_PARFaultStatusSD fault = {
    let syndrome : bits(32) = AArch32_FaultStatusSD(true, fault);
    syndrome[12 .. 12] @ (syndrome[10 .. 10] @ (syndrome[0 .. 0] @ syndrome[31 .. 29]))
}

val AArch32_PARFaultStatusLD : forall ('report_domain_fault : Bool).
  (FaultRecord, bool('report_domain_fault)) -> bits(6) effect {escape, undef}

function AArch32_PARFaultStatusLD (fault, report_domain_fault) = {
    syndrome : bits(32) = undefined : bits(32);
    if fault.typ == Fault_Domain & report_domain_fault then {
        assert(fault.level == 1 | fault.level == 2);
        syndrome = __SetSlice_bits(32, 2, syndrome, 0, if fault.level == 1 then 0b01 else 0b10);
        syndrome = __SetSlice_bits(32, 4, syndrome, 2, 0xF)
    } else {
        syndrome = AArch32_FaultStatusLD(true, fault)
    };
    slice(syndrome, 0, 6)
}

val AArch32_DecodeSysRegAccess : bits(32) -> (SystemAccessType, int, int, int, int, int, bool) effect {undef}

function AArch32_DecodeSysRegAccess instr = {
    let cp_num = UInt(slice(instr, 8, 4));
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    op : SystemAccessType = undefined : SystemAccessType;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    write : bool = undefined : bool;
    if (slice(instr, 28, 4) != 0xF & slice(instr, 24, 4) == 0xE) & [instr[4]] == 0b1 then {
        op = SystemAccessType_RT;
        opc1 = UInt(slice(instr, 21, 3));
        opc2 = UInt(slice(instr, 5, 3));
        CRn = UInt(slice(instr, 16, 4));
        CRm = UInt(slice(instr, 0, 4));
        write = [instr[20]] == 0b0
    } else {
        if slice(instr, 28, 4) != 0xF & slice(instr, 21, 7) == 0b1100010 then {
            op = SystemAccessType_RRT;
            opc1 = UInt(slice(instr, 4, 4));
            CRm = UInt(slice(instr, 0, 4));
            write = [instr[20]] == 0b0
        } else {
            if slice(instr, 28, 4) != 0xF & slice(instr, 25, 3) == 0b110 then {
                op = SystemAccessType_DT;
                CRn = UInt(slice(instr, 12, 4));
                write = [instr[20]] == 0b0
            }
        }
    };
    return((op, cp_num, opc1, CRn, CRm, opc2, write))
}

val __PreFetch : forall ('pc : Int).
  int('pc) -> bool effect {escape, rreg, undef, wreg}

function __PreFetch pc = {
    interrupt_req : InterruptReq = undefined : InterruptReq;
    interrupt_req.take_SE = true;
    interrupt_req.take_vSE = true;
    interrupt_req.take_IRQ = true;
    interrupt_req.take_vIRQ = true;
    interrupt_req.take_FIQ = true;
    interrupt_req.take_vFIQ = true;
    let interrupt_taken : bool = TakePendingInterrupts(interrupt_req);
    let fetch : bool = ~(interrupt_taken);
    BTypeCompatible = false;
    fetch
}

val SPSRWriteByInstr : (bits(32), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SPSRWriteByInstr (value_name, bytemask) = {
    new_spsr : bits(32) = undefined : bits(32);
    new_spsr = SPSR();
    if [bytemask[3]] == 0b1 then {
        new_spsr = __SetSlice_bits(32, 8, new_spsr, 24, slice(value_name, 24, 8))
    };
    if [bytemask[2]] == 0b1 then {
        new_spsr = __SetSlice_bits(32, 8, new_spsr, 16, slice(value_name, 16, 8))
    };
    if [bytemask[1]] == 0b1 then {
        new_spsr = __SetSlice_bits(32, 8, new_spsr, 8, slice(value_name, 8, 8))
    };
    if [bytemask[0]] == 0b1 then {
        new_spsr = __SetSlice_bits(32, 8, new_spsr, 0, slice(value_name, 0, 8))
    };
    SPSR() = new_spsr;
    return()
}

val SelectInstrSet : InstrSet -> unit effect {escape, rreg, undef, wreg}

function SelectInstrSet iset = {
    assert(CurrentInstrSet() == InstrSet_A32 | CurrentInstrSet() == InstrSet_T32);
    assert(iset == InstrSet_A32 | iset == InstrSet_T32);
    PSTATE.T = if iset == InstrSet_A32 then 0b0 else 0b1;
    return()
}

val InITBlock : unit -> bool effect {escape, rreg, undef}

function InITBlock () = {
    if CurrentInstrSet() == InstrSet_T32 then {
        return(slice(PSTATE.IT, 0, 4) != 0x0)
    } else {
        return(false)
    }
}

val AArch32_SysRegReadCanWriteAPSR : forall ('cp_num : Int), 'cp_num in {14, 15}.
  (int('cp_num), bits(32)) -> bool effect {escape, rreg}

function AArch32_SysRegReadCanWriteAPSR (cp_num, instr) = {
    assert(UsingAArch32());
    assert(cp_num == 14 | cp_num == 15);
    assert(cp_num == UInt(slice(instr, 8, 4)));
    let opc1 = UInt(slice(instr, 21, 3));
    let opc2 = UInt(slice(instr, 5, 3));
    let CRn = UInt(slice(instr, 16, 4));
    let CRm = UInt(slice(instr, 0, 4));
    if (((cp_num == 14 & opc1 == 0) & CRn == 0) & CRm == 1) & opc2 == 0 then {
        return(true)
    };
    false
}

val Shift_C : forall 'N 'amount,
  'N >= 0 & ('N - 1 >= 0 | not(not('amount == 0))).
  (bits('N), SRType, int('amount), bits(1)) -> (bits('N), bits(1)) effect {escape, undef}

function Shift_C (value_name, typ, amount, carry_in) = {
    assert(~(typ == SRType_RRX & amount != 1));
    carry_out : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if amount == 0 then {
        (result, carry_out) = (value_name, carry_in)
    } else {
        match typ {
          SRType_LSL => {
              (result, carry_out) = LSL_C(value_name, amount)
          },
          SRType_LSR => {
              (result, carry_out) = LSR_C(value_name, amount)
          },
          SRType_ASR => {
              (result, carry_out) = ASR_C(value_name, amount)
          },
          SRType_ROR => {
              (result, carry_out) = ROR_C(value_name, amount)
          },
          SRType_RRX => {
              (result, carry_out) = RRX_C(value_name, carry_in)
          }
        }
    };
    return((result, carry_out))
}

val Shift : forall 'N 'amount,
  'N >= 0 & ('N - 1 >= 0 | not(not('amount == 0))).
  (bits('N), SRType, int('amount), bits(1)) -> bits('N) effect {escape, undef}

function Shift (value_name, typ, amount, carry_in) = {
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    (result, __anon1) = Shift_C(value_name, typ, amount, carry_in);
    result
}

val A32ExpandImm_C : (bits(12), bits(1)) -> (bits(32), bits(1)) effect {escape, undef}

function A32ExpandImm_C (imm12, carry_in) = {
    let unrotated_value = ZeroExtend(slice(imm12, 0, 8), 32);
    carry_out : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry_out) = Shift_C(unrotated_value, SRType_ROR, 2 * UInt(slice(imm12, 8, 4)), carry_in);
    return((imm32, carry_out))
}

val A32ExpandImm : bits(12) -> bits(32) effect {escape, rreg, undef}

function A32ExpandImm imm12 = {
    __anon1 : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, __anon1) = A32ExpandImm_C(imm12, PSTATE.C);
    imm32
}

val SPSRaccessValid : (bits(5), bits(5)) -> unit effect {escape, rreg, undef}

function SPSRaccessValid (SYSm, mode) = {
    match SYSm {
      0b01110 => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          }
      },
      0b10000 => {
          if mode == M32_IRQ then {
              throw(Error_Unpredictable())
          }
      },
      0b10010 => {
          if mode == M32_Svc then {
              throw(Error_Unpredictable())
          }
      },
      0b10100 => {
          if mode == M32_Abort then {
              throw(Error_Unpredictable())
          }
      },
      0b10110 => {
          if mode == M32_Undef then {
              throw(Error_Unpredictable())
          }
      },
      0b11100 => {
          if (~(HaveEL(EL3)) | mode == M32_Monitor) | ~(IsSecure()) then {
              throw(Error_Unpredictable())
          }
      },
      0b11110 => {
          if ~(HaveEL(EL2)) | mode != M32_Monitor then {
              throw(Error_Unpredictable())
          }
      },
      _ => {
          throw(Error_Unpredictable())
      }
    };
    return()
}

val FPRecipStep : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRecipStep (op1, op2) = {
    assert('N == 16 | 'N == 32);
    let fpcr = StandardFPSCRValue();
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        product : bits('N) = undefined : bits('N);
        if inf1 & zero2 | zero1 & inf2 then {
            product = FPZero(0b0)
        } else {
            product = FPMul(op1, op2, fpcr)
        };
        let two : bits('N) = FPTwo(0b0);
        result = FPSub(two, product, fpcr)
    };
    result
}

val FPHalvedSub : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPHalvedSub (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding = FPRoundingMode(fpcr);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    result_sign : bits(1) = undefined : bits(1);
    result_value : real = undefined : real;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == sign2 then {
            result = FPDefaultNaN();
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b1 then {
                result = FPInfinity(0b0)
            } else {
                if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b0 then {
                    result = FPInfinity(0b1)
                } else {
                    if (zero1 & zero2) & sign1 != sign2 then {
                        result = FPZero(sign1)
                    } else {
                        result_value = (value1_name - value2_name) / 2.0;
                        if result_value == 0.0 then {
                            result_sign = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                            result = FPZero(result_sign)
                        } else {
                            result = FPRound(result_value, fpcr)
                        }
                    }
                }
            }
        }
    };
    result
}

val FPRSqrtStep : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRSqrtStep (op1, op2) = {
    assert('N == 16 | 'N == 32);
    let fpcr = StandardFPSCRValue();
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        product : bits('N) = undefined : bits('N);
        if inf1 & zero2 | zero1 & inf2 then {
            product = FPZero(0b0)
        } else {
            product = FPMul(op1, op2, fpcr)
        };
        let three : bits('N) = FPThree(0b0);
        result = FPHalvedSub(three, product, fpcr)
    };
    result
}

val set_CONTEXTIDR_NS : bits(32) -> unit effect {rreg, wreg}

function set_CONTEXTIDR_NS val_name = {
    let r : bits(32) = val_name;
    CONTEXTIDR_EL1 = __SetSlice_bits(32, 32, CONTEXTIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val HLT_Op_A : unit -> unit effect {escape, rreg, undef, wreg}

function HLT_Op_A () = {
    Halt(DebugHalt_HaltInstruction)
}

val AArch32_AutoGen_SysRegWrite64 : (bits(2), bits(4), bits(4), bits(4), bits(1), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_AutoGen_SysRegWrite64 (el, coproc, opc1, CRm, read, val_name) = {
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    if coproc == 0xF then {
        if CRm == 0xE then {
            if opc1 == 0x4 then {
                set_CNTVOFF(val_name)
            } else {
                if opc1 == 0x6 then {
                    set_CNTHP_CVAL(val_name)
                } else {
                    if opc1 == 0x3 then {
                        if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            set_CNTHV_CVAL(val_name)
                        } else {
                            set_CNTV_CVAL(val_name)
                        }
                    } else {
                        if opc1 == 0x2 then {
                            if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                CNTP_CVAL_S = val_name
                            } else {
                                if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                    set_CNTHP_CVAL(val_name)
                                } else {
                                    set_CNTP_CVAL_NS(val_name)
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRm == 0x2 then {
                if opc1 == 0x1 then {
                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                        TTBR1_S = val_name
                    } else {
                        set_TTBR1_NS(val_name)
                    }
                } else {
                    if opc1 == 0x4 then {
                        set_HTTBR(val_name)
                    } else {
                        if opc1 == 0x6 then {
                            set_VTTBR(val_name)
                        } else {
                            if opc1 == 0x0 then {
                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    TTBR0_S = val_name
                                } else {
                                    set_TTBR0_NS(val_name)
                                }
                            }
                        }
                    }
                }
            } else {
                if opc1 == 0x0 then {
                    if CRm == 0xC then {
                        set_ICC_SGI1R(val_name)
                    } else {
                        if CRm == 0x7 then {
                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                PAR_S = val_name
                            } else {
                                set_PAR_NS(val_name)
                            }
                        } else {
                            if CRm == 0x9 then {
                                set_PMCCNTR(val_name)
                            }
                        }
                    }
                } else {
                    if CRm == 0xC then {
                        if opc1 == 0x1 then {
                            set_ICC_ASGI1R(val_name)
                        } else {
                            if opc1 == 0x2 then {
                                set_ICC_SGI0R(val_name)
                            }
                        }
                    }
                }
            }
        }
    }
}

val AArch32_AutoGen_SysRegRead64 : (bits(2), bits(4), bits(4), bits(4), bits(1)) -> bits(64) effect {escape, rreg, undef}

function AArch32_AutoGen_SysRegRead64 (el, coproc, opc1, CRm, read) = {
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    if coproc == 0xF then {
        if CRm == 0xE then {
            if opc1 == 0x1 then {
                return(get_CNTVCT())
            } else {
                if opc1 == 0x4 then {
                    return(get_CNTVOFF())
                } else {
                    if opc1 == 0x6 then {
                        return(get_CNTHP_CVAL())
                    } else {
                        if opc1 == 0x3 then {
                            if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(get_CNTHV_CVAL())
                            } else {
                                return(get_CNTV_CVAL())
                            }
                        } else {
                            if opc1 == 0x2 then {
                                if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    return(CNTP_CVAL_S)
                                } else {
                                    if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                        return(get_CNTHP_CVAL())
                                    } else {
                                        return(get_CNTP_CVAL_NS())
                                    }
                                }
                            } else {
                                if opc1 == 0x0 then {
                                    return(get_CNTPCT())
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRm == 0x2 then {
                if opc1 == 0x1 then {
                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                        return(TTBR1_S)
                    } else {
                        return(get_TTBR1_NS())
                    }
                } else {
                    if opc1 == 0x4 then {
                        return(get_HTTBR())
                    } else {
                        if opc1 == 0x6 then {
                            return(get_VTTBR())
                        } else {
                            if opc1 == 0x0 then {
                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    return(TTBR0_S)
                                } else {
                                    return(get_TTBR0_NS())
                                }
                            }
                        }
                    }
                }
            } else {
                if opc1 == 0x0 then {
                    if CRm == 0x7 then {
                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                            return(PAR_S)
                        } else {
                            return(get_PAR_NS())
                        }
                    } else {
                        if CRm == 0x9 then {
                            return(get_PMCCNTR())
                        }
                    }
                }
            }
        }
    } else {
        if coproc == 0xE then {
            if opc1 == 0x0 then {
                if CRm == 0x2 then {
                    return(DBGDSAR)
                } else {
                    if CRm == 0x1 then {
                        return(get_DBGDRAR())
                    }
                }
            }
        }
    };
    undefined : bits(64)
}

val AArch32_CheckSETENDEnabled : unit -> unit effect {escape, rreg, undef}

function AArch32_CheckSETENDEnabled () = {
    setend_disabled : bits(1) = undefined : bits(1);
    if PSTATE.EL == EL2 then {
        setend_disabled = [get_HSCTLR()[8]]
    } else {
        setend_disabled = if ELUsingAArch32(EL1) then [get_SCTLR()[8]] else [SCTLR()[8]]
    };
    if setend_disabled == 0b1 then {
        throw(Error_Undefined())
    };
    return()
}

val SETEND_Op_A : forall ('set_bigend : Bool).
  bool('set_bigend) -> unit effect {escape, rreg, undef, wreg}

function SETEND_Op_A set_bigend = {
    AArch32_CheckSETENDEnabled();
    PSTATE.E = if set_bigend then 0b1 else 0b0
}

val aget_CNTKCTL : unit -> bits(32) effect {escape, rreg, undef}

function aget_CNTKCTL () = {
    r : bits(32) = undefined : bits(32);
    if IsInHost() then {
        r = CNTHCTL_EL2;
        return(r)
    };
    let r = CNTKCTL_EL1;
    r
}

overload CNTKCTL = {aget_CNTKCTL}

val __PostExecute : forall ('pc : Int) ('len : Int) ('ok : Bool).
  (int('pc), int('len), bits(32), bool('ok)) -> bool effect {escape, rreg, undef, wreg}

function __PostExecute (pc, len, instr, ok) = {
    InGuardedPage = false;
    PSTATE.BTYPE = BTypeNext;
    if ~(__PC_changed) then {
        _PC = __GetSlice_int(64, pc + len, 0)
    };
    if ShouldAdvanceIT then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    __UpdateSystemCounter();
    ok
}

val AArch64_AArch32SystemAccessTrapSyndrome : bits(32) -> ExceptionRecord effect {escape, rreg, undef}

function AArch64_AArch32SystemAccessTrapSyndrome instr = {
    exception : ExceptionRecord = undefined : ExceptionRecord;
    let cpnum : int = UInt(slice(instr, 8, 4));
    iss : bits(20) = Zeros();
    if (slice(instr, 24, 4) == 0xE & [instr[4]] == 0b1) & slice(instr, 28, 4) != 0xF then {
        match cpnum {
          10 => {
              exception = ExceptionSyndrome(Exception_FPIDTrap)
          },
          14 => {
              exception = ExceptionSyndrome(Exception_CP14RTTrap)
          },
          15 => {
              exception = ExceptionSyndrome(Exception_CP15RTTrap)
          },
          _ => {
              Unreachable()
          }
        };
        iss = __SetSlice_bits(20, 3, iss, 17, slice(instr, 5, 3));
        iss = __SetSlice_bits(20, 3, iss, 14, slice(instr, 21, 3));
        iss = __SetSlice_bits(20, 4, iss, 10, slice(instr, 16, 4));
        if [instr[20]] == 0b1 & slice(instr, 12, 4) == 0xF then {
            iss = __SetSlice_bits(20, 5, iss, 5, 0b11111)
        } else {
            if [instr[20]] == 0b0 & slice(instr, 12, 4) == 0xF then {
                iss = __SetSlice_bits(20, 5, iss, 5, undefined : bits(5))
            } else {
                iss = __SetSlice_bits(20, 5, iss, 5, __GetSlice_int(5, LookUpRIndex(UInt(slice(instr, 12, 4)), PSTATE.M), 0))
            }
        };
        iss = __SetSlice_bits(20, 4, iss, 1, slice(instr, 0, 4))
    } else {
        if slice(instr, 21, 7) == 0b1100010 & slice(instr, 28, 4) != 0xF then {
            match cpnum {
              14 => {
                  exception = ExceptionSyndrome(Exception_CP14RRTTrap)
              },
              15 => {
                  exception = ExceptionSyndrome(Exception_CP15RRTTrap)
              },
              _ => {
                  Unreachable()
              }
            };
            iss = __SetSlice_bits(20, 4, iss, 16, slice(instr, 4, 4));
            if slice(instr, 16, 4) == 0xF then {
                iss = __SetSlice_bits(20, 5, iss, 10, undefined : bits(5))
            } else {
                iss = __SetSlice_bits(20, 5, iss, 10, __GetSlice_int(5, LookUpRIndex(UInt(slice(instr, 16, 4)), PSTATE.M), 0))
            };
            if slice(instr, 12, 4) == 0xF then {
                iss = __SetSlice_bits(20, 5, iss, 5, undefined : bits(5))
            } else {
                iss = __SetSlice_bits(20, 5, iss, 5, __GetSlice_int(5, LookUpRIndex(UInt(slice(instr, 12, 4)), PSTATE.M), 0))
            };
            iss = __SetSlice_bits(20, 4, iss, 1, slice(instr, 0, 4))
        } else {
            if slice(instr, 25, 3) == 0b110 & slice(instr, 28, 4) != 0xF then {
                assert(cpnum == 14);
                exception = ExceptionSyndrome(Exception_CP14DTTrap);
                iss = __SetSlice_bits(20, 8, iss, 12, slice(instr, 0, 8));
                iss = __SetSlice_bits(20, 1, iss, 4, [instr[23]]);
                iss = __SetSlice_bits(20, 2, iss, 1, instr[24 .. 24] @ instr[21 .. 21]);
                if slice(instr, 16, 4) == 0xF then {
                    iss = __SetSlice_bits(20, 5, iss, 5, undefined : bits(5));
                    iss = __SetSlice_bits(20, 1, iss, 3, 0b1)
                } else {
                    iss = __SetSlice_bits(20, 5, iss, 5, __GetSlice_int(5, LookUpRIndex(UInt(slice(instr, 16, 4)), PSTATE.M), 0));
                    iss = __SetSlice_bits(20, 1, iss, 3, 0b0)
                }
            } else {
                Unreachable()
            }
        }
    };
    let iss = __SetSlice_bits(20, 1, iss, 0, [instr[20]]);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 20, __tc2, 0, iss);
    exception.syndrome = __tc2;
    exception
}

val AArch32_AArch32SystemAccessTrapSyndrome : bits(32) -> ExceptionRecord effect {escape, rreg, undef}

function AArch32_AArch32SystemAccessTrapSyndrome instr = {
    exception : ExceptionRecord = undefined : ExceptionRecord;
    let cpnum = UInt(slice(instr, 8, 4));
    iss : bits(20) = Zeros();
    if (slice(instr, 24, 4) == 0xE & [instr[4]] == 0b1) & slice(instr, 28, 4) != 0xF then {
        match cpnum {
          10 => {
              exception = ExceptionSyndrome(Exception_FPIDTrap)
          },
          14 => {
              exception = ExceptionSyndrome(Exception_CP14RTTrap)
          },
          15 => {
              exception = ExceptionSyndrome(Exception_CP15RTTrap)
          },
          _ => {
              Unreachable()
          }
        };
        iss = __SetSlice_bits(20, 3, iss, 17, slice(instr, 5, 3));
        iss = __SetSlice_bits(20, 3, iss, 14, slice(instr, 21, 3));
        iss = __SetSlice_bits(20, 4, iss, 10, slice(instr, 16, 4));
        iss = __SetSlice_bits(20, 4, iss, 5, slice(instr, 12, 4));
        iss = __SetSlice_bits(20, 4, iss, 1, slice(instr, 0, 4))
    } else {
        if slice(instr, 21, 7) == 0b1100010 & slice(instr, 28, 4) != 0xF then {
            match cpnum {
              14 => {
                  exception = ExceptionSyndrome(Exception_CP14RRTTrap)
              },
              15 => {
                  exception = ExceptionSyndrome(Exception_CP15RRTTrap)
              },
              _ => {
                  Unreachable()
              }
            };
            iss = __SetSlice_bits(20, 4, iss, 16, slice(instr, 4, 4));
            iss = __SetSlice_bits(20, 4, iss, 10, slice(instr, 16, 4));
            iss = __SetSlice_bits(20, 4, iss, 5, slice(instr, 12, 4));
            iss = __SetSlice_bits(20, 4, iss, 1, slice(instr, 0, 4))
        } else {
            if slice(instr, 25, 3) == 0b110 & slice(instr, 28, 4) != 0xF then {
                assert(cpnum == 14);
                exception = ExceptionSyndrome(Exception_CP14DTTrap);
                iss = __SetSlice_bits(20, 8, iss, 12, slice(instr, 0, 8));
                iss = __SetSlice_bits(20, 1, iss, 4, [instr[23]]);
                iss = __SetSlice_bits(20, 2, iss, 1, instr[24 .. 24] @ instr[21 .. 21]);
                if slice(instr, 16, 4) == 0xF then {
                    iss = __SetSlice_bits(20, 4, iss, 5, undefined : bits(4));
                    iss = __SetSlice_bits(20, 1, iss, 3, 0b1)
                } else {
                    iss = __SetSlice_bits(20, 4, iss, 5, slice(instr, 16, 4));
                    iss = __SetSlice_bits(20, 1, iss, 3, 0b0)
                }
            } else {
                Unreachable()
            }
        }
    };
    let iss = __SetSlice_bits(20, 1, iss, 0, [instr[20]]);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 20, __tc2, 0, iss);
    exception.syndrome = __tc2;
    exception
}

val ConditionPassed : unit -> bool effect {rreg, undef, wreg}

function ConditionPassed () = {
    __conditionPassed = ConditionHolds(AArch32_CurrentCond());
    __conditionPassed
}

val YIELD_Op_A : unit -> unit effect {rreg, undef, wreg}

function YIELD_Op_A () = {
    if ConditionPassed() then {
        Hint_Yield()
    }
}

val UDF_Op_A : unit -> unit effect {escape, rreg, undef, wreg}

function UDF_Op_A () = {
    if ConditionPassed() then {
        throw(Error_Undefined())
    }
}

val SEVL_Op_A : unit -> unit effect {rreg, undef, wreg}

function SEVL_Op_A () = {
    if ConditionPassed() then {
        SendEventLocal()
    }
}

val SEV_Op_A : unit -> unit effect {rreg, undef, wreg}

function SEV_Op_A () = {
    if ConditionPassed() then {
        SendEvent()
    }
}

val SB_Op_A : unit -> unit effect {rreg, undef, wreg}

function SB_Op_A () = {
    if ConditionPassed() then {
        SpeculationBarrier()
    }
}

val NOP_Op_A : unit -> unit effect {rreg, undef, wreg}

function NOP_Op_A () = {
    if ConditionPassed() then ()
}

val ISB_Op_A : unit -> unit effect {rreg, undef, wreg}

function ISB_Op_A () = {
    if ConditionPassed() then {
        InstructionSynchronizationBarrier()
    }
}

val DSB_Op_A : bits(4) -> unit effect {escape, rreg, undef, wreg}

function DSB_Op_A option_name = {
    if ConditionPassed() then {
        domain : MBReqDomain = undefined : MBReqDomain;
        types : MBReqTypes = undefined : MBReqTypes;
        match option_name {
          0x1 => {
              domain = MBReqDomain_OuterShareable;
              types = MBReqTypes_Reads
          },
          0x2 => {
              domain = MBReqDomain_OuterShareable;
              types = MBReqTypes_Writes
          },
          0x3 => {
              domain = MBReqDomain_OuterShareable;
              types = MBReqTypes_All
          },
          0x5 => {
              domain = MBReqDomain_Nonshareable;
              types = MBReqTypes_Reads
          },
          0x6 => {
              domain = MBReqDomain_Nonshareable;
              types = MBReqTypes_Writes
          },
          0x7 => {
              domain = MBReqDomain_Nonshareable;
              types = MBReqTypes_All
          },
          0x9 => {
              domain = MBReqDomain_InnerShareable;
              types = MBReqTypes_Reads
          },
          0xA => {
              domain = MBReqDomain_InnerShareable;
              types = MBReqTypes_Writes
          },
          0xB => {
              domain = MBReqDomain_InnerShareable;
              types = MBReqTypes_All
          },
          0xD => {
              domain = MBReqDomain_FullSystem;
              types = MBReqTypes_Reads
          },
          0xE => {
              domain = MBReqDomain_FullSystem;
              types = MBReqTypes_Writes
          },
          _ => {
              if option_name == 0x0 then {
                  throw(Error_See("SSBB"))
              } else {
                  if option_name == 0x4 then {
                      throw(Error_See("PSSBB"))
                  } else {
                      domain = MBReqDomain_FullSystem;
                      types = MBReqTypes_All
                  }
              }
          }
        };
        if EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
            if slice(get_HCR(), 10, 2) == 0b11 then {
                domain = MBReqDomain_FullSystem
            };
            if slice(get_HCR(), 10, 2) == 0b10 & domain != MBReqDomain_FullSystem then {
                domain = MBReqDomain_OuterShareable
            };
            if slice(get_HCR(), 10, 2) == 0b01 & domain == MBReqDomain_Nonshareable then {
                domain = MBReqDomain_InnerShareable
            }
        };
        DataSynchronizationBarrier(domain, types)
    }
}

val DMB_Op_A : bits(4) -> unit effect {escape, rreg, undef, wreg}

function DMB_Op_A option_name = {
    if ConditionPassed() then {
        domain : MBReqDomain = undefined : MBReqDomain;
        types : MBReqTypes = undefined : MBReqTypes;
        match option_name {
          0x1 => {
              domain = MBReqDomain_OuterShareable;
              types = MBReqTypes_Reads
          },
          0x2 => {
              domain = MBReqDomain_OuterShareable;
              types = MBReqTypes_Writes
          },
          0x3 => {
              domain = MBReqDomain_OuterShareable;
              types = MBReqTypes_All
          },
          0x5 => {
              domain = MBReqDomain_Nonshareable;
              types = MBReqTypes_Reads
          },
          0x6 => {
              domain = MBReqDomain_Nonshareable;
              types = MBReqTypes_Writes
          },
          0x7 => {
              domain = MBReqDomain_Nonshareable;
              types = MBReqTypes_All
          },
          0x9 => {
              domain = MBReqDomain_InnerShareable;
              types = MBReqTypes_Reads
          },
          0xA => {
              domain = MBReqDomain_InnerShareable;
              types = MBReqTypes_Writes
          },
          0xB => {
              domain = MBReqDomain_InnerShareable;
              types = MBReqTypes_All
          },
          0xD => {
              domain = MBReqDomain_FullSystem;
              types = MBReqTypes_Reads
          },
          0xE => {
              domain = MBReqDomain_FullSystem;
              types = MBReqTypes_Writes
          },
          _ => {
              domain = MBReqDomain_FullSystem;
              types = MBReqTypes_All
          }
        };
        let types = types;
        if EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
            if slice(get_HCR(), 10, 2) == 0b11 then {
                domain = MBReqDomain_FullSystem
            };
            if slice(get_HCR(), 10, 2) == 0b10 & domain != MBReqDomain_FullSystem then {
                domain = MBReqDomain_OuterShareable
            };
            if slice(get_HCR(), 10, 2) == 0b01 & domain == MBReqDomain_Nonshareable then {
                domain = MBReqDomain_InnerShareable
            }
        };
        DataMemoryBarrier(domain, types)
    }
}

val DBG_Op_A : unit -> unit effect {rreg, undef, wreg}

function DBG_Op_A () = {
    if ConditionPassed() then ()
}

val CLREX_Op_A : unit -> unit effect {rreg, undef, wreg}

function CLREX_Op_A () = {
    if ConditionPassed() then {
        ClearExclusiveLocal(ProcessorID())
    }
}

val BankedRegisterAccessValid : (bits(5), bits(5)) -> unit effect {escape, rreg, undef}

function BankedRegisterAccessValid (SYSm, mode) = {
    match SYSm {
      [bitzero] @ [bitzero] @ [bitzero] @ _ : bits(1) @ _ : bits(1) => {
          if mode != M32_FIQ then {
              throw(Error_Unpredictable())
          }
      },
      0b00100 => {
          if mode != M32_FIQ then {
              throw(Error_Unpredictable())
          }
      },
      0b00101 => {
          if mode == M32_System then {
              throw(Error_Unpredictable())
          }
      },
      0b00110 => {
          if mode == M32_Hyp | mode == M32_System then {
              throw(Error_Unpredictable())
          }
      },
      [bitzero] @ [bitone] @ [bitzero] @ _ : bits(1) @ _ : bits(1) => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          }
      },
      [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          }
      },
      0b01110 => {
          if mode == M32_FIQ then {
              throw(Error_Unpredictable())
          }
      },
      [bitone] @ [bitzero] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
          if mode == M32_IRQ then {
              throw(Error_Unpredictable())
          }
      },
      [bitone] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) => {
          if mode == M32_Svc then {
              throw(Error_Unpredictable())
          }
      },
      [bitone] @ [bitzero] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          if mode == M32_Abort then {
              throw(Error_Unpredictable())
          }
      },
      [bitone] @ [bitzero] @ [bitone] @ [bitone] @ _ : bits(1) => {
          if mode == M32_Undef then {
              throw(Error_Unpredictable())
          }
      },
      [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          if (~(HaveEL(EL3)) | ~(IsSecure())) | mode == M32_Monitor then {
              throw(Error_Unpredictable())
          }
      },
      0b11110 => {
          if ~(HaveEL(EL2)) | ~(mode == M32_Monitor | mode == M32_Hyp) then {
              throw(Error_Unpredictable())
          }
      },
      0b11111 => {
          if ~(HaveEL(EL2)) | mode != M32_Monitor then {
              throw(Error_Unpredictable())
          }
      },
      _ => {
          throw(Error_Unpredictable())
      }
    };
    return()
}

val set_SP : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_SP value_name = {
    R(13) = value_name;
    return()
}

val MRS_Op_AS : forall 'd ('read_spsr : Bool),
  ('d >= 0 & 'd <= 14 | not('read_spsr)) & ('d >= 0 & 'd <= 14 | not(not('read_spsr))).
  (int('d), bool('read_spsr)) -> unit effect {escape, rreg, undef, wreg}

function MRS_Op_AS (d, read_spsr) = {
    if ConditionPassed() then {
        psr_val : bits(32) = undefined : bits(32);
        if read_spsr then {
            if PSTATE.M == M32_User | PSTATE.M == M32_System then {
                throw(Error_Unpredictable())
            } else {
                R(d) = SPSR()
            }
        } else {
            mask : bits(32) = 0xF80F03DF;
            if HavePANExt() then {
                mask = __SetSlice_bits(32, 1, mask, 22, 0b1)
            };
            psr_val = GetPSRFromPSTATE() & mask;
            if PSTATE.EL == EL0 then {
                psr_val = __SetSlice_bits(32, 1, psr_val, 22, undefined : bits(1));
                psr_val = __SetSlice_bits(32, 4, psr_val, 6, undefined : bits(4));
                psr_val = __SetSlice_bits(32, 5, psr_val, 0, undefined : bits(5))
            };
            R(d) = psr_val
        }
    }
}

val aget_Rmode : forall ('n : Int), ('n >= 0 & 'n <= 14).
  (int('n), bits(5)) -> bits(32) effect {escape, rreg, undef}

function aget_Rmode (n, mode) = {
    assert(n >= 0 & n <= 14);
    if ~(IsSecure()) then {
        assert(mode != M32_Monitor)
    };
    assert(~(BadMode(mode)));
    if mode == M32_Monitor then {
        if n == 13 then {
            return(SP_mon)
        } else {
            if n == 14 then {
                return(LR_mon)
            } else {
                return(slice(_R[n], 0, 32))
            }
        }
    } else {
        return(slice(_R[LookUpRIndex(n, mode)], 0, 32))
    }
}

overload Rmode = {aget_Rmode}

val aget_R : forall ('n : Int), ('n >= 0 & 'n <= 15).
  int('n) -> bits(32) effect {escape, rreg, undef}

function aget_R n = {
    offset : int = undefined : int;
    if n == 15 then {
        offset = if CurrentInstrSet() == InstrSet_A32 then 8 else 4;
        return(slice(_PC, 0, 32) + offset)
    } else {
        return(aget_Rmode(n, PSTATE.M))
    }
}

overload R = {aget_R}

val get_SP : unit -> bits(32) effect {escape, rreg, undef}

function get_SP () = {
    R(13)
}

val get_PC : unit -> bits(32) effect {escape, rreg, undef}

function get_PC () = {
    R(15)
}

val PLD_l_Op_A : forall ('add : Bool).
  (bool('add), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function PLD_l_Op_A (add, imm32) = {
    if ConditionPassed() then {
        let address = if add then Align(get_PC(), 4) + imm32 else Align(get_PC(), 4) - imm32;
        Hint_PreloadData(address)
    }
}

val PCStoreValue : unit -> bits(32) effect {escape, rreg, undef}

function PCStoreValue () = {
    get_PC()
}

val get_LR : unit -> bits(32) effect {escape, rreg, undef}

function get_LR () = {
    R(14)
}

val UXTH_Op_A : forall 'd 'm 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function UXTH_Op_A (d, m, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = ZeroExtend(slice(rotated, 0, 16), 32)
    }
}

val UXTB16_Op_A : forall 'd 'm 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function UXTB16_Op_A (d, m, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, ZeroExtend(slice(rotated, 0, 8), 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, ZeroExtend(slice(rotated, 16, 8), 16));
        R(d) = __tc2
    }
}

val UXTB_Op_A : forall 'd 'm 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function UXTB_Op_A (d, m, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = ZeroExtend(slice(rotated, 0, 8), 32)
    }
}

val UXTAH_Op_A : forall 'd 'm 'n 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function UXTAH_Op_A (d, m, n, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = R(n) + ZeroExtend(slice(rotated, 0, 16), 32)
    }
}

val UXTAB16_Op_A : forall 'd 'm 'n 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 15) & ('n >= 0 & 'n <= 15) & 'd <= 14.
  (int('d), int('m), int('n), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function UXTAB16_Op_A (d, m, n, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, slice(R(n), 0, 16) + ZeroExtend(slice(rotated, 0, 8), 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, slice(R(n), 16, 16) + ZeroExtend(slice(rotated, 16, 8), 16));
        R(d) = __tc2
    }
}

val UXTAB_Op_A : forall 'd 'm 'n 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function UXTAB_Op_A (d, m, n, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = R(n) + ZeroExtend(slice(rotated, 0, 8), 32)
    }
}

val USUB8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function USUB8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff3 : int = undefined : int;
        diff4 : int = undefined : int;
        diff1 = UInt(slice(R(n), 0, 8)) - UInt(slice(R(m), 0, 8));
        diff2 = UInt(slice(R(n), 8, 8)) - UInt(slice(R(m), 8, 8));
        diff3 = UInt(slice(R(n), 16, 8)) - UInt(slice(R(m), 16, 8));
        diff4 = UInt(slice(R(n), 24, 8)) - UInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, diff1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, diff2, 0));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, diff3, 0));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, diff4, 0));
        R(d) = __tc4;
        __tc5 : bits(4) = PSTATE.GE;
        __tc5 = __SetSlice_bits(4, 1, __tc5, 0, if diff1 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc5;
        __tc6 : bits(4) = PSTATE.GE;
        __tc6 = __SetSlice_bits(4, 1, __tc6, 1, if diff2 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc6;
        __tc7 : bits(4) = PSTATE.GE;
        __tc7 = __SetSlice_bits(4, 1, __tc7, 2, if diff3 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc7;
        __tc8 : bits(4) = PSTATE.GE;
        __tc8 = __SetSlice_bits(4, 1, __tc8, 3, if diff4 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc8
    }
}

val USUB16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function USUB16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff1 = UInt(slice(R(n), 0, 16)) - UInt(slice(R(m), 0, 16));
        diff2 = UInt(slice(R(n), 16, 16)) - UInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff2, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if diff1 >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if diff2 >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val USAX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function USAX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        let sum : int = UInt(slice(R(n), 0, 16)) + UInt(slice(R(m), 16, 16));
        diff = UInt(slice(R(n), 16, 16)) - UInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if sum >= 65536 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if diff >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val USAT16_Op_A : forall 'd 'n 'saturate_to,
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 15) & 'saturate_to >= 0 & 'd <= 14.
  (int('d), int('n), int('saturate_to)) -> unit effect {escape, rreg, undef, wreg}

function USAT16_Op_A (d, n, saturate_to) = {
    if ConditionPassed() then {
        result1 : bits('saturate_to) = undefined : bits('saturate_to);
        result2 : bits('saturate_to) = undefined : bits('saturate_to);
        sat1 : bool = undefined : bool;
        sat2 : bool = undefined : bool;
        (result1, sat1) = UnsignedSatQ(SInt(slice(R(n), 0, 16)), saturate_to);
        (result2, sat2) = UnsignedSatQ(SInt(slice(R(n), 16, 16)), saturate_to);
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, ZeroExtend(result1, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, ZeroExtend(result2, 16));
        R(d) = __tc2;
        if sat1 | sat2 then {
            PSTATE.Q = 0b1
        }
    }
}

val USAT_Op_A : forall 'd 'n 'saturate_to 'shift_n,
  ('n >= 0 & 'n <= 15) & 'saturate_to >= 0 & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('saturate_to), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function USAT_Op_A (d, n, saturate_to, shift_n, shift_t) = {
    if ConditionPassed() then {
        operand : bits(32) = undefined : bits(32);
        result : bits('saturate_to) = undefined : bits('saturate_to);
        sat : bool = undefined : bool;
        operand = Shift(R(n), shift_t, shift_n, PSTATE.C);
        (result, sat) = UnsignedSatQ(SInt(operand), saturate_to);
        R(d) = ZeroExtend(result, 32);
        if sat then {
            PSTATE.Q = 0b1
        }
    }
}

val USADA8_Op_A : forall 'a 'd 'm 'n,
  ('a >= 0 & 'a <= 15 & 'd >= 0 & 'd <= 14 & 'm >= 0 & 'm <= 15 & 'n >= 0 & 'n <= 15).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function USADA8_Op_A (a, d, m, n) = {
    if ConditionPassed() then {
        absdiff1 : int = undefined : int;
        absdiff2 : int = undefined : int;
        absdiff3 : int = undefined : int;
        absdiff4 : int = undefined : int;
        result : int = undefined : int;
        absdiff1 = abs(UInt(slice(aget_R(n), 0, 8)) - UInt(slice(aget_R(m), 0, 8)));
        absdiff2 = abs(UInt(slice(aget_R(n), 8, 8)) - UInt(slice(aget_R(m), 8, 8)));
        absdiff3 = abs(UInt(slice(aget_R(n), 16, 8)) - UInt(slice(aget_R(m), 16, 8)));
        absdiff4 = abs(UInt(slice(aget_R(n), 24, 8)) - UInt(slice(aget_R(m), 24, 8)));
        result = UInt(aget_R(a)) + absdiff1 + absdiff2 + absdiff3 + absdiff4;
        aset_R(d, __GetSlice_int(32, result, 0))
    }
}

val USAD8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function USAD8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        absdiff1 : int = undefined : int;
        absdiff2 : int = undefined : int;
        absdiff3 : int = undefined : int;
        absdiff4 : int = undefined : int;
        result : int = undefined : int;
        absdiff1 = abs(UInt(slice(R(n), 0, 8)) - UInt(slice(R(m), 0, 8)));
        absdiff2 = abs(UInt(slice(R(n), 8, 8)) - UInt(slice(R(m), 8, 8)));
        absdiff3 = abs(UInt(slice(R(n), 16, 8)) - UInt(slice(R(m), 16, 8)));
        absdiff4 = abs(UInt(slice(R(n), 24, 8)) - UInt(slice(R(m), 24, 8)));
        result = absdiff1 + absdiff2 + absdiff3 + absdiff4;
        R(d) = __GetSlice_int(32, result, 0)
    }
}

val UQSUB8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UQSUB8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff3 : int = undefined : int;
        diff4 : int = undefined : int;
        diff1 = UInt(slice(R(n), 0, 8)) - UInt(slice(R(m), 0, 8));
        diff2 = UInt(slice(R(n), 8, 8)) - UInt(slice(R(m), 8, 8));
        diff3 = UInt(slice(R(n), 16, 8)) - UInt(slice(R(m), 16, 8));
        diff4 = UInt(slice(R(n), 24, 8)) - UInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, UnsignedSat(diff1, 8));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, UnsignedSat(diff2, 8));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, UnsignedSat(diff3, 8));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, UnsignedSat(diff4, 8));
        R(d) = __tc4
    }
}

val UQSUB16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UQSUB16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff1 = UInt(slice(R(n), 0, 16)) - UInt(slice(R(m), 0, 16));
        diff2 = UInt(slice(R(n), 16, 16)) - UInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, UnsignedSat(diff1, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, UnsignedSat(diff2, 16));
        R(d) = __tc2
    }
}

val UQSAX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UQSAX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        let sum : int = UInt(slice(R(n), 0, 16)) + UInt(slice(R(m), 16, 16));
        diff = UInt(slice(R(n), 16, 16)) - UInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, UnsignedSat(sum, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, UnsignedSat(diff, 16));
        R(d) = __tc2
    }
}

val UQASX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UQASX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        sum : int = undefined : int;
        diff = UInt(slice(R(n), 0, 16)) - UInt(slice(R(m), 16, 16));
        sum = UInt(slice(R(n), 16, 16)) + UInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, UnsignedSat(diff, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, UnsignedSat(sum, 16));
        R(d) = __tc2
    }
}

val UQADD8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UQADD8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum3 : int = undefined : int;
        sum4 : int = undefined : int;
        sum1 = UInt(slice(R(n), 0, 8)) + UInt(slice(R(m), 0, 8));
        sum2 = UInt(slice(R(n), 8, 8)) + UInt(slice(R(m), 8, 8));
        sum3 = UInt(slice(R(n), 16, 8)) + UInt(slice(R(m), 16, 8));
        sum4 = UInt(slice(R(n), 24, 8)) + UInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, UnsignedSat(sum1, 8));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, UnsignedSat(sum2, 8));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, UnsignedSat(sum3, 8));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, UnsignedSat(sum4, 8));
        R(d) = __tc4
    }
}

val UQADD16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UQADD16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum1 = UInt(slice(R(n), 0, 16)) + UInt(slice(R(m), 0, 16));
        sum2 = UInt(slice(R(n), 16, 16)) + UInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, UnsignedSat(sum1, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, UnsignedSat(sum2, 16));
        R(d) = __tc2
    }
}

val UMULL_Op_A : forall 'dHi 'dLo 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('dHi >= 0 & 'dHi <= 14) & ('dLo >= 0 & 'dLo <= 14).
  (int('dHi), int('dLo), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function UMULL_Op_A (dHi, dLo, m, n, setflags) = {
    if ConditionPassed() then {
        let result : int = UInt(R(n)) * UInt(R(m));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0);
        if setflags then {
            PSTATE.N = __GetSlice_int(1, result, 63);
            PSTATE.Z = IsZeroBit(__GetSlice_int(64, result, 0))
        }
    }
}

val UMLAL_Op_A : forall 'dHi 'dLo 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('dHi >= 0 & 'dHi <= 15) & ('dLo >= 0 & 'dLo <= 15) & 'dHi <= 14 & 'dLo <= 14.
  (int('dHi), int('dLo), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function UMLAL_Op_A (dHi, dLo, m, n, setflags) = {
    if ConditionPassed() then {
        let result : int = UInt(R(n)) * UInt(R(m)) + UInt(R(dHi) @ R(dLo));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0);
        if setflags then {
            PSTATE.N = __GetSlice_int(1, result, 63);
            PSTATE.Z = IsZeroBit(__GetSlice_int(64, result, 0))
        }
    }
}

val UMAAL_Op_A : forall 'dHi 'dLo 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('dHi >= 0 & 'dHi <= 15) & ('dLo >= 0 & 'dLo <= 15) & 'dHi <= 14 & 'dLo <= 14.
  (int('dHi), int('dLo), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UMAAL_Op_A (dHi, dLo, m, n) = {
    if ConditionPassed() then {
        let result : int = UInt(R(n)) * UInt(R(m)) + UInt(R(dHi)) + UInt(R(dLo));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0)
    }
}

val UHSUB8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UHSUB8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff3 : int = undefined : int;
        diff4 : int = undefined : int;
        diff1 = UInt(slice(R(n), 0, 8)) - UInt(slice(R(m), 0, 8));
        diff2 = UInt(slice(R(n), 8, 8)) - UInt(slice(R(m), 8, 8));
        diff3 = UInt(slice(R(n), 16, 8)) - UInt(slice(R(m), 16, 8));
        diff4 = UInt(slice(R(n), 24, 8)) - UInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, diff1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, diff2, 1));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, diff3, 1));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, diff4, 1));
        R(d) = __tc4
    }
}

val UHSUB16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UHSUB16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff1 = UInt(slice(R(n), 0, 16)) - UInt(slice(R(m), 0, 16));
        diff2 = UInt(slice(R(n), 16, 16)) - UInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff2, 1));
        R(d) = __tc2
    }
}

val UHSAX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UHSAX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        let sum : int = UInt(slice(R(n), 0, 16)) + UInt(slice(R(m), 16, 16));
        diff = UInt(slice(R(n), 16, 16)) - UInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff, 1));
        R(d) = __tc2
    }
}

val UHASX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UHASX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        sum : int = undefined : int;
        diff = UInt(slice(R(n), 0, 16)) - UInt(slice(R(m), 16, 16));
        sum = UInt(slice(R(n), 16, 16)) + UInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum, 1));
        R(d) = __tc2
    }
}

val UHADD8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UHADD8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum3 : int = undefined : int;
        sum4 : int = undefined : int;
        sum1 = UInt(slice(R(n), 0, 8)) + UInt(slice(R(m), 0, 8));
        sum2 = UInt(slice(R(n), 8, 8)) + UInt(slice(R(m), 8, 8));
        sum3 = UInt(slice(R(n), 16, 8)) + UInt(slice(R(m), 16, 8));
        sum4 = UInt(slice(R(n), 24, 8)) + UInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, sum1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, sum2, 1));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, sum3, 1));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, sum4, 1));
        R(d) = __tc4
    }
}

val UHADD16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UHADD16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum1 = UInt(slice(R(n), 0, 16)) + UInt(slice(R(m), 0, 16));
        sum2 = UInt(slice(R(n), 16, 16)) + UInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum2, 1));
        R(d) = __tc2
    }
}

val UDIV_Op_A : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UDIV_Op_A (d, m, n) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        if UInt(R(m)) == 0 then {
            result = 0
        } else {
            result = RoundTowardsZero(Real(UInt(R(n))) / Real(UInt(R(m))))
        };
        R(d) = __GetSlice_int(32, result, 0)
    }
}

val UBFX_Op_A : forall 'd 'lsbit 'n 'widthminus1,
  ('n >= 0 & 'n <= 15 | not('lsbit + 'widthminus1 <= 31)) & ('lsbit + 'widthminus1 - 'lsbit + 1 >= 0 | not('lsbit + 'widthminus1 <= 31)) & ('d >= 0 & 'd <= 14 | not('lsbit + 'widthminus1 <= 31)).
  (int('d), int('lsbit), int('n), int('widthminus1)) -> unit effect {escape, rreg, undef, wreg}

function UBFX_Op_A (d, lsbit, n, widthminus1) = {
    if ConditionPassed() then {
        let msbit = lsbit + widthminus1;
        if msbit <= 31 then {
            R(d) = ZeroExtend(slice(R(n), lsbit, msbit - lsbit + 1), 32)
        } else {
            throw(Error_Unpredictable())
        }
    }
}

val UASX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UASX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        sum : int = undefined : int;
        diff = UInt(slice(R(n), 0, 16)) - UInt(slice(R(m), 16, 16));
        sum = UInt(slice(R(n), 16, 16)) + UInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if diff >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if sum >= 65536 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val UADD8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UADD8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum3 : int = undefined : int;
        sum4 : int = undefined : int;
        sum1 = UInt(slice(R(n), 0, 8)) + UInt(slice(R(m), 0, 8));
        sum2 = UInt(slice(R(n), 8, 8)) + UInt(slice(R(m), 8, 8));
        sum3 = UInt(slice(R(n), 16, 8)) + UInt(slice(R(m), 16, 8));
        sum4 = UInt(slice(R(n), 24, 8)) + UInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, sum1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, sum2, 0));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, sum3, 0));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, sum4, 0));
        R(d) = __tc4;
        __tc5 : bits(4) = PSTATE.GE;
        __tc5 = __SetSlice_bits(4, 1, __tc5, 0, if sum1 >= 256 then 0b1 else 0b0);
        PSTATE.GE = __tc5;
        __tc6 : bits(4) = PSTATE.GE;
        __tc6 = __SetSlice_bits(4, 1, __tc6, 1, if sum2 >= 256 then 0b1 else 0b0);
        PSTATE.GE = __tc6;
        __tc7 : bits(4) = PSTATE.GE;
        __tc7 = __SetSlice_bits(4, 1, __tc7, 2, if sum3 >= 256 then 0b1 else 0b0);
        PSTATE.GE = __tc7;
        __tc8 : bits(4) = PSTATE.GE;
        __tc8 = __SetSlice_bits(4, 1, __tc8, 3, if sum4 >= 256 then 0b1 else 0b0);
        PSTATE.GE = __tc8
    }
}

val UADD16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function UADD16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum1 = UInt(slice(R(n), 0, 16)) + UInt(slice(R(m), 0, 16));
        sum2 = UInt(slice(R(n), 16, 16)) + UInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum2, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if sum1 >= 65536 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if sum2 >= 65536 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val TST_rr_Op_A : forall 'm 'n 's,
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('s), SRType) -> unit effect {escape, rreg, undef, wreg}

function TST_rr_Op_A (m, n, s, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) & shifted;
        PSTATE.N = [result[31]];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry
    }
}

val TST_r_Op_A : forall 'm 'n 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function TST_r_Op_A (m, n, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) & shifted;
        PSTATE.N = [result[31]];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry
    }
}

val TST_i_Op_A : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (bits(1), bits(32), int('n)) -> unit effect {escape, rreg, undef, wreg}

function TST_i_Op_A (carry, imm32, n) = {
    if ConditionPassed() then {
        let result : bits(32) = R(n) & imm32;
        PSTATE.N = [result[31]];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry
    }
}

val TEQ_rr_Op_A : forall 'm 'n 's,
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('s), SRType) -> unit effect {escape, rreg, undef, wreg}

function TEQ_rr_Op_A (m, n, s, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) ^ shifted;
        PSTATE.N = [result[31]];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry
    }
}

val TEQ_r_Op_A : forall 'm 'n 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function TEQ_r_Op_A (m, n, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) ^ shifted;
        PSTATE.N = [result[31]];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry
    }
}

val TEQ_i_Op_A : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (bits(1), bits(32), int('n)) -> unit effect {escape, rreg, undef, wreg}

function TEQ_i_Op_A (carry, imm32, n) = {
    if ConditionPassed() then {
        let result : bits(32) = R(n) ^ imm32;
        PSTATE.N = [result[31]];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry
    }
}

val SXTH_Op_A : forall 'd 'm 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function SXTH_Op_A (d, m, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = SignExtend(slice(rotated, 0, 16), 32)
    }
}

val SXTB16_Op_A : forall 'd 'm 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function SXTB16_Op_A (d, m, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, SignExtend(slice(rotated, 0, 8), 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, SignExtend(slice(rotated, 16, 8), 16));
        R(d) = __tc2
    }
}

val SXTB_Op_A : forall 'd 'm 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function SXTB_Op_A (d, m, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = SignExtend(slice(rotated, 0, 8), 32)
    }
}

val SXTAH_Op_A : forall 'd 'm 'n 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function SXTAH_Op_A (d, m, n, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = R(n) + SignExtend(slice(rotated, 0, 16), 32)
    }
}

val SXTAB16_Op_A : forall 'd 'm 'n 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('d >= 0 & 'd <= 15) & ('n >= 0 & 'n <= 15) & 'd <= 14.
  (int('d), int('m), int('n), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function SXTAB16_Op_A (d, m, n, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, slice(R(n), 0, 16) + SignExtend(slice(rotated, 0, 8), 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, slice(R(n), 16, 16) + SignExtend(slice(rotated, 16, 8), 16));
        R(d) = __tc2
    }
}

val SXTAB_Op_A : forall 'd 'm 'n 'rotation,
  ('m >= 0 & 'm <= 15) & 'rotation >= 0 & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('rotation)) -> unit effect {escape, rreg, undef, wreg}

function SXTAB_Op_A (d, m, n, rotation) = {
    if ConditionPassed() then {
        let rotated : bits(32) = ROR(R(m), rotation);
        R(d) = R(n) + SignExtend(slice(rotated, 0, 8), 32)
    }
}

val SUB_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function SUB_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), ~(shifted), 0b1);
        R(d) = result;
        if setflags then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
        }
    }
}

val SSUB8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SSUB8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff3 : int = undefined : int;
        diff4 : int = undefined : int;
        diff1 = SInt(slice(R(n), 0, 8)) - SInt(slice(R(m), 0, 8));
        diff2 = SInt(slice(R(n), 8, 8)) - SInt(slice(R(m), 8, 8));
        diff3 = SInt(slice(R(n), 16, 8)) - SInt(slice(R(m), 16, 8));
        diff4 = SInt(slice(R(n), 24, 8)) - SInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, diff1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, diff2, 0));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, diff3, 0));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, diff4, 0));
        R(d) = __tc4;
        __tc5 : bits(4) = PSTATE.GE;
        __tc5 = __SetSlice_bits(4, 1, __tc5, 0, if diff1 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc5;
        __tc6 : bits(4) = PSTATE.GE;
        __tc6 = __SetSlice_bits(4, 1, __tc6, 1, if diff2 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc6;
        __tc7 : bits(4) = PSTATE.GE;
        __tc7 = __SetSlice_bits(4, 1, __tc7, 2, if diff3 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc7;
        __tc8 : bits(4) = PSTATE.GE;
        __tc8 = __SetSlice_bits(4, 1, __tc8, 3, if diff4 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc8
    }
}

val SSUB16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SSUB16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff1 = SInt(slice(R(n), 0, 16)) - SInt(slice(R(m), 0, 16));
        diff2 = SInt(slice(R(n), 16, 16)) - SInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff2, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if diff1 >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if diff2 >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val SSAX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SSAX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        let sum : int = SInt(slice(R(n), 0, 16)) + SInt(slice(R(m), 16, 16));
        diff = SInt(slice(R(n), 16, 16)) - SInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if sum >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if diff >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val SSAT16_Op_A : forall 'd 'n 'saturate_to,
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 15) & 'saturate_to >= 0 & 'd <= 14.
  (int('d), int('n), int('saturate_to)) -> unit effect {escape, rreg, undef, wreg}

function SSAT16_Op_A (d, n, saturate_to) = {
    if ConditionPassed() then {
        result1 : bits('saturate_to) = undefined : bits('saturate_to);
        result2 : bits('saturate_to) = undefined : bits('saturate_to);
        sat1 : bool = undefined : bool;
        sat2 : bool = undefined : bool;
        (result1, sat1) = SignedSatQ(SInt(slice(R(n), 0, 16)), saturate_to);
        (result2, sat2) = SignedSatQ(SInt(slice(R(n), 16, 16)), saturate_to);
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, SignExtend(result1, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, SignExtend(result2, 16));
        R(d) = __tc2;
        if sat1 | sat2 then {
            PSTATE.Q = 0b1
        }
    }
}

val SSAT_Op_A : forall 'd 'n 'saturate_to 'shift_n,
  ('n >= 0 & 'n <= 15) & 'saturate_to >= 0 & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('saturate_to), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function SSAT_Op_A (d, n, saturate_to, shift_n, shift_t) = {
    if ConditionPassed() then {
        operand : bits(32) = undefined : bits(32);
        result : bits('saturate_to) = undefined : bits('saturate_to);
        sat : bool = undefined : bool;
        operand = Shift(R(n), shift_t, shift_n, PSTATE.C);
        (result, sat) = SignedSatQ(SInt(operand), saturate_to);
        R(d) = SignExtend(result, 32);
        if sat then {
            PSTATE.Q = 0b1
        }
    }
}

val SMUSD_Op_A : forall 'd 'm ('m_swap : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_swap)) & ('m >= 0 & 'm <= 15 | not(not('m_swap))) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), bool('m_swap), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMUSD_Op_A (d, m, m_swap, n) = {
    if ConditionPassed() then {
        operand2 : bits(32) = undefined : bits(32);
        product1 : int = undefined : int;
        product2 : int = undefined : int;
        result : int = undefined : int;
        operand2 = if m_swap then ROR(R(m), 16) else R(m);
        product1 = SInt(slice(R(n), 0, 16)) * SInt(slice(operand2, 0, 16));
        product2 = SInt(slice(R(n), 16, 16)) * SInt(slice(operand2, 16, 16));
        result = product1 - product2;
        R(d) = __GetSlice_int(32, result, 0)
    }
}

val SMULWB_Op_A : forall 'd 'm ('m_high : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_high)) & ('m >= 0 & 'm <= 15 | not(not('m_high))) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), bool('m_high), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMULWB_Op_A (d, m, m_high, n) = {
    if ConditionPassed() then {
        operand2 : bits(16) = undefined : bits(16);
        product : int = undefined : int;
        operand2 = if m_high then slice(R(m), 16, 16) else slice(R(m), 0, 16);
        product = SInt(R(n)) * SInt(operand2);
        R(d) = __GetSlice_int(32, product, 16)
    }
}

val SMULL_Op_A : forall 'dHi 'dLo 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('dHi >= 0 & 'dHi <= 14) & ('dLo >= 0 & 'dLo <= 14).
  (int('dHi), int('dLo), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function SMULL_Op_A (dHi, dLo, m, n, setflags) = {
    if ConditionPassed() then {
        let result : int = SInt(R(n)) * SInt(R(m));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0);
        if setflags then {
            PSTATE.N = __GetSlice_int(1, result, 63);
            PSTATE.Z = IsZeroBit(__GetSlice_int(64, result, 0))
        }
    }
}

val SMULBB_Op_A : forall 'd 'm ('m_high : Bool) 'n ('n_high : Bool),
  ('n >= 0 & 'n <= 15 | not('n_high)) & ('n >= 0 & 'n <= 15 | not(not('n_high))) & ('m >= 0 & 'm <= 15 | not('m_high)) & ('m >= 0 & 'm <= 15 | not(not('m_high))) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), bool('m_high), int('n), bool('n_high)) -> unit effect {escape, rreg, undef, wreg}

function SMULBB_Op_A (d, m, m_high, n, n_high) = {
    if ConditionPassed() then {
        operand1 : bits(16) = undefined : bits(16);
        operand2 : bits(16) = undefined : bits(16);
        result : int = undefined : int;
        operand1 = if n_high then slice(R(n), 16, 16) else slice(R(n), 0, 16);
        operand2 = if m_high then slice(R(m), 16, 16) else slice(R(m), 0, 16);
        result = SInt(operand1) * SInt(operand2);
        R(d) = __GetSlice_int(32, result, 0)
    }
}

val SMUAD_Op_A : forall 'd 'm ('m_swap : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_swap)) & ('m >= 0 & 'm <= 15 | not(not('m_swap))) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), bool('m_swap), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMUAD_Op_A (d, m, m_swap, n) = {
    if ConditionPassed() then {
        operand2 : bits(32) = undefined : bits(32);
        product1 : int = undefined : int;
        product2 : int = undefined : int;
        result : int = undefined : int;
        operand2 = if m_swap then ROR(R(m), 16) else R(m);
        product1 = SInt(slice(R(n), 0, 16)) * SInt(slice(operand2, 0, 16));
        product2 = SInt(slice(R(n), 16, 16)) * SInt(slice(operand2, 16, 16));
        result = product1 + product2;
        R(d) = __GetSlice_int(32, result, 0);
        if result != SInt(__GetSlice_int(32, result, 0)) then {
            PSTATE.Q = 0b1
        }
    }
}

val SMMUL_Op_A : forall 'd 'm 'n ('round : Bool),
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), bool('round)) -> unit effect {escape, rreg, undef, wreg}

function SMMUL_Op_A (d, m, n, round) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        result = SInt(R(n)) * SInt(R(m));
        if round then {
            result = result + 2147483648
        };
        R(d) = __GetSlice_int(32, result, 32)
    }
}

val SMMLS_Op_A : forall 'a 'd 'm 'n ('round : Bool),
  ('a >= 0 & 'a <= 15) & ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), int('n), bool('round)) -> unit effect {escape, rreg, undef, wreg}

function SMMLS_Op_A (a, d, m, n, round) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        result = shl_int(SInt(R(a)), 32) - SInt(R(n)) * SInt(R(m));
        if round then {
            result = result + 2147483648
        };
        R(d) = __GetSlice_int(32, result, 32)
    }
}

val SMMLA_Op_A : forall 'a 'd 'm 'n ('round : Bool),
  ('a >= 0 & 'a <= 15) & ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), int('n), bool('round)) -> unit effect {escape, rreg, undef, wreg}

function SMMLA_Op_A (a, d, m, n, round) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        result = shl_int(SInt(R(a)), 32) + SInt(R(n)) * SInt(R(m));
        if round then {
            result = result + 2147483648
        };
        R(d) = __GetSlice_int(32, result, 32)
    }
}

val SMLSLD_Op_A : forall 'dHi 'dLo 'm ('m_swap : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_swap)) & ('m >= 0 & 'm <= 15 | not(not('m_swap))) & ('n >= 0 & 'n <= 15) & ('dHi >= 0 & 'dHi <= 15) & ('dLo >= 0 & 'dLo <= 15) & 'dHi <= 14 & 'dLo <= 14.
  (int('dHi), int('dLo), int('m), bool('m_swap), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMLSLD_Op_A (dHi, dLo, m, m_swap, n) = {
    if ConditionPassed() then {
        operand2 : bits(32) = undefined : bits(32);
        product1 : int = undefined : int;
        product2 : int = undefined : int;
        result : int = undefined : int;
        operand2 = if m_swap then ROR(R(m), 16) else R(m);
        product1 = SInt(slice(R(n), 0, 16)) * SInt(slice(operand2, 0, 16));
        product2 = SInt(slice(R(n), 16, 16)) * SInt(slice(operand2, 16, 16));
        result = product1 - product2 + SInt(R(dHi) @ R(dLo));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0)
    }
}

val SMLSD_Op_A : forall 'a 'd 'm ('m_swap : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_swap)) & ('m >= 0 & 'm <= 15 | not(not('m_swap))) & ('n >= 0 & 'n <= 15) & ('a >= 0 & 'a <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), bool('m_swap), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMLSD_Op_A (a, d, m, m_swap, n) = {
    if ConditionPassed() then {
        operand2 : bits(32) = undefined : bits(32);
        product1 : int = undefined : int;
        product2 : int = undefined : int;
        result : int = undefined : int;
        operand2 = if m_swap then ROR(R(m), 16) else R(m);
        product1 = SInt(slice(R(n), 0, 16)) * SInt(slice(operand2, 0, 16));
        product2 = SInt(slice(R(n), 16, 16)) * SInt(slice(operand2, 16, 16));
        result = product1 - product2 + SInt(R(a));
        R(d) = __GetSlice_int(32, result, 0);
        if result != SInt(__GetSlice_int(32, result, 0)) then {
            PSTATE.Q = 0b1
        }
    }
}

val SMLAWB_Op_A : forall 'a 'd 'm ('m_high : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_high)) & ('m >= 0 & 'm <= 15 | not(not('m_high))) & ('n >= 0 & 'n <= 15) & ('a >= 0 & 'a <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), bool('m_high), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMLAWB_Op_A (a, d, m, m_high, n) = {
    if ConditionPassed() then {
        operand2 : bits(16) = undefined : bits(16);
        result : int = undefined : int;
        operand2 = if m_high then slice(R(m), 16, 16) else slice(R(m), 0, 16);
        result = SInt(R(n)) * SInt(operand2) + shl_int(SInt(R(a)), 16);
        R(d) = __GetSlice_int(32, result, 16);
        if shr_int(result, 16) != SInt(R(d)) then {
            PSTATE.Q = 0b1
        }
    }
}

val SMLALD_Op_A : forall 'dHi 'dLo 'm ('m_swap : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_swap)) & ('m >= 0 & 'm <= 15 | not(not('m_swap))) & ('n >= 0 & 'n <= 15) & ('dHi >= 0 & 'dHi <= 15) & ('dLo >= 0 & 'dLo <= 15) & 'dHi <= 14 & 'dLo <= 14.
  (int('dHi), int('dLo), int('m), bool('m_swap), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMLALD_Op_A (dHi, dLo, m, m_swap, n) = {
    if ConditionPassed() then {
        operand2 : bits(32) = undefined : bits(32);
        product1 : int = undefined : int;
        product2 : int = undefined : int;
        result : int = undefined : int;
        operand2 = if m_swap then ROR(R(m), 16) else R(m);
        product1 = SInt(slice(R(n), 0, 16)) * SInt(slice(operand2, 0, 16));
        product2 = SInt(slice(R(n), 16, 16)) * SInt(slice(operand2, 16, 16));
        result = product1 + product2 + SInt(R(dHi) @ R(dLo));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0)
    }
}

val SMLALBB_Op_A : forall 'dHi 'dLo 'm ('m_high : Bool) 'n ('n_high : Bool),
  ('n >= 0 & 'n <= 15 | not('n_high)) & ('n >= 0 & 'n <= 15 | not(not('n_high))) & ('m >= 0 & 'm <= 15 | not('m_high)) & ('m >= 0 & 'm <= 15 | not(not('m_high))) & ('dHi >= 0 & 'dHi <= 15) & ('dLo >= 0 & 'dLo <= 15) & 'dHi <= 14 & 'dLo <= 14.
  (int('dHi), int('dLo), int('m), bool('m_high), int('n), bool('n_high)) -> unit effect {escape, rreg, undef, wreg}

function SMLALBB_Op_A (dHi, dLo, m, m_high, n, n_high) = {
    if ConditionPassed() then {
        operand1 : bits(16) = undefined : bits(16);
        operand2 : bits(16) = undefined : bits(16);
        result : int = undefined : int;
        operand1 = if n_high then slice(R(n), 16, 16) else slice(R(n), 0, 16);
        operand2 = if m_high then slice(R(m), 16, 16) else slice(R(m), 0, 16);
        result = SInt(operand1) * SInt(operand2) + SInt(R(dHi) @ R(dLo));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0)
    }
}

val SMLAL_Op_A : forall 'dHi 'dLo 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('dHi >= 0 & 'dHi <= 15) & ('dLo >= 0 & 'dLo <= 15) & 'dHi <= 14 & 'dLo <= 14.
  (int('dHi), int('dLo), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function SMLAL_Op_A (dHi, dLo, m, n, setflags) = {
    if ConditionPassed() then {
        let result : int = SInt(R(n)) * SInt(R(m)) + SInt(R(dHi) @ R(dLo));
        R(dHi) = __GetSlice_int(32, result, 32);
        R(dLo) = __GetSlice_int(32, result, 0);
        if setflags then {
            PSTATE.N = __GetSlice_int(1, result, 63);
            PSTATE.Z = IsZeroBit(__GetSlice_int(64, result, 0))
        }
    }
}

val SMLAD_Op_A : forall 'a 'd 'm ('m_swap : Bool) 'n,
  ('m >= 0 & 'm <= 15 | not('m_swap)) & ('m >= 0 & 'm <= 15 | not(not('m_swap))) & ('n >= 0 & 'n <= 15) & ('a >= 0 & 'a <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), bool('m_swap), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SMLAD_Op_A (a, d, m, m_swap, n) = {
    if ConditionPassed() then {
        operand2 : bits(32) = undefined : bits(32);
        product1 : int = undefined : int;
        product2 : int = undefined : int;
        result : int = undefined : int;
        operand2 = if m_swap then ROR(R(m), 16) else R(m);
        product1 = SInt(slice(R(n), 0, 16)) * SInt(slice(operand2, 0, 16));
        product2 = SInt(slice(R(n), 16, 16)) * SInt(slice(operand2, 16, 16));
        result = product1 + product2 + SInt(R(a));
        R(d) = __GetSlice_int(32, result, 0);
        if result != SInt(__GetSlice_int(32, result, 0)) then {
            PSTATE.Q = 0b1
        }
    }
}

val SMLABB_Op_A : forall 'a 'd 'm ('m_high : Bool) 'n ('n_high : Bool),
  ('n >= 0 & 'n <= 15 | not('n_high)) & ('n >= 0 & 'n <= 15 | not(not('n_high))) & ('m >= 0 & 'm <= 15 | not('m_high)) & ('m >= 0 & 'm <= 15 | not(not('m_high))) & ('a >= 0 & 'a <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), bool('m_high), int('n), bool('n_high)) -> unit effect {escape, rreg, undef, wreg}

function SMLABB_Op_A (a, d, m, m_high, n, n_high) = {
    if ConditionPassed() then {
        operand1 : bits(16) = undefined : bits(16);
        operand2 : bits(16) = undefined : bits(16);
        result : int = undefined : int;
        operand1 = if n_high then slice(R(n), 16, 16) else slice(R(n), 0, 16);
        operand2 = if m_high then slice(R(m), 16, 16) else slice(R(m), 0, 16);
        result = SInt(operand1) * SInt(operand2) + SInt(R(a));
        R(d) = __GetSlice_int(32, result, 0);
        if result != SInt(__GetSlice_int(32, result, 0)) then {
            PSTATE.Q = 0b1
        }
    }
}

val SHSUB8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHSUB8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff3 : int = undefined : int;
        diff4 : int = undefined : int;
        diff1 = SInt(slice(R(n), 0, 8)) - SInt(slice(R(m), 0, 8));
        diff2 = SInt(slice(R(n), 8, 8)) - SInt(slice(R(m), 8, 8));
        diff3 = SInt(slice(R(n), 16, 8)) - SInt(slice(R(m), 16, 8));
        diff4 = SInt(slice(R(n), 24, 8)) - SInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, diff1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, diff2, 1));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, diff3, 1));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, diff4, 1));
        R(d) = __tc4
    }
}

val SHSUB16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHSUB16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff1 = SInt(slice(R(n), 0, 16)) - SInt(slice(R(m), 0, 16));
        diff2 = SInt(slice(R(n), 16, 16)) - SInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff2, 1));
        R(d) = __tc2
    }
}

val SHSAX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHSAX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        let sum : int = SInt(slice(R(n), 0, 16)) + SInt(slice(R(m), 16, 16));
        diff = SInt(slice(R(n), 16, 16)) - SInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, diff, 1));
        R(d) = __tc2
    }
}

val SHASX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHASX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        sum : int = undefined : int;
        diff = SInt(slice(R(n), 0, 16)) - SInt(slice(R(m), 16, 16));
        sum = SInt(slice(R(n), 16, 16)) + SInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum, 1));
        R(d) = __tc2
    }
}

val SHADD8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHADD8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum3 : int = undefined : int;
        sum4 : int = undefined : int;
        sum1 = SInt(slice(R(n), 0, 8)) + SInt(slice(R(m), 0, 8));
        sum2 = SInt(slice(R(n), 8, 8)) + SInt(slice(R(m), 8, 8));
        sum3 = SInt(slice(R(n), 16, 8)) + SInt(slice(R(m), 16, 8));
        sum4 = SInt(slice(R(n), 24, 8)) + SInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, sum1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, sum2, 1));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, sum3, 1));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, sum4, 1));
        R(d) = __tc4
    }
}

val SHADD16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHADD16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum1 = SInt(slice(R(n), 0, 16)) + SInt(slice(R(m), 0, 16));
        sum2 = SInt(slice(R(n), 16, 16)) + SInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum1, 1));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum2, 1));
        R(d) = __tc2
    }
}

val SEL_Op_A : forall 'd 'm 'n,
  ('d >= 0 & 'd <= 15) & ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SEL_Op_A (d, m, n) = {
    if ConditionPassed() then {
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, if [PSTATE.GE[0]] == 0b1 then slice(R(n), 0, 8) else slice(R(m), 0, 8));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, if [PSTATE.GE[1]] == 0b1 then slice(R(n), 8, 8) else slice(R(m), 8, 8));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, if [PSTATE.GE[2]] == 0b1 then slice(R(n), 16, 8) else slice(R(m), 16, 8));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, if [PSTATE.GE[3]] == 0b1 then slice(R(n), 24, 8) else slice(R(m), 24, 8));
        R(d) = __tc4
    }
}

val SDIV_Op_A : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SDIV_Op_A (d, m, n) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        if SInt(R(m)) == 0 then {
            result = 0
        } else {
            result = RoundTowardsZero(Real(SInt(R(n))) / Real(SInt(R(m))))
        };
        R(d) = __GetSlice_int(32, result, 0)
    }
}

val SBFX_Op_A : forall 'd 'lsbit 'n 'widthminus1,
  ('n >= 0 & 'n <= 15 | not('lsbit + 'widthminus1 <= 31)) & ('lsbit + 'widthminus1 - 'lsbit + 1 >= 0 | not('lsbit + 'widthminus1 <= 31)) & ('d >= 0 & 'd <= 14 | not('lsbit + 'widthminus1 <= 31)).
  (int('d), int('lsbit), int('n), int('widthminus1)) -> unit effect {escape, rreg, undef, wreg}

function SBFX_Op_A (d, lsbit, n, widthminus1) = {
    if ConditionPassed() then {
        let msbit = lsbit + widthminus1;
        if msbit <= 31 then {
            R(d) = SignExtend(slice(R(n), lsbit, msbit - lsbit + 1), 32)
        } else {
            throw(Error_Unpredictable())
        }
    }
}

val SBC_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function SBC_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), ~(shifted), PSTATE.C);
        R(d) = result;
        if setflags then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
        }
    }
}

val SASX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SASX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        sum : int = undefined : int;
        diff = SInt(slice(R(n), 0, 16)) - SInt(slice(R(m), 16, 16));
        sum = SInt(slice(R(n), 16, 16)) + SInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, diff, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if diff >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if sum >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val SADD8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SADD8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum3 : int = undefined : int;
        sum4 : int = undefined : int;
        sum1 = SInt(slice(R(n), 0, 8)) + SInt(slice(R(m), 0, 8));
        sum2 = SInt(slice(R(n), 8, 8)) + SInt(slice(R(m), 8, 8));
        sum3 = SInt(slice(R(n), 16, 8)) + SInt(slice(R(m), 16, 8));
        sum4 = SInt(slice(R(n), 24, 8)) + SInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, __GetSlice_int(8, sum1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, __GetSlice_int(8, sum2, 0));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, __GetSlice_int(8, sum3, 0));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, __GetSlice_int(8, sum4, 0));
        R(d) = __tc4;
        __tc5 : bits(4) = PSTATE.GE;
        __tc5 = __SetSlice_bits(4, 1, __tc5, 0, if sum1 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc5;
        __tc6 : bits(4) = PSTATE.GE;
        __tc6 = __SetSlice_bits(4, 1, __tc6, 1, if sum2 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc6;
        __tc7 : bits(4) = PSTATE.GE;
        __tc7 = __SetSlice_bits(4, 1, __tc7, 2, if sum3 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc7;
        __tc8 : bits(4) = PSTATE.GE;
        __tc8 = __SetSlice_bits(4, 1, __tc8, 3, if sum4 >= 0 then 0b1 else 0b0);
        PSTATE.GE = __tc8
    }
}

val SADD16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SADD16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum1 = SInt(slice(R(n), 0, 16)) + SInt(slice(R(m), 0, 16));
        sum2 = SInt(slice(R(n), 16, 16)) + SInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, __GetSlice_int(16, sum1, 0));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, __GetSlice_int(16, sum2, 0));
        R(d) = __tc2;
        __tc3 : bits(4) = PSTATE.GE;
        __tc3 = __SetSlice_bits(4, 2, __tc3, 0, if sum1 >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc3;
        __tc4 : bits(4) = PSTATE.GE;
        __tc4 = __SetSlice_bits(4, 2, __tc4, 2, if sum2 >= 0 then 0b11 else 0b00);
        PSTATE.GE = __tc4
    }
}

val RSC_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function RSC_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(~(R(n)), shifted, PSTATE.C);
        R(d) = result;
        if setflags then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
        }
    }
}

val RSB_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function RSB_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(~(R(n)), shifted, 0b1);
        R(d) = result;
        if setflags then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
        }
    }
}

val ROR_r_Op_A : forall 'd 'm 'n ('setflags : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ROR_r_Op_A (d, m, n, setflags) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        let shift_n = UInt(slice(R(m), 0, 8));
        (result, carry) = Shift_C(R(n), SRType_ROR, shift_n, PSTATE.C);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val REVSH_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function REVSH_Op_A (d, m) = {
    if ConditionPassed() then {
        result : bits(32) = undefined : bits(32);
        result = __SetSlice_bits(32, 24, result, 8, SignExtend(slice(R(m), 0, 8), 24));
        result = __SetSlice_bits(32, 8, result, 0, slice(R(m), 8, 8));
        R(d) = result
    }
}

val REV16_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function REV16_Op_A (d, m) = {
    if ConditionPassed() then {
        result : bits(32) = undefined : bits(32);
        result = __SetSlice_bits(32, 8, result, 24, slice(R(m), 16, 8));
        result = __SetSlice_bits(32, 8, result, 16, slice(R(m), 24, 8));
        result = __SetSlice_bits(32, 8, result, 8, slice(R(m), 0, 8));
        result = __SetSlice_bits(32, 8, result, 0, slice(R(m), 8, 8));
        R(d) = result
    }
}

val REV_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function REV_Op_A (d, m) = {
    if ConditionPassed() then {
        result : bits(32) = undefined : bits(32);
        result = __SetSlice_bits(32, 8, result, 24, slice(R(m), 0, 8));
        result = __SetSlice_bits(32, 8, result, 16, slice(R(m), 8, 8));
        result = __SetSlice_bits(32, 8, result, 8, slice(R(m), 16, 8));
        result = __SetSlice_bits(32, 8, result, 0, slice(R(m), 24, 8));
        R(d) = result
    }
}

val RBIT_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function RBIT_Op_A (d, m) = {
    if ConditionPassed() then {
        result : bits(32) = undefined : bits(32);
        foreach (i from 0 to 31 by 1 in inc) {
            result = __SetSlice_bits(32, 1, result, 31 - i, [R(m)[i]])
        };
        R(d) = result
    }
}

val QSUB8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QSUB8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff3 : int = undefined : int;
        diff4 : int = undefined : int;
        diff1 = SInt(slice(R(n), 0, 8)) - SInt(slice(R(m), 0, 8));
        diff2 = SInt(slice(R(n), 8, 8)) - SInt(slice(R(m), 8, 8));
        diff3 = SInt(slice(R(n), 16, 8)) - SInt(slice(R(m), 16, 8));
        diff4 = SInt(slice(R(n), 24, 8)) - SInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, SignedSat(diff1, 8));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, SignedSat(diff2, 8));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, SignedSat(diff3, 8));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, SignedSat(diff4, 8));
        R(d) = __tc4
    }
}

val QSUB16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QSUB16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff1 : int = undefined : int;
        diff2 : int = undefined : int;
        diff1 = SInt(slice(R(n), 0, 16)) - SInt(slice(R(m), 0, 16));
        diff2 = SInt(slice(R(n), 16, 16)) - SInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, SignedSat(diff1, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, SignedSat(diff2, 16));
        R(d) = __tc2
    }
}

val QSUB_Op_A : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QSUB_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sat : bool = undefined : bool;
        __tc1 : bits(32) = undefined : bits(32);
        (__tc1, sat) = SignedSatQ(SInt(R(m)) - SInt(R(n)), 32);
        R(d) = __tc1;
        if sat then {
            PSTATE.Q = 0b1
        }
    }
}

val QSAX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QSAX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        let sum : int = SInt(slice(R(n), 0, 16)) + SInt(slice(R(m), 16, 16));
        diff = SInt(slice(R(n), 16, 16)) - SInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, SignedSat(sum, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, SignedSat(diff, 16));
        R(d) = __tc2
    }
}

val QDSUB_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QDSUB_Op_A (d, m, n) = {
    if ConditionPassed() then {
        doubled : bits(32) = undefined : bits(32);
        sat1 : bool = undefined : bool;
        sat2 : bool = undefined : bool;
        (doubled, sat1) = SignedSatQ(2 * SInt(R(n)), 32);
        __tc1 : bits(32) = undefined : bits(32);
        (__tc1, sat2) = SignedSatQ(SInt(R(m)) - SInt(doubled), 32);
        R(d) = __tc1;
        if sat1 | sat2 then {
            PSTATE.Q = 0b1
        }
    }
}

val QDADD_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QDADD_Op_A (d, m, n) = {
    if ConditionPassed() then {
        doubled : bits(32) = undefined : bits(32);
        sat1 : bool = undefined : bool;
        sat2 : bool = undefined : bool;
        (doubled, sat1) = SignedSatQ(2 * SInt(R(n)), 32);
        __tc1 : bits(32) = undefined : bits(32);
        (__tc1, sat2) = SignedSatQ(SInt(R(m)) + SInt(doubled), 32);
        R(d) = __tc1;
        if sat1 | sat2 then {
            PSTATE.Q = 0b1
        }
    }
}

val QASX_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QASX_Op_A (d, m, n) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        sum : int = undefined : int;
        diff = SInt(slice(R(n), 0, 16)) - SInt(slice(R(m), 16, 16));
        sum = SInt(slice(R(n), 16, 16)) + SInt(slice(R(m), 0, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, SignedSat(diff, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, SignedSat(sum, 16));
        R(d) = __tc2
    }
}

val QADD8_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QADD8_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum3 : int = undefined : int;
        sum4 : int = undefined : int;
        sum1 = SInt(slice(R(n), 0, 8)) + SInt(slice(R(m), 0, 8));
        sum2 = SInt(slice(R(n), 8, 8)) + SInt(slice(R(m), 8, 8));
        sum3 = SInt(slice(R(n), 16, 8)) + SInt(slice(R(m), 16, 8));
        sum4 = SInt(slice(R(n), 24, 8)) + SInt(slice(R(m), 24, 8));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 8, __tc1, 0, SignedSat(sum1, 8));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 8, __tc2, 8, SignedSat(sum2, 8));
        R(d) = __tc2;
        __tc3 : bits(32) = R(d);
        __tc3 = __SetSlice_bits(32, 8, __tc3, 16, SignedSat(sum3, 8));
        R(d) = __tc3;
        __tc4 : bits(32) = R(d);
        __tc4 = __SetSlice_bits(32, 8, __tc4, 24, SignedSat(sum4, 8));
        R(d) = __tc4
    }
}

val QADD16_Op_A : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & 'd <= 14.
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QADD16_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sum1 : int = undefined : int;
        sum2 : int = undefined : int;
        sum1 = SInt(slice(R(n), 0, 16)) + SInt(slice(R(m), 0, 16));
        sum2 = SInt(slice(R(n), 16, 16)) + SInt(slice(R(m), 16, 16));
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, SignedSat(sum1, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, SignedSat(sum2, 16));
        R(d) = __tc2
    }
}

val QADD_Op_A : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function QADD_Op_A (d, m, n) = {
    if ConditionPassed() then {
        sat : bool = undefined : bool;
        __tc1 : bits(32) = undefined : bits(32);
        (__tc1, sat) = SignedSatQ(SInt(R(m)) + SInt(R(n)), 32);
        R(d) = __tc1;
        if sat then {
            PSTATE.Q = 0b1
        }
    }
}

val PLI_r_Op_A : forall ('add : Bool) 'm 'n 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))).
  (bool('add), int('m), int('n), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function PLI_r_Op_A (add, m, n, shift_n, shift_t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        address = if add then R(n) + offset else R(n) - offset;
        Hint_PreloadInstr(address)
    }
}

val PLI_i_Op_A : forall ('add : Bool) 'n,
  ('n >= 0 & 'n <= 15 | not(not('n == 15))).
  (bool('add), bits(32), int('n)) -> unit effect {escape, rreg, undef, wreg}

function PLI_i_Op_A (add, imm32, n) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let base : bits(32) = if n == 15 then Align(get_PC(), 4) else R(n);
        address = if add then base + imm32 else base - imm32;
        Hint_PreloadInstr(address)
    }
}

val PLD_r_Op_A : forall ('add : Bool) ('is_pldw : Bool) 'm 'n 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))).
  (bool('add), bool('is_pldw), int('m), int('n), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function PLD_r_Op_A (add, is_pldw, m, n, shift_n, shift_t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        address = if add then R(n) + offset else R(n) - offset;
        if is_pldw then {
            Hint_PreloadDataForWrite(address)
        } else {
            Hint_PreloadData(address)
        }
    }
}

val PLD_i_Op_A : forall ('add : Bool) ('is_pldw : Bool) 'n,
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))).
  (bool('add), bits(32), bool('is_pldw), int('n)) -> unit effect {escape, rreg, undef, wreg}

function PLD_i_Op_A (add, imm32, is_pldw, n) = {
    if ConditionPassed() then {
        let address : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        if is_pldw then {
            Hint_PreloadDataForWrite(address)
        } else {
            Hint_PreloadData(address)
        }
    }
}

val PKH_Op_A : forall 'd 'm 'n 'shift_n ('tbform : Bool),
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 15) & ('n >= 0 & 'n <= 15 | not(not('tbform))) & 'd <= 14 & ('n >= 0 & 'n <= 15 | not('tbform)).
  (int('d), int('m), int('n), int('shift_n), SRType, bool('tbform)) -> unit effect {escape, rreg, undef, wreg}

function PKH_Op_A (d, m, n, shift_n, shift_t, tbform) = {
    if ConditionPassed() then {
        let operand2 : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 0, if tbform then slice(operand2, 0, 16) else slice(R(n), 0, 16));
        R(d) = __tc1;
        __tc2 : bits(32) = R(d);
        __tc2 = __SetSlice_bits(32, 16, __tc2, 16, if tbform then slice(R(n), 16, 16) else slice(operand2, 16, 16));
        R(d) = __tc2
    }
}

val ORR_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function ORR_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) | shifted;
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val ORN_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function ORN_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) | ~(shifted);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val ORN_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (bits(1), int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ORN_i_Op_A (carry, d, imm32, n, setflags) = {
    if ConditionPassed() then {
        let result : bits(32) = R(n) | ~(imm32);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val MVN_rr_Op_A : forall 'd 'm 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function MVN_rr_Op_A (d, m, s, setflags, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = ~(shifted);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val MUL_Op_A : forall 'd 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function MUL_Op_A (d, m, n, setflags) = {
    if ConditionPassed() then {
        operand1 : int = undefined : int;
        operand2 : int = undefined : int;
        result : int = undefined : int;
        operand1 = SInt(R(n));
        operand2 = SInt(R(m));
        result = operand1 * operand2;
        R(d) = __GetSlice_int(32, result, 0);
        if setflags then {
            PSTATE.N = __GetSlice_int(1, result, 31);
            PSTATE.Z = IsZeroBit(__GetSlice_int(32, result, 0))
        }
    }
}

val MOV_rr_Op_A : forall 'd 'm 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function MOV_rr_Op_A (d, m, s, setflags, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        let shift_n = UInt(slice(R(s), 0, 8));
        (result, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val MOVT_Op_A : forall ('d : Int), ('d >= 0 & 'd <= 15 & 'd <= 14).
  (int('d), bits(16)) -> unit effect {escape, rreg, undef, wreg}

function MOVT_Op_A (d, imm16) = {
    if ConditionPassed() then {
        __tc1 : bits(32) = R(d);
        __tc1 = __SetSlice_bits(32, 16, __tc1, 16, imm16);
        R(d) = __tc1
    }
}

val MLS_Op_A : forall 'a 'd 'm 'n,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('a >= 0 & 'a <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function MLS_Op_A (a, d, m, n) = {
    if ConditionPassed() then {
        addend : int = undefined : int;
        operand1 : int = undefined : int;
        operand2 : int = undefined : int;
        result : int = undefined : int;
        operand1 = SInt(R(n));
        operand2 = SInt(R(m));
        addend = SInt(R(a));
        result = addend - operand1 * operand2;
        R(d) = __GetSlice_int(32, result, 0)
    }
}

val MLA_Op_A : forall 'a 'd 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & ('a >= 0 & 'a <= 15) & ('d >= 0 & 'd <= 14).
  (int('a), int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function MLA_Op_A (a, d, m, n, setflags) = {
    if ConditionPassed() then {
        addend : int = undefined : int;
        operand1 : int = undefined : int;
        operand2 : int = undefined : int;
        result : int = undefined : int;
        operand1 = SInt(R(n));
        operand2 = SInt(R(m));
        addend = SInt(R(a));
        result = operand1 * operand2 + addend;
        R(d) = __GetSlice_int(32, result, 0);
        if setflags then {
            PSTATE.N = __GetSlice_int(1, result, 31);
            PSTATE.Z = IsZeroBit(__GetSlice_int(32, result, 0))
        }
    }
}

val LSR_r_Op_A : forall 'd 'm 'n ('setflags : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function LSR_r_Op_A (d, m, n, setflags) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        let shift_n = UInt(slice(R(m), 0, 8));
        (result, carry) = Shift_C(R(n), SRType_LSR, shift_n, PSTATE.C);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val LSL_r_Op_A : forall 'd 'm 'n ('setflags : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function LSL_r_Op_A (d, m, n, setflags) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        let shift_n = UInt(slice(R(m), 0, 8));
        (result, carry) = Shift_C(R(n), SRType_LSL, shift_n, PSTATE.C);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val EOR_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function EOR_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) ^ shifted;
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val CRC32_Op_A : forall ('crc32c : Bool) 'd 'm 'n 'size,
  ('n >= 0 & 'n <= 15) & ('m >= 0 & 'm <= 15) & 'size >= 0 & ('d >= 0 & 'd <= 14).
  (bool('crc32c), int('d), int('m), int('n), int('size)) -> unit effect {escape, rreg, undef, wreg}

function CRC32_Op_A (crc32c, d, m, n, size) = {
    if ConditionPassed() then {
        acc : bits(32) = undefined : bits(32);
        poly : bits(32) = undefined : bits(32);
        tempacc : bits('size + 32) = undefined : bits('size + 32);
        tempval : bits('size + 32) = undefined : bits('size + 32);
        val_name : bits('size) = undefined : bits('size);
        acc = R(n);
        val_name = slice(R(m), 0, size);
        poly = __GetSlice_int(32, if crc32c then 517762881 else 79764919, 0);
        tempacc = BitReverse(acc) @ Zeros(size);
        tempval = BitReverse(val_name) @ Zeros(32);
        R(d) = BitReverse(Poly32Mod2(tempacc ^ tempval, poly))
    }
}

val CMP_rr_Op_A : forall 'm 'n 's,
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('s), SRType) -> unit effect {escape, rreg, undef, wreg}

function CMP_rr_Op_A (m, n, s, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), ~(shifted), 0b1);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    }
}

val CMP_r_Op_A : forall 'm 'n 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function CMP_r_Op_A (m, n, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), ~(shifted), 0b1);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    }
}

val CMP_i_Op_A : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (bits(32), int('n)) -> unit effect {escape, rreg, undef, wreg}

function CMP_i_Op_A (imm32, n) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(R(n), ~(imm32), 0b1);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    }
}

val CMN_rr_Op_A : forall 'm 'n 's,
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('s), SRType) -> unit effect {escape, rreg, undef, wreg}

function CMN_rr_Op_A (m, n, s, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), shifted, 0b0);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    }
}

val CMN_r_Op_A : forall 'm 'n 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15).
  (int('m), int('n), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function CMN_r_Op_A (m, n, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), shifted, 0b0);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    }
}

val CMN_i_Op_A : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (bits(32), int('n)) -> unit effect {escape, rreg, undef, wreg}

function CMN_i_Op_A (imm32, n) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(R(n), imm32, 0b0);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    }
}

val CLZ_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function CLZ_Op_A (d, m) = {
    if ConditionPassed() then {
        let result : int = CountLeadingZeroBits(R(m));
        R(d) = __GetSlice_int(32, result, 0)
    }
}

val BIC_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function BIC_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) & ~(shifted);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val BFI_Op_A : forall 'd 'lsbit 'msbit 'n,
  ('d >= 0 & 'd <= 15 | not('msbit >= 'lsbit)) & ('n >= 0 & 'n <= 15 | not('msbit >= 'lsbit)) & ('d >= 0 & 'd <= 14 | not('msbit >= 'lsbit)).
  (int('d), int('lsbit), int('msbit), int('n)) -> unit effect {escape, rreg, undef, wreg}

function BFI_Op_A (d, lsbit, msbit, n) = {
    if ConditionPassed() then {
        if msbit >= lsbit then {
            __tc1 : bits(32) = R(d);
            __tc1 = __SetSlice_bits(32, msbit - lsbit + 1, __tc1, lsbit, slice(R(n), 0, msbit - lsbit + 1));
            R(d) = __tc1
        } else {
            throw(Error_Unpredictable())
        }
    }
}

val BFC_Op_A : forall 'd 'lsbit 'msbit,
  ('d >= 0 & 'd <= 15 | not('msbit >= 'lsbit)) & ('d >= 0 & 'd <= 14 | not('msbit >= 'lsbit)).
  (int('d), int('lsbit), int('msbit)) -> unit effect {escape, rreg, undef, wreg}

function BFC_Op_A (d, lsbit, msbit) = {
    if ConditionPassed() then {
        if msbit >= lsbit then {
            __tc1 : bits(32) = R(d);
            __tc1 = __SetSlice_bits(32, msbit - lsbit + 1, __tc1, lsbit, replicate_bits(0b0, msbit - lsbit + 1));
            R(d) = __tc1
        } else {
            throw(Error_Unpredictable())
        }
    }
}

val ASR_r_Op_A : forall 'd 'm 'n ('setflags : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ASR_r_Op_A (d, m, n, setflags) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        let shift_n = UInt(slice(R(m), 0, 8));
        (result, carry) = Shift_C(R(n), SRType_ASR, shift_n, PSTATE.C);
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val AND_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function AND_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) & shifted;
        R(d) = result;
        if setflags then {
            PSTATE.N = [result[31]];
            PSTATE.Z = IsZeroBit(result);
            PSTATE.C = carry
        }
    }
}

val ADD_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function ADD_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), shifted, 0b0);
        R(d) = result;
        if setflags then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
        }
    }
}

val ADD_i_OpT_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ADD_i_OpT_A (d, imm32, n, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(R(n), imm32, 0b0);
        R(d) = result;
        if setflags then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
        }
    }
}

val ADC_rr_Op_A : forall 'd 'm 'n 's ('setflags : Bool),
  ('s >= 0 & 's <= 15) & ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('m), int('n), int('s), bool('setflags), SRType) -> unit effect {escape, rreg, undef, wreg}

function ADC_rr_Op_A (d, m, n, s, setflags, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        shift_n : int = undefined : int;
        shifted : bits(32) = undefined : bits(32);
        shift_n = UInt(slice(R(s), 0, 8));
        shifted = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), shifted, PSTATE.C);
        R(d) = result;
        if setflags then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
        }
    }
}

val AArch32_SysRegWrite64 : forall ('cp_num : Int).
  (int('cp_num), bits(32), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_SysRegWrite64 (cp_num, instr, val_name) = {
    __anon1 : bool = undefined : bool;
    el : bits(2) = undefined : bits(2);
    (__anon1, el) = ELFromM32(PSTATE.M);
    let opc1 = slice(instr, 4, 4);
    let CRm = slice(instr, 0, 4);
    AArch32_AutoGen_SysRegWrite64(el, __GetSlice_int(4, cp_num, 0), opc1, CRm, 0b0, val_name);
    return()
}

val AArch32_SysRegRead64 : forall ('cp_num : Int).
  (int('cp_num), bits(32)) -> bits(64) effect {escape, rreg, undef}

function AArch32_SysRegRead64 (cp_num, instr) = {
    __anon1 : bool = undefined : bool;
    el : bits(2) = undefined : bits(2);
    (__anon1, el) = ELFromM32(PSTATE.M);
    let opc1 = slice(instr, 4, 4);
    let CRm = slice(instr, 0, 4);
    AArch32_AutoGen_SysRegRead64(el, __GetSlice_int(4, cp_num, 0), opc1, CRm, 0b1)
}

val AArch64_CheckCP15InstrCoarseTraps : forall ('CRn : Int) ('nreg : Int) ('CRm : Int).
  (int('CRn), int('nreg), int('CRm)) -> bool effect {escape, rreg, undef}

function AArch64_CheckCP15InstrCoarseTraps (CRn, nreg, CRm) = {
    major : int = undefined : int;
    if EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
        major = if nreg == 1 then CRn else CRm;
        if (~(IsInHost()) & ~(major == 4 | major == 14)) & [HSTR_EL2[major]] == 0b1 then {
            return(true)
        };
        if ([HCR_EL2[20]] == 0b1 & nreg == 1) & ((CRn == 9 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8) | CRn == 10 & (CRm == 0 | CRm == 1 | CRm == 4 | CRm == 8)) | CRn == 11 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 3 | CRm == 4 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8 | CRm == 15)) then {
            return(true)
        }
    };
    false
}

val BranchWritePC : (bits(32), BranchType) -> unit effect {escape, rreg, undef, wreg}

function BranchWritePC (address__arg, branch_type) = {
    address = address__arg;
    if CurrentInstrSet() == InstrSet_A32 then {
        address = __SetSlice_bits(32, 2, address, 0, 0b00)
    } else {
        address = __SetSlice_bits(32, 1, address, 0, 0b0)
    };
    BranchTo(address, branch_type)
}

val CBNZ_Op_A : forall ('n : Int), (0 <= 'n & 'n <= 15).
  (bits(32), int('n), bool) -> unit effect {escape, rreg, undef, wreg}

function CBNZ_Op_A (imm32, n, nonzero) = {
    if nonzero != IsZero(aget_R(n)) then {
        BranchWritePC(get_PC() + imm32, BranchType_DIR)
    }
}

val BL_i_Op_A : (bits(32), InstrSet) -> unit effect {escape, rreg, undef, wreg}

function BL_i_Op_A (imm32, targetInstrSet) = {
    if ConditionPassed() then {
        targetAddress : bits(32) = undefined : bits(32);
        if CurrentInstrSet() == InstrSet_A32 then {
            set_LR(get_PC() - 4)
        } else {
            set_LR(slice(get_PC(), 1, 31) @ 0b1)
        };
        if targetInstrSet == InstrSet_A32 then {
            targetAddress = Align(get_PC(), 4) + imm32
        } else {
            targetAddress = get_PC() + imm32
        };
        SelectInstrSet(targetInstrSet);
        BranchWritePC(targetAddress, BranchType_DIRCALL)
    }
}

val B_Op_A : bits(32) -> unit effect {escape, rreg, undef, wreg}

function B_Op_A imm32 = {
    if ConditionPassed() then {
        BranchWritePC(get_PC() + imm32, BranchType_DIR)
    }
}

val BXWritePC : (bits(32), BranchType) -> unit effect {escape, rreg, undef, wreg}

function BXWritePC (address__arg, branch_type) = {
    address = address__arg;
    if [address[0]] == 0b1 then {
        SelectInstrSet(InstrSet_T32);
        address = __SetSlice_bits(32, 1, address, 0, 0b0)
    } else {
        SelectInstrSet(InstrSet_A32);
        if [address[1]] == 0b1 & ConstrainUnpredictableBool(Unpredictable_A32FORCEALIGNPC) then {
            address = __SetSlice_bits(32, 1, address, 1, 0b0)
        }
    };
    BranchTo(address, branch_type)
}

val LoadWritePC : bits(32) -> unit effect {escape, rreg, undef, wreg}

function LoadWritePC address = {
    BXWritePC(address, BranchType_INDIR)
}

val BXJ_Op_A : forall ('m : Int), ('m >= 0 & 'm <= 15).
  int('m) -> unit effect {escape, rreg, undef, wreg}

function BXJ_Op_A m = {
    if ConditionPassed() then {
        BXWritePC(R(m), BranchType_INDIR)
    }
}

val BX_Op_A : forall ('m : Int), ('m >= 0 & 'm <= 15).
  int('m) -> unit effect {escape, rreg, undef, wreg}

function BX_Op_A m = {
    if ConditionPassed() then {
        BXWritePC(R(m), BranchType_INDIR)
    }
}

val BLX_r_Op_A : forall ('m : Int), ('m >= 0 & 'm <= 15).
  int('m) -> unit effect {escape, rreg, undef, wreg}

function BLX_r_Op_A m = {
    if ConditionPassed() then {
        next_instr_addr : bits(32) = undefined : bits(32);
        let target : bits(32) = R(m);
        if CurrentInstrSet() == InstrSet_A32 then {
            next_instr_addr = get_PC() - 4;
            set_LR(next_instr_addr)
        } else {
            next_instr_addr = get_PC() - 2;
            set_LR(slice(next_instr_addr, 1, 31) @ 0b1)
        };
        BXWritePC(target, BranchType_INDCALL)
    }
}

val ALUWritePC : bits(32) -> unit effect {escape, rreg, undef, wreg}

function ALUWritePC address = {
    if CurrentInstrSet() == InstrSet_A32 then {
        BXWritePC(address, BranchType_INDIR)
    } else {
        BranchWritePC(address, BranchType_INDIR)
    }
}

val LSR_i_Op_A : forall 'd 'm ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), bool('setflags), int('shift_n)) -> unit effect {escape, rreg, undef, wreg}

function LSR_i_Op_A (d, m, setflags, shift_n) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        (result, carry) = Shift_C(R(m), SRType_LSR, shift_n, PSTATE.C);
        if d == 15 then {
            ALUWritePC(result)
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val LSL_i_Op_A : forall 'd 'm ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), bool('setflags), int('shift_n)) -> unit effect {escape, rreg, undef, wreg}

function LSL_i_Op_A (d, m, setflags, shift_n) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        (result, carry) = Shift_C(R(m), SRType_LSL, shift_n, PSTATE.C);
        if d == 15 then {
            ALUWritePC(result)
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val ASR_i_Op_A : forall 'd 'm ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), bool('setflags), int('shift_n)) -> unit effect {escape, rreg, undef, wreg}

function ASR_i_Op_A (d, m, setflags, shift_n) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        (result, carry) = Shift_C(R(m), SRType_ASR, shift_n, PSTATE.C);
        if d == 15 then {
            ALUWritePC(result)
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val ADR_Op_A : forall ('add : Bool) 'd,
  ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (bool('add), int('d), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function ADR_Op_A (add, d, imm32) = {
    if ConditionPassed() then {
        let result = if add then Align(get_PC(), 4) + imm32 else Align(get_PC(), 4) - imm32;
        if d == 15 then {
            ALUWritePC(result)
        } else {
            R(d) = result
        }
    }
}

val AArch64_MonitorModeTrap : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_MonitorModeTrap () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    let exception = ExceptionSyndrome(Exception_Uncategorized);
    if IsSecureEL2Enabled() then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    };
    AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
}

val MSR_br_Op_AS : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (bits(5), int('n), bool) -> unit effect {escape, rreg, undef, wreg}

function MSR_br_Op_AS (SYSm, n, write_spsr) = {
    if ConditionPassed() then {
        mode : bits(5) = undefined : bits(5);
        if PSTATE.EL == EL0 then {
            throw(Error_Unpredictable())
        } else {
            mode = PSTATE.M;
            if write_spsr then {
                SPSRaccessValid(SYSm, mode);
                match SYSm {
                  0b01110 => {
                      SPSR_fiq = aget_R(n)
                  },
                  0b10000 => {
                      SPSR_irq = aget_R(n)
                  },
                  0b10010 => {
                      set_SPSR_svc(aget_R(n))
                  },
                  0b10100 => {
                      SPSR_abt = aget_R(n)
                  },
                  0b10110 => {
                      SPSR_und = aget_R(n)
                  },
                  0b11100 => {
                      if ~(ELUsingAArch32(EL3)) then {
                          AArch64_MonitorModeTrap()
                      };
                      set_SPSR_mon(aget_R(n))
                  },
                  0b11110 => {
                      set_SPSR_hyp(aget_R(n))
                  }
                }
            } else {
                BankedRegisterAccessValid(SYSm, mode);
                match SYSm {
                  [bitzero] @ [bitzero] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
                      let m = UInt(slice(SYSm, 0, 3)) + 8;
                      assert(0 <= m & m <= 14);
                      aset_Rmode(m, M32_User, aget_R(n))
                  },
                  [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
                      let m = UInt(slice(SYSm, 0, 3)) + 8;
                      assert(0 <= m & m <= 14);
                      aset_Rmode(m, M32_FIQ, aget_R(n))
                  },
                  [bitone] @ [bitzero] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_Rmode(m, M32_IRQ, aget_R(n))
                  },
                  [bitone] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_Rmode(m, M32_Svc, aget_R(n))
                  },
                  [bitone] @ [bitzero] @ [bitone] @ [bitzero] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_Rmode(m, M32_Abort, aget_R(n))
                  },
                  [bitone] @ [bitzero] @ [bitone] @ [bitone] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_Rmode(m, M32_Undef, aget_R(n))
                  },
                  [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
                      if ~(ELUsingAArch32(EL3)) then {
                          AArch64_MonitorModeTrap()
                      };
                      let m = 14 - UInt([SYSm[0]]);
                      aset_Rmode(m, M32_Monitor, aget_R(n))
                  },
                  0b11110 => {
                      set_ELR_hyp(aget_R(n))
                  },
                  0b11111 => {
                      aset_Rmode(13, M32_Hyp, aget_R(n))
                  }
                }
            }
        }
    }
}

val MRS_br_Op_AS : forall ('d : Int), ('d >= 0 & 'd <= 14).
  (bits(5), int('d), bool) -> unit effect {escape, rreg, undef, wreg}

function MRS_br_Op_AS (SYSm, d, read_spsr) = {
    if ConditionPassed() then {
        mode : bits(5) = undefined : bits(5);
        if PSTATE.EL == EL0 then {
            throw(Error_Unpredictable())
        } else {
            mode = PSTATE.M;
            if read_spsr then {
                SPSRaccessValid(SYSm, mode);
                match SYSm {
                  0b01110 => {
                      aset_R(d, SPSR_fiq)
                  },
                  0b10000 => {
                      aset_R(d, SPSR_irq)
                  },
                  0b10010 => {
                      aset_R(d, get_SPSR_svc())
                  },
                  0b10100 => {
                      aset_R(d, SPSR_abt)
                  },
                  0b10110 => {
                      aset_R(d, SPSR_und)
                  },
                  0b11100 => {
                      if ~(ELUsingAArch32(EL3)) then {
                          AArch64_MonitorModeTrap()
                      };
                      aset_R(d, get_SPSR_mon())
                  },
                  0b11110 => {
                      aset_R(d, get_SPSR_hyp())
                  }
                }
            } else {
                BankedRegisterAccessValid(SYSm, mode);
                match SYSm {
                  [bitzero] @ [bitzero] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
                      let m = UInt(slice(SYSm, 0, 3)) + 8;
                      assert(0 <= m & m <= 14);
                      aset_R(d, aget_Rmode(m, M32_User))
                  },
                  [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
                      let m = UInt(slice(SYSm, 0, 3)) + 8;
                      assert(0 <= m & m <= 14);
                      aset_R(d, aget_Rmode(m, M32_FIQ))
                  },
                  [bitone] @ [bitzero] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_R(d, aget_Rmode(m, M32_IRQ))
                  },
                  [bitone] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_R(d, aget_Rmode(m, M32_Svc))
                  },
                  [bitone] @ [bitzero] @ [bitone] @ [bitzero] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_R(d, aget_Rmode(m, M32_Abort))
                  },
                  [bitone] @ [bitzero] @ [bitone] @ [bitone] @ _ : bits(1) => {
                      let m = 14 - UInt([SYSm[0]]);
                      aset_R(d, aget_Rmode(m, M32_Undef))
                  },
                  [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
                      if ~(ELUsingAArch32(EL3)) then {
                          AArch64_MonitorModeTrap()
                      };
                      let m = 14 - UInt([SYSm[0]]);
                      aset_R(d, aget_Rmode(m, M32_Monitor))
                  },
                  0b11110 => {
                      aset_R(d, get_ELR_hyp())
                  },
                  0b11111 => {
                      aset_R(d, aget_Rmode(13, M32_Hyp))
                  }
                }
            }
        }
    }
}

val YIELD_T2_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function YIELD_T2_A_decode () = {
    __unconditional = false;
    __PostDecode();
    YIELD_Op_A()
}

val YIELD_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function YIELD_T1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    YIELD_Op_A()
}

val YIELD_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function YIELD_A1_A_decode cond = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    YIELD_Op_A()
}

val UXTH_T2_A_decode : (bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTH_T2_A_decode (Rd, rotate, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTH_Op_A(d, m, rotation)
}

val UXTH_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function UXTH_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = 0;
    __PostDecode();
    UXTH_Op_A(d, m, rotation)
}

val UXTH_A1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTH_A1_A_decode (cond, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTH_Op_A(d, m, rotation)
}

val UXTB16_T1_A_decode : (bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTB16_T1_A_decode (Rd, rotate, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTB16_Op_A(d, m, rotation)
}

val UXTB16_A1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTB16_A1_A_decode (cond, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTB16_Op_A(d, m, rotation)
}

val UXTB_T2_A_decode : (bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTB_T2_A_decode (Rd, rotate, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTB_Op_A(d, m, rotation)
}

val UXTB_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function UXTB_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = 0;
    __PostDecode();
    UXTB_Op_A(d, m, rotation)
}

val UXTB_A1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTB_A1_A_decode (cond, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTB_Op_A(d, m, rotation)
}

val UXTAH_T1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTAH_T1_A_decode (Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("UXTH"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTAH_Op_A(d, m, n, rotation)
}

val UXTAH_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTAH_A1_A_decode (cond, Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("UXTH"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTAH_Op_A(d, m, n, rotation)
}

val UXTAB16_T1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTAB16_T1_A_decode (Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("UXTB16"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTAB16_Op_A(d, m, n, rotation)
}

val UXTAB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTAB16_A1_A_decode (cond, Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("UXTB16"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTAB16_Op_A(d, m, n, rotation)
}

val UXTAB_T1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTAB_T1_A_decode (Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("UXTB"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTAB_Op_A(d, m, n, rotation)
}

val UXTAB_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UXTAB_A1_A_decode (cond, Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("UXTB"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UXTAB_Op_A(d, m, n, rotation)
}

val USUB8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USUB8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USUB8_Op_A(d, m, n)
}

val USUB8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USUB8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USUB8_Op_A(d, m, n)
}

val USUB16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USUB16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USUB16_Op_A(d, m, n)
}

val USUB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USUB16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USUB16_Op_A(d, m, n)
}

val USAX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USAX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAX_Op_A(d, m, n)
}

val USAX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USAX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAX_Op_A(d, m, n)
}

val USAT16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USAT16_T1_A_decode (Rn, Rd, sat_imm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAT16_Op_A(d, n, saturate_to)
}

val USAT16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USAT16_A1_A_decode (cond, sat_imm, Rd, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAT16_Op_A(d, n, saturate_to)
}

val USAT_T1_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function USAT_T1_A_decode (sh, Rn, imm3, Rd, imm2, sat_imm) = {
    __unconditional = false;
    if sh == 0b1 & (imm3 @ imm2) == 0b00000 then {
        throw(Error_See("USAT16"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(sh @ 0b0, imm3 @ imm2);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAT_Op_A(d, n, saturate_to, shift_n, shift_t)
}

val USAT_A1_A_decode : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USAT_A1_A_decode (cond, sat_imm, Rd, imm5, sh, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(sh @ 0b0, imm5);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAT_Op_A(d, n, saturate_to, shift_n, shift_t)
}

val USADA8_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USADA8_T1_A_decode (Rn, Ra, Rd, Rm) = {
    __unconditional = false;
    if Ra == 0xF then {
        throw(Error_See("USAD8"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USADA8_Op_A(a, d, m, n)
}

val USADA8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USADA8_A1_A_decode (cond, Rd, Ra, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Ra == 0xF then {
        throw(Error_See("USAD8"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USADA8_Op_A(a, d, m, n)
}

val USAD8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USAD8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAD8_Op_A(d, m, n)
}

val USAD8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function USAD8_A1_A_decode (cond, Rd, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    USAD8_Op_A(d, m, n)
}

val UQSUB8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQSUB8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQSUB8_Op_A(d, m, n)
}

val UQSUB8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQSUB8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQSUB8_Op_A(d, m, n)
}

val UQSUB16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQSUB16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQSUB16_Op_A(d, m, n)
}

val UQSUB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQSUB16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQSUB16_Op_A(d, m, n)
}

val UQSAX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQSAX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQSAX_Op_A(d, m, n)
}

val UQSAX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQSAX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQSAX_Op_A(d, m, n)
}

val UQASX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQASX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQASX_Op_A(d, m, n)
}

val UQASX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQASX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQASX_Op_A(d, m, n)
}

val UQADD8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQADD8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQADD8_Op_A(d, m, n)
}

val UQADD8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQADD8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQADD8_Op_A(d, m, n)
}

val UQADD16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQADD16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQADD16_Op_A(d, m, n)
}

val UQADD16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UQADD16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UQADD16_Op_A(d, m, n)
}

val UMULL_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UMULL_T1_A_decode (Rn, RdLo, RdHi, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = false;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UMULL_Op_A(dHi, dLo, m, n, setflags)
}

val UMULL_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UMULL_A1_A_decode (cond, S, RdHi, RdLo, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UMULL_Op_A(dHi, dLo, m, n, setflags)
}

val UMLAL_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UMLAL_T1_A_decode (Rn, RdLo, RdHi, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = false;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UMLAL_Op_A(dHi, dLo, m, n, setflags)
}

val UMLAL_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UMLAL_A1_A_decode (cond, S, RdHi, RdLo, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UMLAL_Op_A(dHi, dLo, m, n, setflags)
}

val UMAAL_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UMAAL_T1_A_decode (Rn, RdLo, RdHi, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UMAAL_Op_A(dHi, dLo, m, n)
}

val UMAAL_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UMAAL_A1_A_decode (cond, RdHi, RdLo, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UMAAL_Op_A(dHi, dLo, m, n)
}

val UHSUB8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHSUB8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHSUB8_Op_A(d, m, n)
}

val UHSUB8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHSUB8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHSUB8_Op_A(d, m, n)
}

val UHSUB16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHSUB16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHSUB16_Op_A(d, m, n)
}

val UHSUB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHSUB16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHSUB16_Op_A(d, m, n)
}

val UHSAX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHSAX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHSAX_Op_A(d, m, n)
}

val UHSAX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHSAX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHSAX_Op_A(d, m, n)
}

val UHASX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHASX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHASX_Op_A(d, m, n)
}

val UHASX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHASX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHASX_Op_A(d, m, n)
}

val UHADD8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHADD8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHADD8_Op_A(d, m, n)
}

val UHADD8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHADD8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHADD8_Op_A(d, m, n)
}

val UHADD16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHADD16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHADD16_Op_A(d, m, n)
}

val UHADD16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UHADD16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UHADD16_Op_A(d, m, n)
}

val UDIV_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UDIV_T1_A_decode (Rn, Ra, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if ((d == 15 | n == 15) | m == 15) | a != 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UDIV_Op_A(d, m, n)
}

val UDIV_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UDIV_A1_A_decode (cond, Rd, Ra, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if ((d == 15 | n == 15) | m == 15) | a != 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UDIV_Op_A(d, m, n)
}

val UDF_T2_A_decode : (bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function UDF_T2_A_decode (imm4, imm12) = {
    __unconditional = false;
    let imm32 = ZeroExtend(imm4 @ imm12, 32);
    __PostDecode();
    UDF_Op_A()
}

val UDF_T1_A_decode : bits(8) -> unit effect {escape, rreg, undef, wreg}

function UDF_T1_A_decode imm8 = {
    __unconditional = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    __PostDecode();
    UDF_Op_A()
}

val UDF_A1_A_decode : (bits(12), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UDF_A1_A_decode (imm12, imm4) = {
    __unconditional = false;
    let imm32 = ZeroExtend(imm12 @ imm4, 32);
    __PostDecode();
    UDF_Op_A()
}

val UBFX_T1_A_decode : (bits(4), bits(3), bits(4), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function UBFX_T1_A_decode (Rn, imm3, Rd, imm2, widthm1) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let lsbit = UInt(imm3 @ imm2);
    let widthminus1 = UInt(widthm1);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UBFX_Op_A(d, lsbit, n, widthminus1)
}

val UBFX_A1_A_decode : (bits(4), bits(5), bits(4), bits(5), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UBFX_A1_A_decode (cond, widthm1, Rd, lsb, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let lsbit = UInt(lsb);
    let widthminus1 = UInt(widthm1);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UBFX_Op_A(d, lsbit, n, widthminus1)
}

val UASX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UASX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UASX_Op_A(d, m, n)
}

val UASX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UASX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UASX_Op_A(d, m, n)
}

val UADD8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UADD8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UADD8_Op_A(d, m, n)
}

val UADD8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UADD8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UADD8_Op_A(d, m, n)
}

val UADD16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UADD16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UADD16_Op_A(d, m, n)
}

val UADD16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function UADD16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    UADD16_Op_A(d, m, n)
}

val TST_rr_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function TST_rr_A1_A_decode (cond, Rn, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let shift_t = DecodeRegShift(typ);
    if (n == 15 | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    TST_rr_Op_A(m, n, s, shift_t)
}

val TST_r_T2_A_decode : (bits(4), bits(3), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function TST_r_T2_A_decode (Rn, imm3, imm2, typ, Rm) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if n == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    TST_r_Op_A(m, n, shift_n, shift_t)
}

val TST_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function TST_r_T1_A_decode (Rm, Rn) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    TST_r_Op_A(m, n, shift_n, shift_t)
}

val TST_r_A1_A_decode : (bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function TST_r_A1_A_decode (cond, Rn, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    TST_r_Op_A(m, n, shift_n, shift_t)
}

val TST_i_T1_A_decode : (bits(1), bits(4), bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function TST_i_T1_A_decode (i, Rn, imm3, imm8) = {
    __unconditional = false;
    let n = UInt(Rn);
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    TST_i_Op_A(carry, imm32, n)
}

val TST_i_A1_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function TST_i_A1_A_decode (cond, Rn, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    TST_i_Op_A(carry, imm32, n)
}

val TEQ_rr_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function TEQ_rr_A1_A_decode (cond, Rn, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let shift_t = DecodeRegShift(typ);
    if (n == 15 | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    TEQ_rr_Op_A(m, n, s, shift_t)
}

val TEQ_r_T1_A_decode : (bits(4), bits(3), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function TEQ_r_T1_A_decode (Rn, imm3, imm2, typ, Rm) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if n == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    TEQ_r_Op_A(m, n, shift_n, shift_t)
}

val TEQ_r_A1_A_decode : (bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function TEQ_r_A1_A_decode (cond, Rn, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    TEQ_r_Op_A(m, n, shift_n, shift_t)
}

val TEQ_i_T1_A_decode : (bits(1), bits(4), bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function TEQ_i_T1_A_decode (i, Rn, imm3, imm8) = {
    __unconditional = false;
    let n = UInt(Rn);
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    TEQ_i_Op_A(carry, imm32, n)
}

val TEQ_i_A1_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function TEQ_i_A1_A_decode (cond, Rn, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    TEQ_i_Op_A(carry, imm32, n)
}

val SXTH_T2_A_decode : (bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTH_T2_A_decode (Rd, rotate, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTH_Op_A(d, m, rotation)
}

val SXTH_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function SXTH_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = 0;
    __PostDecode();
    SXTH_Op_A(d, m, rotation)
}

val SXTH_A1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTH_A1_A_decode (cond, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTH_Op_A(d, m, rotation)
}

val SXTB16_T1_A_decode : (bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTB16_T1_A_decode (Rd, rotate, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTB16_Op_A(d, m, rotation)
}

val SXTB16_A1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTB16_A1_A_decode (cond, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTB16_Op_A(d, m, rotation)
}

val SXTB_T2_A_decode : (bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTB_T2_A_decode (Rd, rotate, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTB_Op_A(d, m, rotation)
}

val SXTB_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function SXTB_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = 0;
    __PostDecode();
    SXTB_Op_A(d, m, rotation)
}

val SXTB_A1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTB_A1_A_decode (cond, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTB_Op_A(d, m, rotation)
}

val SXTAH_T1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTAH_T1_A_decode (Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("SXTH"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTAH_Op_A(d, m, n, rotation)
}

val SXTAH_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTAH_A1_A_decode (cond, Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("SXTH"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTAH_Op_A(d, m, n, rotation)
}

val SXTAB16_T1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTAB16_T1_A_decode (Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("SXTB16"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTAB16_Op_A(d, m, n, rotation)
}

val SXTAB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTAB16_A1_A_decode (cond, Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("SXTB16"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTAB16_Op_A(d, m, n, rotation)
}

val SXTAB_T1_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTAB_T1_A_decode (Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("SXTB"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTAB_Op_A(d, m, n, rotation)
}

val SXTAB_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SXTAB_A1_A_decode (cond, Rn, Rd, rotate, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("SXTB"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let rotation = UInt(rotate @ 0b000);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SXTAB_Op_A(d, m, n, rotation)
}

val SUB_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SUB_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUB_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val SSUB8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSUB8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSUB8_Op_A(d, m, n)
}

val SSUB8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSUB8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSUB8_Op_A(d, m, n)
}

val SSUB16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSUB16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSUB16_Op_A(d, m, n)
}

val SSUB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSUB16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSUB16_Op_A(d, m, n)
}

val SSAX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSAX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSAX_Op_A(d, m, n)
}

val SSAX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSAX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSAX_Op_A(d, m, n)
}

val SSAT16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSAT16_T1_A_decode (Rn, Rd, sat_imm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm) + 1;
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSAT16_Op_A(d, n, saturate_to)
}

val SSAT16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSAT16_A1_A_decode (cond, sat_imm, Rd, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm) + 1;
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSAT16_Op_A(d, n, saturate_to)
}

val SSAT_T1_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function SSAT_T1_A_decode (sh, Rn, imm3, Rd, imm2, sat_imm) = {
    __unconditional = false;
    if sh == 0b1 & (imm3 @ imm2) == 0b00000 then {
        throw(Error_See("SSAT16"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm) + 1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(sh @ 0b0, imm3 @ imm2);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSAT_Op_A(d, n, saturate_to, shift_n, shift_t)
}

val SSAT_A1_A_decode : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SSAT_A1_A_decode (cond, sat_imm, Rd, imm5, sh, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let saturate_to = UInt(sat_imm) + 1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(sh @ 0b0, imm5);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SSAT_Op_A(d, n, saturate_to, shift_n, shift_t)
}

val SMUSD_T1_A_decode : (bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMUSD_T1_A_decode (Rn, Rd, M, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMUSD_Op_A(d, m, m_swap, n)
}

val SMUSD_A1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMUSD_A1_A_decode (cond, Rd, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMUSD_Op_A(d, m, m_swap, n)
}

val SMULWB_T1_A_decode : (bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMULWB_T1_A_decode (Rn, Rd, M, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_high = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMULWB_Op_A(d, m, m_high, n)
}

val SMULWB_A1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMULWB_A1_A_decode (cond, Rd, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_high = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMULWB_Op_A(d, m, m_high, n)
}

val SMULL_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMULL_T1_A_decode (Rn, RdLo, RdHi, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = false;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMULL_Op_A(dHi, dLo, m, n, setflags)
}

val SMULL_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMULL_A1_A_decode (cond, S, RdHi, RdLo, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMULL_Op_A(dHi, dLo, m, n, setflags)
}

val SMULBB_T1_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMULBB_T1_A_decode (Rn, Rd, N, M, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let n_high = N == 0b1;
    let m_high = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMULBB_Op_A(d, m, m_high, n, n_high)
}

val SMULBB_A1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMULBB_A1_A_decode (cond, Rd, Rm, M, N, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let n_high = N == 0b1;
    let m_high = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMULBB_Op_A(d, m, m_high, n, n_high)
}

val SMUAD_T1_A_decode : (bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMUAD_T1_A_decode (Rn, Rd, M, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMUAD_Op_A(d, m, m_swap, n)
}

val SMUAD_A1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMUAD_A1_A_decode (cond, Rd, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMUAD_Op_A(d, m, m_swap, n)
}

val SMMUL_T1_A_decode : (bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMMUL_T1_A_decode (Rn, Rd, R, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let round = R == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMMUL_Op_A(d, m, n, round)
}

val SMMUL_A1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMMUL_A1_A_decode (cond, Rd, Rm, R, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let round = R == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMMUL_Op_A(d, m, n, round)
}

val SMMLS_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMMLS_T1_A_decode (Rn, Ra, Rd, R, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let round = R == 0b1;
    if ((d == 15 | n == 15) | m == 15) | a == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMMLS_Op_A(a, d, m, n, round)
}

val SMMLS_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMMLS_A1_A_decode (cond, Rd, Ra, Rm, R, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let round = R == 0b1;
    if ((d == 15 | n == 15) | m == 15) | a == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMMLS_Op_A(a, d, m, n, round)
}

val SMMLA_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMMLA_T1_A_decode (Rn, Ra, Rd, R, Rm) = {
    __unconditional = false;
    if Ra == 0xF then {
        throw(Error_See("SMMUL"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let round = R == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMMLA_Op_A(a, d, m, n, round)
}

val SMMLA_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMMLA_A1_A_decode (cond, Rd, Ra, Rm, R, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Ra == 0xF then {
        throw(Error_See("SMMUL"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let round = R == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMMLA_Op_A(a, d, m, n, round)
}

val SMLSLD_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLSLD_T1_A_decode (Rn, RdLo, RdHi, M, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLSLD_Op_A(dHi, dLo, m, m_swap, n)
}

val SMLSLD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLSLD_A1_A_decode (cond, RdHi, RdLo, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLSLD_Op_A(dHi, dLo, m, m_swap, n)
}

val SMLSD_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLSD_T1_A_decode (Rn, Ra, Rd, M, Rm) = {
    __unconditional = false;
    if Ra == 0xF then {
        throw(Error_See("SMUSD"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLSD_Op_A(a, d, m, m_swap, n)
}

val SMLSD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLSD_A1_A_decode (cond, Rd, Ra, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Ra == 0xF then {
        throw(Error_See("SMUSD"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLSD_Op_A(a, d, m, m_swap, n)
}

val SMLAWB_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLAWB_T1_A_decode (Rn, Ra, Rd, M, Rm) = {
    __unconditional = false;
    if Ra == 0xF then {
        throw(Error_See("SMULWB, SMULWT"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let m_high = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLAWB_Op_A(a, d, m, m_high, n)
}

val SMLAWB_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLAWB_A1_A_decode (cond, Rd, Ra, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let m_high = M == 0b1;
    if ((d == 15 | n == 15) | m == 15) | a == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLAWB_Op_A(a, d, m, m_high, n)
}

val SMLALD_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLALD_T1_A_decode (Rn, RdLo, RdHi, M, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLALD_Op_A(dHi, dLo, m, m_swap, n)
}

val SMLALD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLALD_A1_A_decode (cond, RdHi, RdLo, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let m_swap = M == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLALD_Op_A(dHi, dLo, m, m_swap, n)
}

val SMLALBB_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLALBB_T1_A_decode (Rn, RdLo, RdHi, N, M, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let n_high = N == 0b1;
    let m_high = M == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLALBB_Op_A(dHi, dLo, m, m_high, n, n_high)
}

val SMLALBB_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLALBB_A1_A_decode (cond, RdHi, RdLo, Rm, M, N, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let n_high = N == 0b1;
    let m_high = M == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLALBB_Op_A(dHi, dLo, m, m_high, n, n_high)
}

val SMLAL_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLAL_T1_A_decode (Rn, RdLo, RdHi, Rm) = {
    __unconditional = false;
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = false;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLAL_Op_A(dHi, dLo, m, n, setflags)
}

val SMLAL_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLAL_A1_A_decode (cond, S, RdHi, RdLo, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let dLo = UInt(RdLo);
    let dHi = UInt(RdHi);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    if ((dLo == 15 | dHi == 15) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if dHi == dLo then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLAL_Op_A(dHi, dLo, m, n, setflags)
}

val SMLAD_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLAD_T1_A_decode (Rn, Ra, Rd, M, Rm) = {
    __unconditional = false;
    if Ra == 0xF then {
        throw(Error_See("SMUAD"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLAD_Op_A(a, d, m, m_swap, n)
}

val SMLAD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLAD_A1_A_decode (cond, Rd, Ra, Rm, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Ra == 0xF then {
        throw(Error_See("SMUAD"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let m_swap = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLAD_Op_A(a, d, m, m_swap, n)
}

val SMLABB_T1_A_decode : (bits(4), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLABB_T1_A_decode (Rn, Ra, Rd, N, M, Rm) = {
    __unconditional = false;
    if Ra == 0xF then {
        throw(Error_See("SMULBB, SMULBT, SMULTB, SMULTT"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let n_high = N == 0b1;
    let m_high = M == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLABB_Op_A(a, d, m, m_high, n, n_high)
}

val SMLABB_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMLABB_A1_A_decode (cond, Rd, Ra, Rm, M, N, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let n_high = N == 0b1;
    let m_high = M == 0b1;
    if ((d == 15 | n == 15) | m == 15) | a == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMLABB_Op_A(a, d, m, m_high, n, n_high)
}

val SHSUB8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHSUB8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHSUB8_Op_A(d, m, n)
}

val SHSUB8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHSUB8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHSUB8_Op_A(d, m, n)
}

val SHSUB16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHSUB16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHSUB16_Op_A(d, m, n)
}

val SHSUB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHSUB16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHSUB16_Op_A(d, m, n)
}

val SHSAX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHSAX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHSAX_Op_A(d, m, n)
}

val SHSAX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHSAX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHSAX_Op_A(d, m, n)
}

val SHASX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHASX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHASX_Op_A(d, m, n)
}

val SHASX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHASX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHASX_Op_A(d, m, n)
}

val SHADD8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHADD8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHADD8_Op_A(d, m, n)
}

val SHADD8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHADD8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHADD8_Op_A(d, m, n)
}

val SHADD16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHADD16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHADD16_Op_A(d, m, n)
}

val SHADD16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHADD16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SHADD16_Op_A(d, m, n)
}

val SEVL_T2_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function SEVL_T2_A_decode () = {
    __unconditional = false;
    __PostDecode();
    SEVL_Op_A()
}

val SEVL_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function SEVL_T1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    SEVL_Op_A()
}

val SEVL_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function SEVL_A1_A_decode cond = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    SEVL_Op_A()
}

val SEV_T2_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function SEV_T2_A_decode () = {
    __unconditional = false;
    __PostDecode();
    SEV_Op_A()
}

val SEV_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function SEV_T1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    SEV_Op_A()
}

val SEV_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function SEV_A1_A_decode cond = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    SEV_Op_A()
}

val SETPAN_T1_A_decode : bits(1) -> unit effect {escape, rreg, undef, wreg}

function SETPAN_T1_A_decode imm1 = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HavePANExt()) then {
        throw(Error_Undefined())
    };
    let value_name : bits(1) = imm1;
    __PostDecode();
    SETPAN_Op_A(value_name)
}

val SETPAN_A1_A_decode : bits(1) -> unit effect {escape, rreg, undef, wreg}

function SETPAN_A1_A_decode imm1 = {
    __unconditional = true;
    if ~(HavePANExt()) then {
        throw(Error_Undefined())
    };
    let value_name : bits(1) = imm1;
    __PostDecode();
    SETPAN_Op_A(value_name)
}

val SETEND_T1_A_decode : bits(1) -> unit effect {escape, rreg, undef, wreg}

function SETEND_T1_A_decode E = {
    __unconditional = true;
    let set_bigend : bool = E == 0b1;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SETEND_Op_A(set_bigend)
}

val SETEND_A1_A_decode : bits(1) -> unit effect {escape, rreg, undef, wreg}

function SETEND_A1_A_decode E = {
    __unconditional = true;
    let set_bigend : bool = E == 0b1;
    __PostDecode();
    SETEND_Op_A(set_bigend)
}

val SEL_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SEL_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SEL_Op_A(d, m, n)
}

val SEL_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SEL_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SEL_Op_A(d, m, n)
}

val SDIV_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SDIV_T1_A_decode (Rn, Ra, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if ((d == 15 | n == 15) | m == 15) | a != 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SDIV_Op_A(d, m, n)
}

val SDIV_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SDIV_A1_A_decode (cond, Rd, Ra, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if ((d == 15 | n == 15) | m == 15) | a != 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SDIV_Op_A(d, m, n)
}

val SBFX_T1_A_decode : (bits(4), bits(3), bits(4), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function SBFX_T1_A_decode (Rn, imm3, Rd, imm2, widthm1) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let lsbit = UInt(imm3 @ imm2);
    let widthminus1 = UInt(widthm1);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SBFX_Op_A(d, lsbit, n, widthminus1)
}

val SBFX_A1_A_decode : (bits(4), bits(5), bits(4), bits(5), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SBFX_A1_A_decode (cond, widthm1, Rd, lsb, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let lsbit = UInt(lsb);
    let widthminus1 = UInt(widthm1);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SBFX_Op_A(d, lsbit, n, widthminus1)
}

val SBC_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SBC_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SBC_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val SB_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function SB_T1_A_decode () = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SB_Op_A()
}

val SB_A1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function SB_A1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    SB_Op_A()
}

val SASX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SASX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SASX_Op_A(d, m, n)
}

val SASX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SASX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SASX_Op_A(d, m, n)
}

val SADD8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SADD8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SADD8_Op_A(d, m, n)
}

val SADD8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SADD8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SADD8_Op_A(d, m, n)
}

val SADD16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SADD16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SADD16_Op_A(d, m, n)
}

val SADD16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SADD16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SADD16_Op_A(d, m, n)
}

val RSC_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function RSC_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RSC_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val RSB_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function RSB_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RSB_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val ROR_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ROR_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    __PostDecode();
    ROR_r_Op_A(d, m, n, setflags)
}

val REVSH_T2_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function REVSH_T2_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let n = UInt(Rn);
    if (m != n | d == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    REVSH_Op_A(d, m)
}

val REVSH_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function REVSH_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    __PostDecode();
    REVSH_Op_A(d, m)
}

val REVSH_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function REVSH_A1_A_decode (cond, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    REVSH_Op_A(d, m)
}

val REV16_T2_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function REV16_T2_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let n = UInt(Rn);
    if (m != n | d == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    REV16_Op_A(d, m)
}

val REV16_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function REV16_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    __PostDecode();
    REV16_Op_A(d, m)
}

val REV16_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function REV16_A1_A_decode (cond, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    REV16_Op_A(d, m)
}

val REV_T2_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function REV_T2_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let n = UInt(Rn);
    if (m != n | d == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    REV_Op_A(d, m)
}

val REV_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function REV_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    __PostDecode();
    REV_Op_A(d, m)
}

val REV_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function REV_A1_A_decode (cond, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    REV_Op_A(d, m)
}

val RBIT_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function RBIT_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let n = UInt(Rn);
    if (m != n | d == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RBIT_Op_A(d, m)
}

val RBIT_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function RBIT_A1_A_decode (cond, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RBIT_Op_A(d, m)
}

val QSUB8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSUB8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSUB8_Op_A(d, m, n)
}

val QSUB8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSUB8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSUB8_Op_A(d, m, n)
}

val QSUB16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSUB16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSUB16_Op_A(d, m, n)
}

val QSUB16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSUB16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSUB16_Op_A(d, m, n)
}

val QSUB_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSUB_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSUB_Op_A(d, m, n)
}

val QSUB_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSUB_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSUB_Op_A(d, m, n)
}

val QSAX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSAX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSAX_Op_A(d, m, n)
}

val QSAX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QSAX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QSAX_Op_A(d, m, n)
}

val QDSUB_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QDSUB_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QDSUB_Op_A(d, m, n)
}

val QDSUB_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QDSUB_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QDSUB_Op_A(d, m, n)
}

val QDADD_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QDADD_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QDADD_Op_A(d, m, n)
}

val QDADD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QDADD_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QDADD_Op_A(d, m, n)
}

val QASX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QASX_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QASX_Op_A(d, m, n)
}

val QASX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QASX_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QASX_Op_A(d, m, n)
}

val QADD8_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QADD8_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QADD8_Op_A(d, m, n)
}

val QADD8_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QADD8_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QADD8_Op_A(d, m, n)
}

val QADD16_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QADD16_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QADD16_Op_A(d, m, n)
}

val QADD16_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QADD16_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QADD16_Op_A(d, m, n)
}

val QADD_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QADD_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QADD_Op_A(d, m, n)
}

val QADD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function QADD_A1_A_decode (cond, Rn, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    QADD_Op_A(d, m, n)
}

val PLI_r_T1_A_decode : (bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function PLI_r_T1_A_decode (Rn, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("PLI (immediate, literal)"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    let add = true;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    PLI_r_Op_A(add, m, n, shift_n, shift_t)
}

val PLI_r_A1_A_decode : (bits(1), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function PLI_r_A1_A_decode (U, Rn, imm5, typ, Rm) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let add = U == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    PLI_r_Op_A(add, m, n, shift_n, shift_t)
}

val PLI_i_T3_A_decode : (bits(1), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function PLI_i_T3_A_decode (U, imm12) = {
    __unconditional = false;
    let n = 15;
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    PLI_i_Op_A(add, imm32, n)
}

val PLI_i_T2_A_decode : (bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function PLI_i_T2_A_decode (Rn, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("encoding T3"))
    };
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8, 32);
    let add = false;
    __PostDecode();
    PLI_i_Op_A(add, imm32, n)
}

val PLI_i_T1_A_decode : (bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function PLI_i_T1_A_decode (Rn, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("encoding T3"))
    };
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let add = true;
    __PostDecode();
    PLI_i_Op_A(add, imm32, n)
}

val PLI_i_A1_A_decode : (bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function PLI_i_A1_A_decode (U, Rn, imm12) = {
    __unconditional = false;
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    PLI_i_Op_A(add, imm32, n)
}

val PLD_r_T1_A_decode : (bits(1), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function PLD_r_T1_A_decode (W, Rn, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("PLD (literal)"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    let add = true;
    let is_pldw = W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    PLD_r_Op_A(add, is_pldw, m, n, shift_n, shift_t)
}

val PLD_r_A1_A_decode : (bits(1), bits(1), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function PLD_r_A1_A_decode (U, R, Rn, imm5, typ, Rm) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let add = U == 0b1;
    let is_pldw = R == 0b0;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if m == 15 | n == 15 & is_pldw then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    PLD_r_Op_A(add, is_pldw, m, n, shift_n, shift_t)
}

val PLD_l_T1_A_decode : (bits(1), bits(1), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function PLD_l_T1_A_decode (U, W, imm12) = {
    __unconditional = false;
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    PLD_l_Op_A(add, imm32)
}

val PLD_l_A1_A_decode : (bits(1), bits(1), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function PLD_l_A1_A_decode (U, R, imm12) = {
    __unconditional = false;
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    PLD_l_Op_A(add, imm32)
}

val PLD_i_T2_A_decode : (bits(1), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function PLD_i_T2_A_decode (W, Rn, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("PLD (literal)"))
    };
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8, 32);
    let add = false;
    let is_pldw = W == 0b1;
    __PostDecode();
    PLD_i_Op_A(add, imm32, is_pldw, n)
}

val PLD_i_T1_A_decode : (bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function PLD_i_T1_A_decode (W, Rn, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("PLD (literal)"))
    };
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let add = true;
    let is_pldw = W == 0b1;
    __PostDecode();
    PLD_i_Op_A(add, imm32, is_pldw, n)
}

val PLD_i_A1_A_decode : (bits(1), bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function PLD_i_A1_A_decode (U, R, Rn, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("PLD (literal)"))
    };
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    let is_pldw = R == 0b0;
    __PostDecode();
    PLD_i_Op_A(add, imm32, is_pldw, n)
}

val PKH_T1_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function PKH_T1_A_decode (S, Rn, imm3, Rd, imm2, tb, T, Rm) = {
    __unconditional = false;
    if S == 0b1 | T == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let tbform = tb == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(tb @ 0b0, imm3 @ imm2);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    PKH_Op_A(d, m, n, shift_n, shift_t, tbform)
}

val PKH_A1_A_decode : (bits(4), bits(4), bits(4), bits(5), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function PKH_A1_A_decode (cond, Rn, Rd, imm5, tb, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let tbform = tb == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(tb @ 0b0, imm5);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    PKH_Op_A(d, m, n, shift_n, shift_t, tbform)
}

val ORR_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ORR_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ORR_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val ORN_r_T1_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ORN_r_T1_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("MVN (register)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ORN_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ORN_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ORN_i_T1_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("MVN (immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ORN_i_Op_A(carry, d, imm32, n, setflags)
}

val NOP_T2_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function NOP_T2_A_decode () = {
    __unconditional = false;
    __PostDecode();
    NOP_Op_A()
}

val NOP_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function NOP_T1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    NOP_Op_A()
}

val NOP_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function NOP_A1_A_decode cond = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    NOP_Op_A()
}

val MVN_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MVN_rr_A1_A_decode (cond, S, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if (d == 15 | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MVN_rr_Op_A(d, m, s, setflags, shift_t)
}

val MUL_T2_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MUL_T2_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = false;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MUL_Op_A(d, m, n, setflags)
}

val MUL_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function MUL_T1_A_decode (Rn, Rdm) = {
    __unconditional = false;
    let d = UInt(Rdm);
    let n = UInt(Rn);
    let m = UInt(Rdm);
    let setflags = ~(InITBlock());
    __PostDecode();
    MUL_Op_A(d, m, n, setflags)
}

val MUL_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MUL_A1_A_decode (cond, S, Rd, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MUL_Op_A(d, m, n, setflags)
}

val MSR_br_T1_AS_decode : (bits(1), bits(4), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function MSR_br_T1_AS_decode (R, Rn, M1, M) = {
    __unconditional = false;
    let n = UInt(Rn);
    let write_spsr = R == 0b1;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    let SYSm = M @ M1;
    __PostDecode();
    MSR_br_Op_AS(SYSm, n, write_spsr)
}

val MSR_br_A1_AS_decode : (bits(4), bits(1), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MSR_br_A1_AS_decode (cond, R, M1, M, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let write_spsr = R == 0b1;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    let SYSm = M @ M1;
    __PostDecode();
    MSR_br_Op_AS(SYSm, n, write_spsr)
}

val MRS_br_T1_AS_decode : (bits(1), bits(4), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function MRS_br_T1_AS_decode (R, M1, Rd, M) = {
    __unconditional = false;
    let d = UInt(Rd);
    let read_spsr = R == 0b1;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    let SYSm = M @ M1;
    __PostDecode();
    MRS_br_Op_AS(SYSm, d, read_spsr)
}

val MRS_br_A1_AS_decode : (bits(4), bits(1), bits(4), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function MRS_br_A1_AS_decode (cond, R, M1, Rd, M) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let read_spsr = R == 0b1;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    let SYSm = M @ M1;
    __PostDecode();
    MRS_br_Op_AS(SYSm, d, read_spsr)
}

val MRS_T1_AS_decode : (bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MRS_T1_AS_decode (R, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let read_spsr = R == 0b1;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MRS_Op_AS(d, read_spsr)
}

val MRS_A1_AS_decode : (bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MRS_A1_AS_decode (cond, R, Rd) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let read_spsr = R == 0b1;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MRS_Op_AS(d, read_spsr)
}

val MOV_rr_T2_A_decode : (bits(2), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MOV_rr_T2_A_decode (typ, S, Rm, Rd, Rs) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if (d == 15 | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_rr_Op_A(d, m, s, setflags, shift_t)
}

val MOV_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MOV_rr_A1_A_decode (cond, S, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if (d == 15 | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_rr_Op_A(d, m, s, setflags, shift_t)
}

val MOVT_T1_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function MOVT_T1_A_decode (i, imm4, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let imm16 = ((imm4 @ i) @ imm3) @ imm8;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOVT_Op_A(d, imm16)
}

val MOVT_A1_A_decode : (bits(4), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function MOVT_A1_A_decode (cond, imm4, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let imm16 = imm4 @ imm12;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOVT_Op_A(d, imm16)
}

val MLS_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MLS_T1_A_decode (Rn, Ra, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if ((d == 15 | n == 15) | m == 15) | a == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MLS_Op_A(a, d, m, n)
}

val MLS_A1_A_decode : (bits(4), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MLS_A1_A_decode (cond, Rd, Ra, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    if ((d == 15 | n == 15) | m == 15) | a == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MLS_Op_A(a, d, m, n)
}

val MLA_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MLA_T1_A_decode (Rn, Ra, Rd, Rm) = {
    __unconditional = false;
    if Ra == 0xF then {
        throw(Error_See("MUL"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let setflags = false;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MLA_Op_A(a, d, m, n, setflags)
}

val MLA_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MLA_A1_A_decode (cond, S, Rd, Ra, Rm, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let a = UInt(Ra);
    let setflags = S == 0b1;
    if ((d == 15 | n == 15) | m == 15) | a == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MLA_Op_A(a, d, m, n, setflags)
}

val LSR_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function LSR_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    __PostDecode();
    LSR_r_Op_A(d, m, n, setflags)
}

val LSR_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function LSR_i_T1_A_decode (imm5, Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    __anon1 : SRType = undefined : SRType;
    shift_n : int = undefined : int;
    (__anon1, shift_n) = DecodeImmShift(0b01, imm5);
    __PostDecode();
    LSR_i_Op_A(d, m, setflags, shift_n)
}

val LSL_r_T2_A_decode : (bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function LSL_r_T2_A_decode (S, Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LSL_r_Op_A(d, m, n, setflags)
}

val LSL_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function LSL_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    __PostDecode();
    LSL_r_Op_A(d, m, n, setflags)
}

val LSL_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function LSL_i_T1_A_decode (imm5, Rm, Rd) = {
    __unconditional = false;
    if imm5 == 0b00000 then {
        throw(Error_See("MOV (register)"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    __anon1 : SRType = undefined : SRType;
    shift_n : int = undefined : int;
    (__anon1, shift_n) = DecodeImmShift(0b00, imm5);
    __PostDecode();
    LSL_i_Op_A(d, m, setflags, shift_n)
}

val ISB_T1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function ISB_T1_A_decode option_name = {
    __unconditional = false;
    __PostDecode();
    ISB_Op_A()
}

val ISB_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function ISB_A1_A_decode option_name = {
    __unconditional = false;
    __PostDecode();
    ISB_Op_A()
}

val HLT_T1_A_decode : bits(6) -> unit effect {escape, rreg, undef, wreg}

function HLT_T1_A_decode imm6 = {
    __unconditional = true;
    if [EDSCR[14]] == 0b0 | ~(HaltingAllowed()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    HLT_Op_A()
}

val HLT_A1_A_decode : (bits(4), bits(12), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function HLT_A1_A_decode (cond, imm12, imm4) = {
    __unconditional = true;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if [EDSCR[14]] == 0b0 | ~(HaltingAllowed()) then {
        throw(Error_Undefined())
    };
    if cond != 0xE then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    HLT_Op_A()
}

val EOR_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function EOR_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    EOR_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val DSB_T1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function DSB_T1_A_decode option_name = {
    __unconditional = false;
    __PostDecode();
    DSB_Op_A(option_name)
}

val DSB_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function DSB_A1_A_decode option_name = {
    __unconditional = false;
    __PostDecode();
    DSB_Op_A(option_name)
}

val DMB_T1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function DMB_T1_A_decode option_name = {
    __unconditional = false;
    __PostDecode();
    DMB_Op_A(option_name)
}

val DMB_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function DMB_A1_A_decode option_name = {
    __unconditional = false;
    __PostDecode();
    DMB_Op_A(option_name)
}

val DBG_T1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function DBG_T1_A_decode option_name = {
    __unconditional = false;
    __PostDecode();
    DBG_Op_A()
}

val DBG_A1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function DBG_A1_A_decode (cond, option_name) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    DBG_Op_A()
}

val CRC32_T1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CRC32_T1_A_decode (C, Rn, Rd, sz, Rm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveCRCExt()) then {
        throw(Error_Undefined())
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let size : {|8, 16, 32, 64|} = shl_int(8, UInt(sz));
    let crc32c : bool = C == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if size == 64 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CRC32_Op_A(crc32c, d, m, n, size)
}

val CRC32_A1_A_decode : (bits(4), bits(2), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CRC32_A1_A_decode (cond, sz, Rn, Rd, C, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if ~(HaveCRCExt()) then {
        throw(Error_Undefined())
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let size : {|8, 16, 32, 64|} = shl_int(8, UInt(sz));
    let crc32c : bool = C == 0b1;
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    if size == 64 then {
        throw(Error_Unpredictable())
    };
    if cond != 0xE then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CRC32_Op_A(crc32c, d, m, n, size)
}

val CMP_rr_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CMP_rr_A1_A_decode (cond, Rn, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let shift_t = DecodeRegShift(typ);
    if (n == 15 | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CMP_rr_Op_A(m, n, s, shift_t)
}

val CMP_r_T3_A_decode : (bits(4), bits(3), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CMP_r_T3_A_decode (Rn, imm3, imm2, typ, Rm) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if n == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CMP_r_Op_A(m, n, shift_n, shift_t)
}

val CMP_r_T2_A_decode : (bits(1), bits(4), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function CMP_r_T2_A_decode (N, Rm, Rn) = {
    __unconditional = false;
    let n = UInt(N @ Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if n < 8 & m < 8 then {
        throw(Error_Unpredictable())
    };
    if n == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CMP_r_Op_A(m, n, shift_n, shift_t)
}

val CMP_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function CMP_r_T1_A_decode (Rm, Rn) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    CMP_r_Op_A(m, n, shift_n, shift_t)
}

val CMP_r_A1_A_decode : (bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CMP_r_A1_A_decode (cond, Rn, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    CMP_r_Op_A(m, n, shift_n, shift_t)
}

val CMP_i_T2_A_decode : (bits(1), bits(4), bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function CMP_i_T2_A_decode (i, Rn, imm3, imm8) = {
    __unconditional = false;
    let n = UInt(Rn);
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CMP_i_Op_A(imm32, n)
}

val CMP_i_T1_A_decode : (bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function CMP_i_T1_A_decode (Rn, imm8) = {
    __unconditional = false;
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8, 32);
    __PostDecode();
    CMP_i_Op_A(imm32, n)
}

val CMP_i_A1_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function CMP_i_A1_A_decode (cond, Rn, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    CMP_i_Op_A(imm32, n)
}

val CMN_rr_A1_A_decode : (bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CMN_rr_A1_A_decode (cond, Rn, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let shift_t = DecodeRegShift(typ);
    if (n == 15 | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CMN_rr_Op_A(m, n, s, shift_t)
}

val CMN_r_T2_A_decode : (bits(4), bits(3), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CMN_r_T2_A_decode (Rn, imm3, imm2, typ, Rm) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if n == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CMN_r_Op_A(m, n, shift_n, shift_t)
}

val CMN_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function CMN_r_T1_A_decode (Rm, Rn) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    CMN_r_Op_A(m, n, shift_n, shift_t)
}

val CMN_r_A1_A_decode : (bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CMN_r_A1_A_decode (cond, Rn, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    CMN_r_Op_A(m, n, shift_n, shift_t)
}

val CMN_i_T1_A_decode : (bits(1), bits(4), bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function CMN_i_T1_A_decode (i, Rn, imm3, imm8) = {
    __unconditional = false;
    let n = UInt(Rn);
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CMN_i_Op_A(imm32, n)
}

val CMN_i_A1_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function CMN_i_A1_A_decode (cond, Rn, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    CMN_i_Op_A(imm32, n)
}

val CLZ_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CLZ_T1_A_decode (Rn, Rd, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let n = UInt(Rn);
    if (m != n | d == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CLZ_Op_A(d, m)
}

val CLZ_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CLZ_A1_A_decode (cond, Rd, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CLZ_Op_A(d, m)
}

val CLREX_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function CLREX_T1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    CLREX_Op_A()
}

val CLREX_A1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function CLREX_A1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    CLREX_Op_A()
}

val CBNZ_T1_A_decode : (bits(1), bits(1), bits(5), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function CBNZ_T1_A_decode (op, i, imm5, Rn) = {
    __unconditional = true;
    let n = UInt(Rn);
    let imm32 = ZeroExtend((i @ imm5) @ 0b0, 32);
    let nonzero = op == 0b1;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CBNZ_Op_A(imm32, n, nonzero)
}

val BXJ_T1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function BXJ_T1_A_decode Rm = {
    __unconditional = false;
    let m = UInt(Rm);
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BXJ_Op_A(m)
}

val BXJ_A1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BXJ_A1_A_decode (cond, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = UInt(Rm);
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BXJ_Op_A(m)
}

val BX_T1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function BX_T1_A_decode Rm = {
    __unconditional = false;
    let m = UInt(Rm);
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BX_Op_A(m)
}

val BX_A1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BX_A1_A_decode (cond, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = UInt(Rm);
    __PostDecode();
    BX_Op_A(m)
}

val BL_i_T2_A_decode : (bits(1), bits(10), bits(1), bits(1), bits(10), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function BL_i_T2_A_decode (S, imm10H, J1, J2, imm10L, H) = {
    __unconditional = false;
    if H == 0b1 then {
        throw(Error_Undefined())
    };
    let I1 = ~(J1 ^ S);
    let I2 = ~(J2 ^ S);
    let imm32 : bits(32) = SignExtend(((((S @ I1) @ I2) @ imm10H) @ imm10L) @ 0b00, 32);
    let targetInstrSet = InstrSet_A32;
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BL_i_Op_A(imm32, targetInstrSet)
}

val BL_i_T1_A_decode : (bits(1), bits(10), bits(1), bits(1), bits(11)) -> unit effect {escape, rreg, undef, wreg}

function BL_i_T1_A_decode (S, imm10, J1, J2, imm11) = {
    __unconditional = false;
    let I1 = ~(J1 ^ S);
    let I2 = ~(J2 ^ S);
    let imm32 : bits(32) = SignExtend(((((S @ I1) @ I2) @ imm10) @ imm11) @ 0b0, 32);
    let targetInstrSet = InstrSet_T32;
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BL_i_Op_A(imm32, targetInstrSet)
}

val BL_i_A2_A_decode : (bits(1), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function BL_i_A2_A_decode (H, imm24) = {
    __unconditional = false;
    let imm32 = SignExtend((imm24 @ H) @ 0b0, 32);
    let targetInstrSet = InstrSet_T32;
    __PostDecode();
    BL_i_Op_A(imm32, targetInstrSet)
}

val BL_i_A1_A_decode : (bits(4), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function BL_i_A1_A_decode (cond, imm24) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = SignExtend(imm24 @ 0b00, 32);
    let targetInstrSet = InstrSet_A32;
    __PostDecode();
    BL_i_Op_A(imm32, targetInstrSet)
}

val BLX_r_T1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function BLX_r_T1_A_decode Rm = {
    __unconditional = false;
    let m = UInt(Rm);
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BLX_r_Op_A(m)
}

val BLX_r_A1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BLX_r_A1_A_decode (cond, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = UInt(Rm);
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BLX_r_Op_A(m)
}

val BIC_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BIC_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BIC_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val BFI_T1_A_decode : (bits(4), bits(3), bits(4), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function BFI_T1_A_decode (Rn, imm3, Rd, imm2, msb) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("BFC"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let msbit = UInt(msb);
    let lsbit = UInt(imm3 @ imm2);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BFI_Op_A(d, lsbit, msbit, n)
}

val BFI_A1_A_decode : (bits(4), bits(5), bits(4), bits(5), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BFI_A1_A_decode (cond, msb, Rd, lsb, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("BFC"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let msbit = UInt(msb);
    let lsbit = UInt(lsb);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BFI_Op_A(d, lsbit, msbit, n)
}

val BFC_T1_A_decode : (bits(3), bits(4), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function BFC_T1_A_decode (imm3, Rd, imm2, msb) = {
    __unconditional = false;
    let d = UInt(Rd);
    let msbit = UInt(msb);
    let lsbit = UInt(imm3 @ imm2);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BFC_Op_A(d, lsbit, msbit)
}

val BFC_A1_A_decode : (bits(4), bits(5), bits(4), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function BFC_A1_A_decode (cond, msb, Rd, lsb) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let msbit = UInt(msb);
    let lsbit = UInt(lsb);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BFC_Op_A(d, lsbit, msbit)
}

val B_T4_A_decode : (bits(1), bits(10), bits(1), bits(1), bits(11)) -> unit effect {escape, rreg, undef, wreg}

function B_T4_A_decode (S, imm10, J1, J2, imm11) = {
    __unconditional = false;
    let I1 = ~(J1 ^ S);
    let I2 = ~(J2 ^ S);
    let imm32 : bits(32) = SignExtend(((((S @ I1) @ I2) @ imm10) @ imm11) @ 0b0, 32);
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    B_Op_A(imm32)
}

val B_T3_A_decode : (bits(1), bits(4), bits(6), bits(1), bits(1), bits(11)) -> unit effect {escape, rreg, undef, wreg}

function B_T3_A_decode (S, cond, imm6, J1, J2, imm11) = {
    __unconditional = false;
    if slice(cond, 1, 3) == 0b111 then {
        throw(Error_See("Related encodings"))
    };
    let imm32 = SignExtend(((((S @ J2) @ J1) @ imm6) @ imm11) @ 0b0, 32);
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    B_Op_A(imm32)
}

val B_T2_A_decode : bits(11) -> unit effect {escape, rreg, undef, wreg}

function B_T2_A_decode imm11 = {
    __unconditional = false;
    let imm32 : bits(32) = SignExtend(imm11 @ 0b0, 32);
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    B_Op_A(imm32)
}

val B_T1_A_decode : (bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function B_T1_A_decode (cond, imm8) = {
    __unconditional = false;
    if cond == 0xE then {
        throw(Error_See("UDF"))
    };
    if cond == 0xF then {
        throw(Error_See("SVC"))
    };
    let imm32 = SignExtend(imm8 @ 0b0, 32);
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    B_Op_A(imm32)
}

val B_A1_A_decode : (bits(4), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function B_A1_A_decode (cond, imm24) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = SignExtend(imm24 @ 0b00, 32);
    __PostDecode();
    B_Op_A(imm32)
}

val ASR_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ASR_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    __PostDecode();
    ASR_r_Op_A(d, m, n, setflags)
}

val ASR_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ASR_i_T1_A_decode (imm5, Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    __anon1 : SRType = undefined : SRType;
    shift_n : int = undefined : int;
    (__anon1, shift_n) = DecodeImmShift(0b10, imm5);
    __PostDecode();
    ASR_i_Op_A(d, m, setflags, shift_n)
}

val AND_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AND_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    AND_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val ADR_T3_A_decode : (bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADR_T3_A_decode (i, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let imm32 = ZeroExtend((i @ imm3) @ imm8, 32);
    let add = true;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADR_Op_A(add, d, imm32)
}

val ADR_T2_A_decode : (bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADR_T2_A_decode (i, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let imm32 = ZeroExtend((i @ imm3) @ imm8, 32);
    let add = false;
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADR_Op_A(add, d, imm32)
}

val ADR_T1_A_decode : (bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADR_T1_A_decode (Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let add = true;
    __PostDecode();
    ADR_Op_A(add, d, imm32)
}

val ADR_A2_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function ADR_A2_A_decode (cond, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    assert(0 <= d & d <= 14);
    let imm32 : bits(32) = A32ExpandImm(imm12);
    let add : bool = false;
    __PostDecode();
    ADR_Op_A(add, d, imm32)
}

val ADR_A1_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function ADR_A1_A_decode (cond, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    assert(0 <= d & d <= 14);
    let imm32 : bits(32) = A32ExpandImm(imm12);
    let add : bool = true;
    __PostDecode();
    ADR_Op_A(add, d, imm32)
}

val ADD_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADD_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val ADD_i_T4_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADD_i_T4_A_decode (i, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("ADR"))
    };
    if Rn == 0xD then {
        throw(Error_See("ADD (SP plus immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = false;
    let imm32 = ZeroExtend((i @ imm3) @ imm8, 32);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_i_OpT_A(d, imm32, n, setflags)
}

val ADD_i_T3_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADD_i_T3_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMN (immediate)"))
    };
    if Rn == 0xD then {
        throw(Error_See("ADD (SP plus immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags : bool = S == 0b1;
    let imm32 : bits(32) = T32ExpandImm((i @ imm3) @ imm8);
    if d == 15 & ~(setflags) | n == 15 then {
        throw(Error_Unpredictable())
    };
    assert(0 <= d & d <= 14);
    __PostDecode();
    ADD_i_OpT_A(d, imm32, n, setflags)
}

val ADD_i_T2_A_decode : (bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADD_i_T2_A_decode (Rdn, imm8) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let setflags = ~(InITBlock());
    let imm32 = ZeroExtend(imm8, 32);
    __PostDecode();
    ADD_i_OpT_A(d, imm32, n, setflags)
}

val ADD_i_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ADD_i_T1_A_decode (imm3, Rn, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = ~(InITBlock());
    let imm32 = ZeroExtend(imm3, 32);
    __PostDecode();
    ADD_i_OpT_A(d, imm32, n, setflags)
}

val ADC_rr_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADC_rr_A1_A_decode (cond, S, Rn, Rd, Rs, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let s = UInt(Rs);
    let setflags = S == 0b1;
    let shift_t = DecodeRegShift(typ);
    if ((d == 15 | n == 15) | m == 15) | s == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADC_rr_Op_A(d, m, n, s, setflags, shift_t)
}

val AArch64_AArch32SystemAccessTrap : (bits(2), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AArch32SystemAccessTrap (target_el, aarch32_instr) = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    let exception = AArch64_AArch32SystemAccessTrapSyndrome(aarch32_instr);
    if (target_el == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckAArch32SystemAccessEL3Traps : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckAArch32SystemAccessEL3Traps instr = {
    assert(HaveEL(EL3) & PSTATE.EL != EL3);
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    cp_num : int = undefined : int;
    op : SystemAccessType = undefined : SystemAccessType;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    write : bool = undefined : bool;
    (op, cp_num, opc1, CRn, CRm, opc2, write) = AArch32_DecodeSysRegAccess(instr);
    trap : bool = undefined : bool;
    trap = false;
    if cp_num == 14 then {
        if ((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 4) & ~(write) | ((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 4) & write) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 3) & opc2 == 4) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 4) & opc2 == 4 then {
            trap = [MDCR_EL3[10]] == 0b1
        } else {
            if opc1 == 0 & (~(Halted()) | ~(((op == SystemAccessType_RT & CRn == 0) & CRm == 5) & opc2 == 0)) then {
                trap = [MDCR_EL3[9]] == 0b1
            } else {
                if opc1 == 1 then {
                    trap = [CPTR_EL3[20]] == 0b1
                }
            }
        }
    } else {
        if cp_num == 15 then {
            if ((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 0 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 12) & CRm == 0) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 3) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 8) & opc2 >= 4 then {
                trap = PSTATE.EL == EL1 & IsSecure()
            } else {
                if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 2 | (((op == SystemAccessType_RT & opc1 == 4) & CRn == 1) & CRm == 1) & opc2 == 2 then {
                    trap = [CPTR_EL3[31]] == 0b1
                } else {
                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm >= 8 | ((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & (CRm == 12 | CRm == 13 | CRm == 14)) | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 9 then {
                        trap = [MDCR_EL3[6]] == 0b1
                    }
                }
            }
        }
    };
    if trap then {
        AArch64_AArch32SystemAccessTrap(EL3, instr)
    }
}

val AArch64_CheckAArch32SystemAccessEL2Traps : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckAArch32SystemAccessEL2Traps instr = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2));
    trap : bool = undefined : bool;
    trap = false;
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    cp_num : int = undefined : int;
    op : SystemAccessType = undefined : SystemAccessType;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    write : bool = undefined : bool;
    (op, cp_num, opc1, CRn, CRm, opc2, write) = AArch32_DecodeSysRegAccess(instr);
    if cp_num == 14 & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
        if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 0 | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 0) | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 2 then {
            trap = ([MDCR_EL2[11]] == 0b1 | [MDCR_EL2[8]] == 0b1) | [HCR_EL2[27]] == 0b1
        } else {
            if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 4 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 4) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 3) & opc2 == 4) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 4) & opc2 == 4 then {
                trap = ([MDCR_EL2[10]] == 0b1 | [MDCR_EL2[8]] == 0b1) | [HCR_EL2[27]] == 0b1
            } else {
                if opc1 == 0 & (~(Halted()) | ~(((op == SystemAccessType_RT & CRn == 0) & CRm == 5) & opc2 == 0)) then {
                    trap = ([MDCR_EL2[9]] == 0b1 | [MDCR_EL2[8]] == 0b1) | [HCR_EL2[27]] == 0b1
                } else {
                    if opc1 == 1 then {
                        trap = [CPTR_EL2[if [HCR_EL2[34]] == 0 then 20 else 28]] == 0b1
                    } else {
                        if (((op == SystemAccessType_RT & opc1 == 7) & CRn == 0) & CRm == 0) & opc2 == 0 then {
                            trap = [HCR_EL2[15]] == 0b1
                        }
                    }
                }
            }
        }
    } else {
        if cp_num == 14 & PSTATE.EL == EL2 then {
            if opc1 == 1 then {
                trap = [CPTR_EL2[if [HCR_EL2[34]] == 0 then 20 else 28]] == 0b1
            }
        } else {
            if cp_num == 15 & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
                if ((((((((((((((((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 0 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 0) | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 1) | (op == SystemAccessType_RRT & opc1 == 1) & CRm == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 3) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 3) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 0) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 6) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 6) & CRm == 0) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 1) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 1) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 2) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 2) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 3) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 3) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 13) & CRm == 0) & opc2 == 1 then {
                    trap = if write then [HCR_EL2[26]] == 0b1 else [HCR_EL2[30]] == 0b1
                } else {
                    if (op == SystemAccessType_RT & opc1 == 0) & CRn == 8 then {
                        trap = write & [HCR_EL2[25]] == 0b1
                    } else {
                        if ((((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 6) & opc2 == 2 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 10) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 14) & opc2 == 2 then {
                            trap = write & [HCR_EL2[22]] == 0b1
                        } else {
                            if ((((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 6) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 10) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 14) & opc2 == 1 then {
                                trap = write & [HCR_EL2[23]] == 0b1
                            } else {
                                if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 5) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 5) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 1) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 11) & opc2 == 1 then {
                                    trap = write & [HCR_EL2[24]] == 0b1
                                } else {
                                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 3 then {
                                        trap = [HCR_EL2[21]] == 0b1
                                    } else {
                                        if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 2 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 3) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 6) | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 7 then {
                                            trap = [HCR_EL2[16]] == 0b1
                                        } else {
                                            if ((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 2) & CRn == 0) & CRm == 0) & opc2 == 0 then {
                                                trap = [HCR_EL2[17]] == 0b1
                                            } else {
                                                if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 2) & opc2 <= 7) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm >= 3) & opc2 <= 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 3) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 5) & (opc2 == 4 | opc2 == 5) then {
                                                    trap = [HCR_EL2[18]] == 0b1
                                                } else {
                                                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 2 then {
                                                        trap = [CPTR_EL2[31]] == 0b1
                                                    } else {
                                                        if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 0 then {
                                                            trap = [MDCR_EL2[5]] == 0b1 | [MDCR_EL2[6]] == 0b1
                                                        } else {
                                                            if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm >= 8 | ((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & (CRm == 12 | CRm == 13 | CRm == 14)) | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 9 then {
                                                                trap = [MDCR_EL2[6]] == 0b1
                                                            } else {
                                                                if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm == 2) & (opc2 == 0 | opc2 == 1 | opc2 == 2) then {
                                                                    if ~(HaveVirtHostExt()) | [HCR_EL2[34]] == 0b0 then {
                                                                        trap = [CNTHCTL_EL2[1]] == 0b0
                                                                    } else {
                                                                        trap = [CNTHCTL_EL2[11]] == 0b0
                                                                    }
                                                                } else {
                                                                    if (op == SystemAccessType_RRT & opc1 == 0) & CRm == 14 then {
                                                                        trap = [CNTHCTL_EL2[if [HCR_EL2[34]] == 0 then 0 else 10]] == 0b0
                                                                    } else {
                                                                        if ((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 0 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 12) & CRm == 0) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 3) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 8) & opc2 >= 4 then {
                                                                            trap = ((IsSecureEL2Enabled() & PSTATE.EL == EL1) & IsSecure()) & ELUsingAArch32(EL1)
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if trap then {
        AArch64_AArch32SystemAccessTrap(EL2, instr)
    }
}

val AArch64_CheckAArch32SystemAccessEL1Traps : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckAArch32SystemAccessEL1Traps instr = {
    assert(PSTATE.EL == EL0);
    trap : bool = undefined : bool;
    trap = false;
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    cp_num : int = undefined : int;
    op : SystemAccessType = undefined : SystemAccessType;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    write : bool = undefined : bool;
    (op, cp_num, opc1, CRn, CRm, opc2, write) = AArch32_DecodeSysRegAccess(instr);
    if cp_num == 14 then {
        if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 5) & opc2 == 0 | (op == SystemAccessType_DT & CRn == 5) & opc2 == 0 then {
            trap = ~(Halted()) & [MDSCR_EL1[12]] == 0b1
        } else {
            if opc1 == 0 then {
                trap = [MDSCR_EL1[12]] == 0b1
            } else {
                if opc1 == 1 then {
                    trap = [CPACR()[28]] == 0b1
                }
            }
        }
    } else {
        if cp_num == 15 then {
            if ((((((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 0 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 3) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 6) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 7) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 13) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 14) & opc2 == 3) | ((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm >= 12 then {
                trap = [PMUSERENR_EL0[0]] == 0b0
            } else {
                if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 14) & opc2 == 4 then {
                    trap = [PMUSERENR_EL0[0]] == 0b0 & [PMUSERENR_EL0[1]] == 0b0
                } else {
                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 13) & opc2 == 0 | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 9 then {
                        trap = [PMUSERENR_EL0[0]] == 0b0 & (write | [PMUSERENR_EL0[2]] == 0b0)
                    } else {
                        if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 13) & opc2 == 2 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm >= 8) & CRm <= 11 then {
                            trap = [PMUSERENR_EL0[0]] == 0b0 & (write | [PMUSERENR_EL0[3]] == 0b0)
                        } else {
                            if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 5 then {
                                trap = [PMUSERENR_EL0[0]] == 0b0 & [PMUSERENR_EL0[3]] == 0b0
                            } else {
                                if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm == 2) & (opc2 == 0 | opc2 == 1 | opc2 == 2) then {
                                    trap = [CNTKCTL()[9]] == 0b0
                                } else {
                                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm == 0) & opc2 == 0 then {
                                        trap = [CNTKCTL()[9]] == 0b0 & [CNTKCTL()[1]] == 0b0
                                    } else {
                                        if (op == SystemAccessType_RRT & opc1 == 1) & CRm == 14 then {
                                            trap = [CNTKCTL()[1]] == 0b0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if trap then {
        AArch64_AArch32SystemAccessTrap(EL1, instr)
    }
}

val AArch64_CheckAArch32SystemAccessTraps : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckAArch32SystemAccessTraps instr = {
    if PSTATE.EL == EL0 then {
        AArch64_CheckAArch32SystemAccessEL1Traps(instr)
    };
    if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2)) & ~(IsInHost()) then {
        AArch64_CheckAArch32SystemAccessEL2Traps(instr)
    };
    AArch64_CheckAArch32SystemAccessEL3Traps(instr)
}

val __TakeColdReset : unit -> unit effect {escape, rreg, undef, wreg}

function __TakeColdReset () = {
    TakeReset(true)
}

val AArch32_WriteModeByInstr : bits(5) -> unit effect {escape, rreg, undef, wreg}

function AArch32_WriteModeByInstr mode = {
    el : bits(2) = undefined : bits(2);
    valid_name : bool = undefined : bool;
    (valid_name, el) = ELFromM32(mode);
    if UInt(el) > UInt(PSTATE.EL) then {
        valid_name = false
    };
    if (PSTATE.M == M32_Hyp | mode == M32_Hyp) & PSTATE.M != mode then {
        valid_name = false
    };
    if (((PSTATE.M == M32_Monitor & HaveEL(EL2)) & el == EL1) & [get_SCR()[0]] == 0b1) & [get_HCR()[27]] == 0b1 then {
        valid_name = false
    };
    if ~(valid_name) then {
        PSTATE.IL = 0b1
    } else {
        AArch32_WriteMode(mode)
    }
}

val CPSRWriteByInstr : (bits(32), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function CPSRWriteByInstr (value_name, bytemask) = {
    let privileged = PSTATE.EL != EL0;
    if [bytemask[3]] == 0b1 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.Q) = slice(value_name, 27, 5)
    };
    if [bytemask[2]] == 0b1 then {
        if privileged then {
            PSTATE.PAN = [value_name[22]]
        };
        PSTATE.GE = slice(value_name, 16, 4)
    };
    if [bytemask[1]] == 0b1 then {
        PSTATE.E = [value_name[9]];
        if privileged then {
            PSTATE.A = [value_name[8]]
        }
    };
    if [bytemask[0]] == 0b1 then {
        if privileged then {
            (PSTATE.I @ PSTATE.F) = slice(value_name, 6, 2);
            AArch32_WriteModeByInstr(slice(value_name, 0, 5))
        }
    };
    return()
}

val MSR_r_Op_AS : forall 'n ('write_spsr : Bool),
  ('n >= 0 & 'n <= 15 | not('write_spsr)) & ('n >= 0 & 'n <= 15 | not(not('write_spsr))).
  (bits(4), int('n), bool('write_spsr)) -> unit effect {escape, rreg, undef, wreg}

function MSR_r_Op_AS (mask, n, write_spsr) = {
    if ConditionPassed() then {
        if write_spsr then {
            if PSTATE.M == M32_User | PSTATE.M == M32_System then {
                throw(Error_Unpredictable())
            } else {
                SPSRWriteByInstr(R(n), mask)
            }
        } else {
            CPSRWriteByInstr(R(n), mask)
        }
    }
}

val MSR_r_T1_AS_decode : (bits(1), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MSR_r_T1_AS_decode (R, Rn, mask) = {
    __unconditional = false;
    let n = UInt(Rn);
    let write_spsr = R == 0b1;
    if mask == 0x0 then {
        throw(Error_Unpredictable())
    };
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MSR_r_Op_AS(mask, n, write_spsr)
}

val MSR_r_A1_AS_decode : (bits(4), bits(1), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MSR_r_A1_AS_decode (cond, R, mask, Rn) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let write_spsr = R == 0b1;
    if mask == 0x0 then {
        throw(Error_Unpredictable())
    };
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MSR_r_Op_AS(mask, n, write_spsr)
}

val MSR_i_Op_AS : forall ('write_spsr : Bool).
  (bits(32), bits(4), bool('write_spsr)) -> unit effect {escape, rreg, undef, wreg}

function MSR_i_Op_AS (imm32, mask, write_spsr) = {
    if ConditionPassed() then {
        if write_spsr then {
            if PSTATE.M == M32_User | PSTATE.M == M32_System then {
                throw(Error_Unpredictable())
            } else {
                SPSRWriteByInstr(imm32, mask)
            }
        } else {
            CPSRWriteByInstr(imm32, mask)
        }
    }
}

val MSR_i_A1_AS_decode : (bits(4), bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function MSR_i_A1_AS_decode (cond, R, mask, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if mask == 0x0 & R == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    let imm32 = A32ExpandImm(imm12);
    let write_spsr = R == 0b1;
    if mask == 0x0 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MSR_i_Op_AS(imm32, mask, write_spsr)
}

val CPS_OpT_AS : forall ('affectA : Bool) ('affectF : Bool) ('affectI : Bool) ('changemode : Bool) ('disable : Bool) ('enable : Bool).
  (bool('affectA), bool('affectF), bool('affectI), bool('changemode), bool('disable), bool('enable), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function CPS_OpT_AS (affectA, affectF, affectI, changemode, disable, enable, mode) = {
    if PSTATE.EL != EL0 then {
        if enable then {
            if affectA then {
                PSTATE.A = 0b0
            };
            if affectI then {
                PSTATE.I = 0b0
            };
            if affectF then {
                PSTATE.F = 0b0
            }
        };
        if disable then {
            if affectA then {
                PSTATE.A = 0b1
            };
            if affectI then {
                PSTATE.I = 0b1
            };
            if affectF then {
                PSTATE.F = 0b1
            }
        };
        if changemode then {
            AArch32_WriteModeByInstr(mode)
        }
    }
}

val CPS_T2_AS_decode : (bits(2), bits(1), bits(1), bits(1), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function CPS_T2_AS_decode (imod, M, A, I, F, mode) = {
    __unconditional = true;
    if imod == 0b00 & M == 0b0 then {
        throw(Error_See("Hint instructions"))
    };
    if mode != 0b00000 & M == 0b0 then {
        throw(Error_Unpredictable())
    };
    if [imod[1]] == 0b1 & ((A @ I) @ F) == 0b000 | [imod[1]] == 0b0 & ((A @ I) @ F) != 0b000 then {
        throw(Error_Unpredictable())
    };
    let enable = imod == 0b10;
    let disable = imod == 0b11;
    let changemode = M == 0b1;
    let affectA = A == 0b1;
    let affectI = I == 0b1;
    let affectF = F == 0b1;
    if imod == 0b01 | InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CPS_OpT_AS(affectA, affectF, affectI, changemode, disable, enable, mode)
}

val CPS_T1pre_AS_decode : (bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function CPS_T1pre_AS_decode (im, A, I, F) = {
    __unconditional = true;
    let mode = undefined : bits(5);
    if ((A @ I) @ F) == 0b000 then {
        throw(Error_Unpredictable())
    };
    let enable = im == 0b0;
    let disable = im == 0b1;
    let changemode = false;
    let affectA = A == 0b1;
    let affectI = I == 0b1;
    let affectF = F == 0b1;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CPS_OpT_AS(affectA, affectF, affectI, changemode, disable, enable, mode)
}

val CPS_A1_AS_decode : (bits(2), bits(1), bits(1), bits(1), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function CPS_A1_AS_decode (imod, M, A, I, F, mode) = {
    __unconditional = true;
    if mode != 0b00000 & M == 0b0 then {
        throw(Error_Unpredictable())
    };
    if [imod[1]] == 0b1 & ((A @ I) @ F) == 0b000 | [imod[1]] == 0b0 & ((A @ I) @ F) != 0b000 then {
        throw(Error_Unpredictable())
    };
    let enable = imod == 0b10;
    let disable = imod == 0b11;
    let changemode = M == 0b1;
    let affectA = A == 0b1;
    let affectI = I == 0b1;
    let affectF = F == 0b1;
    if imod == 0b00 & M == 0b0 | imod == 0b01 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    CPS_OpT_AS(affectA, affectF, affectI, changemode, disable, enable, mode)
}

val AArch32_ExceptionReturn : (bits(32), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_ExceptionReturn (new_pc__arg, spsr) = {
    new_pc = new_pc__arg;
    SynchronizeContext();
    SetPSTATEFromPSR(spsr);
    ClearExclusiveLocal(ProcessorID());
    SendEventLocal();
    if PSTATE.IL == 0b1 then {
        new_pc = __SetSlice_bits(32, 2, new_pc, 0, undefined : bits(2))
    } else {
        if PSTATE.T == 0b1 then {
            new_pc = __SetSlice_bits(32, 1, new_pc, 0, 0b0)
        } else {
            new_pc = __SetSlice_bits(32, 2, new_pc, 0, 0b00)
        }
    };
    BranchTo(new_pc, BranchType_ERET)
}

val SUBS_PC_OpT_AS : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (bits(32), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SUBS_PC_OpT_AS (imm32, n) = {
    if ConditionPassed() then {
        __anon1 : bits(4) = undefined : bits(4);
        operand2 : bits(32) = undefined : bits(32);
        result : bits(32) = undefined : bits(32);
        if PSTATE.M == M32_User | PSTATE.M == M32_System then {
            throw(Error_Unpredictable())
        } else {
            operand2 = imm32;
            (result, __anon1) = AddWithCarry(R(n), ~(operand2), 0b1);
            AArch32_ExceptionReturn(result, SPSR())
        }
    }
}

val SUBS_PC_T1pre_AS_decode : bits(8) -> unit effect {escape, rreg, undef, wreg}

function SUBS_PC_T1pre_AS_decode imm8 = {
    __unconditional = false;
    let m : int = undefined;
    let shift_n : int = undefined;
    let shift_t : SRType = undefined : SRType;
    if IsZero(imm8) then {
        throw(Error_See("ERET"))
    };
    if PSTATE.EL == EL2 then {
        throw(Error_Undefined())
    };
    let n : int(14) = 14;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUBS_PC_OpT_AS(imm32, n)
}

val SUBS_PC_OpA_AS : forall 'm 'n ('register_form : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15 | not('register_form)) & ('n >= 0 & 'n <= 15).
  (bits(32), int('m), int('n), bits(4), bool('register_form), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function SUBS_PC_OpA_AS (imm32, m, n, opcode, register_form, shift_n, shift_t) = {
    if ConditionPassed() then {
        __anon1 : bits(4) = undefined : bits(4);
        __anon2 : bits(4) = undefined : bits(4);
        __anon3 : bits(4) = undefined : bits(4);
        __anon4 : bits(4) = undefined : bits(4);
        __anon5 : bits(4) = undefined : bits(4);
        __anon6 : bits(4) = undefined : bits(4);
        operand2 : bits(32) = undefined : bits(32);
        result : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Undefined())
        } else {
            if PSTATE.M == M32_User | PSTATE.M == M32_System then {
                throw(Error_Unpredictable())
            } else {
                operand2 = if register_form then Shift(R(m), shift_t, shift_n, PSTATE.C) else imm32;
                match opcode {
                  0x0 => {
                      result = R(n) & operand2
                  },
                  0x1 => {
                      result = R(n) ^ operand2
                  },
                  0x2 => {
                      (result, __anon1) = AddWithCarry(R(n), ~(operand2), 0b1)
                  },
                  0x3 => {
                      (result, __anon2) = AddWithCarry(~(R(n)), operand2, 0b1)
                  },
                  0x4 => {
                      (result, __anon3) = AddWithCarry(R(n), operand2, 0b0)
                  },
                  0x5 => {
                      (result, __anon4) = AddWithCarry(R(n), operand2, PSTATE.C)
                  },
                  0x6 => {
                      (result, __anon5) = AddWithCarry(R(n), ~(operand2), PSTATE.C)
                  },
                  0x7 => {
                      (result, __anon6) = AddWithCarry(~(R(n)), operand2, PSTATE.C)
                  },
                  0xC => {
                      result = R(n) | operand2
                  },
                  0xD => {
                      result = operand2
                  },
                  0xE => {
                      result = R(n) & ~(operand2)
                  },
                  0xF => {
                      result = ~(operand2)
                  }
                };
                AArch32_ExceptionReturn(result, SPSR())
            }
        }
    }
}

val SUBS_PC_A2pre_AS_decode : (bits(4), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SUBS_PC_A2pre_AS_decode (cond, opcode, Rn, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let register_form = true;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    SUBS_PC_OpA_AS(imm32, m, n, opcode, register_form, shift_n, shift_t)
}

val SUBS_PC_A1pre_AS_decode : (bits(4), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function SUBS_PC_A1pre_AS_decode (cond, opcode, Rn, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = 0;
    let shift_n = 0;
    let shift_t : SRType = undefined : SRType;
    let n = UInt(Rn);
    let imm32 : bits(32) = A32ExpandImm(imm12);
    let register_form : bool = false;
    __PostDecode();
    SUBS_PC_OpA_AS(imm32, m, n, opcode, register_form, shift_n, shift_t)
}

val ERET_Op_AS : unit -> unit effect {escape, rreg, undef, wreg}

function ERET_Op_AS () = {
    if ConditionPassed() then {
        new_pc_value : bits(32) = undefined : bits(32);
        if PSTATE.M == M32_User | PSTATE.M == M32_System then {
            throw(Error_Unpredictable())
        } else {
            new_pc_value = if PSTATE.EL == EL2 then get_ELR_hyp() else R(14);
            AArch32_ExceptionReturn(new_pc_value, SPSR())
        }
    }
}

val ERET_T1_A_decode : bits(8) -> unit effect {escape, rreg, undef, wreg}

function ERET_T1_A_decode imm8 = {
    __unconditional = false;
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ERET_Op_AS()
}

val ERET_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function ERET_A1_A_decode cond = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    ERET_Op_AS()
}

val ALUExceptionReturn : bits(32) -> unit effect {escape, rreg, undef, wreg}

function ALUExceptionReturn address = {
    if PSTATE.EL == EL2 then {
        throw(Error_Undefined())
    } else {
        if PSTATE.M == M32_User | PSTATE.M == M32_System then {
            throw(Error_Unpredictable())
        } else {
            AArch32_ExceptionReturn(address, SPSR())
        }
    }
}

val SUB_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function SUB_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), ~(shifted), 0b1);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val SUB_r_T2_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SUB_r_T2_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMP (register)"))
    };
    if Rn == 0xD then {
        throw(Error_See("SUB (SP minus register)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 & ~(setflags) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUB_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val SUB_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function SUB_r_T1_A_decode (Rm, Rn, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    SUB_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val SUB_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SUB_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xD then {
        throw(Error_See("SUB (SP minus register)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    SUB_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val SUB_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function SUB_i_Op_A (d, imm32, n, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(R(n), ~(imm32), 0b1);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val SUB_i_T4_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function SUB_i_T4_A_decode (i, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("ADR"))
    };
    if Rn == 0xD then {
        throw(Error_See("SUB (SP minus immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = false;
    let imm32 = ZeroExtend((i @ imm3) @ imm8, 32);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUB_i_Op_A(d, imm32, n, setflags)
}

val SUB_i_T3_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function SUB_i_T3_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMP (immediate)"))
    };
    if Rn == 0xD then {
        throw(Error_See("SUB (SP minus immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if d == 15 & ~(setflags) | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUB_i_Op_A(d, imm32, n, setflags)
}

val SUB_i_T2_A_decode : (bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function SUB_i_T2_A_decode (Rdn, imm8) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let setflags = ~(InITBlock());
    let imm32 = ZeroExtend(imm8, 32);
    __PostDecode();
    SUB_i_Op_A(d, imm32, n, setflags)
}

val SUB_i_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function SUB_i_T1_A_decode (imm3, Rn, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = ~(InITBlock());
    let imm32 = ZeroExtend(imm3, 32);
    __PostDecode();
    SUB_i_Op_A(d, imm32, n, setflags)
}

val SUB_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function SUB_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF & S == 0b0 then {
        throw(Error_See("ADR"))
    };
    if Rn == 0xD then {
        throw(Error_See("SUB (SP minus immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    SUB_i_Op_A(d, imm32, n, setflags)
}

val SUB_SP_r_Op_A : forall 'd 'm ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_r_Op_A (d, m, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(get_SP(), ~(shifted), 0b1);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val SUB_SP_r_T1_A_decode : (bits(1), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_r_T1_A_decode (S, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMP (register)"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if d == 15 & ~(setflags) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUB_SP_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val SUB_SP_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_r_A1_A_decode (cond, S, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    SUB_SP_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val SUB_SP_i_Op_A : forall 'd ('setflags : Bool),
  ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_i_Op_A (d, imm32, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(get_SP(), ~(imm32), 0b1);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val SUB_SP_i_T3_A_decode : (bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_i_T3_A_decode (i, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let setflags = false;
    let imm32 = ZeroExtend((i @ imm3) @ imm8, 32);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUB_SP_i_Op_A(d, imm32, setflags)
}

val SUB_SP_i_T2_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_i_T2_A_decode (i, S, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMP (immediate)"))
    };
    let d = UInt(Rd);
    let setflags = S == 0b1;
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if d == 15 & ~(setflags) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SUB_SP_i_Op_A(d, imm32, setflags)
}

val SUB_SP_i_T1_A_decode : bits(7) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_i_T1_A_decode imm7 = {
    __unconditional = false;
    let d = 13;
    let setflags = false;
    let imm32 : bits(32) = ZeroExtend(imm7 @ 0b00, 32);
    __PostDecode();
    SUB_SP_i_Op_A(d, imm32, setflags)
}

val SUB_SP_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function SUB_SP_i_A1_A_decode (cond, S, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    SUB_SP_i_Op_A(d, imm32, setflags)
}

val SBC_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function SBC_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), ~(shifted), PSTATE.C);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val SBC_r_T2_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SBC_r_T2_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SBC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val SBC_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function SBC_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    SBC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val SBC_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SBC_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    SBC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val SBC_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function SBC_i_Op_A (d, imm32, n, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(R(n), ~(imm32), PSTATE.C);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val SBC_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function SBC_i_T1_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SBC_i_Op_A(d, imm32, n, setflags)
}

val SBC_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function SBC_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    SBC_i_Op_A(d, imm32, n, setflags)
}

val RSC_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function RSC_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(~(R(n)), shifted, PSTATE.C);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val RSC_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function RSC_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    RSC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val RSC_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function RSC_i_Op_A (d, imm32, n, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(~(R(n)), imm32, PSTATE.C);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val RSC_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function RSC_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    RSC_i_Op_A(d, imm32, n, setflags)
}

val RSB_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function RSB_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(~(R(n)), shifted, 0b1);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val RSB_r_T1_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function RSB_r_T1_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RSB_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val RSB_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function RSB_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    RSB_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val RSB_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function RSB_i_Op_A (d, imm32, n, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(~(R(n)), imm32, 0b1);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val RSB_i_T2_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function RSB_i_T2_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RSB_i_Op_A(d, imm32, n, setflags)
}

val RSB_i_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function RSB_i_T1_A_decode (Rn, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = ~(InITBlock());
    let imm32 = Zeros(32);
    __PostDecode();
    RSB_i_Op_A(d, imm32, n, setflags)
}

val RSB_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function RSB_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    RSB_i_Op_A(d, imm32, n, setflags)
}

val ORR_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function ORR_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) | shifted;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val ORR_r_T2_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ORR_r_T2_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("Related encodings"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ORR_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ORR_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ORR_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    ORR_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ORR_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ORR_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    ORR_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ORR_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (bits(1), int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ORR_i_Op_A (carry, d, imm32, n, setflags) = {
    if ConditionPassed() then {
        let result : bits(32) = R(n) | imm32;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val ORR_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ORR_i_T1_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("MOV (immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ORR_i_Op_A(carry, d, imm32, n, setflags)
}

val ORR_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function ORR_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    ORR_i_Op_A(carry, d, imm32, n, setflags)
}

val MVN_r_Op_A : forall 'd 'm ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function MVN_r_Op_A (d, m, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = ~(shifted);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val MVN_r_T2_A_decode : (bits(1), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MVN_r_T2_A_decode (S, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MVN_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val MVN_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function MVN_r_T1_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    MVN_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val MVN_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MVN_r_A1_A_decode (cond, S, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    MVN_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val MVN_i_Op_A : forall 'd ('setflags : Bool),
  ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (bits(1), int('d), bits(32), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function MVN_i_Op_A (carry, d, imm32, setflags) = {
    if ConditionPassed() then {
        let result = ~(imm32);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val MVN_i_T1_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function MVN_i_T1_A_decode (i, S, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MVN_i_Op_A(carry, d, imm32, setflags)
}

val MVN_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function MVN_i_A1_A_decode (cond, S, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    MVN_i_Op_A(carry, d, imm32, setflags)
}

val MOV_r_Op_A : forall 'd 'm ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function MOV_r_Op_A (d, m, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = shifted;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val MOV_r_T3_A_decode : (bits(1), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MOV_r_T3_A_decode (S, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if d == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val MOV_r_T2archex_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function MOV_r_T2archex_A_decode (Rm, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = true;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val MOV_r_T1_A_decode : (bits(1), bits(4), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function MOV_r_T1_A_decode (D, Rm, Rd) = {
    __unconditional = false;
    let d = UInt(D @ Rd);
    let m = UInt(Rm);
    let setflags = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if (d == 15 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val MOV_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function MOV_r_A1_A_decode (cond, S, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    MOV_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val MOV_i_Op_A : forall 'd ('setflags : Bool),
  ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (bits(1), int('d), bits(32), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function MOV_i_Op_A (carry, d, imm32, setflags) = {
    if ConditionPassed() then {
        let result = imm32;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val MOV_i_T3pre_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function MOV_i_T3pre_A_decode (i, imm4, imm3, Rd, imm8) = {
    __unconditional = false;
    let carry = undefined : bits(1);
    let d = UInt(Rd);
    let setflags = false;
    let imm32 = ZeroExtend(((imm4 @ i) @ imm3) @ imm8, 32);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_i_Op_A(carry, d, imm32, setflags)
}

val MOV_i_T2pre_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function MOV_i_T2pre_A_decode (i, S, imm3, Rd, imm8) = {
    __unconditional = false;
    carry : bits(1) = undefined : bits(1);
    let d = UInt(Rd);
    let setflags = S == 0b1;
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_i_Op_A(carry, d, imm32, setflags)
}

val MOV_i_T1pre_A_decode : (bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function MOV_i_T1pre_A_decode (Rd, imm8) = {
    __unconditional = false;
    carry : bits(1) = undefined : bits(1);
    let d = UInt(Rd);
    let setflags = ~(InITBlock());
    let imm32 = ZeroExtend(imm8, 32);
    let carry = PSTATE.C;
    __PostDecode();
    MOV_i_Op_A(carry, d, imm32, setflags)
}

val MOV_i_A2pre_A_decode : (bits(4), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function MOV_i_A2pre_A_decode (cond, imm4, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let carry = undefined : bits(1);
    let d = UInt(Rd);
    let setflags = false;
    let imm32 = ZeroExtend(imm4 @ imm12, 32);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MOV_i_Op_A(carry, d, imm32, setflags)
}

val MOV_i_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function MOV_i_A1pre_A_decode (cond, S, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    carry : bits(1) = undefined : bits(1);
    let d = UInt(Rd);
    let setflags = S == 0b1;
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    MOV_i_Op_A(carry, d, imm32, setflags)
}

val EOR_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function EOR_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) ^ shifted;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val EOR_r_T2_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function EOR_r_T2_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("TEQ (register)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 & ~(setflags) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    EOR_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val EOR_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function EOR_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    EOR_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val EOR_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function EOR_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    EOR_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val EOR_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (bits(1), int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function EOR_i_Op_A (carry, d, imm32, n, setflags) = {
    if ConditionPassed() then {
        let result : bits(32) = R(n) ^ imm32;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val EOR_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function EOR_i_T1_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("TEQ (immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if d == 15 & ~(setflags) | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    EOR_i_Op_A(carry, d, imm32, n, setflags)
}

val EOR_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function EOR_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    EOR_i_Op_A(carry, d, imm32, n, setflags)
}

val BIC_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function BIC_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) & ~(shifted);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val BIC_r_T2_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BIC_r_T2_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BIC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val BIC_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function BIC_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    BIC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val BIC_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BIC_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    BIC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val BIC_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (bits(1), int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function BIC_i_Op_A (carry, d, imm32, n, setflags) = {
    if ConditionPassed() then {
        let result : bits(32) = R(n) & ~(imm32);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val BIC_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function BIC_i_T1_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BIC_i_Op_A(carry, d, imm32, n, setflags)
}

val BIC_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function BIC_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    BIC_i_Op_A(carry, d, imm32, n, setflags)
}

val AND_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function AND_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        carry : bits(1) = undefined : bits(1);
        result : bits(32) = undefined : bits(32);
        shifted : bits(32) = undefined : bits(32);
        (shifted, carry) = Shift_C(R(m), shift_t, shift_n, PSTATE.C);
        result = R(n) & shifted;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val AND_r_T2_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AND_r_T2_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("TST (register)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 & ~(setflags) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    AND_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val AND_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function AND_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    AND_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val AND_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AND_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    AND_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val AND_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (bits(1), int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function AND_i_Op_A (carry, d, imm32, n, setflags) = {
    if ConditionPassed() then {
        let result : bits(32) = R(n) & imm32;
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                PSTATE.N = [result[31]];
                PSTATE.Z = IsZeroBit(result);
                PSTATE.C = carry
            }
        }
    }
}

val AND_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function AND_i_T1_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("TST (immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = T32ExpandImm_C((i @ imm3) @ imm8, PSTATE.C);
    if d == 15 & ~(setflags) | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    AND_i_Op_A(carry, d, imm32, n, setflags)
}

val AND_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function AND_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    carry : bits(1) = undefined : bits(1);
    imm32 : bits(32) = undefined : bits(32);
    (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);
    __PostDecode();
    AND_i_Op_A(carry, d, imm32, n, setflags)
}

val ADD_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function ADD_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), shifted, 0b0);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val ADD_r_T3_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADD_r_T3_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMN (register)"))
    };
    if Rn == 0xD then {
        throw(Error_See("ADD (SP plus register)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 & ~(setflags) | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ADD_r_T2_A_decode : (bits(1), bits(4), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ADD_r_T2_A_decode (DN, Rm, Rdn) = {
    __unconditional = false;
    if (DN @ Rdn) == 0xD | Rm == 0xD then {
        throw(Error_See("ADD (SP plus register)"))
    };
    let d = UInt(DN @ Rdn);
    let n = d;
    let m = UInt(Rm);
    let setflags : bool = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if n == 15 & m == 15 then {
        throw(Error_Unpredictable())
    };
    if (d == 15 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ADD_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ADD_r_T1_A_decode (Rm, Rn, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    ADD_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ADD_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADD_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xD then {
        throw(Error_See("ADD (SP plus register)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    ADD_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ADD_i_OpA_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ADD_i_OpA_A (d, imm32, n, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(R(n), imm32, 0b0);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val ADD_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function ADD_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF & S == 0b0 then {
        throw(Error_See("ADR"))
    };
    if Rn == 0xD then {
        throw(Error_See("ADD (SP plus immediate)"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    ADD_i_OpA_A(d, imm32, n, setflags)
}

val ADD_SP_r_Op_A : forall 'd 'm ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_r_Op_A (d, m, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(get_SP(), shifted, 0b0);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val ADD_SP_r_T3_A_decode : (bits(1), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_r_T3_A_decode (S, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMN (register)"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if d == 15 & ~(setflags) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_SP_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val ADD_SP_r_T2_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_r_T2_A_decode Rm = {
    __unconditional = false;
    if Rm == 0xD then {
        throw(Error_See("encoding T1"))
    };
    let d = 13;
    let m = UInt(Rm);
    let setflags = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    ADD_SP_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val ADD_SP_r_T1_A_decode : (bits(1), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_r_T1_A_decode (DM, Rdm) = {
    __unconditional = false;
    let d = UInt(DM @ Rdm);
    let m = UInt(DM @ Rdm);
    let setflags = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if (d == 15 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_SP_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val ADD_SP_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_r_A1_A_decode (cond, S, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    ADD_SP_r_Op_A(d, m, setflags, shift_n, shift_t)
}

val ADD_SP_i_Op_A : forall 'd ('setflags : Bool),
  ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_i_Op_A (d, imm32, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(get_SP(), imm32, 0b0);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val ADD_SP_i_T4_A_decode : (bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_i_T4_A_decode (i, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let setflags = false;
    let imm32 = ZeroExtend((i @ imm3) @ imm8, 32);
    if d == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_SP_i_Op_A(d, imm32, setflags)
}

val ADD_SP_i_T3_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_i_T3_A_decode (i, S, imm3, Rd, imm8) = {
    __unconditional = false;
    if Rd == 0xF & S == 0b1 then {
        throw(Error_See("CMN (immediate)"))
    };
    let d = UInt(Rd);
    let setflags = S == 0b1;
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if d == 15 & ~(setflags) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADD_SP_i_Op_A(d, imm32, setflags)
}

val ADD_SP_i_T2_A_decode : bits(7) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_i_T2_A_decode imm7 = {
    __unconditional = false;
    let d = 13;
    let setflags = false;
    let imm32 : bits(32) = ZeroExtend(imm7 @ 0b00, 32);
    __PostDecode();
    ADD_SP_i_Op_A(d, imm32, setflags)
}

val ADD_SP_i_T1_A_decode : (bits(3), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_i_T1_A_decode (Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let setflags = false;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    __PostDecode();
    ADD_SP_i_Op_A(d, imm32, setflags)
}

val ADD_SP_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function ADD_SP_i_A1_A_decode (cond, S, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    ADD_SP_i_Op_A(d, imm32, setflags)
}

val ADC_r_Op_A : forall 'd 'm 'n ('setflags : Bool) 'shift_n,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), int('m), int('n), bool('setflags), int('shift_n), SRType) -> unit effect {escape, rreg, undef, wreg}

function ADC_r_Op_A (d, m, n, setflags, shift_n, shift_t) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        let shifted : bits(32) = Shift(R(m), shift_t, shift_n, PSTATE.C);
        (result, nzcv) = AddWithCarry(R(n), shifted, PSTATE.C);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val ADC_r_T2_A_decode : (bits(1), bits(4), bits(3), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADC_r_T2_A_decode (S, Rn, imm3, Rd, imm2, typ, Rm) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm3 @ imm2);
    if (d == 15 | n == 15) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ADC_r_T1_A_decode : (bits(3), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function ADC_r_T1_A_decode (Rm, Rdn) = {
    __unconditional = false;
    let d = UInt(Rdn);
    let n = UInt(Rdn);
    let m = UInt(Rm);
    let setflags = ~(InITBlock());
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    ADC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ADC_r_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function ADC_r_A1_A_decode (cond, S, Rn, Rd, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let setflags = S == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    __PostDecode();
    ADC_r_Op_A(d, m, n, setflags, shift_n, shift_t)
}

val ADC_i_Op_A : forall 'd 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 14 | not(not('d == 15))).
  (int('d), bits(32), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function ADC_i_Op_A (d, imm32, n, setflags) = {
    if ConditionPassed() then {
        nzcv : bits(4) = undefined : bits(4);
        result : bits(32) = undefined : bits(32);
        (result, nzcv) = AddWithCarry(R(n), imm32, PSTATE.C);
        if d == 15 then {
            if setflags then {
                ALUExceptionReturn(result)
            } else {
                ALUWritePC(result)
            }
        } else {
            R(d) = result;
            if setflags then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
            }
        }
    }
}

val ADC_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(3), bits(4), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function ADC_i_T1_A_decode (i, S, Rn, imm3, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = T32ExpandImm((i @ imm3) @ imm8);
    if d == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    ADC_i_Op_A(d, imm32, n, setflags)
}

val ADC_i_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function ADC_i_A1_A_decode (cond, S, Rn, Rd, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let n = UInt(Rn);
    let setflags = S == 0b1;
    let imm32 = A32ExpandImm(imm12);
    __PostDecode();
    ADC_i_Op_A(d, imm32, n, setflags)
}

val AArch32_TakeSMCException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeSMCException () = {
    assert(HaveEL(EL3) & ELUsingAArch32(EL3));
    AArch32_ITAdvance();
    SSAdvance();
    let preferred_exception_return : bits(32) = NextInstrAddr();
    let vect_offset = 8;
    let lr_offset = 0;
    AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_TakeMonitorTrapException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeMonitorTrapException () = {
    assert(HaveEL(EL3) & ELUsingAArch32(EL3));
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset = 4;
    let lr_offset = if CurrentInstrSet() == InstrSet_A32 then 4 else 2;
    AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
}

val ICIALLUIS : unit -> unit effect {escape, rreg, undef, wreg}

function ICIALLUIS () = {
    IC_IALLUIS()
}

val ICIALLU : unit -> unit effect {escape, rreg, undef, wreg}

function ICIALLU () = {
    IC_IALLU()
}

val DCISW : bits(32) -> unit effect {escape, rreg, undef, wreg}

function DCISW val_name = {
    DC_ISW(ZeroExtend(val_name))
}

val DCCSW : bits(32) -> unit effect {escape, rreg, undef, wreg}

function DCCSW val_name = {
    DC_CSW(ZeroExtend(val_name))
}

val DCPS_Op_A : bits(2) -> unit effect {escape, rreg, undef, wreg}

function DCPS_Op_A opt = {
    DCPSInstruction(opt)
}

val DCPS_T1_A_decode : bits(2) -> unit effect {escape, rreg, undef, wreg}

function DCPS_T1_A_decode opt = {
    __unconditional = true;
    if ~(Halted()) | opt == 0b00 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    DCPS_Op_A(opt)
}

val AArch32_TakeSVCException : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeSVCException immediate = {
    AArch32_ITAdvance();
    SSAdvance();
    let route_to_hyp = (EL2Enabled() & PSTATE.EL == EL0) & [get_HCR()[27]] == 0b1;
    let preferred_exception_return : bits(32) = NextInstrAddr();
    let vect_offset = 8;
    let lr_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if PSTATE.EL == EL2 | route_to_hyp then {
        exception = ExceptionSyndrome(Exception_SupervisorCall);
        __tc1 : bits(25) = exception.syndrome;
        __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
        exception.syndrome = __tc1;
        if PSTATE.EL == EL2 then {
            AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
        } else {
            AArch32_EnterHypMode(exception, preferred_exception_return, 20)
        }
    } else {
        AArch32_EnterMode(M32_Svc, preferred_exception_return, lr_offset, vect_offset)
    }
}

val AArch32_CallSupervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CallSupervisor immediate__arg = {
    immediate = immediate__arg;
    if AArch32_CurrentCond() != 0xE then {
        immediate = undefined : bits(16)
    };
    if AArch32_GeneralExceptionsToAArch64() then {
        AArch64_CallSupervisor(immediate)
    } else {
        AArch32_TakeSVCException(immediate)
    }
}

val SVC_Op_A : bits(32) -> unit effect {escape, rreg, undef, wreg}

function SVC_Op_A imm32 = {
    if ConditionPassed() then {
        AArch32_CallSupervisor(slice(imm32, 0, 16))
    }
}

val SVC_T1_A_decode : bits(8) -> unit effect {escape, rreg, undef, wreg}

function SVC_T1_A_decode imm8 = {
    __unconditional = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    __PostDecode();
    SVC_Op_A(imm32)
}

val SVC_A1_A_decode : (bits(4), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function SVC_A1_A_decode (cond, imm24) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = ZeroExtend(imm24, 32);
    __PostDecode();
    SVC_Op_A(imm32)
}

val AArch32_TakeHypTrapException : ExceptionRecord -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeHypTrapException exception = {
    assert((HaveEL(EL2) & ~(IsSecure())) & ELUsingAArch32(EL2));
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset = 20;
    AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
}

val AArch32_TakeHVCException : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeHVCException immediate = {
    assert(HaveEL(EL2) & ELUsingAArch32(EL2));
    AArch32_ITAdvance();
    SSAdvance();
    let preferred_exception_return : bits(32) = NextInstrAddr();
    let vect_offset = 8;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_HypervisorCall);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    if PSTATE.EL == EL2 then {
        AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
    } else {
        AArch32_EnterHypMode(exception, preferred_exception_return, 20)
    }
}

val AArch32_EncodePARSD : (AddressDescriptor, bits(1)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_EncodePARSD (addrdesc, supersection) = {
    par : bits(32) = undefined : bits(32);
    par = Zeros(32);
    if ~(IsFault(addrdesc)) then {
        par = __SetSlice_bits(32, 1, par, 0, 0b0);
        par = __SetSlice_bits(32, 1, par, 1, supersection);
        par = __SetSlice_bits(32, 2, par, 2, AArch32_PAROuterAttrs(addrdesc.memattrs));
        par = __SetSlice_bits(32, 3, par, 4, AArch32_PARInnerAttrs(addrdesc.memattrs));
        par = __SetSlice_bits(32, 1, par, 7, if addrdesc.memattrs.shareable then 0b1 else 0b0);
        par = __SetSlice_bits(32, 1, par, 9, addrdesc.paddress.NS);
        par = __SetSlice_bits(32, 1, par, 10, if addrdesc.memattrs.outershareable then 0b0 else 0b1);
        par = __SetSlice_bits(32, 1, par, 11, 0b0);
        par = __SetSlice_bits(32, 20, par, 12, slice(addrdesc.paddress.address, 12, 20))
    } else {
        par = __SetSlice_bits(32, 1, par, 0, 0b1);
        par = __SetSlice_bits(32, 6, par, 1, AArch32_PARFaultStatusSD(addrdesc.fault));
        par = __SetSlice_bits(32, 1, par, 11, 0b0)
    };
    __tc1 : bits(64) = get_PAR();
    let __tc1 = __SetSlice_bits(64, 32, __tc1, 0, par);
    set_PAR(__tc1)
}

val AArch32_EncodePARLD : forall ('report_domain_fault : Bool).
  (AddressDescriptor, bool('report_domain_fault)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_EncodePARLD (addrdesc, report_domain_fault) = {
    par : bits(64) = undefined : bits(64);
    par = Zeros(64);
    if ~(IsFault(addrdesc)) then {
        par = __SetSlice_bits(64, 1, par, 0, 0b0);
        par = __SetSlice_bits(64, 2, par, 7, PARShareabilityDecode(addrdesc.memattrs));
        par = __SetSlice_bits(64, 1, par, 9, addrdesc.paddress.NS);
        par = __SetSlice_bits(64, 1, par, 11, 0b1);
        par = __SetSlice_bits(64, 28, par, 12, slice(addrdesc.paddress.address, 12, 28));
        par = __SetSlice_bits(64, 8, par, 56, PARAttrsDecode(addrdesc.memattrs))
    } else {
        par = __SetSlice_bits(64, 1, par, 0, 0b1);
        par = __SetSlice_bits(64, 6, par, 1, AArch32_PARFaultStatusLD(addrdesc.fault, report_domain_fault));
        par = __SetSlice_bits(64, 1, par, 8, if addrdesc.fault.s2fs1walk then 0b1 else 0b0);
        par = __SetSlice_bits(64, 1, par, 9, if addrdesc.fault.secondstage then 0b1 else 0b0);
        par = __SetSlice_bits(64, 1, par, 11, 0b1)
    };
    __tc1 : bits(64) = get_PAR();
    let __tc1 = __SetSlice_bits(64, 64, __tc1, 0, par);
    set_PAR(__tc1)
}

val AArch32_CheckForWFxTrap : forall ('is_wfe : Bool).
  (bits(2), bool('is_wfe)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckForWFxTrap (target_el, is_wfe) = {
    assert(HaveEL(target_el));
    if ~(ELUsingAArch32(target_el)) then {
        AArch64_CheckForWFxTrap(target_el, is_wfe);
        return()
    };
    trap : bool = undefined : bool;
    match target_el {
      ? if ? == EL1 => {
          trap = (if is_wfe then [get_SCTLR()[18]] else [get_SCTLR()[16]]) == 0b0
      },
      ? if ? == EL2 => {
          trap = (if is_wfe then [get_HCR()[14]] else [get_HCR()[13]]) == 0b1
      },
      ? if ? == EL3 => {
          trap = (if is_wfe then [get_SCR()[13]] else [get_SCR()[12]]) == 0b1
      }
    };
    let trap = trap;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if trap then {
        if ((target_el == EL1 & EL2Enabled()) & ~(ELUsingAArch32(EL2))) & [HCR_EL2[27]] == 0b1 then {
            AArch64_WFxTrap(target_el, is_wfe)
        };
        if target_el == EL3 then {
            AArch32_TakeMonitorTrapException()
        } else {
            if target_el == EL2 then {
                exception = ExceptionSyndrome(Exception_WFxTrap);
                __tc1 : bits(25) = exception.syndrome;
                __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
                exception.syndrome = __tc1;
                __tc2 : bits(25) = exception.syndrome;
                __tc2 = __SetSlice_bits(25, 1, __tc2, 0, if is_wfe then 0b1 else 0b0);
                exception.syndrome = __tc2;
                AArch32_TakeHypTrapException(exception)
            } else {
                AArch32_TakeUndefInstrException()
            }
        }
    }
}

val WFI_Op_A : unit -> unit effect {escape, rreg, undef, wreg}

function WFI_Op_A () = {
    if ConditionPassed() then {
        if ~(InterruptPending()) then {
            if PSTATE.EL == EL0 then {
                AArch32_CheckForWFxTrap(EL1, false)
            };
            if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ~(IsInHost()) then {
                AArch32_CheckForWFxTrap(EL2, false)
            };
            if HaveEL(EL3) & PSTATE.M != M32_Monitor then {
                AArch32_CheckForWFxTrap(EL3, false)
            };
            WaitForInterrupt()
        }
    }
}

val WFI_T2_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function WFI_T2_A_decode () = {
    __unconditional = false;
    __PostDecode();
    WFI_Op_A()
}

val WFI_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function WFI_T1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    WFI_Op_A()
}

val WFI_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function WFI_A1_A_decode cond = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    WFI_Op_A()
}

val WFE_Op_A : unit -> unit effect {escape, rreg, undef, wreg}

function WFE_Op_A () = {
    if ConditionPassed() then {
        if IsEventRegisterSet() then {
            ClearEventRegister()
        } else {
            if PSTATE.EL == EL0 then {
                AArch32_CheckForWFxTrap(EL1, true)
            };
            if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ~(IsInHost()) then {
                AArch32_CheckForWFxTrap(EL2, true)
            };
            if HaveEL(EL3) & PSTATE.M != M32_Monitor then {
                AArch32_CheckForWFxTrap(EL3, true)
            };
            WaitForEvent()
        }
    }
}

val WFE_T2_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function WFE_T2_A_decode () = {
    __unconditional = false;
    __PostDecode();
    WFE_Op_A()
}

val WFE_T1_A_decode : unit -> unit effect {escape, rreg, undef, wreg}

function WFE_T1_A_decode () = {
    __unconditional = false;
    __PostDecode();
    WFE_Op_A()
}

val WFE_A1_A_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function WFE_A1_A_decode cond = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    WFE_Op_A()
}

val AArch32_CheckForSMCUndefOrTrap : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckForSMCUndefOrTrap () = {
    if ~(HaveEL(EL3)) | PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    exception : ExceptionRecord = undefined : ExceptionRecord;
    route_to_hyp : bool = undefined : bool;
    if EL2Enabled() & ~(ELUsingAArch32(EL2)) then {
        AArch64_CheckForSMCUndefOrTrap(Zeros(16))
    } else {
        route_to_hyp = ((HaveEL(EL2) & ~(IsSecure())) & PSTATE.EL == EL1) & [get_HCR()[19]] == 0b1;
        if route_to_hyp then {
            exception = ExceptionSyndrome(Exception_MonitorCall);
            AArch32_TakeHypTrapException(exception)
        }
    }
}

val SMC_Op_AS : unit -> unit effect {escape, rreg, undef, wreg}

function SMC_Op_AS () = {
    if ConditionPassed() then {
        c : Constraint = undefined : Constraint;
        AArch32_CheckForSMCUndefOrTrap();
        if ~(ELUsingAArch32(EL3)) then {
            if [SCR_EL3[7]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            if [get_SCR()[7]] == 0b1 then {
                if IsSecure() then {
                    c = ConstrainUnpredictable(Unpredictable_SMD);
                    assert(c == Constraint_NOP | c == Constraint_UNDEF);
                    if c == Constraint_NOP then {
                        EndOfInstruction()
                    }
                };
                throw(Error_Undefined())
            }
        };
        if ~(ELUsingAArch32(EL3)) then {
            AArch64_CallSecureMonitor(Zeros(16))
        } else {
            AArch32_TakeSMCException()
        }
    }
}

val SMC_T1_AS_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function SMC_T1_AS_decode imm4 = {
    __unconditional = false;
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    SMC_Op_AS()
}

val SMC_A1_AS_decode : (bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SMC_A1_AS_decode (cond, imm4) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    __PostDecode();
    SMC_Op_AS()
}

val AArch32_CheckFPAdvSIMDTrap : forall ('advsimd : Bool).
  bool('advsimd) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckFPAdvSIMDTrap advsimd = {
    exception : ExceptionRecord = undefined : ExceptionRecord;
    hcptr_cp10 : bits(1) = undefined : bits(1);
    hcptr_tase : bits(1) = undefined : bits(1);
    if EL2Enabled() & ~(ELUsingAArch32(EL2)) then {
        AArch64_CheckFPAdvSIMDTrap()
    } else {
        if HaveEL(EL2) & ~(IsSecure()) then {
            hcptr_tase = [get_HCPTR()[15]];
            hcptr_cp10 = [get_HCPTR()[10]];
            if (HaveEL(EL3) & ELUsingAArch32(EL3)) & ~(IsSecure()) then {
                if [NSACR[15]] == 0b1 then {
                    hcptr_tase = 0b1
                };
                if [NSACR[10]] == 0b0 then {
                    hcptr_cp10 = 0b1
                }
            };
            if advsimd & hcptr_tase == 0b1 | hcptr_cp10 == 0b1 then {
                exception = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
                __tc1 : bits(25) = exception.syndrome;
                __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
                exception.syndrome = __tc1;
                if advsimd then {
                    __tc2 : bits(25) = exception.syndrome;
                    __tc2 = __SetSlice_bits(25, 1, __tc2, 5, 0b1);
                    exception.syndrome = __tc2
                } else {
                    __tc3 : bits(25) = exception.syndrome;
                    __tc3 = __SetSlice_bits(25, 1, __tc3, 5, 0b0);
                    exception.syndrome = __tc3;
                    __tc4 : bits(25) = exception.syndrome;
                    __tc4 = __SetSlice_bits(25, 4, __tc4, 0, 0xA);
                    exception.syndrome = __tc4
                };
                if PSTATE.EL == EL2 then {
                    AArch32_TakeUndefInstrException(exception)
                } else {
                    AArch32_TakeHypTrapException(exception)
                }
            }
        };
        if HaveEL(EL3) & ~(ELUsingAArch32(EL3)) then {
            if [CPTR_EL3[10]] == 0b1 then {
                AArch64_AdvSIMDFPAccessTrap(EL3)
            }
        }
    };
    return()
}

val AArch32_CheckCP15InstrCoarseTraps : forall ('CRn : Int) ('nreg : Int) ('CRm : Int).
  (int('CRn), int('nreg), int('CRm)) -> bool effect {escape, rreg, undef}

function AArch32_CheckCP15InstrCoarseTraps (CRn, nreg, CRm) = {
    major : int = undefined : int;
    if EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
        if PSTATE.EL == EL0 & ~(ELUsingAArch32(EL2)) then {
            return(AArch64_CheckCP15InstrCoarseTraps(CRn, nreg, CRm))
        };
        major = if nreg == 1 then CRn else CRm;
        if ~(major == 4 | major == 14) & [get_HSTR()[major]] == 0b1 then {
            return(true)
        };
        if ([get_HCR()[20]] == 0b1 & nreg == 1) & ((CRn == 9 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8) | CRn == 10 & (CRm == 0 | CRm == 1 | CRm == 4 | CRm == 8)) | CRn == 11 & (CRm == 0 | CRm == 1 | CRm == 2 | CRm == 3 | CRm == 4 | CRm == 5 | CRm == 6 | CRm == 7 | CRm == 8 | CRm == 15)) then {
            return(true)
        }
    };
    false
}

val AArch32_CheckAdvSIMDOrFPEnabled : forall ('fpexc_check : Bool) ('advsimd : Bool).
  (bool('fpexc_check), bool('advsimd)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckAdvSIMDOrFPEnabled (fpexc_check, advsimd) = {
    c : Constraint = undefined : Constraint;
    cpacr_asedis : bits(1) = undefined : bits(1);
    cpacr_cp10 : bits(2) = undefined : bits(2);
    disabled : bool = undefined : bool;
    fpexc_en : bits(1) = undefined : bits(1);
    if (PSTATE.EL == EL0 & (~(HaveEL(EL2)) | ~(ELUsingAArch32(EL2)) & [HCR_EL2[27]] == 0b0)) & ~(ELUsingAArch32(EL1)) then {
        AArch64_CheckFPAdvSIMDEnabled()
    } else {
        if (((PSTATE.EL == EL0 & HaveEL(EL2)) & ~(ELUsingAArch32(EL2))) & [HCR_EL2[27]] == 0b1) & ~(ELUsingAArch32(EL1)) then {
            if fpexc_check & [HCR_EL2[31]] == 0b0 then {
                fpexc_en = undefined;
                if fpexc_en == 0b0 then {
                    throw(Error_Undefined())
                }
            };
            AArch64_CheckFPAdvSIMDEnabled()
        } else {
            cpacr_asedis = [get_CPACR()[31]];
            cpacr_cp10 = slice(get_CPACR(), 20, 2);
            if (HaveEL(EL3) & ELUsingAArch32(EL3)) & ~(IsSecure()) then {
                if [NSACR[15]] == 0b1 then {
                    cpacr_asedis = 0b1
                };
                if [NSACR[10]] == 0b0 then {
                    cpacr_cp10 = 0b00
                }
            };
            if PSTATE.EL != EL2 then {
                if advsimd & cpacr_asedis == 0b1 then {
                    throw(Error_Undefined())
                };
                if cpacr_cp10 == 0b10 then {
                    (c, cpacr_cp10) = ConstrainUnpredictableBits(Unpredictable_RESCPACR)
                };
                match cpacr_cp10 {
                  0b00 => {
                      disabled = true
                  },
                  0b01 => {
                      disabled = PSTATE.EL == EL0
                  },
                  0b11 => {
                      disabled = false
                  }
                };
                if disabled then {
                    throw(Error_Undefined())
                }
            };
            if fpexc_check & [get_FPEXC()[30]] == 0b0 then {
                throw(Error_Undefined())
            };
            AArch32_CheckFPAdvSIMDTrap(advsimd)
        }
    }
}

val CheckVFPEnabled : forall ('include_fpexc_check : Bool).
  bool('include_fpexc_check) -> unit effect {escape, rreg, undef, wreg}

function CheckVFPEnabled include_fpexc_check_name = {
    let advsimd = false;
    AArch32_CheckAdvSIMDOrFPEnabled(include_fpexc_check_name, advsimd);
    return()
}

val VSQRT_Op_A : forall 'd 'esize 'm,
  ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VSQRT_Op_A (d, esize, m) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        match esize {
          16 => {
              S(d) = Zeros(16) @ FPSqrt(slice(S(m), 0, 16), FPSCR)
          },
          32 => {
              S(d) = FPSqrt(S(m), FPSCR)
          },
          64 => {
              D(d) = FPSqrt(D(m), FPSCR)
          }
        }
    }
}

val VSQRT_T1_A_decode : (bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSQRT_T1_A_decode (D, Vd, size, M, Vm) = {
    __unconditional = false;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let ('esize, 'd, 'm) : ({|16, 32, 64|}, range(0, 31), range(0, 31)) = match size {
      0b01 => (16, UInt(Vd @ D), UInt(Vm @ M)),
      0b10 => (32, UInt(Vd @ D), UInt(Vm @ M)),
      0b11 => (64, UInt(D @ Vd), UInt(M @ Vm))
    };
    __PostDecode();
    VSQRT_Op_A(d, esize, m)
}

val VSQRT_A1_A_decode : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSQRT_A1_A_decode (cond, D, Vd, size, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let (esize, d, m) : ({|16, 32, 64|}, range(0, 31), range(0, 31)) = match size {
      0b01 => (16, UInt(Vd @ D), UInt(Vm @ M)),
      0b10 => (32, UInt(Vd @ D), UInt(Vm @ M)),
      0b11 => (64, UInt(D @ Vd), UInt(M @ Vm))
    };
    __PostDecode();
    VSQRT_Op_A(d, esize, m)
}

val VSEL_Op_A : forall 'd 'esize 'm 'n,
  ('n >= 0 & 'n <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('n >= 0 & 'n <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('n >= 0 & 'n <= 31 | not('esize == 64)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (bits(4), int('d), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VSEL_Op_A (cond, d, esize, m, n) = {
    CheckVFPEnabled(true);
    match esize {
      16 => {
          S(d) = Zeros(16) @ slice(if ConditionHolds(cond) then S(n) else S(m), 0, 16)
      },
      32 => {
          S(d) = if ConditionHolds(cond) then S(n) else S(m)
      },
      64 => {
          D(d) = if ConditionHolds(cond) then D(n) else D(m)
      }
    }
}

val VSEL_T1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSEL_T1_A_decode (D, cc, Vn, Vd, size, N, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    let cond : bits(4) = (cc @ ([cc[1]] ^ [cc[0]])) @ 0b0;
    __PostDecode();
    VSEL_Op_A(cond, d, esize, m, n)
}

val VSEL_A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSEL_A1_A_decode (D, cc, Vn, Vd, size, N, M, Vm) = {
    __unconditional = true;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    let cond : bits(4) = (cc @ ([cc[1]] ^ [cc[0]])) @ 0b0;
    __PostDecode();
    VSEL_Op_A(cond, d, esize, m, n)
}

val VRINTZ_vfp_Op_A : forall 'd 'esize ('exact : Bool) 'm,
  ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), bool('exact), int('m), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function VRINTZ_vfp_Op_A (d, esize, exact, m, rounding) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        match esize {
          16 => {
              S(d) = Zeros(16) @ FPRoundInt(slice(S(m), 0, 16), FPSCR, rounding, exact)
          },
          32 => {
              S(d) = FPRoundInt(S(m), FPSCR, rounding, exact)
          },
          64 => {
              D(d) = FPRoundInt(D(m), FPSCR, rounding, exact)
          }
        }
    }
}

val VRINTZ_vfp_T1_A_decode : (bits(1), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTZ_vfp_T1_A_decode (D, Vd, size, op, M, Vm) = {
    __unconditional = false;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let rounding : FPRounding = if op == 0b1 then FPRounding_ZERO else FPRoundingMode(FPSCR);
    let exact : bool = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VRINTZ_vfp_Op_A(d, esize, exact, m, rounding)
}

val VRINTZ_vfp_A1_A_decode : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTZ_vfp_A1_A_decode (cond, D, Vd, size, op, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let rounding : FPRounding = if op == 0b1 then FPRounding_ZERO else FPRoundingMode(FPSCR);
    let exact : bool = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VRINTZ_vfp_Op_A(d, esize, exact, m, rounding)
}

val VRINTX_vfp_Op_A : forall 'd 'esize ('exact : Bool) 'm,
  ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), bool('exact), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VRINTX_vfp_Op_A (d, esize, exact, m) = {
    if ConditionPassed() then {
        rounding : FPRounding = undefined : FPRounding;
        CheckVFPEnabled(true);
        rounding = FPRoundingMode(FPSCR);
        match esize {
          16 => {
              S(d) = Zeros(16) @ FPRoundInt(slice(S(m), 0, 16), FPSCR, rounding, exact)
          },
          32 => {
              S(d) = FPRoundInt(S(m), FPSCR, rounding, exact)
          },
          64 => {
              D(d) = FPRoundInt(D(m), FPSCR, rounding, exact)
          }
        }
    }
}

val VRINTX_vfp_T1_A_decode : (bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTX_vfp_T1_A_decode (D, Vd, size, M, Vm) = {
    __unconditional = false;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let exact : bool = true;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VRINTX_vfp_Op_A(d, esize, exact, m)
}

val VRINTX_vfp_A1_A_decode : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTX_vfp_A1_A_decode (cond, D, Vd, size, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let exact : bool = true;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VRINTX_vfp_Op_A(d, esize, exact, m)
}

val VRINTA_vfp_Op_A : forall 'd 'esize ('exact : Bool) 'm,
  ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), bool('exact), int('m), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function VRINTA_vfp_Op_A (d, esize, exact, m, rounding) = {
    CheckVFPEnabled(true);
    match esize {
      16 => {
          S(d) = Zeros(16) @ FPRoundInt(slice(S(m), 0, 16), FPSCR, rounding, exact)
      },
      32 => {
          S(d) = FPRoundInt(S(m), FPSCR, rounding, exact)
      },
      64 => {
          D(d) = FPRoundInt(D(m), FPSCR, rounding, exact)
      }
    }
}

val VRINTA_vfp_T1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTA_vfp_T1_A_decode (D, RM, Vd, size, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let rounding : FPRounding = FPDecodeRM(RM);
    let exact : bool = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VRINTA_vfp_Op_A(d, esize, exact, m, rounding)
}

val VRINTA_vfp_A1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTA_vfp_A1_A_decode (D, RM, Vd, size, M, Vm) = {
    __unconditional = true;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let rounding : FPRounding = FPDecodeRM(RM);
    let exact : bool = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VRINTA_vfp_Op_A(d, esize, exact, m, rounding)
}

val VNMLA_Op_A : forall 'd 'esize 'm 'n,
  ('n >= 0 & 'n <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('n >= 0 & 'n <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('n >= 0 & 'n <= 31 | not('esize == 64)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), int('m), int('n), VFPNegMul) -> unit effect {escape, rreg, undef, wreg}

function VNMLA_Op_A (d, esize, m, n, typ) = {
    if ConditionPassed() then {
        product16 : bits(16) = undefined : bits(16);
        product32 : bits(32) = undefined : bits(32);
        product64 : bits(64) = undefined : bits(64);
        CheckVFPEnabled(true);
        match esize {
          16 => {
              product16 = FPMul(slice(S(n), 0, 16), slice(S(m), 0, 16), FPSCR);
              match typ {
                VFPNegMul_VNMLA => {
                    S(d) = Zeros(16) @ FPAdd(FPNeg(slice(S(d), 0, 16)), FPNeg(product16), FPSCR)
                },
                VFPNegMul_VNMLS => {
                    S(d) = Zeros(16) @ FPAdd(FPNeg(slice(S(d), 0, 16)), product16, FPSCR)
                },
                VFPNegMul_VNMUL => {
                    S(d) = Zeros(16) @ FPNeg(product16)
                }
              }
          },
          32 => {
              product32 = FPMul(S(n), S(m), FPSCR);
              match typ {
                VFPNegMul_VNMLA => {
                    S(d) = FPAdd(FPNeg(S(d)), FPNeg(product32), FPSCR)
                },
                VFPNegMul_VNMLS => {
                    S(d) = FPAdd(FPNeg(S(d)), product32, FPSCR)
                },
                VFPNegMul_VNMUL => {
                    S(d) = FPNeg(product32)
                }
              }
          },
          64 => {
              product64 = FPMul(D(n), D(m), FPSCR);
              match typ {
                VFPNegMul_VNMLA => {
                    D(d) = FPAdd(FPNeg(D(d)), FPNeg(product64), FPSCR)
                },
                VFPNegMul_VNMLS => {
                    D(d) = FPAdd(FPNeg(D(d)), product64, FPSCR)
                },
                VFPNegMul_VNMUL => {
                    D(d) = FPNeg(product64)
                }
              }
          }
        }
    }
}

val VNMLA_T2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VNMLA_T2_A_decode (D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let typ : VFPNegMul = VFPNegMul_VNMUL;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VNMLA_Op_A(d, esize, m, n, typ)
}

val VNMLA_T1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VNMLA_T1_A_decode (D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let typ : VFPNegMul = if op == 0b1 then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VNMLA_Op_A(d, esize, m, n, typ)
}

val VNMLA_A2_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VNMLA_A2_A_decode (cond, D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let typ : VFPNegMul = VFPNegMul_VNMUL;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VNMLA_Op_A(d, esize, m, n, typ)
}

val VNMLA_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VNMLA_A1_A_decode (cond, D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let typ : VFPNegMul = if op == 0b1 then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VNMLA_Op_A(d, esize, m, n, typ)
}

val VMSR_Op_AS : forall ('t : Int), ('t >= 0 & 't <= 15).
  (bits(4), int('t)) -> unit effect {escape, rreg, undef, wreg}

function VMSR_Op_AS (reg, t) = {
    if ConditionPassed() then {
        if reg == 0x1 then {
            CheckVFPEnabled(true);
            FPSCR = R(t)
        } else {
            if PSTATE.EL == EL0 then {
                throw(Error_Undefined())
            } else {
                CheckVFPEnabled(false);
                match reg {
                  0x0 => (),
                  0x8 => {
                      set_FPEXC(R(t))
                  },
                  _ => {
                      Unreachable()
                  }
                }
            }
        }
    }
}

val VMSR_T1A1_AS_decode__0 : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMSR_T1A1_AS_decode__1 : (bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMSR_T1A1_AS_decode = {VMSR_T1A1_AS_decode__0, VMSR_T1A1_AS_decode__1}

function VMSR_T1A1_AS_decode__0 (cond, reg, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    if (reg & 0xE) != 0x0 & reg != 0x8 then {
        throw(Error_Unpredictable())
    };
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMSR_Op_AS(reg, t)
}

function VMSR_T1A1_AS_decode__1 (reg, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    if (reg & 0xE) != 0x0 & reg != 0x8 then {
        throw(Error_Unpredictable())
    };
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMSR_Op_AS(reg, t)
}

val VMOV_ss_Op_A : forall 'm 't 't2 ('to_arm_registers : Bool),
  ('m >= 0 & 'm <= 31 | not('to_arm_registers)) & ('t >= 0 & 't <= 14 | not('to_arm_registers)) & ('m + 1 >= 0 & 'm + 1 <= 31 | not('to_arm_registers)) & ('t2 >= 0 & 't2 <= 14 | not('to_arm_registers)) & ('t >= 0 & 't <= 15 | not(not('to_arm_registers))) & ('m >= 0 & 'm <= 31 | not(not('to_arm_registers))) & ('t2 >= 0 & 't2 <= 15 | not(not('to_arm_registers))) & ('m + 1 <= 31 | not(not('to_arm_registers))).
  (int('m), int('t), int('t2), bool('to_arm_registers)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_ss_Op_A (m, t, t2, to_arm_registers) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        if to_arm_registers then {
            R(t) = S(m);
            R(t2) = S(m + 1)
        } else {
            S(m) = R(t);
            S(m + 1) = R(t2)
        }
    }
}

val VMOV_ss_T1A1_A_decode__0 : (bits(4), bits(1), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMOV_ss_T1A1_A_decode__1 : (bits(1), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMOV_ss_T1A1_A_decode = {
  VMOV_ss_T1A1_A_decode__0,
  VMOV_ss_T1A1_A_decode__1
}

function VMOV_ss_T1A1_A_decode__0 (cond, op, Rt2, Rt, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let to_arm_registers = op == 0b1;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let m = UInt(Vm @ M);
    if (t == 15 | t2 == 15) | m == 31 then {
        throw(Error_Unpredictable())
    };
    if to_arm_registers & t == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_ss_Op_A(m, t, t2, to_arm_registers)
}

function VMOV_ss_T1A1_A_decode__1 (op, Rt2, Rt, M, Vm) = {
    __unconditional = false;
    let to_arm_registers = op == 0b1;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let m = UInt(Vm @ M);
    if (t == 15 | t2 == 15) | m == 31 then {
        throw(Error_Unpredictable())
    };
    if to_arm_registers & t == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_ss_Op_A(m, t, t2, to_arm_registers)
}

val VMOV_s_Op_A : forall 'n 't ('to_arm_register : Bool),
  ('n >= 0 & 'n <= 31 | not('to_arm_register)) & ('t >= 0 & 't <= 14 | not('to_arm_register)) & ('t >= 0 & 't <= 15 | not(not('to_arm_register))) & ('n >= 0 & 'n <= 31 | not(not('to_arm_register))).
  (int('n), int('t), bool('to_arm_register)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_s_Op_A (n, t, to_arm_register) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        if to_arm_register then {
            R(t) = S(n)
        } else {
            S(n) = R(t)
        }
    }
}

val VMOV_s_T1_A_decode : (bits(1), bits(4), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_s_T1_A_decode (op, Vn, Rt, N) = {
    __unconditional = false;
    let to_arm_register = op == 0b1;
    let t = UInt(Rt);
    let n = UInt(Vn @ N);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_s_Op_A(n, t, to_arm_register)
}

val VMOV_s_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_s_A1_A_decode (cond, op, Vn, Rt, N) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let to_arm_register = op == 0b1;
    let t = UInt(Rt);
    let n = UInt(Vn @ N);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_s_Op_A(n, t, to_arm_register)
}

val VMOV_h_Op_A : forall 'n 't ('to_arm_register : Bool),
  ('n >= 0 & 'n <= 31 | not('to_arm_register)) & ('t >= 0 & 't <= 14 | not('to_arm_register)) & ('t >= 0 & 't <= 15 | not(not('to_arm_register))) & ('n >= 0 & 'n <= 31 | not(not('to_arm_register))).
  (int('n), int('t), bool('to_arm_register)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_h_Op_A (n, t, to_arm_register) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        if to_arm_register then {
            R(t) = Zeros(16) @ slice(S(n), 0, 16)
        } else {
            S(n) = Zeros(16) @ slice(R(t), 0, 16)
        }
    }
}

val VMOV_h_T1_A_decode : (bits(1), bits(4), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_h_T1_A_decode (op, Vn, Rt, N) = {
    __unconditional = false;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    let to_arm_register = op == 0b1;
    let t = UInt(Rt);
    let n = UInt(Vn @ N);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_h_Op_A(n, t, to_arm_register)
}

val VMOV_h_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_h_A1_A_decode (cond, op, Vn, Rt, N) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let to_arm_register = op == 0b1;
    let t = UInt(Rt);
    let n = UInt(Vn @ N);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_h_Op_A(n, t, to_arm_register)
}

val VMOV_d_Op_A : forall 'm 't 't2 ('to_arm_registers : Bool),
  ('m >= 0 & 'm <= 31 | not('to_arm_registers)) & ('t >= 0 & 't <= 14 | not('to_arm_registers)) & ('t2 >= 0 & 't2 <= 14 | not('to_arm_registers)) & ('m >= 0 & 'm <= 31 | not(not('to_arm_registers))) & ('t >= 0 & 't <= 15 | not(not('to_arm_registers))) & ('t2 >= 0 & 't2 <= 15 | not(not('to_arm_registers))).
  (int('m), int('t), int('t2), bool('to_arm_registers)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_d_Op_A (m, t, t2, to_arm_registers) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        if to_arm_registers then {
            R(t) = slice(D(m), 0, 32);
            R(t2) = slice(D(m), 32, 32)
        } else {
            __tc1 : bits(64) = D(m);
            __tc1 = __SetSlice_bits(64, 32, __tc1, 0, R(t));
            D(m) = __tc1;
            __tc2 : bits(64) = D(m);
            __tc2 = __SetSlice_bits(64, 32, __tc2, 32, R(t2));
            D(m) = __tc2
        }
    }
}

val VMOV_d_T1A1_A_decode__0 : (bits(4), bits(1), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMOV_d_T1A1_A_decode__1 : (bits(1), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMOV_d_T1A1_A_decode = {
  VMOV_d_T1A1_A_decode__0,
  VMOV_d_T1A1_A_decode__1
}

function VMOV_d_T1A1_A_decode__0 (cond, op, Rt2, Rt, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let to_arm_registers = op == 0b1;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let m = UInt(M @ Vm);
    if t == 15 | t2 == 15 then {
        throw(Error_Unpredictable())
    };
    if to_arm_registers & t == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_d_Op_A(m, t, t2, to_arm_registers)
}

function VMOV_d_T1A1_A_decode__1 (op, Rt2, Rt, M, Vm) = {
    __unconditional = false;
    let to_arm_registers = op == 0b1;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let m = UInt(M @ Vm);
    if t == 15 | t2 == 15 then {
        throw(Error_Unpredictable())
    };
    if to_arm_registers & t == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_d_Op_A(m, t, t2, to_arm_registers)
}

val VMOVX_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VMOVX_Op_A (d, m) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        S(d) = Zeros(16) @ slice(S(m), 16, 16)
    }
}

val VMOVX_T1_A_decode : (bits(1), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOVX_T1_A_decode (D, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let d = UInt(Vd @ D);
    let m = UInt(Vm @ M);
    __PostDecode();
    VMOVX_Op_A(d, m)
}

val VMOVX_A1_A_decode : (bits(1), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOVX_A1_A_decode (D, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let d = UInt(Vd @ D);
    let m = UInt(Vm @ M);
    __PostDecode();
    VMOVX_Op_A(d, m)
}

val VJCVT_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VJCVT_Op_A (d, m) = {
    CheckVFPEnabled(true);
    let fltval : bits(64) = D(m);
    let intval : bits(32) = FPToFixedJS(fltval, FPSCR, false);
    S(d) = intval
}

val VJCVT_T1_A_decode : (bits(1), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VJCVT_T1_A_decode (D, Vd, M, Vm) = {
    __unconditional = true;
    if ~(HaveFJCVTZSExt()) then {
        throw(Error_Undefined())
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    let d = UInt(Vd @ D);
    let m = UInt(M @ Vm);
    __PostDecode();
    VJCVT_Op_A(d, m)
}

val VJCVT_A1_A_decode : (bits(4), bits(1), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VJCVT_A1_A_decode (cond, D, Vd, M, Vm) = {
    __unconditional = true;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if ~(HaveFJCVTZSExt()) then {
        throw(Error_Undefined())
    };
    if cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let d = UInt(Vd @ D);
    let m = UInt(M @ Vm);
    __PostDecode();
    VJCVT_Op_A(d, m)
}

val VINS_Op_A : forall 'd 'm,
  ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VINS_Op_A (d, m) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        S(d) = slice(S(m), 0, 16) @ slice(S(d), 0, 16)
    }
}

val VINS_T1_A_decode : (bits(1), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VINS_T1_A_decode (D, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let d = UInt(Vd @ D);
    let m = UInt(Vm @ M);
    __PostDecode();
    VINS_Op_A(d, m)
}

val VINS_A1_A_decode : (bits(1), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VINS_A1_A_decode (D, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let d = UInt(Vd @ D);
    let m = UInt(Vm @ M);
    __PostDecode();
    VINS_Op_A(d, m)
}

val VFNMA_Op_A : forall 'd 'esize 'm 'n ('op1_neg : Bool),
  ('n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31 & 'm >= 0 & 'm <= 31).
  (int('d), int('esize), int('m), int('n), bool('op1_neg)) -> unit effect {escape, rreg, undef, wreg}

function VFNMA_Op_A (d, esize, m, n, op1_neg) = {
    if ConditionPassed() then {
        op16 : bits(16) = undefined : bits(16);
        op32 : bits(32) = undefined : bits(32);
        op64 : bits(64) = undefined : bits(64);
        CheckVFPEnabled(true);
        match esize {
          16 => {
              op16 = if op1_neg then FPNeg(slice(aget_S(n), 0, 16)) else slice(aget_S(n), 0, 16);
              aset_S(d, Zeros(16) @ FPMulAdd(FPNeg(slice(aget_S(d), 0, 16)), op16, slice(aget_S(m), 0, 16), FPSCR))
          },
          32 => {
              op32 = if op1_neg then FPNeg(aget_S(n)) else aget_S(n);
              aset_S(d, FPMulAdd(FPNeg(aget_S(d)), op32, aget_S(m), FPSCR))
          },
          64 => {
              op64 = if op1_neg then FPNeg(aget_D(n)) else aget_D(n);
              aset_D(d, FPMulAdd(FPNeg(aget_D(d)), op64, aget_D(m), FPSCR))
          }
        }
    }
}

val VFNMA_T1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFNMA_T1_A_decode (D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let op1_neg : bool = op == 0b1;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VFNMA_Op_A(d, esize, m, n, op1_neg)
}

val VFNMA_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFNMA_A1_A_decode (cond, D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let op1_neg : bool = op == 0b1;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VFNMA_Op_A(d, esize, m, n, op1_neg)
}

val VDIV_Op_A : forall 'd 'esize 'm 'n,
  ('n >= 0 & 'n <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('n >= 0 & 'n <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('n >= 0 & 'n <= 31 | not('esize == 64)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VDIV_Op_A (d, esize, m, n) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        match esize {
          16 => {
              S(d) = Zeros(16) @ FPDiv(slice(S(n), 0, 16), slice(S(m), 0, 16), FPSCR)
          },
          32 => {
              S(d) = FPDiv(S(n), S(m), FPSCR)
          },
          64 => {
              D(d) = FPDiv(D(n), D(m), FPSCR)
          }
        }
    }
}

val VDIV_T1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VDIV_T1_A_decode (D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VDIV_Op_A(d, esize, m, n)
}

val VDIV_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VDIV_A1_A_decode (cond, D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    let 'n = n;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31)));
    __PostDecode();
    VDIV_Op_A(d, esize, m, n)
}

val VCVT_xv_Op_A : forall 'd 'fp_size 'frac_bits 'size ('to_fixed : Bool) ('unsigned : Bool),
  ('d >= 0 & 'd <= 31 & 'frac_bits >= 0 & 'size >= 0).
  (int('d), int('fp_size), int('frac_bits), int('size), bool('to_fixed), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_xv_Op_A (d, fp_size, frac_bits, size, to_fixed, unsigned) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        if to_fixed then {
            result : bits('size) = undefined : bits('size);
            match fp_size {
              16 => {
                  result = FPToFixed(slice(aget_S(d), 0, 16), frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                  aset_S(d, Extend(result, 32, unsigned))
              },
              32 => {
                  result = FPToFixed(aget_S(d), frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                  aset_S(d, Extend(result, 32, unsigned))
              },
              64 => {
                  result = FPToFixed(aget_D(d), frac_bits, unsigned, FPSCR, FPRounding_ZERO);
                  aset_D(d, Extend(result, 64, unsigned))
              }
            };
            let result = result;
            ()
        } else {
            match fp_size {
              16 => {
                  let fp16 : bits(16) = FixedToFP(slice(aget_S(d), 0, size), frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
                  aset_S(d, Zeros(16) @ fp16)
              },
              32 => {
                  aset_S(d, FixedToFP(slice(aget_S(d), 0, size), frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN))
              },
              64 => {
                  aset_D(d, FixedToFP(slice(aget_D(d), 0, size), frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN))
              }
            }
        }
    }
}

val VCVT_xv_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_xv_T1_A_decode (D, op, U, Vd, sf, sx, i, imm4) = {
    __unconditional = false;
    if sf == 0b00 | sf == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sf == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let to_fixed : bool = op == 0b1;
    let unsigned : bool = U == 0b1;
    let size : {|16, 32|} = if sx == 0b0 then 16 else 32;
    let frac_bits : int = size - UInt(imm4 @ i);
    d : int = undefined : int;
    fp_size : int = undefined : int;
    match sf {
      0b01 => {
          fp_size = 16;
          d = UInt(Vd @ D)
      },
      0b10 => {
          fp_size = 32;
          d = UInt(Vd @ D)
      },
      0b11 => {
          fp_size = 64;
          d = UInt(D @ Vd)
      }
    };
    if frac_bits < 0 then {
        throw(Error_Unpredictable())
    };
    let 'fp_size = fp_size;
    let 'd = d;
    assert(constraint(('fp_size in {16, 32, 64} & 0 <= 'd & 'd <= 31)));
    __PostDecode();
    VCVT_xv_Op_A(d, fp_size, frac_bits, size, to_fixed, unsigned)
}

val VCVT_xv_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_xv_A1_A_decode (cond, D, op, U, Vd, sf, sx, i, imm4) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if sf == 0b00 | sf == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sf == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let to_fixed : bool = op == 0b1;
    let unsigned : bool = U == 0b1;
    let size : {|16, 32|} = if sx == 0b0 then 16 else 32;
    let frac_bits : int = size - UInt(imm4 @ i);
    d : int = undefined : int;
    fp_size : int = undefined : int;
    match sf {
      0b01 => {
          fp_size = 16;
          d = UInt(Vd @ D)
      },
      0b10 => {
          fp_size = 32;
          d = UInt(Vd @ D)
      },
      0b11 => {
          fp_size = 64;
          d = UInt(D @ Vd)
      }
    };
    if frac_bits < 0 then {
        throw(Error_Unpredictable())
    };
    let 'fp_size = fp_size;
    let 'd = d;
    assert(constraint(('fp_size in {16, 32, 64} & 0 <= 'd & 'd <= 31)));
    __PostDecode();
    VCVT_xv_Op_A(d, fp_size, frac_bits, size, to_fixed, unsigned)
}

val VCVT_iv_Op_A : forall 'd 'esize 'm ('to_integer : Bool) ('unsigned : Bool),
  ('m >= 0 & 'm <= 31 & 'd >= 0 & 'd <= 31).
  (int('d), int('esize), int('m), FPRounding, bool('to_integer), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_iv_Op_A (d, esize, m, rounding, to_integer, unsigned) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        if to_integer then {
            match esize {
              16 => {
                  aset_S(d, FPToFixed(slice(aget_S(m), 0, 16), 0, unsigned, FPSCR, rounding))
              },
              32 => {
                  aset_S(d, FPToFixed(aget_S(m), 0, unsigned, FPSCR, rounding))
              },
              64 => {
                  aset_S(d, FPToFixed(aget_D(m), 0, unsigned, FPSCR, rounding))
              }
            }
        } else {
            match esize {
              16 => {
                  let fp16 : bits(16) = FixedToFP(aget_S(m), 0, unsigned, FPSCR, rounding);
                  aset_S(d, Zeros(16) @ fp16)
              },
              32 => {
                  aset_S(d, FixedToFP(aget_S(m), 0, unsigned, FPSCR, rounding))
              },
              64 => {
                  aset_D(d, FixedToFP(aget_S(m), 0, unsigned, FPSCR, rounding))
              }
            }
        }
    }
}

val VCVT_iv_T1_A_decode : (bits(1), bits(3), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_iv_T1_A_decode (D, opc2, Vd, size, op, M, Vm) = {
    __unconditional = false;
    if opc2 != 0b000 & (opc2 & 0b110) != 0b100 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let to_integer : bool = [opc2[2]] == 0b1;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    rounding : FPRounding = undefined : FPRounding;
    unsigned : bool = undefined : bool;
    if to_integer then {
        unsigned = [opc2[0]] == 0b0;
        rounding = if op == 0b1 then FPRounding_ZERO else FPRoundingMode(FPSCR);
        d = UInt(Vd @ D);
        match size {
          0b01 => {
              esize = 16;
              m = UInt(Vm @ M)
          },
          0b10 => {
              esize = 32;
              m = UInt(Vm @ M)
          },
          0b11 => {
              esize = 64;
              m = UInt(M @ Vm)
          }
        }
    } else {
        unsigned = op == 0b0;
        rounding = FPRoundingMode(FPSCR);
        m = UInt(Vm @ M);
        match size {
          0b01 => {
              esize = 16;
              d = UInt(Vd @ D)
          },
          0b10 => {
              esize = 32;
              d = UInt(Vd @ D)
          },
          0b11 => {
              esize = 64;
              d = UInt(D @ Vd)
          }
        }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCVT_iv_Op_A(d, esize, m, rounding, to_integer, unsigned)
}

val VCVT_iv_A1_A_decode : (bits(4), bits(1), bits(3), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_iv_A1_A_decode (cond, D, opc2, Vd, size, op, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if opc2 != 0b000 & (opc2 & 0b110) != 0b100 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let to_integer : bool = [opc2[2]] == 0b1;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    rounding : FPRounding = undefined : FPRounding;
    unsigned : bool = undefined : bool;
    if to_integer then {
        unsigned = [opc2[0]] == 0b0;
        rounding = if op == 0b1 then FPRounding_ZERO else FPRoundingMode(FPSCR);
        d = UInt(Vd @ D);
        match size {
          0b01 => {
              esize = 16;
              m = UInt(Vm @ M)
          },
          0b10 => {
              esize = 32;
              m = UInt(Vm @ M)
          },
          0b11 => {
              esize = 64;
              m = UInt(M @ Vm)
          }
        }
    } else {
        unsigned = op == 0b0;
        rounding = FPRoundingMode(FPSCR);
        m = UInt(Vm @ M);
        match size {
          0b01 => {
              esize = 16;
              d = UInt(Vd @ D)
          },
          0b10 => {
              esize = 32;
              d = UInt(Vd @ D)
          },
          0b11 => {
              esize = 64;
              d = UInt(D @ Vd)
          }
        }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCVT_iv_Op_A(d, esize, m, rounding, to_integer, unsigned)
}

val VCVT_ds_Op_A : forall 'd ('double_to_single : Bool) 'm,
  ('m >= 0 & 'm <= 31 | not('double_to_single)) & ('d >= 0 & 'd <= 31 | not('double_to_single)) & ('m >= 0 & 'm <= 31 | not(not('double_to_single))) & ('d >= 0 & 'd <= 31 | not(not('double_to_single))).
  (int('d), bool('double_to_single), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_ds_Op_A (d, double_to_single, m) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        if double_to_single then {
            S(d) = FPConvert(D(m), FPSCR)
        } else {
            D(d) = FPConvert(S(m), FPSCR)
        }
    }
}

val VCVT_ds_T1A1_A_decode__0 : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VCVT_ds_T1A1_A_decode__1 : (bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VCVT_ds_T1A1_A_decode = {
  VCVT_ds_T1A1_A_decode__0,
  VCVT_ds_T1A1_A_decode__1
}

function VCVT_ds_T1A1_A_decode__0 (cond, D, Vd, size, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let double_to_single : bool = size == 0b11;
    let d = if double_to_single then UInt(Vd @ D) else UInt(D @ Vd);
    let m = if double_to_single then UInt(M @ Vm) else UInt(Vm @ M);
    __PostDecode();
    assert(0 <= d & d <= 31 & 0 <= m & m <= 31);
    VCVT_ds_Op_A(d, double_to_single, m)
}

function VCVT_ds_T1A1_A_decode__1 (D, Vd, size, M, Vm) = {
    __unconditional = false;
    let double_to_single : bool = size == 0b11;
    let d = if double_to_single then UInt(Vd @ D) else UInt(D @ Vd);
    let m = if double_to_single then UInt(M @ Vm) else UInt(Vm @ M);
    __PostDecode();
    assert(0 <= d & d <= 31 & 0 <= m & m <= 31);
    VCVT_ds_Op_A(d, double_to_single, m)
}

val VCVTB_Op_A : forall ('convert_from_half : Bool) 'd 'lowbit 'm ('uses_double : Bool),
  ('m >= 0 & 'm <= 31 | not('convert_from_half)) & ('d >= 0 & 'd <= 31 | not('uses_double) | not('convert_from_half)) & ('d >= 0 & 'd <= 31 | not(not('uses_double)) | not('convert_from_half)) & ('m >= 0 & 'm <= 31 | not('uses_double) | not(not('convert_from_half))) & ('m >= 0 & 'm <= 31 | not(not('uses_double)) | not(not('convert_from_half))) & ('d >= 0 & 'd <= 31 | not(not('convert_from_half))).
  (bool('convert_from_half), int('d), int('lowbit), int('m), bool('uses_double)) -> unit effect {escape, rreg, undef, wreg}

function VCVTB_Op_A (convert_from_half, d, lowbit, m, uses_double) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        hp : bits(16) = undefined : bits(16);
        if convert_from_half then {
            hp = slice(S(m), lowbit, 16);
            if uses_double then {
                D(d) = FPConvert(hp, FPSCR)
            } else {
                S(d) = FPConvert(hp, FPSCR)
            }
        } else {
            if uses_double then {
                hp = FPConvert(D(m), FPSCR)
            } else {
                hp = FPConvert(S(m), FPSCR)
            };
            __tc1 : bits(32) = S(d);
            __tc1 = __SetSlice_bits(32, 16, __tc1, lowbit, hp);
            S(d) = __tc1
        }
    }
}

val VCVTB_T1A1_A_decode__0 : (bits(4), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VCVTB_T1A1_A_decode__1 : (bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VCVTB_T1A1_A_decode = {VCVTB_T1A1_A_decode__0, VCVTB_T1A1_A_decode__1}

function VCVTB_T1A1_A_decode__0 (cond, D, op, Vd, sz, T, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let uses_double : bool = sz == 0b1;
    let convert_from_half : bool = op == 0b0;
    let lowbit : int = if T == 0b1 then 16 else 0;
    d : int = undefined : int;
    m : int = undefined : int;
    if uses_double then {
        if convert_from_half then {
            d = UInt(D @ Vd);
            m = UInt(Vm @ M)
        } else {
            d = UInt(Vd @ D);
            m = UInt(M @ Vm)
        }
    } else {
        d = UInt(Vd @ D);
        m = UInt(Vm @ M)
    };
    let 'd = d;
    let 'm = m;
    assert(constraint((0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCVTB_Op_A(convert_from_half, d, lowbit, m, uses_double)
}

function VCVTB_T1A1_A_decode__1 (D, op, Vd, sz, T, M, Vm) = {
    __unconditional = false;
    let uses_double : bool = sz == 0b1;
    let convert_from_half : bool = op == 0b0;
    let lowbit : int = if T == 0b1 then 16 else 0;
    d : int = undefined : int;
    m : int = undefined : int;
    if uses_double then {
        if convert_from_half then {
            d = UInt(D @ Vd);
            m = UInt(Vm @ M)
        } else {
            d = UInt(Vd @ D);
            m = UInt(M @ Vm)
        }
    } else {
        d = UInt(Vd @ D);
        m = UInt(Vm @ M)
    };
    let 'd = d;
    let 'm = m;
    assert(constraint((0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCVTB_Op_A(convert_from_half, d, lowbit, m, uses_double)
}

val VCVTA_vfp_Op_A : forall 'd 'esize 'm ('unsigned : Bool),
  ('m >= 0 & 'm <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), int('m), FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VCVTA_vfp_Op_A (d, esize, m, rounding, unsigned) = {
    CheckVFPEnabled(true);
    match esize {
      16 => {
          S(d) = FPToFixed(slice(S(m), 0, 16), 0, unsigned, FPSCR, rounding)
      },
      32 => {
          S(d) = FPToFixed(S(m), 0, unsigned, FPSCR, rounding)
      },
      64 => {
          S(d) = FPToFixed(D(m), 0, unsigned, FPSCR, rounding)
      }
    }
}

val VCVTA_vfp_T1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVTA_vfp_T1_A_decode (D, RM, Vd, size, op, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let rounding : FPRounding = FPDecodeRM(RM);
    let unsigned : bool = op == 0b0;
    let d = UInt(Vd @ D);
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          m = UInt(M @ Vm)
      }
    };
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCVTA_vfp_Op_A(d, esize, m, rounding, unsigned)
}

val VCVTA_vfp_A1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVTA_vfp_A1_A_decode (D, RM, Vd, size, op, M, Vm) = {
    __unconditional = true;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let rounding : FPRounding = FPDecodeRM(RM);
    let unsigned : bool = op == 0b0;
    let d = UInt(Vd @ D);
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          m = UInt(M @ Vm)
      }
    };
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCVTA_vfp_Op_A(d, esize, m, rounding, unsigned)
}

val VCMP_Op_A : forall 'd 'esize 'm ('quiet_nan_exc : Bool) ('with_zero : Bool),
  ('m >= 0 & 'm <= 31 | not(not('with_zero)) | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('m >= 0 & 'm <= 31 | not(not('with_zero)) | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('m >= 0 & 'm <= 31 | not(not('with_zero)) | not('esize == 64)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (int('d), int('esize), int('m), bool('quiet_nan_exc), bool('with_zero)) -> unit effect {escape, rreg, undef, wreg}

function VCMP_Op_A (d, esize, m, quiet_nan_exc, with_zero) = {
    if ConditionPassed() then {
        CheckVFPEnabled(true);
        nzcv : bits(4) = undefined : bits(4);
        match esize {
          16 => {
              let op16 : bits(16) = if with_zero then FPZero(0b0) else slice(S(m), 0, 16);
              nzcv = FPCompare(slice(S(d), 0, 16), op16, quiet_nan_exc, FPSCR)
          },
          32 => {
              let op32 : bits(32) = if with_zero then FPZero(0b0) else S(m);
              nzcv = FPCompare(S(d), op32, quiet_nan_exc, FPSCR)
          },
          64 => {
              let op64 : bits(64) = if with_zero then FPZero(0b0) else D(m);
              nzcv = FPCompare(D(d), op64, quiet_nan_exc, FPSCR)
          }
        };
        (FPSCR[31 .. 31] @ FPSCR[30 .. 30] @ FPSCR[29 .. 29] @ FPSCR[28 .. 28]) = nzcv
    }
}

val VCMP_T2A2pre_A_decode__0 : (bits(4), bits(1), bits(4), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

val VCMP_T2A2pre_A_decode__1 : (bits(1), bits(4), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

overload VCMP_T2A2pre_A_decode = {
  VCMP_T2A2pre_A_decode__0,
  VCMP_T2A2pre_A_decode__1
}

function VCMP_T2A2pre_A_decode__0 (cond, D, Vd, size, E) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let 'm = 0;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let quiet_nan_exc : bool = E == 0b1;
    let with_zero : bool = true;
    d : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd)
      }
    };
    let 'd = d;
    let 'esize = esize;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31)));
    __PostDecode();
    VCMP_Op_A(d, esize, m, quiet_nan_exc, with_zero)
}

function VCMP_T2A2pre_A_decode__1 (D, Vd, size, E) = {
    __unconditional = false;
    let 'm = 0;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let quiet_nan_exc : bool = E == 0b1;
    let with_zero : bool = true;
    d : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd)
      }
    };
    let 'd = d;
    let 'esize = esize;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31)));
    __PostDecode();
    VCMP_Op_A(d, esize, m, quiet_nan_exc, with_zero)
}

val VCMP_T1_A_decode : (bits(1), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCMP_T1_A_decode (D, Vd, size, E, M, Vm) = {
    __unconditional = false;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let quiet_nan_exc : bool = E == 0b1;
    let with_zero : bool = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCMP_Op_A(d, esize, m, quiet_nan_exc, with_zero)
}

val VCMP_A1_A_decode : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCMP_A1_A_decode (cond, D, Vd, size, E, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let quiet_nan_exc : bool = E == 0b1;
    let with_zero : bool = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let 'd = d;
    let 'esize = esize;
    let 'm = m;
    assert(constraint(('esize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31)));
    __PostDecode();
    VCMP_Op_A(d, esize, m, quiet_nan_exc, with_zero)
}

val CheckAdvSIMDOrVFPEnabled : forall ('include_fpexc_check : Bool) ('advsimd : Bool).
  (bool('include_fpexc_check), bool('advsimd)) -> unit effect {escape, rreg, undef, wreg}

function CheckAdvSIMDOrVFPEnabled (include_fpexc_check_name, advsimd) = {
    AArch32_CheckAdvSIMDOrFPEnabled(include_fpexc_check_name, advsimd);
    return()
}

val VSUB_f_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  ('n >= 0 & 'm >= 0 & 'd >= 0 & 'regs >= 0 & 'd + 'regs <= 31 & 'n + 'regs <= 31 & 'm + 'regs <= 31).
  (bool, int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VSUB_f_Op_A (advsimd, d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if advsimd then {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                foreach (e from 0 to (elements - 1) by 1 in inc) {
                    assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
                    aset_D(d + r, aset_Elem(aget_D(d + r), e, esize, FPSub(aget_Elem(aget_D(n + r), e, esize), aget_Elem(aget_D(m + r), e, esize), StandardFPSCRValue())))
                }
            }
        } else {
            match esize {
              16 => {
                  aset_S(d, Zeros(16) @ FPSub(slice(aget_S(n), 0, 16), slice(aget_S(m), 0, 16), FPSCR))
              },
              32 => {
                  aset_S(d, FPSub(aget_S(n), aget_S(m), FPSCR))
              },
              64 => {
                  aset_D(d, FPSub(aget_D(n), aget_D(m), FPSCR))
              }
            }
        }
    }
}

val VSUB_f_T2A2pre_A_decode__0 : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VSUB_f_T2A2pre_A_decode__1 : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VSUB_f_T2A2pre_A_decode = {
  VSUB_f_T2A2pre_A_decode__0,
  VSUB_f_T2A2pre_A_decode__1
}

function VSUB_f_T2A2pre_A_decode__0 (cond, D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let regs = 0;
    let elements = 0;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VSUB_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

function VSUB_f_T2A2pre_A_decode__1 (D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    let regs = 0;
    let elements = 0;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VSUB_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VSUB_f_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSUB_f_T1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_n >= 0 & '_m >= 0 & '_d >= 0 & '_regs >= 0 & '_d + '_regs <= 31 & '_n + '_regs <= 31 & '_m + '_regs <= 31)));
    __PostDecode();
    VSUB_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VSUB_f_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSUB_f_A1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_n >= 0 & '_m >= 0 & '_d >= 0 & '_regs >= 0 & '_d + '_regs <= 31 & '_n + '_regs <= 31 & '_m + '_regs <= 31)));
    __PostDecode();
    VSUB_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VNEG_Op_A : forall ('advsimd : Bool) 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  (0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (bool('advsimd), int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VNEG_Op_A (advsimd, d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if advsimd then {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                foreach (e from 0 to (elements - 1) by 1 in inc) {
                    assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
                    if floating_point then {
                        assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point) | not('advsimd))));
                        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('floating_point) | not('advsimd))));
                        D(d + r) = aset_Elem(D(d + r), e, esize, FPNeg(aget_Elem(D(m + r), e, esize)))
                    } else {
                        assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                        result = negate(SInt(aget_Elem(D(m + r), e, esize)));
                        D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 0))
                    }
                }
            }
        } else {
            match esize {
              16 => {
                  S(d) = Zeros(16) @ FPNeg(slice(S(m), 0, 16))
              },
              32 => {
                  S(d) = FPNeg(S(m))
              },
              64 => {
                  D(d) = FPNeg(D(m))
              }
            }
        }
    }
}

val VNEG_T2A2pre_A_decode__0 : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VNEG_T2A2pre_A_decode__1 : (bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VNEG_T2A2pre_A_decode = {
  VNEG_T2A2pre_A_decode__0,
  VNEG_T2A2pre_A_decode__1
}

function VNEG_T2A2pre_A_decode__0 (cond, D, Vd, size, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let floating_point : bool = undefined : bool;
    let regs = undefined : int;
    let elements = undefined : int;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= m & m <= 31 & 0 <= d & d <= 31);
    VNEG_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

function VNEG_T2A2pre_A_decode__1 (D, Vd, size, M, Vm) = {
    __unconditional = false;
    let floating_point : bool = undefined : bool;
    let regs = undefined : int;
    let elements = undefined : int;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= m & m <= 31 & 0 <= d & d <= 31);
    VNEG_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

val VNEG_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VNEG_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VNEG_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

val VNEG_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VNEG_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VNEG_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

val VMUL_f_Op_A : forall ('advsimd : Bool) 'd 'elements 'esize 'm 'n 'regs,
  ('n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31 & 'm >= 0 & 'm <= 31).
  (bool('advsimd), int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_f_Op_A (advsimd, d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if advsimd then {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                foreach (e from 0 to (elements - 1) by 1 in inc) {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('advsimd))));
                    assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not('advsimd))));
                    assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31 | not('advsimd))));
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('advsimd))));
                    aset_D(d + r, aset_Elem(aget_D(d + r), e, esize, FPMul(aget_Elem(aget_D(n + r), e, esize), aget_Elem(aget_D(m + r), e, esize), StandardFPSCRValue())))
                }
            }
        } else {
            match esize {
              16 => {
                  aset_S(d, Zeros(16) @ FPMul(slice(aget_S(n), 0, 16), slice(aget_S(m), 0, 16), FPSCR))
              },
              32 => {
                  aset_S(d, FPMul(aget_S(n), aget_S(m), FPSCR))
              },
              64 => {
                  aset_D(d, FPMul(aget_D(n), aget_D(m), FPSCR))
              }
            }
        }
    }
}

val VMUL_f_T2A2pre_A_decode__0 : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMUL_f_T2A2pre_A_decode__1 : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMUL_f_T2A2pre_A_decode = {
  VMUL_f_T2A2pre_A_decode__0,
  VMUL_f_T2A2pre_A_decode__1
}

function VMUL_f_T2A2pre_A_decode__0 (cond, D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let floating_point : bool = undefined : bool;
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VMUL_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

function VMUL_f_T2A2pre_A_decode__1 (D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    let floating_point : bool = undefined : bool;
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VMUL_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VMUL_f_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_f_T1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMUL_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VMUL_f_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_f_A1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMUL_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VMOV_sr_Op_A : forall ('advsimd : Bool) 'esize 'index 'n 't ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 | not('unsigned)) & ('esize >= 0 | not('unsigned)) & ('t >= 0 & 't <= 14 | not('unsigned)) & ('n >= 0 & 'n <= 31 | not(not('unsigned))) & ('esize >= 0 | not(not('unsigned))) & ('t >= 0 & 't <= 14 | not(not('unsigned))).
  (bool('advsimd), int('esize), int('index), int('n), int('t), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_sr_Op_A (advsimd, esize, index, n, t, unsigned) = {
    if ConditionPassed() then {
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if unsigned then {
            R(t) = ZeroExtend(aget_Elem(D(n), index, esize), 32)
        } else {
            R(t) = SignExtend(aget_Elem(D(n), index, esize), 32)
        }
    }
}

val VMOV_sr_T1A1_A_decode__0 : (bits(4), bits(1), bits(2), bits(4), bits(4), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

val VMOV_sr_T1A1_A_decode__1 : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

overload VMOV_sr_T1A1_A_decode = {
  VMOV_sr_T1A1_A_decode__0,
  VMOV_sr_T1A1_A_decode__1
}

function VMOV_sr_T1A1_A_decode__0 (cond, U, opc1, Vn, Rt, N, opc2) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    advsimd : bool = undefined : bool;
    esize : int = undefined : int;
    index : int = undefined : int;
    match (U @ opc1) @ opc2 {
      _ : bits(1) @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          advsimd = true;
          esize = 8;
          index = UInt([opc1[0]] @ opc2)
      },
      _ : bits(1) @ [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitone] => {
          advsimd = true;
          esize = 16;
          index = UInt([opc1[0]] @ [opc2[1]])
      },
      [bitzero] @ [bitzero] @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          advsimd = false;
          esize = 32;
          index = UInt([opc1[0]])
      },
      [bitone] @ [bitzero] @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          throw(Error_Undefined())
      },
      _ : bits(1) @ [bitzero] @ _ : bits(1) @ [bitone] @ [bitzero] => {
          throw(Error_Undefined())
      }
    };
    let index = index;
    let esize = esize;
    let advsimd = advsimd;
    let t = UInt(Rt);
    let n = UInt(N @ Vn);
    let unsigned : bool = U == 0b1;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(index >= 0 & esize <= 32 & esize >= 0 & (index + 1) * esize <= 64);
    VMOV_sr_Op_A(advsimd, esize, index, n, t, unsigned)
}

function VMOV_sr_T1A1_A_decode__1 (U, opc1, Vn, Rt, N, opc2) = {
    __unconditional = false;
    advsimd : bool = undefined : bool;
    esize : int = undefined : int;
    index : int = undefined : int;
    match (U @ opc1) @ opc2 {
      _ : bits(1) @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          advsimd = true;
          esize = 8;
          index = UInt([opc1[0]] @ opc2)
      },
      _ : bits(1) @ [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitone] => {
          advsimd = true;
          esize = 16;
          index = UInt([opc1[0]] @ [opc2[1]])
      },
      [bitzero] @ [bitzero] @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          advsimd = false;
          esize = 32;
          index = UInt([opc1[0]])
      },
      [bitone] @ [bitzero] @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          throw(Error_Undefined())
      },
      _ : bits(1) @ [bitzero] @ _ : bits(1) @ [bitone] @ [bitzero] => {
          throw(Error_Undefined())
      }
    };
    let index = index;
    let esize = esize;
    let advsimd = advsimd;
    let t = UInt(Rt);
    let n = UInt(N @ Vn);
    let unsigned : bool = U == 0b1;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(index >= 0 & esize <= 32 & esize >= 0 & (index + 1) * esize <= 64);
    VMOV_sr_Op_A(advsimd, esize, index, n, t, unsigned)
}

val VMOV_rs_Op_A : forall ('advsimd : Bool) 'd 'esize 'index 't,
  ('d >= 0 & 'd <= 31) & ('t >= 0 & 't <= 15) & 'esize >= 0.
  (bool('advsimd), int('d), int('esize), int('index), int('t)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_rs_Op_A (advsimd, d, esize, index, t) = {
    if ConditionPassed() then {
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        D(d) = aset_Elem(D(d), index, esize, slice(R(t), 0, esize))
    }
}

val VMOV_rs_T1A1_A_decode__0 : (bits(4), bits(2), bits(4), bits(4), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

val VMOV_rs_T1A1_A_decode__1 : (bits(2), bits(4), bits(4), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

overload VMOV_rs_T1A1_A_decode = {
  VMOV_rs_T1A1_A_decode__0,
  VMOV_rs_T1A1_A_decode__1
}

function VMOV_rs_T1A1_A_decode__0 (cond, opc1, Vd, Rt, D, opc2) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    advsimd : bool = undefined : bool;
    esize : int = undefined : int;
    index : int = undefined : int;
    match opc1 @ opc2 {
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          advsimd = true;
          esize = 8;
          index = UInt([opc1[0]] @ opc2)
      },
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitone] => {
          advsimd = true;
          esize = 16;
          index = UInt([opc1[0]] @ [opc2[1]])
      },
      [bitzero] @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          advsimd = false;
          esize = 32;
          index = UInt([opc1[0]])
      },
      [bitzero] @ _ : bits(1) @ [bitone] @ [bitzero] => {
          throw(Error_Undefined())
      }
    };
    let index = index;
    let esize = esize;
    let advsimd = advsimd;
    let d = UInt(D @ Vd);
    let t = UInt(Rt);
    assert(constraint('_esize >= 0));
    assert(constraint(('_t >= 0 & '_t <= 15)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_rs_Op_A(advsimd, d, esize, index, t)
}

function VMOV_rs_T1A1_A_decode__1 (opc1, Vd, Rt, D, opc2) = {
    __unconditional = false;
    advsimd : bool = undefined : bool;
    esize : int = undefined : int;
    index : int = undefined : int;
    match opc1 @ opc2 {
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          advsimd = true;
          esize = 8;
          index = UInt([opc1[0]] @ opc2)
      },
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitone] => {
          advsimd = true;
          esize = 16;
          index = UInt([opc1[0]] @ [opc2[1]])
      },
      [bitzero] @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          advsimd = false;
          esize = 32;
          index = UInt([opc1[0]])
      },
      [bitzero] @ _ : bits(1) @ [bitone] @ [bitzero] => {
          throw(Error_Undefined())
      }
    };
    let index = index;
    let esize = esize;
    let advsimd = advsimd;
    let d = UInt(D @ Vd);
    let t = UInt(Rt);
    assert(constraint('_esize >= 0));
    assert(constraint(('_t >= 0 & '_t <= 15)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMOV_rs_Op_A(advsimd, d, esize, index, t)
}

val VMOV_r_Op_A : forall ('advsimd : Bool) 'd 'm 'regs ('single_register : Bool),
  ('m >= 0 & 'm <= 31 | not('single_register)) & ('d >= 0 & 'd <= 31 | not('single_register)).
  (bool('advsimd), int('d), int('m), int('regs), bool('single_register)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_r_Op_A (advsimd, d, m, regs, single_register) = {
    if ConditionPassed() then {
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if single_register then {
            S(d) = S(m)
        } else {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('single_register)))));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('single_register)))));
                D(d + r) = D(m + r)
            }
        }
    }
}

val VMOV_r_T2A2_A_decode__0 : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMOV_r_T2A2_A_decode__1 : (bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMOV_r_T2A2_A_decode = {
  VMOV_r_T2A2_A_decode__0,
  VMOV_r_T2A2_A_decode__1
}

function VMOV_r_T2A2_A_decode__0 (cond, D, Vd, size, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let single_register : bool = size == 0b10;
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    m : int = undefined : int;
    regs : int = undefined : int;
    if single_register then {
        d = UInt(Vd @ D);
        m = UInt(Vm @ M)
    } else {
        d = UInt(D @ Vd);
        m = UInt(M @ Vm);
        regs = 1
    };
    __PostDecode();
    let d = d;
    let m = m;
    assert(0 <= d & d <= 31 & 0 <= m & m <= 31);
    VMOV_r_Op_A(advsimd, d, m, regs, single_register)
}

function VMOV_r_T2A2_A_decode__1 (D, Vd, size, M, Vm) = {
    __unconditional = false;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let single_register : bool = size == 0b10;
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    m : int = undefined : int;
    regs : int = undefined : int;
    if single_register then {
        d = UInt(Vd @ D);
        m = UInt(Vm @ M)
    } else {
        d = UInt(D @ Vd);
        m = UInt(M @ Vm);
        regs = 1
    };
    __PostDecode();
    let d = d;
    let m = m;
    assert(0 <= d & d <= 31 & 0 <= m & m <= 31);
    VMOV_r_Op_A(advsimd, d, m, regs, single_register)
}

val VMOV_i_Op_A : forall ('advsimd : Bool) 'd 'regs ('single_register : Bool),
  ('d >= 0 & 'd <= 31 | not('single_register)).
  (bool('advsimd), int('d), bits(32), bits(64), int('regs), bool('single_register)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_i_Op_A (advsimd, d, imm32, imm64, regs, single_register) = {
    if ConditionPassed() then {
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if single_register then {
            S(d) = imm32
        } else {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('single_register)))));
                D(d + r) = imm64
            }
        }
    }
}

val VMOV_i_T5A5pre_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_i_T5A5pre_A_decode (i, D, imm3, Vd, cmode, Q, op, imm4) = {
    __unconditional = false;
    let imm32 = undefined : bits(32);
    if (op == 0b0 & [cmode[0]] == 0b1) & slice(cmode, 2, 2) != 0b11 then {
        throw(Error_See("VORR (immediate)"))
    };
    if op == 0b1 & cmode != 0xE then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let single_register = false;
    let advsimd = true;
    let imm64 = AdvSIMDExpandImm(op, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMOV_i_Op_A(advsimd, d, imm32, imm64, regs, single_register)
}

val VMOV_i_T4A4pre_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_i_T4A4pre_A_decode (i, D, imm3, Vd, cmode, Q, op, imm4) = {
    __unconditional = false;
    let imm32 = undefined : bits(32);
    if (op == 0b0 & [cmode[0]] == 0b1) & slice(cmode, 2, 2) != 0b11 then {
        throw(Error_See("VORR (immediate)"))
    };
    if op == 0b1 & cmode != 0xE then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let single_register = false;
    let advsimd = true;
    let imm64 = AdvSIMDExpandImm(op, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMOV_i_Op_A(advsimd, d, imm32, imm64, regs, single_register)
}

val VMOV_i_T3A3pre_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_i_T3A3pre_A_decode (i, D, imm3, Vd, cmode, Q, op, imm4) = {
    __unconditional = false;
    let imm32 = undefined : bits(32);
    if (op == 0b0 & [cmode[0]] == 0b1) & slice(cmode, 2, 2) != 0b11 then {
        throw(Error_See("VORR (immediate)"))
    };
    if op == 0b1 & cmode != 0xE then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let single_register = false;
    let advsimd = true;
    let imm64 = AdvSIMDExpandImm(op, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMOV_i_Op_A(advsimd, d, imm32, imm64, regs, single_register)
}

val VMOV_i_T2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_i_T2_A_decode (D, imm4H, Vd, size, imm4L) = {
    __unconditional = false;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let single_register : bool = size != 0b11;
    let advsimd : bool(false) = false;
    imm16 : bits(16) = undefined : bits(16);
    imm32 : bits(32) = undefined : bits(32);
    imm64 : bits(64) = undefined : bits(64);
    d : int = undefined : int;
    regs : int = undefined : int;
    match size {
      0b01 => {
          d = UInt(Vd @ D);
          imm16 = VFPExpandImm(imm4H @ imm4L);
          imm32 = Zeros(16) @ imm16
      },
      0b10 => {
          d = UInt(Vd @ D);
          imm32 = VFPExpandImm(imm4H @ imm4L)
      },
      0b11 => {
          d = UInt(D @ Vd);
          imm64 = VFPExpandImm(imm4H @ imm4L);
          regs = 1
      }
    };
    let d = d;
    assert(0 <= d & d <= 31);
    __PostDecode();
    VMOV_i_Op_A(advsimd, d, imm32, imm64, regs, single_register)
}

val VMOV_i_T1A1pre_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_i_T1A1pre_A_decode (i, D, imm3, Vd, cmode, Q, op, imm4) = {
    __unconditional = false;
    let imm32 = undefined : bits(32);
    if (op == 0b0 & [cmode[0]] == 0b1) & slice(cmode, 2, 2) != 0b11 then {
        throw(Error_See("VORR (immediate)"))
    };
    if op == 0b1 & cmode != 0xE then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let single_register = false;
    let advsimd = true;
    let imm64 = AdvSIMDExpandImm(op, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMOV_i_Op_A(advsimd, d, imm32, imm64, regs, single_register)
}

val VMOV_i_A2_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOV_i_A2_A_decode (cond, D, imm4H, Vd, size, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let single_register : bool = size != 0b11;
    let advsimd : bool(false) = false;
    imm16 : bits(16) = undefined : bits(16);
    imm32 : bits(32) = undefined : bits(32);
    imm64 : bits(64) = undefined : bits(64);
    d : int = undefined : int;
    regs : int = undefined : int;
    match size {
      0b01 => {
          d = UInt(Vd @ D);
          imm16 = VFPExpandImm(imm4H @ imm4L);
          imm32 = Zeros(16) @ imm16
      },
      0b10 => {
          d = UInt(Vd @ D);
          imm32 = VFPExpandImm(imm4H @ imm4L)
      },
      0b11 => {
          d = UInt(D @ Vd);
          imm64 = VFPExpandImm(imm4H @ imm4L);
          regs = 1
      }
    };
    let d = d;
    assert(0 <= d & d <= 31);
    __PostDecode();
    VMOV_i_Op_A(advsimd, d, imm32, imm64, regs, single_register)
}

val VMLA_f_Op_A : forall ('add : Bool) ('advsimd : Bool) 'd 'elements 'esize 'm 'n 'regs,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (bool('add), bool('advsimd), int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_f_Op_A (add, advsimd, d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        addend : bits('esize) = undefined : bits('esize);
        addend16 : bits(16) = undefined : bits(16);
        addend32 : bits(32) = undefined : bits(32);
        addend64 : bits(64) = undefined : bits(64);
        product : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if advsimd then {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                foreach (e from 0 to (elements - 1) by 1 in inc) {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('advsimd))));
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('advsimd))));
                    assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not('advsimd))));
                    assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31 | not('advsimd))));
                    product = FPMul(aget_Elem(D(n + r), e, esize), aget_Elem(D(m + r), e, esize), StandardFPSCRValue());
                    addend = if add then product else FPNeg(product);
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPAdd(aget_Elem(D(d + r), e, esize), addend, StandardFPSCRValue()))
                }
            }
        } else {
            match esize {
              16 => {
                  addend16 = if add then FPMul(slice(S(n), 0, 16), slice(S(m), 0, 16), FPSCR) else FPNeg(FPMul(slice(S(n), 0, 16), slice(S(m), 0, 16), FPSCR));
                  S(d) = Zeros(16) @ FPAdd(slice(S(d), 0, 16), addend16, FPSCR)
              },
              32 => {
                  addend32 = if add then FPMul(S(n), S(m), FPSCR) else FPNeg(FPMul(S(n), S(m), FPSCR));
                  S(d) = FPAdd(S(d), addend32, FPSCR)
              },
              64 => {
                  addend64 = if add then FPMul(D(n), D(m), FPSCR) else FPNeg(FPMul(D(n), D(m), FPSCR));
                  D(d) = FPAdd(D(d), addend64, FPSCR)
              }
            }
        }
    }
}

val VMLA_f_T2A2pre_A_decode__0 : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMLA_f_T2A2pre_A_decode__1 : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMLA_f_T2A2pre_A_decode = {
  VMLA_f_T2A2pre_A_decode__0,
  VMLA_f_T2A2pre_A_decode__1
}

function VMLA_f_T2A2pre_A_decode__0 (cond, D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let floating_point : bool = undefined : bool;
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let advsimd : bool(false) = false;
    let add : bool = op == 0b0;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VMLA_f_Op_A(add, advsimd, d, elements, esize, m, n, regs)
}

function VMLA_f_T2A2pre_A_decode__1 (D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    let floating_point : bool = undefined : bool;
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let advsimd : bool(false) = false;
    let add : bool = op == 0b0;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VMLA_f_Op_A(add, advsimd, d, elements, esize, m, n, regs)
}

val VMLA_f_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_f_T1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd = true;
    let add = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMLA_f_Op_A(add, advsimd, d, elements, esize, m, n, regs)
}

val VMLA_f_A1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_f_A1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    let add = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMLA_f_Op_A(add, advsimd, d, elements, esize, m, n, regs)
}

val VMAXNM_Op_A : forall ('advsimd : Bool) 'd 'elements 'esize 'm ('maximum : Bool) 'n 'regs,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (bool('advsimd), int('d), int('elements), int('esize), int('m), bool('maximum), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VMAXNM_Op_A (advsimd, d, elements, esize, m, maximum, n, regs) = {
    CheckAdvSIMDOrVFPEnabled(true, advsimd);
    op1 : bits('esize) = undefined : bits('esize);
    op2 : bits('esize) = undefined : bits('esize);
    if advsimd then {
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('advsimd))));
                assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not('advsimd))));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31 | not('advsimd))));
                op1 = aget_Elem(D(n + r), e, esize);
                op2 = aget_Elem(D(m + r), e, esize);
                if maximum then {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('maximum) | not('advsimd))));
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPMaxNum(op1, op2, StandardFPSCRValue()))
                } else {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('maximum)) | not('advsimd))));
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPMinNum(op1, op2, StandardFPSCRValue()))
                }
            }
        }
    } else {
        match esize {
          16 => {
              if maximum then {
                  S(d) = Zeros(16) @ FPMaxNum(slice(S(n), 0, 16), slice(S(m), 0, 16), FPSCR)
              } else {
                  S(d) = Zeros(16) @ FPMinNum(slice(S(n), 0, 16), slice(S(m), 0, 16), FPSCR)
              }
          },
          32 => {
              if maximum then {
                  S(d) = FPMaxNum(S(n), S(m), FPSCR)
              } else {
                  S(d) = FPMinNum(S(n), S(m), FPSCR)
              }
          },
          64 => {
              if maximum then {
                  D(d) = FPMaxNum(D(n), D(m), FPSCR)
              } else {
                  D(d) = FPMinNum(D(n), D(m), FPSCR)
              }
          }
        }
    }
}

val VMAXNM_T2A2pre_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMAXNM_T2A2pre_A_decode (D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = true;
    let regs = undefined : int;
    let elements = undefined : int;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd : bool(false) = false;
    let maximum : bool = op == 0b0;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VMAXNM_Op_A(advsimd, d, elements, esize, m, maximum, n, regs)
}

val VMAXNM_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMAXNM_T1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let maximum = op == 0b0;
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMAXNM_Op_A(advsimd, d, elements, esize, m, maximum, n, regs)
}

val VMAXNM_A1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMAXNM_A1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let maximum = op == 0b0;
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMAXNM_Op_A(advsimd, d, elements, esize, m, maximum, n, regs)
}

val VFMA_Op_A : forall ('advsimd : Bool) 'd 'elements 'esize 'm 'n ('op1_neg : Bool) 'regs,
  ('esize >= 0 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (bool('advsimd), int('d), int('elements), int('esize), int('m), int('n), bool('op1_neg), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VFMA_Op_A (advsimd, d, elements, esize, m, n, op1_neg, regs) = {
    if ConditionPassed() then {
        op16 : bits(16) = undefined : bits(16);
        op32 : bits(32) = undefined : bits(32);
        op64 : bits(64) = undefined : bits(64);
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if advsimd then {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                foreach (e from 0 to (elements - 1) by 1 in inc) {
                    assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31 | not('advsimd))));
                    op1 : bits('esize) = aget_Elem(D(n + r), e, esize);
                    if op1_neg then {
                        op1 = FPNeg(op1)
                    };
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPMulAdd(aget_Elem(D(d + r), e, esize), op1, aget_Elem(D(m + r), e, esize), StandardFPSCRValue()))
                }
            }
        } else {
            match esize {
              16 => {
                  op16 = if op1_neg then FPNeg(slice(S(n), 0, 16)) else slice(S(n), 0, 16);
                  S(d) = Zeros(16) @ FPMulAdd(slice(S(d), 0, 16), op16, slice(S(m), 0, 16), FPSCR)
              },
              32 => {
                  op32 = if op1_neg then FPNeg(S(n)) else S(n);
                  S(d) = FPMulAdd(S(d), op32, S(m), FPSCR)
              },
              64 => {
                  op64 = if op1_neg then FPNeg(D(n)) else D(n);
                  D(d) = FPMulAdd(D(d), op64, D(m), FPSCR)
              }
            }
        }
    }
}

val VFMA_T2A2pre_A_decode__0 : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VFMA_T2A2pre_A_decode__1 : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VFMA_T2A2pre_A_decode = {
  VFMA_T2A2pre_A_decode__0,
  VFMA_T2A2pre_A_decode__1
}

function VFMA_T2A2pre_A_decode__0 (D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    let floating_point : bool = undefined : bool;
    let regs = undefined : int;
    let elements = undefined : int;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    let op1_neg : bool = op == 0b1;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31 & esize >= 0);
    VFMA_Op_A(advsimd, d, elements, esize, m, n, op1_neg, regs)
}

function VFMA_T2A2pre_A_decode__1 (cond, D, Vn, Vd, size, N, op, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let floating_point : bool = undefined : bool;
    let regs = undefined : int;
    let elements = undefined : int;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    let op1_neg : bool = op == 0b1;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31 & esize >= 0);
    VFMA_Op_A(advsimd, d, elements, esize, m, n, op1_neg, regs)
}

val VFMA_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFMA_T1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd = true;
    let op1_neg = op == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_esize >= 0 & 0 <= '_n & '_n <= 31 & 0 <= '_m & '_m <= 31 & 0 <= '_d & '_d <= 31)));
    __PostDecode();
    VFMA_Op_A(advsimd, d, elements, esize, m, n, op1_neg, regs)
}

val VFMA_A1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFMA_A1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    let op1_neg = op == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_esize >= 0 & 0 <= '_n & '_n <= 31 & 0 <= '_m & '_m <= 31 & 0 <= '_d & '_d <= 31)));
    __PostDecode();
    VFMA_Op_A(advsimd, d, elements, esize, m, n, op1_neg, regs)
}

val VADD_f_Op_A : forall ('advsimd : Bool) 'd 'elements 'esize 'm 'n 'regs,
  ('n >= 0 & 'n <= 31 & 'm >= 0 & 'm <= 31 & 'd >= 0 & 'd <= 31).
  (bool('advsimd), int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VADD_f_Op_A (advsimd, d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if advsimd then {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                foreach (e from 0 to (elements - 1) by 1 in inc) {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('advsimd))));
                    assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not('advsimd))));
                    assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31 | not('advsimd))));
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('advsimd))));
                    aset_D(d + r, aset_Elem(aget_D(d + r), e, esize, FPAdd(aget_Elem(aget_D(n + r), e, esize), aget_Elem(aget_D(m + r), e, esize), StandardFPSCRValue())))
                }
            }
        } else {
            match esize {
              16 => {
                  aset_S(d, Zeros(16) @ FPAdd(slice(aget_S(n), 0, 16), slice(aget_S(m), 0, 16), FPSCR))
              },
              32 => {
                  aset_S(d, FPAdd(aget_S(n), aget_S(m), FPSCR))
              },
              64 => {
                  aset_D(d, FPAdd(aget_D(n), aget_D(m), FPSCR))
              }
            }
        }
    }
}

val VADD_f_T2A2pre_A_decode__0 : (bits(4), bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VADD_f_T2A2pre_A_decode__1 : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VADD_f_T2A2pre_A_decode = {
  VADD_f_T2A2pre_A_decode__0,
  VADD_f_T2A2pre_A_decode__1
}

function VADD_f_T2A2pre_A_decode__0 (cond, D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VADD_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

function VADD_f_T2A2pre_A_decode__1 (D, Vn, Vd, size, N, M, Vm) = {
    __unconditional = false;
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    n : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          n = UInt(Vn @ N);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          n = UInt(N @ Vn);
          m = UInt(M @ Vm)
      }
    };
    let n = n;
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= n & n <= 31 & 0 <= m & m <= 31 & 0 <= d & d <= 31);
    VADD_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VADD_f_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VADD_f_T1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VADD_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VADD_f_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VADD_f_A1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VADD_f_Op_A(advsimd, d, elements, esize, m, n, regs)
}

val VABS_Op_A : forall ('advsimd : Bool) 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  ('m >= 0 & 'm <= 31 & 'd >= 0 & 'd <= 31).
  (bool('advsimd), int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VABS_Op_A (advsimd, d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        CheckAdvSIMDOrVFPEnabled(true, advsimd);
        if advsimd then {
            foreach (r from 0 to (regs - 1) by 1 in inc) {
                foreach (e from 0 to (elements - 1) by 1 in inc) {
                    if floating_point then {
                        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not('floating_point) | not('advsimd))));
                        assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point) | not('advsimd))));
                        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('floating_point) | not('advsimd))));
                        aset_D(d + r, aset_Elem(aget_D(d + r), e, esize, FPAbs(aget_Elem(aget_D(m + r), e, esize))))
                    } else {
                        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('floating_point)) | not('advsimd))));
                        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not(not('floating_point)) | not('advsimd))));
                        assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('floating_point)) | not('advsimd))));
                        result = abs(SInt(aget_Elem(aget_D(m + r), e, esize)));
                        aset_D(d + r, aset_Elem(aget_D(d + r), e, esize, __GetSlice_int(esize, result, 0)))
                    }
                }
            }
        } else {
            match esize {
              16 => {
                  aset_S(d, Zeros(16) @ FPAbs(slice(aget_S(m), 0, 16)))
              },
              32 => {
                  aset_S(d, FPAbs(aget_S(m)))
              },
              64 => {
                  aset_D(d, FPAbs(aget_D(m)))
              }
            }
        }
    }
}

val VABS_T2A2pre_A_decode__0 : (bits(4), bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VABS_T2A2pre_A_decode__1 : (bits(1), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VABS_T2A2pre_A_decode = {
  VABS_T2A2pre_A_decode__0,
  VABS_T2A2pre_A_decode__1
}

function VABS_T2A2pre_A_decode__0 (cond, D, Vd, size, M, Vm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let floating_point : bool = undefined : bool;
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= m & m <= 31 & 0 <= d & d <= 31);
    VABS_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

function VABS_T2A2pre_A_decode__1 (D, Vd, size, M, Vm) = {
    __unconditional = false;
    let floating_point : bool = undefined : bool;
    let 'regs = undefined : int;
    let 'elements = undefined : int;
    if slice(FPSCR, 16, 3) != 0b000 | slice(FPSCR, 20, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let advsimd : bool(false) = false;
    d : int = undefined : int;
    esize : int = undefined : int;
    m : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b10 => {
          esize = 32;
          d = UInt(Vd @ D);
          m = UInt(Vm @ M)
      },
      0b11 => {
          esize = 64;
          d = UInt(D @ Vd);
          m = UInt(M @ Vm)
      }
    };
    let m = m;
    let esize = esize;
    let d = d;
    __PostDecode();
    assert(0 <= m & m <= 31 & 0 <= d & d <= 31);
    VABS_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

val VABS_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABS_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VABS_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

val VABS_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABS_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let advsimd = true;
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VABS_Op_A(advsimd, d, elements, esize, floating_point, m, regs)
}

val CheckAdvSIMDEnabled : unit -> unit effect {escape, rreg, undef, wreg}

function CheckAdvSIMDEnabled () = {
    let fpexc_check = true;
    let advsimd = true;
    AArch32_CheckAdvSIMDOrFPEnabled(fpexc_check, advsimd);
    foreach (i from 0 to 31 by 1 in inc) {
        _Dclone[i] = D(i)
    };
    return()
}

val VZIP_Op_A : forall 'd 'esize 'm ('quadword_operation : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('esize), int('m), bool('quadword_operation)) -> unit effect {escape, rreg, undef, wreg}

function VZIP_Op_A (d, esize, m, quadword_operation) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        if quadword_operation then {
            if d == m then {
                aset_Q(shr_int(d, 1), undefined : bits(128));
                aset_Q(shr_int(m, 1), undefined : bits(128))
            } else {
                zipped_q : bits(256) = undefined : bits(256);
                foreach (e from 0 to (128 / esize - 1) by 1 in inc) {
                    zipped_q = aset_Elem(zipped_q, 2 * e, esize, aget_Elem(aget_Q(shr_int(d, 1)), e, esize));
                    zipped_q = aset_Elem(zipped_q, 2 * e + 1, esize, aget_Elem(aget_Q(shr_int(m, 1)), e, esize))
                };
                aset_Q(shr_int(d, 1), slice(zipped_q, 0, 128));
                aset_Q(shr_int(m, 1), slice(zipped_q, 128, 128))
            }
        } else {
            if d == m then {
                aset_D(d, undefined : bits(64));
                aset_D(m, undefined : bits(64))
            } else {
                zipped_d : bits(128) = undefined : bits(128);
                foreach (e from 0 to (64 / esize - 1) by 1 in inc) {
                    zipped_d = aset_Elem(zipped_d, 2 * e, esize, aget_Elem(aget_D(d), e, esize));
                    zipped_d = aset_Elem(zipped_d, 2 * e + 1, esize, aget_Elem(aget_D(m), e, esize))
                };
                aset_D(d, slice(zipped_d, 0, 64));
                aset_D(m, slice(zipped_d, 64, 64))
            }
        }
    }
}

val VZIP_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VZIP_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 | Q == 0b0 & size == 0b10 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let quadword_operation = Q == 0b1;
    let esize = shl_int(8, UInt(size));
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    VZIP_Op_A(d, esize, m, quadword_operation)
}

val VUZP_Op_A : forall 'd 'esize 'm ('quadword_operation : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('esize), int('m), bool('quadword_operation)) -> unit effect {escape, rreg, undef, wreg}

function VUZP_Op_A (d, esize, m, quadword_operation) = {
    if ConditionPassed() then {
        zipped_d : bits(128) = undefined : bits(128);
        zipped_q : bits(256) = undefined : bits(256);
        CheckAdvSIMDEnabled();
        if quadword_operation then {
            if d == m then {
                Q(shr_int(d, 1)) = undefined : bits(128);
                Q(shr_int(m, 1)) = undefined : bits(128)
            } else {
                zipped_q = Q(shr_int(m, 1)) @ Q(shr_int(d, 1));
                foreach (e from 0 to (128 / esize - 1) by 1 in inc) {
                    Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, esize, aget_Elem(zipped_q, 2 * e, esize));
                    Q(shr_int(m, 1)) = aset_Elem(Q(shr_int(m, 1)), e, esize, aget_Elem(zipped_q, 2 * e + 1, esize))
                }
            }
        } else {
            if d == m then {
                D(d) = undefined : bits(64);
                D(m) = undefined : bits(64)
            } else {
                zipped_d = D(m) @ D(d);
                foreach (e from 0 to (64 / esize - 1) by 1 in inc) {
                    D(d) = aset_Elem(D(d), e, esize, aget_Elem(zipped_d, 2 * e, esize));
                    D(m) = aset_Elem(D(m), e, esize, aget_Elem(zipped_d, 2 * e + 1, esize))
                }
            }
        }
    }
}

val VUZP_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VUZP_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 | Q == 0b0 & size == 0b10 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let quadword_operation = Q == 0b1;
    let esize = shl_int(8, UInt(size));
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    VUZP_Op_A(d, esize, m, quadword_operation)
}

val VTST_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VTST_Op_A (d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                if ~(IsZero(aget_Elem(D(n + r), e, esize) & aget_Elem(D(m + r), e, esize))) then {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                    D(d + r) = aset_Elem(D(d + r), e, esize, Ones(esize))
                } else {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                    D(d + r) = aset_Elem(D(d + r), e, esize, Zeros(esize))
                }
            }
        }
    }
}

val VTST_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VTST_T1A1_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VTST_Op_A(d, elements, esize, m, n, regs)
}

val VTRN_Op_A : forall 'd 'elements 'esize 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VTRN_Op_A (d, elements, esize, m, regs) = {
    if ConditionPassed() then {
        h : int = undefined : int;
        CheckAdvSIMDEnabled();
        h = elements / 2;
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            if d == m then {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('d == 'm))));
                D(d + r) = undefined : bits(64)
            } else {
                foreach (e from 0 to (h - 1) by 1 in inc) {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('d == 'm)))));
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('d == 'm)))));
                    D(d + r) = aset_Elem(D(d + r), 2 * e + 1, esize, aget_Elem(Din(m + r), 2 * e, esize));
                    D(m + r) = aset_Elem(D(m + r), 2 * e, esize, aget_Elem(Din(d + r), 2 * e + 1, esize))
                }
            }
        }
    }
}

val VTRN_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VTRN_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VTRN_Op_A(d, elements, esize, m, regs)
}

val VTBL_Op_A : forall 'd ('is_vtbl : Bool) 'length 'm 'n,
  (('n + 3 >= 0 & 'n + 3 <= 31 | not('length == 4)) & ('n + 2 >= 0 & 'n + 2 <= 31 | not('length >= 3)) & ('n + 1 >= 0 & 'n + 1 <= 31 | not('length >= 2)) & 'n >= 0 & 'n <= 31 & 'm >= 0 & 'm <= 31 & 'd >= 0 & 'd <= 31).
  (int('d), bool('is_vtbl), int('length), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VTBL_Op_A (d, is_vtbl, length, m, n) = {
    if ConditionPassed() then {
        table : bits(256) = undefined : bits(256);
        table1 : bits(64) = undefined : bits(64);
        table2 : bits(64) = undefined : bits(64);
        table3 : bits(64) = undefined : bits(64);
        CheckAdvSIMDEnabled();
        table3 = if length == 4 then D(n + 3) else Zeros(64);
        table2 = if length >= 3 then D(n + 2) else Zeros(64);
        table1 = if length >= 2 then D(n + 1) else Zeros(64);
        table = ((table3 @ table2) @ table1) @ D(n);
        foreach (i from 0 to 7 by 1 in inc) {
            let index = UInt(aget_Elem(D(m), i, 8));
            if index < 8 * length then {
                assert(index >= 0 & 8 >= 0 & (index + 1) * 8 <= 256);
                D(d) = aset_Elem(D(d), i, 8, aget_Elem(table, index, 8))
            } else {
                if is_vtbl then {
                    D(d) = aset_Elem(D(d), i, 8, Zeros(8))
                }
            }
        }
    }
}

val VTBL_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VTBL_T1A1_A_decode (D, Vn, Vd, len, N, op, M, Vm) = {
    __unconditional = false;
    let is_vtbl = op == 0b0;
    let length = UInt(len) + 1;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    if n + length > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VTBL_Op_A(d, is_vtbl, length, m, n)
}

val VSWP_Op_A : forall ('d : Int) ('m : Int) ('regs : Int).
  (int('d), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VSWP_Op_A (d, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            if d == m then {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('d == 'm))));
                D(d + r) = undefined : bits(64)
            } else {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('d == 'm)))));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('d == 'm)))));
                D(d + r) = Din(m + r);
                D(m + r) = Din(d + r)
            }
        }
    }
}

val VSWP_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSWP_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VSWP_Op_A(d, m, regs)
}

val VSUB_i_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VSUB_i_Op_A (d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(D(n + r), e, esize) - aget_Elem(D(m + r), e, esize))
            }
        }
    }
}

val VSUB_i_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSUB_i_T1A1_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VSUB_i_Op_A(d, elements, esize, m, n, regs)
}

val VSUBL_Op_A : forall 'd 'elements 'esize ('is_vsubw : Bool) 'm 'n ('unsigned : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('elements), int('esize), bool('is_vsubw), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VSUBL_Op_A (d, elements, esize, is_vsubw, m, n, unsigned) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & esize >= 0 & (e + 1) * esize <= 64);
            if is_vsubw then {
                assert((e + 1) * (2 * esize) <= 128);
                op1 = asl_Int(aget_Elem(Qin(shr_int(n, 1)), e, 2 * esize), unsigned)
            } else {
                op1 = asl_Int(aget_Elem(Din(n), e, esize), unsigned)
            };
            let result = op1 - asl_Int(aget_Elem(Din(m), e, esize), unsigned);
            Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, __GetSlice_int(2 * esize, result, 0))
        }
    }
}

val VSUBL_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSUBL_T1A1_A_decode (U, D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vd[0]] == 0b1 | op == 0b1 & [Vn[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let is_vsubw = op == 0b1;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VSUBL_Op_A(d, elements, esize, is_vsubw, m, n, unsigned)
}

val VSUBHN_Op_A : forall 'd 'elements 'esize 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VSUBHN_Op_A (d, elements, esize, m, n) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & 2 * esize >= 0 & (e + 1) * (2 * esize) <= 128);
            let result : bits(2 * 'esize) = aget_Elem(Qin(shr_int(n, 1)), e, 2 * esize) - aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize);
            D(d) = aset_Elem(D(d), e, esize, slice(result, esize, esize))
        }
    }
}

val VSUBHN_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSUBHN_T1A1_A_decode (D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vn[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VSUBHN_Op_A(d, elements, esize, m, n)
}

val VSRI_Op_A : forall 'd 'elements 'esize 'm 'regs 'shift_amount,
  ('shift_amount >= 0 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m), int('regs), int('shift_amount)) -> unit effect {escape, rreg, undef, wreg}

function VSRI_Op_A (d, elements, esize, m, regs, shift_amount) = {
    if ConditionPassed() then {
        mask : bits('esize) = undefined : bits('esize);
        shifted_op : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        mask = LSR(Ones(esize), shift_amount);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                shifted_op = LSR(aget_Elem(D(m + r), e, esize), shift_amount);
                D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(D(d + r), e, esize) & ~(mask) | shifted_op)
            }
        }
    }
}

val VSRI_T1A1_A_decode : (bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSRI_T1A1_A_decode (D, imm6, Vd, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_shift_amount >= 0 & '_esize >= 0)));
    __PostDecode();
    VSRI_Op_A(d, elements, esize, m, regs, shift_amount)
}

val VSRA_Op_A : forall 'd 'elements 'esize 'm 'regs 'shift_amount ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), int('shift_amount), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VSRA_Op_A (d, elements, esize, m, regs, shift_amount, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                result = shr_int(asl_Int(aget_Elem(D(m + r), e, esize), unsigned), shift_amount);
                D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(D(d + r), e, esize) + result)
            }
        }
    }
}

val VSRA_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSRA_T1A1_A_decode (U, D, imm6, Vd, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VSRA_Op_A(d, elements, esize, m, regs, shift_amount, unsigned)
}

val VSLI_Op_A : forall 'd 'elements 'esize 'm 'regs 'shift_amount,
  ('shift_amount >= 0 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m), int('regs), int('shift_amount)) -> unit effect {escape, rreg, undef, wreg}

function VSLI_Op_A (d, elements, esize, m, regs, shift_amount) = {
    if ConditionPassed() then {
        mask : bits('esize) = undefined : bits('esize);
        shifted_op : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        mask = LSL(Ones(esize), shift_amount);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                shifted_op = LSL(aget_Elem(D(m + r), e, esize), shift_amount);
                D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(D(d + r), e, esize) & ~(mask) | shifted_op)
            }
        }
    }
}

val VSLI_T1A1_A_decode : (bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSLI_T1A1_A_decode (D, imm6, Vd, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = UInt(imm6) - 8
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = UInt(imm6) - 16
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = UInt(imm6) - 32
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_shift_amount >= 0 & '_esize >= 0)));
    __PostDecode();
    VSLI_Op_A(d, elements, esize, m, regs, shift_amount)
}

val VSHRN_Op_A : forall 'd 'elements 'esize 'm 'shift_amount,
  (0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31 & 'shift_amount >= 0 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m), int('shift_amount)) -> unit effect {escape, rreg, undef, wreg}

function VSHRN_Op_A (d, elements, esize, m, shift_amount) = {
    if ConditionPassed() then {
        result : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & 2 * esize >= 0 & (e + 1) * (2 * esize) <= 128);
            result = LSR(aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize), shift_amount);
            D(d) = aset_Elem(D(d), e, esize, slice(result, 0, esize))
        }
    }
}

val VSHRN_T1A1_A_decode : (bits(1), bits(6), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSHRN_T1A1_A_decode (D, imm6, Vd, M, Vm) = {
    __unconditional = false;
    if (imm6 & 0b111000) == 0b000000 then {
        throw(Error_See("Related encodings"))
    };
    if [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match imm6 {
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    assert(constraint((0 <= '_m & '_m <= 31 & 0 <= '_d & '_d <= 31 & '_shift_amount >= 0 & '_esize >= 0)));
    __PostDecode();
    VSHRN_Op_A(d, elements, esize, m, shift_amount)
}

val VSHR_Op_A : forall 'd 'elements 'esize 'm 'regs 'shift_amount ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), int('shift_amount), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VSHR_Op_A (d, elements, esize, m, regs, shift_amount, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                result = shr_int(asl_Int(aget_Elem(D(m + r), e, esize), unsigned), shift_amount);
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 0))
            }
        }
    }
}

val VSHR_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSHR_T1A1_A_decode (U, D, imm6, Vd, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VSHR_Op_A(d, elements, esize, m, regs, shift_amount, unsigned)
}

val VSHL_r_Op_A : forall 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VSHL_r_Op_A (d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        shift : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                shift = SInt(slice(aget_Elem(D(n + r), e, esize), 0, 8));
                result = shl_int(asl_Int(aget_Elem(D(m + r), e, esize), unsigned), shift);
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 0))
            }
        }
    }
}

val VSHL_r_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSHL_r_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vm[0]] == 0b1) | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let n = UInt(N @ Vn);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VSHL_r_Op_A(d, elements, esize, m, n, regs, unsigned)
}

val VSHL_i_Op_A : forall 'd 'elements 'esize 'm 'regs 'shift_amount,
  ('esize >= 0 & 'shift_amount >= 0).
  (int('d), int('elements), int('esize), int('m), int('regs), int('shift_amount)) -> unit effect {escape, rreg, undef, wreg}

function VSHL_i_Op_A (d, elements, esize, m, regs, shift_amount) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, LSL(aget_Elem(D(m + r), e, esize), shift_amount))
            }
        }
    }
}

val VSHL_i_T1A1_A_decode : (bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSHL_i_T1A1_A_decode (D, imm6, Vd, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = UInt(imm6) - 8
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = UInt(imm6) - 16
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = UInt(imm6) - 32
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_esize >= 0 & '_shift_amount >= 0)));
    __PostDecode();
    VSHL_i_Op_A(d, elements, esize, m, regs, shift_amount)
}

val VSHLL_Op_A : forall 'd 'elements 'esize 'm 'shift_amount ('unsigned : Bool),
  ('m >= 0 & 'm <= 31 & 'esize >= 0 & 0 <= 'd & 'd <= 31).
  (int('d), int('elements), int('esize), int('m), int('shift_amount), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VSHLL_Op_A (d, elements, esize, m, shift_amount, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & (e + 1) * esize <= 64);
            result = shl_int(asl_Int(aget_Elem(Din(m), e, esize), unsigned), shift_amount);
            Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, __GetSlice_int(2 * esize, result, 0))
        }
    }
}

val VSHLL_T2A2_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSHLL_T2A2_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if size == 0b11 | [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let shift_amount : int = esize;
    let unsigned = false;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    VSHLL_Op_A(d, elements, esize, m, shift_amount, unsigned)
}

val VSHLL_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VSHLL_T1A1_A_decode (U, D, imm6, Vd, M, Vm) = {
    __unconditional = false;
    if (imm6 & 0b111000) == 0b000000 then {
        throw(Error_See("Related encodings"))
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match imm6 {
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = UInt(imm6) - 8
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = UInt(imm6) - 16
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = UInt(imm6) - 32
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    if shift_amount == 0 then {
        throw(Error_See("VMOVL"))
    };
    let unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    assert(constraint(('_m >= 0 & '_m <= 31 & '_esize >= 0 & 0 <= '_d & '_d <= 31)));
    __PostDecode();
    VSHLL_Op_A(d, elements, esize, m, shift_amount, unsigned)
}

val VRSUBHN_Op_A : forall 'd 'elements 'esize 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VRSUBHN_Op_A (d, elements, esize, m, n) = {
    if ConditionPassed() then {
        result : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        round_const : int = undefined : int;
        CheckAdvSIMDEnabled();
        round_const = shl_int(1, esize - 1);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & (e + 1) * (2 * esize) <= 128);
            result = aget_Elem(Qin(shr_int(n, 1)), e, 2 * esize) - aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize) + round_const;
            D(d) = aset_Elem(D(d), e, esize, slice(result, esize, esize))
        }
    }
}

val VRSUBHN_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSUBHN_T1A1_A_decode (D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vn[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VRSUBHN_Op_A(d, elements, esize, m, n)
}

val VRSRA_Op_A : forall 'd 'elements 'esize 'm 'regs 'shift_amount ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), int('shift_amount), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VRSRA_Op_A (d, elements, esize, m, regs, shift_amount, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        round_const : int = undefined : int;
        CheckAdvSIMDEnabled();
        round_const = shl_int(1, shift_amount - 1);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                result = shr_int(asl_Int(aget_Elem(D(m + r), e, esize), unsigned) + round_const, shift_amount);
                D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(D(d + r), e, esize) + result)
            }
        }
    }
}

val VRSRA_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSRA_T1A1_A_decode (U, D, imm6, Vd, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRSRA_Op_A(d, elements, esize, m, regs, shift_amount, unsigned)
}

val VRSQRTS_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VRSQRTS_Op_A (d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, FPRSqrtStep(aget_Elem(D(n + r), e, esize), aget_Elem(D(m + r), e, esize)))
            }
        }
    }
}

val VRSQRTS_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSQRTS_T1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRSQRTS_Op_A(d, elements, esize, m, n, regs)
}

val VRSQRTS_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSQRTS_A1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRSQRTS_Op_A(d, elements, esize, m, n, regs)
}

val VRSQRTE_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VRSQRTE_Op_A (d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                if floating_point then {
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPRSqrtEstimate(aget_Elem(D(m + r), e, esize), StandardFPSCRValue()))
                } else {
                    D(d + r) = aset_Elem(D(d + r), e, esize, UnsignedRSqrtEstimate(aget_Elem(D(m + r), e, esize)))
                }
            }
        }
    }
}

val VRSQRTE_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSQRTE_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let floating_point = F == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRSQRTE_Op_A(d, elements, esize, floating_point, m, regs)
}

val VRSQRTE_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSQRTE_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRSQRTE_Op_A(d, elements, esize, floating_point, m, regs)
}

val VRSHRN_Op_A : forall 'd 'elements 'esize 'm 'shift_amount,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 'esize >= 0 & 'shift_amount >= 0).
  (int('d), int('elements), int('esize), int('m), int('shift_amount)) -> unit effect {escape, rreg, undef, wreg}

function VRSHRN_Op_A (d, elements, esize, m, shift_amount) = {
    if ConditionPassed() then {
        result : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        round_const : int = undefined : int;
        CheckAdvSIMDEnabled();
        round_const = shl_int(1, shift_amount - 1);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & (e + 1) * (2 * esize) <= 128);
            result = LSR(aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize) + round_const, shift_amount);
            D(d) = aset_Elem(D(d), e, esize, slice(result, 0, esize))
        }
    }
}

val VRSHRN_T1A1_A_decode : (bits(1), bits(6), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSHRN_T1A1_A_decode (D, imm6, Vd, M, Vm) = {
    __unconditional = false;
    if (imm6 & 0b111000) == 0b000000 then {
        throw(Error_See("Related encodings"))
    };
    if [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match imm6 {
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    assert(constraint((0 <= '_d & '_d <= 31 & 0 <= '_m & '_m <= 31 & '_esize >= 0 & '_shift_amount >= 0)));
    __PostDecode();
    VRSHRN_Op_A(d, elements, esize, m, shift_amount)
}

val VRSHR_Op_A : forall 'd 'elements 'esize 'm 'regs 'shift_amount ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), int('shift_amount), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VRSHR_Op_A (d, elements, esize, m, regs, shift_amount, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        round_const : int = undefined : int;
        CheckAdvSIMDEnabled();
        round_const = shl_int(1, shift_amount - 1);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                result = shr_int(asl_Int(aget_Elem(D(m + r), e, esize), unsigned) + round_const, shift_amount);
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 0))
            }
        }
    }
}

val VRSHR_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSHR_T1A1_A_decode (U, D, imm6, Vd, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRSHR_Op_A(d, elements, esize, m, regs, shift_amount, unsigned)
}

val VRSHL_Op_A : forall 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VRSHL_Op_A (d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        round_const : int = undefined : int;
        shift : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                shift = SInt(slice(aget_Elem(D(n + r), e, esize), 0, 8));
                round_const = shl_int(1, negate(shift) - 1);
                result = shl_int(asl_Int(aget_Elem(D(m + r), e, esize), unsigned) + round_const, shift);
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 0))
            }
        }
    }
}

val VRSHL_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRSHL_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vm[0]] == 0b1) | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let n = UInt(N @ Vn);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VRSHL_Op_A(d, elements, esize, m, n, regs, unsigned)
}

val VRINTZ_asimd_Op_A : forall 'd 'elements 'esize ('exact : Bool) 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('exact), int('m), int('regs), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function VRINTZ_asimd_Op_A (d, elements, esize, exact, m, regs, rounding) = {
    CheckAdvSIMDEnabled();
    op1 : bits('esize) = undefined : bits('esize);
    result : bits('esize) = undefined : bits('esize);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            op1 = aget_Elem(D(m + r), e, esize);
            result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
            D(d + r) = aset_Elem(D(d + r), e, esize, result)
        }
    }
}

val VRINTZ_asimd_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTZ_asimd_T1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = true;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPRounding_ZERO;
    let exact = false;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VRINTZ_asimd_Op_A(d, elements, esize, exact, m, regs, rounding)
}

val VRINTZ_asimd_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTZ_asimd_A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = true;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPRounding_ZERO;
    let exact = false;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRINTZ_asimd_Op_A(d, elements, esize, exact, m, regs, rounding)
}

val VRINTX_asimd_Op_A : forall 'd 'elements 'esize ('exact : Bool) 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('exact), int('m), int('regs), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function VRINTX_asimd_Op_A (d, elements, esize, exact, m, regs, rounding) = {
    CheckAdvSIMDEnabled();
    op1 : bits('esize) = undefined : bits('esize);
    result : bits('esize) = undefined : bits('esize);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            op1 = aget_Elem(D(m + r), e, esize);
            result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
            D(d + r) = aset_Elem(D(d + r), e, esize, result)
        }
    }
}

val VRINTX_asimd_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTX_asimd_T1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = true;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPRounding_TIEEVEN;
    let exact = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VRINTX_asimd_Op_A(d, elements, esize, exact, m, regs, rounding)
}

val VRINTX_asimd_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTX_asimd_A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = true;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPRounding_TIEEVEN;
    let exact = true;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRINTX_asimd_Op_A(d, elements, esize, exact, m, regs, rounding)
}

val VRINTA_asimd_Op_A : forall 'd 'elements 'esize ('exact : Bool) 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('exact), int('m), int('regs), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function VRINTA_asimd_Op_A (d, elements, esize, exact, m, regs, rounding) = {
    CheckAdvSIMDEnabled();
    op1 : bits('esize) = undefined : bits('esize);
    result : bits('esize) = undefined : bits('esize);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            op1 = aget_Elem(D(m + r), e, esize);
            result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
            D(d + r) = aset_Elem(D(d + r), e, esize, result)
        }
    }
}

val VRINTA_asimd_T1_A_decode : (bits(1), bits(2), bits(4), bits(3), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTA_asimd_T1_A_decode (D, size, Vd, op, Q, M, Vm) = {
    __unconditional = true;
    if [op[2]] != [op[0]] then {
        throw(Error_See("Related encodings"))
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPDecodeRM([op[2]] @ ~([op[1]]));
    let exact = false;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRINTA_asimd_Op_A(d, elements, esize, exact, m, regs, rounding)
}

val VRINTA_asimd_A1_A_decode : (bits(1), bits(2), bits(4), bits(3), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRINTA_asimd_A1_A_decode (D, size, Vd, op, Q, M, Vm) = {
    __unconditional = true;
    if [op[2]] != [op[0]] then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPDecodeRM([op[2]] @ ~([op[1]]));
    let exact = false;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRINTA_asimd_Op_A(d, elements, esize, exact, m, regs, rounding)
}

val VRHADD_Op_A : forall 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VRHADD_Op_A (d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = asl_Int(aget_Elem(D(n + r), e, esize), unsigned);
                op2 = asl_Int(aget_Elem(D(m + r), e, esize), unsigned);
                result = op1 + op2 + 1;
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 1))
            }
        }
    }
}

val VRHADD_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRHADD_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VRHADD_Op_A(d, elements, esize, m, n, regs, unsigned)
}

val VREV16_Op_A : forall 'containers 'd 'elements_per_container 'esize 'm 'regs,
  'esize >= 0.
  (int('containers), int('d), int('elements_per_container), int('esize), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VREV16_Op_A (containers, d, elements_per_container, esize, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        result : bits(64) = undefined : bits(64);
        element : int = undefined : int;
        rev_element : int = undefined : int;
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            element = 0;
            foreach (c from 0 to (containers - 1) by 1 in inc) {
                rev_element = element + elements_per_container - 1;
                foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                    let elem = element;
                    assert(elem >= 0 & (elem + 1) * esize <= 64);
                    result = aset_Elem(result, rev_element, esize, aget_Elem(D(m + r), elem, esize));
                    element = element + 1;
                    rev_element = rev_element - 1
                }
            };
            assert(d + r >= 0 & d + r <= 31);
            D(d + r) = result
        }
    }
}

val VREV16_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VREV16_T1A1_A_decode (D, size, Vd, op, Q, M, Vm) = {
    __unconditional = false;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let 'esize : {|8, 16, 32, 64|} = shl_int(8, UInt(size));
    container_size : int = undefined : int;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      }
    };
    let 'container_size = container_size;
    assert(constraint('container_size in {16, 32, 64}));
    let 'containers : {'n, 'n == div(64, 'container_size). int('n)} = 64 / container_size;
    let 'elements_per_container : {'n, 'n == div('container_size, 'esize). int('n)} = container_size / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VREV16_Op_A(containers, d, elements_per_container, esize, m, regs)
}

val VRECPS_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VRECPS_Op_A (d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, FPRecipStep(aget_Elem(D(n + r), e, esize), aget_Elem(D(m + r), e, esize)))
            }
        }
    }
}

val VRECPS_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRECPS_T1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRECPS_Op_A(d, elements, esize, m, n, regs)
}

val VRECPS_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRECPS_A1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRECPS_Op_A(d, elements, esize, m, n, regs)
}

val VRECPE_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VRECPE_Op_A (d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                if floating_point then {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point))));
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('floating_point))));
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPRecipEstimate(aget_Elem(D(m + r), e, esize), StandardFPSCRValue()))
                } else {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('floating_point)))));
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('floating_point)))));
                    D(d + r) = aset_Elem(D(d + r), e, esize, UnsignedRecipEstimate(aget_Elem(D(m + r), e, esize)))
                }
            }
        }
    }
}

val VRECPE_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRECPE_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let floating_point = F == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRECPE_Op_A(d, elements, esize, floating_point, m, regs)
}

val VRECPE_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRECPE_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VRECPE_Op_A(d, elements, esize, floating_point, m, regs)
}

val VRADDHN_Op_A : forall 'd 'elements 'esize 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VRADDHN_Op_A (d, elements, esize, m, n) = {
    if ConditionPassed() then {
        result : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        round_const : int = undefined : int;
        CheckAdvSIMDEnabled();
        round_const = shl_int(1, esize - 1);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & 2 * esize >= 0 & (e + 1) * (2 * esize) <= 128);
            result = aget_Elem(Qin(shr_int(n, 1)), e, 2 * esize) + aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize) + round_const;
            D(d) = aset_Elem(D(d), e, esize, slice(result, esize, esize))
        }
    }
}

val VRADDHN_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VRADDHN_T1A1_A_decode (D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vn[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VRADDHN_Op_A(d, elements, esize, m, n)
}

val VQSUB_Op_A : forall 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQSUB_Op_A (d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        diff : int = undefined : int;
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                diff = asl_Int(aget_Elem(D(n + r), e, esize), unsigned) - asl_Int(aget_Elem(D(m + r), e, esize), unsigned);
                __tc1 : bits('esize) = undefined : bits('esize);
                (__tc1, sat) = SatQ(diff, esize, unsigned);
                D(d + r) = aset_Elem(D(d + r), e, esize, __tc1);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQSUB_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQSUB_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQSUB_Op_A(d, elements, esize, m, n, regs, unsigned)
}

val VQSHRN_Op_A : forall 'd ('dest_unsigned : Bool) 'elements 'esize 'm 'shift_amount ('src_unsigned : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 'esize >= 0).
  (int('d), bool('dest_unsigned), int('elements), int('esize), int('m), int('shift_amount), bool('src_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQSHRN_Op_A (d, dest_unsigned, elements, esize, m, shift_amount, src_unsigned) = {
    if ConditionPassed() then {
        operand : int = undefined : int;
        result : bits('esize) = undefined : bits('esize);
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & 2 * esize >= 0 & (e + 1) * (2 * esize) <= 128);
            operand = asl_Int(aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize), src_unsigned);
            (result, sat) = SatQ(shr_int(operand, shift_amount), esize, dest_unsigned);
            D(d) = aset_Elem(D(d), e, esize, result);
            if sat then {
                FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
            }
        }
    }
}

val VQSHRN_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQSHRN_T1A1_A_decode (U, D, imm6, Vd, op, M, Vm) = {
    __unconditional = false;
    if (imm6 & 0b111000) == 0b000000 then {
        throw(Error_See("Related encodings"))
    };
    if U == 0b0 & op == 0b0 then {
        throw(Error_See("VSHRN"))
    };
    if [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match imm6 {
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let src_unsigned = U == 0b1 & op == 0b1;
    let dest_unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    assert(constraint((0 <= '_d & '_d <= 31 & 0 <= '_m & '_m <= 31 & '_esize >= 0)));
    __PostDecode();
    VQSHRN_Op_A(d, dest_unsigned, elements, esize, m, shift_amount, src_unsigned)
}

val VQSHL_r_Op_A : forall 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQSHL_r_Op_A (d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        operand : int = undefined : int;
        result : bits('esize) = undefined : bits('esize);
        sat : bool = undefined : bool;
        shift : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                shift = SInt(slice(aget_Elem(D(n + r), e, esize), 0, 8));
                operand = asl_Int(aget_Elem(D(m + r), e, esize), unsigned);
                (result, sat) = SatQ(shl_int(operand, shift), esize, unsigned);
                D(d + r) = aset_Elem(D(d + r), e, esize, result);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQSHL_r_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQSHL_r_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vm[0]] == 0b1) | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let n = UInt(N @ Vn);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQSHL_r_Op_A(d, elements, esize, m, n, regs, unsigned)
}

val VQSHL_i_Op_A : forall 'd ('dest_unsigned : Bool) 'elements 'esize 'm 'regs 'shift_amount ('src_unsigned : Bool),
  'esize >= 0.
  (int('d), bool('dest_unsigned), int('elements), int('esize), int('m), int('regs), int('shift_amount), bool('src_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQSHL_i_Op_A (d, dest_unsigned, elements, esize, m, regs, shift_amount, src_unsigned) = {
    if ConditionPassed() then {
        operand : int = undefined : int;
        result : bits('esize) = undefined : bits('esize);
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                operand = asl_Int(aget_Elem(D(m + r), e, esize), src_unsigned);
                (result, sat) = SatQ(shl_int(operand, shift_amount), esize, dest_unsigned);
                D(d + r) = aset_Elem(D(d + r), e, esize, result);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQSHL_i_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQSHL_i_T1A1_A_decode (U, D, imm6, Vd, op, L, Q, M, Vm) = {
    __unconditional = false;
    if ((L @ imm6) & 0b1111000) == 0b0000000 then {
        throw(Error_See("Related encodings"))
    };
    if U == 0b0 & op == 0b0 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match L @ imm6 {
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = UInt(imm6) - 8
      },
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = UInt(imm6) - 16
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = UInt(imm6) - 32
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 64;
          elements = 1;
          shift_amount = UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let src_unsigned = U == 0b1 & op == 0b1;
    let dest_unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VQSHL_i_Op_A(d, dest_unsigned, elements, esize, m, regs, shift_amount, src_unsigned)
}

val VQRSHRN_Op_A : forall 'd ('dest_unsigned : Bool) 'elements 'esize 'm 'shift_amount ('src_unsigned : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 'esize >= 0).
  (int('d), bool('dest_unsigned), int('elements), int('esize), int('m), int('shift_amount), bool('src_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQRSHRN_Op_A (d, dest_unsigned, elements, esize, m, shift_amount, src_unsigned) = {
    if ConditionPassed() then {
        result : bits('esize) = undefined : bits('esize);
        round_const : int = undefined : int;
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        round_const = shl_int(1, shift_amount - 1);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & (e + 1) * (2 * esize) <= 128);
            let operand = asl_Int(aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize), src_unsigned);
            (result, sat) = SatQ(shr_int(operand + round_const, shift_amount), esize, dest_unsigned);
            D(d) = aset_Elem(D(d), e, esize, result);
            if sat then {
                FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
            }
        }
    }
}

val VQRSHRN_T1A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRSHRN_T1A1_A_decode (U, D, imm6, Vd, op, M, Vm) = {
    __unconditional = false;
    if (imm6 & 0b111000) == 0b000000 then {
        throw(Error_See("Related encodings"))
    };
    if U == 0b0 & op == 0b0 then {
        throw(Error_See("VRSHRN"))
    };
    if [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    shift_amount : int = undefined : int;
    match imm6 {
      [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 8;
          elements = 8;
          shift_amount = 16 - UInt(imm6)
      },
      [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 16;
          elements = 4;
          shift_amount = 32 - UInt(imm6)
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          esize = 32;
          elements = 2;
          shift_amount = 64 - UInt(imm6)
      }
    };
    let shift_amount = shift_amount;
    let esize = esize;
    let elements = elements;
    let src_unsigned = U == 0b1 & op == 0b1;
    let dest_unsigned = U == 0b1;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    assert(constraint((0 <= '_d & '_d <= 31 & 0 <= '_m & '_m <= 31 & '_esize >= 0)));
    __PostDecode();
    VQRSHRN_Op_A(d, dest_unsigned, elements, esize, m, shift_amount, src_unsigned)
}

val VQRSHL_Op_A : forall 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQRSHL_Op_A (d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        operand : int = undefined : int;
        result : bits('esize) = undefined : bits('esize);
        round_const : int = undefined : int;
        sat : bool = undefined : bool;
        shift : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                shift = SInt(slice(aget_Elem(D(n + r), e, esize), 0, 8));
                round_const = shl_int(1, negate(1) - shift);
                operand = asl_Int(aget_Elem(D(m + r), e, esize), unsigned);
                (result, sat) = SatQ(shl_int(operand + round_const, shift), esize, unsigned);
                D(d + r) = aset_Elem(D(d + r), e, esize, result);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQRSHL_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRSHL_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vm[0]] == 0b1) | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let n = UInt(N @ Vn);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQRSHL_Op_A(d, elements, esize, m, n, regs, unsigned)
}

val VQRDMULH_Op_A : forall 'd 'elements 'esize 'index 'm 'n 'regs ('scalar_form : Bool),
  ('m >= 0 & 'm <= 31 | not('scalar_form)) & ('esize >= 0 | not('scalar_form)) & 'esize >= 0.
  (int('d), int('elements), int('esize), int('index), int('m), int('n), int('regs), bool('scalar_form)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMULH_Op_A (d, elements, esize, index, m, n, regs, scalar_form) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        result : bits('esize) = undefined : bits('esize);
        round_const : int = undefined : int;
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        round_const = shl_int(1, esize - 1);
        if scalar_form then {
            op2 = SInt(aget_Elem(D(m), index, esize))
        };
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = SInt(aget_Elem(D(n + r), e, esize));
                if ~(scalar_form) then {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('scalar_form)))));
                    op2 = SInt(aget_Elem(D(m + r), e, esize))
                };
                (result, sat) = SignedSatQ(shr_int(2 * op1 * op2 + round_const, esize), esize);
                D(d + r) = aset_Elem(D(d + r), e, esize, result);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQRDMULH_T2A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMULH_T2A2_A_decode (Q, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= m & m <= 31);
    VQRDMULH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQRDMULH_T1A1pre_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMULH_T1A1pre_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    let 'index = undefined : int;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let scalar_form = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQRDMULH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQRDMLSH_Op_A : forall 'd 'elements 'esize 'index 'm 'n 'regs ('scalar_form : Bool),
  ('m >= 0 & 'm <= 31 | not('scalar_form)) & ('esize >= 0 | not('scalar_form)) & 'esize >= 0.
  (int('d), int('elements), int('esize), int('index), int('m), int('n), int('regs), bool('scalar_form)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLSH_Op_A (d, elements, esize, index, m, n, regs, scalar_form) = {
    CheckAdvSIMDEnabled();
    let round_const = shl_int(1, esize - 1);
    op2 : int = undefined : int;
    if scalar_form then {
        op2 = SInt(aget_Elem(D(m), index, esize))
    };
    op1 : int = undefined : int;
    op3 : int = undefined : int;
    result : bits('esize) = undefined : bits('esize);
    sat : bool = undefined : bool;
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
            op1 = SInt(aget_Elem(D(n + r), e, esize));
            op3 = shl_int(SInt(aget_Elem(D(d + r), e, esize)), esize);
            if ~(scalar_form) then {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('scalar_form)))));
                op2 = SInt(aget_Elem(D(m + r), e, esize))
            };
            (result, sat) = SignedSatQ(shr_int(op3 - 2 * (op1 * op2) + round_const, esize), esize);
            D(d + r) = aset_Elem(D(d + r), e, esize, result);
            if sat then {
                FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
            }
        }
    }
}

val VQRDMLSH_T2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLSH_T2_A_decode (Q, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let add : bool(false) = false;
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= m & m <= 31);
    VQRDMLSH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQRDMLSH_T1A1pre_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLSH_T1A1pre_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    let 'index = undefined : int;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let add = false;
    let scalar_form = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQRDMLSH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQRDMLSH_A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLSH_A2_A_decode (Q, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let add : bool(false) = false;
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= m & m <= 31);
    VQRDMLSH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQRDMLAH_Op_A : forall 'd 'elements 'esize 'index 'm 'n 'regs ('scalar_form : Bool),
  ('m >= 0 & 'm <= 31 | not('scalar_form)) & ('esize >= 0 | not('scalar_form)) & 'esize >= 0.
  (int('d), int('elements), int('esize), int('index), int('m), int('n), int('regs), bool('scalar_form)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLAH_Op_A (d, elements, esize, index, m, n, regs, scalar_form) = {
    CheckAdvSIMDEnabled();
    let round_const = shl_int(1, esize - 1);
    op2 : int = undefined : int;
    if scalar_form then {
        op2 = SInt(aget_Elem(D(m), index, esize))
    };
    op1 : int = undefined : int;
    op3 : int = undefined : int;
    result : bits('esize) = undefined : bits('esize);
    sat : bool = undefined : bool;
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
            op1 = SInt(aget_Elem(D(n + r), e, esize));
            op3 = shl_int(SInt(aget_Elem(D(d + r), e, esize)), esize);
            if ~(scalar_form) then {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('scalar_form)))));
                op2 = SInt(aget_Elem(D(m + r), e, esize))
            };
            (result, sat) = SignedSatQ(shr_int(op3 + 2 * (op1 * op2) + round_const, esize), esize);
            D(d + r) = aset_Elem(D(d + r), e, esize, result);
            if sat then {
                FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
            }
        }
    }
}

val VQRDMLAH_T2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLAH_T2_A_decode (Q, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let add : bool(true) = true;
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= m & m <= 31);
    VQRDMLAH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQRDMLAH_T1A1pre_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLAH_T1A1pre_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    let 'index = undefined : int;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let add = true;
    let scalar_form = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQRDMLAH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQRDMLAH_A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQRDMLAH_A2_A_decode (Q, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let add : bool(true) = true;
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= m & m <= 31);
    VQRDMLAH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQNEG_Op_A : forall 'd 'elements 'esize 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VQNEG_Op_A (d, elements, esize, m, regs) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                result = negate(SInt(aget_Elem(D(m + r), e, esize)));
                __tc1 : bits('esize) = undefined : bits('esize);
                (__tc1, sat) = SignedSatQ(result, esize);
                D(d + r) = aset_Elem(D(d + r), e, esize, __tc1);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQNEG_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQNEG_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQNEG_Op_A(d, elements, esize, m, regs)
}

val VQMOVN_Op_A : forall 'd ('dest_unsigned : Bool) 'elements 'esize 'm ('src_unsigned : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 'esize >= 0).
  (int('d), bool('dest_unsigned), int('elements), int('esize), int('m), bool('src_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQMOVN_Op_A (d, dest_unsigned, elements, esize, m, src_unsigned) = {
    if ConditionPassed() then {
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & (e + 1) * (2 * esize) <= 128);
            let operand = asl_Int(aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize), src_unsigned);
            __tc1 : bits('esize) = undefined : bits('esize);
            (__tc1, sat) = SatQ(operand, esize, dest_unsigned);
            D(d) = aset_Elem(D(d), e, esize, __tc1);
            if sat then {
                FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
            }
        }
    }
}

val VQMOVN_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQMOVN_T1A1_A_decode (D, size, Vd, op, M, Vm) = {
    __unconditional = false;
    if op == 0b00 then {
        throw(Error_See("VMOVN"))
    };
    if size == 0b11 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let src_unsigned = op == 0b11;
    let dest_unsigned = [op[0]] == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    VQMOVN_Op_A(d, dest_unsigned, elements, esize, m, src_unsigned)
}

val VQDMULL_Op_A : forall 'd 'elements 'esize 'index 'm 'n ('scalar_form : Bool),
  ('m >= 0 & 'm <= 31 & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 64 | not('scalar_form)) & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31).
  (int('d), int('elements), int('esize), int('index), int('m), int('n), bool('scalar_form)) -> unit effect {escape, rreg, undef, wreg}

function VQDMULL_Op_A (d, elements, esize, index, m, n, scalar_form) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        if scalar_form then {
            op2 = SInt(aget_Elem(Din(m), index, esize))
        };
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
            if ~(scalar_form) then {
                assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not(not('scalar_form)))));
                op2 = SInt(aget_Elem(Din(m), e, esize))
            };
            op1 = SInt(aget_Elem(Din(n), e, esize));
            (product, sat) = SignedSatQ(2 * op1 * op2, 2 * esize);
            Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, product);
            if sat then {
                FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
            }
        }
    }
}

val VQDMULL_T2A2_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQDMULL_T2A2_A_decode (D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & n >= 0 & n <= 31 & d >= 0 & d <= 31);
    VQDMULL_Op_A(d, elements, esize, index, m, n, scalar_form)
}

val VQDMULL_T1A1pre_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQDMULL_T1A1pre_A_decode (D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    let 'index = undefined : int;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let scalar_form = false;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    __PostDecode();
    VQDMULL_Op_A(d, elements, esize, index, m, n, scalar_form)
}

val VQDMULH_Op_A : forall 'd 'elements 'esize 'index 'm 'n 'regs ('scalar_form : Bool),
  ('m >= 0 & 'm <= 31 | not('scalar_form)) & ('esize >= 0 | not('scalar_form)) & ('esize >= 0 | not(not('scalar_form))).
  (int('d), int('elements), int('esize), int('index), int('m), int('n), int('regs), bool('scalar_form)) -> unit effect {escape, rreg, undef, wreg}

function VQDMULH_Op_A (d, elements, esize, index, m, n, regs, scalar_form) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        result : bits('esize) = undefined : bits('esize);
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        if scalar_form then {
            op2 = SInt(aget_Elem(D(m), index, esize))
        };
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                if ~(scalar_form) then {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('scalar_form)))));
                    op2 = SInt(aget_Elem(D(m + r), e, esize))
                };
                op1 = SInt(aget_Elem(D(n + r), e, esize));
                (result, sat) = SignedSatQ(shr_int(2 * op1 * op2, esize), esize);
                D(d + r) = aset_Elem(D(d + r), e, esize, result);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQDMULH_T2A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQDMULH_T2A2_A_decode (Q, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & n >= 0 & n <= 31 & d >= 0 & d <= 31);
    VQDMULH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQDMULH_T1A1pre_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQDMULH_T1A1pre_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    let 'index = undefined : int;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let scalar_form = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQDMULH_Op_A(d, elements, esize, index, m, n, regs, scalar_form)
}

val VQDMLAL_Op_A : forall ('add : Bool) 'd 'elements 'esize 'index 'm 'n ('scalar_form : Bool),
  ('m >= 0 & 'm <= 31 & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 64 | not('scalar_form)) & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31).
  (bool('add), int('d), int('elements), int('esize), int('index), int('m), int('n), bool('scalar_form)) -> unit effect {escape, rreg, undef, wreg}

function VQDMLAL_Op_A (add, d, elements, esize, index, m, n, scalar_form) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        result : int = undefined : int;
        sat1 : bool = undefined : bool;
        sat2 : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        if scalar_form then {
            op2 = SInt(aget_Elem(Din(m), index, esize))
        };
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
            if ~(scalar_form) then {
                assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64 | not(not('scalar_form)))));
                op2 = SInt(aget_Elem(Din(m), e, esize))
            };
            op1 = SInt(aget_Elem(Din(n), e, esize));
            (product, sat1) = SignedSatQ(2 * op1 * op2, 2 * esize);
            if add then {
                result = SInt(aget_Elem(Qin(shr_int(d, 1)), e, 2 * esize)) + SInt(product)
            } else {
                result = SInt(aget_Elem(Qin(shr_int(d, 1)), e, 2 * esize)) - SInt(product)
            };
            __tc1 : bits(2 * 'esize) = undefined : bits(2 * 'esize);
            (__tc1, sat2) = SignedSatQ(result, 2 * esize);
            Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, __tc1);
            if sat1 | sat2 then {
                FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
            }
        }
    }
}

val VQDMLAL_T2A2_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQDMLAL_T2A2_A_decode (D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let add : bool = op == 0b0;
    let scalar_form : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let m = m;
    let index = index;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & n >= 0 & n <= 31 & d >= 0 & d <= 31);
    VQDMLAL_Op_A(add, d, elements, esize, index, m, n, scalar_form)
}

val VQDMLAL_T1A1pre_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQDMLAL_T1A1pre_A_decode (D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    let 'index = undefined : int;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let add = op == 0b0;
    let scalar_form = false;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    __PostDecode();
    VQDMLAL_Op_A(add, d, elements, esize, index, m, n, scalar_form)
}

val VQADD_Op_A : forall 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VQADD_Op_A (d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        sat : bool = undefined : bool;
        sum : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                sum = asl_Int(aget_Elem(D(n + r), e, esize), unsigned) + asl_Int(aget_Elem(D(m + r), e, esize), unsigned);
                __tc1 : bits('esize) = undefined : bits('esize);
                (__tc1, sat) = SatQ(sum, esize, unsigned);
                D(d + r) = aset_Elem(D(d + r), e, esize, __tc1);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQADD_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQADD_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQADD_Op_A(d, elements, esize, m, n, regs, unsigned)
}

val VQABS_Op_A : forall 'd 'elements 'esize 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VQABS_Op_A (d, elements, esize, m, regs) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        sat : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                result = abs(SInt(aget_Elem(D(m + r), e, esize)));
                __tc1 : bits('esize) = undefined : bits('esize);
                (__tc1, sat) = SignedSatQ(result, esize);
                D(d + r) = aset_Elem(D(d + r), e, esize, __tc1);
                if sat then {
                    FPSCR = __SetSlice_bits(32, 1, FPSCR, 27, 0b1)
                }
            }
        }
    }
}

val VQABS_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VQABS_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VQABS_Op_A(d, elements, esize, m, regs)
}

val VPMAX_i_Op_A : forall 'd 'elements 'esize 'm ('maximum : Bool) 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & 'esize >= 0 & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('elements), int('esize), int('m), bool('maximum), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VPMAX_i_Op_A (d, elements, esize, m, maximum, n, unsigned) = {
    if ConditionPassed() then {
        h : int = undefined : int;
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        dest : bits(64) = undefined : bits(64);
        h = elements / 2;
        foreach (e from 0 to (h - 1) by 1 in inc) {
            op1 = asl_Int(aget_Elem(D(n), 2 * e, esize), unsigned);
            op2 = asl_Int(aget_Elem(D(n), 2 * e + 1, esize), unsigned);
            result = if maximum then max(op1, op2) else min(op1, op2);
            dest = aset_Elem(dest, e, esize, __GetSlice_int(esize, result, 0));
            op1 = asl_Int(aget_Elem(D(m), 2 * e, esize), unsigned);
            op2 = asl_Int(aget_Elem(D(m), 2 * e + 1, esize), unsigned);
            result = if maximum then max(op1, op2) else min(op1, op2);
            dest = aset_Elem(dest, e + h, esize, __GetSlice_int(esize, result, 0))
        };
        D(d) = dest
    }
}

val VPMAX_i_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPMAX_i_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, op, Vm) = {
    __unconditional = false;
    if size == 0b11 | Q == 0b1 then {
        throw(Error_Undefined())
    };
    let maximum = op == 0b0;
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VPMAX_i_Op_A(d, elements, esize, m, maximum, n, unsigned)
}

val VPMAX_f_Op_A : forall 'd 'elements 'esize 'm ('maximum : Bool) 'n,
  ('n >= 0 & 'n <= 31 & 'esize >= 0) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('elements), int('esize), int('m), bool('maximum), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VPMAX_f_Op_A (d, elements, esize, m, maximum, n) = {
    if ConditionPassed() then {
        h : int = undefined : int;
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        dest : bits(64) = undefined : bits(64);
        h = elements / 2;
        foreach (e from 0 to (h - 1) by 1 in inc) {
            op1 = aget_Elem(D(n), 2 * e, esize);
            op2 = aget_Elem(D(n), 2 * e + 1, esize);
            dest = aset_Elem(dest, e, esize, if maximum then FPMax(op1, op2, StandardFPSCRValue()) else FPMin(op1, op2, StandardFPSCRValue()));
            op1 = aget_Elem(D(m), 2 * e, esize);
            op2 = aget_Elem(D(m), 2 * e + 1, esize);
            dest = aset_Elem(dest, e + h, esize, if maximum then FPMax(op1, op2, StandardFPSCRValue()) else FPMin(op1, op2, StandardFPSCRValue()))
        };
        D(d) = dest
    }
}

val VPMAX_f_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPMAX_f_T1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let maximum = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_esize >= 0)));
    __PostDecode();
    VPMAX_f_Op_A(d, elements, esize, m, maximum, n)
}

val VPMAX_f_A1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPMAX_f_A1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let maximum = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_esize >= 0)));
    __PostDecode();
    VPMAX_f_Op_A(d, elements, esize, m, maximum, n)
}

val VPADD_i_Op_A : forall 'd 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & 'esize >= 0 & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VPADD_i_Op_A (d, elements, esize, m, n) = {
    if ConditionPassed() then {
        h : int = undefined : int;
        CheckAdvSIMDEnabled();
        dest : bits(64) = undefined : bits(64);
        h = elements / 2;
        foreach (e from 0 to (h - 1) by 1 in inc) {
            dest = aset_Elem(dest, e, esize, aget_Elem(D(n), 2 * e, esize) + aget_Elem(D(n), 2 * e + 1, esize));
            dest = aset_Elem(dest, e + h, esize, aget_Elem(D(m), 2 * e, esize) + aget_Elem(D(m), 2 * e + 1, esize))
        };
        D(d) = dest
    }
}

val VPADD_i_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPADD_i_T1A1_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 | Q == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VPADD_i_Op_A(d, elements, esize, m, n)
}

val VPADD_f_Op_A : forall 'd 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31 & 'esize >= 0) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VPADD_f_Op_A (d, elements, esize, m, n) = {
    if ConditionPassed() then {
        h : int = undefined : int;
        CheckAdvSIMDEnabled();
        dest : bits(64) = undefined : bits(64);
        h = elements / 2;
        foreach (e from 0 to (h - 1) by 1 in inc) {
            dest = aset_Elem(dest, e, esize, FPAdd(aget_Elem(D(n), 2 * e, esize), aget_Elem(D(n), 2 * e + 1, esize), StandardFPSCRValue()));
            dest = aset_Elem(dest, e + h, esize, FPAdd(aget_Elem(D(m), 2 * e, esize), aget_Elem(D(m), 2 * e + 1, esize), StandardFPSCRValue()))
        };
        D(d) = dest
    }
}

val VPADD_f_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPADD_f_T1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_esize >= 0)));
    __PostDecode();
    VPADD_f_Op_A(d, elements, esize, m, n)
}

val VPADD_f_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPADD_f_A1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_esize >= 0)));
    __PostDecode();
    VPADD_f_Op_A(d, elements, esize, m, n)
}

val VPADDL_Op_A : forall 'd 'elements 'esize 'm 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VPADDL_Op_A (d, elements, esize, m, regs, unsigned) = {
    if ConditionPassed() then {
        h : int = undefined : int;
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        h = elements / 2;
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (h - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                op1 = aget_Elem(D(m + r), 2 * e, esize);
                op2 = aget_Elem(D(m + r), 2 * e + 1, esize);
                result = asl_Int(op1, unsigned) + asl_Int(op2, unsigned);
                D(d + r) = aset_Elem(D(d + r), e, 2 * esize, __GetSlice_int(2 * esize, result, 0))
            }
        }
    }
}

val VPADDL_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPADDL_T1A1_A_decode (D, size, Vd, op, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = op == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VPADDL_Op_A(d, elements, esize, m, regs, unsigned)
}

val VPADAL_Op_A : forall 'd 'elements 'esize 'm 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VPADAL_Op_A (d, elements, esize, m, regs, unsigned) = {
    if ConditionPassed() then {
        h : int = undefined : int;
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        h = elements / 2;
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (h - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                op1 = aget_Elem(D(m + r), 2 * e, esize);
                op2 = aget_Elem(D(m + r), 2 * e + 1, esize);
                result = asl_Int(op1, unsigned) + asl_Int(op2, unsigned);
                D(d + r) = aset_Elem(D(d + r), e, 2 * esize, aget_Elem(D(d + r), e, 2 * esize) + result)
            }
        }
    }
}

val VPADAL_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VPADAL_T1A1_A_decode (D, size, Vd, op, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = op == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VPADAL_Op_A(d, elements, esize, m, regs, unsigned)
}

val VORR_r_Op_A : forall ('d : Int) ('m : Int) ('n : Int) ('regs : Int).
  (int('d), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VORR_r_Op_A (d, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
            D(d + r) = D(n + r) | D(m + r)
        }
    }
}

val VORR_r_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VORR_r_T1A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VORR_r_Op_A(d, m, n, regs)
}

val VORR_i_Op_A : forall ('d : Int) ('regs : Int).
  (int('d), bits(64), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VORR_i_Op_A (d, imm64, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            D(d + r) = D(d + r) | imm64
        }
    }
}

val VORR_i_T2A2_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VORR_i_T2A2_A_decode (i, D, imm3, Vd, cmode, Q, imm4) = {
    __unconditional = false;
    if [cmode[0]] == 0b0 | slice(cmode, 2, 2) == 0b11 then {
        throw(Error_See("VMOV (immediate)"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let imm64 = AdvSIMDExpandImm(0b0, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VORR_i_Op_A(d, imm64, regs)
}

val VORR_i_T1A1_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VORR_i_T1A1_A_decode (i, D, imm3, Vd, cmode, Q, imm4) = {
    __unconditional = false;
    if [cmode[0]] == 0b0 | slice(cmode, 2, 2) == 0b11 then {
        throw(Error_See("VMOV (immediate)"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let imm64 = AdvSIMDExpandImm(0b0, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VORR_i_Op_A(d, imm64, regs)
}

val VORN_r_Op_A : forall ('d : Int) ('m : Int) ('n : Int) ('regs : Int).
  (int('d), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VORN_r_Op_A (d, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
            D(d + r) = D(n + r) | ~(D(m + r))
        }
    }
}

val VORN_r_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VORN_r_T1A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VORN_r_Op_A(d, m, n, regs)
}

val VMVN_r_Op_A : forall ('d : Int) ('m : Int) ('regs : Int).
  (int('d), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VMVN_r_Op_A (d, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            D(d + r) = ~(D(m + r))
        }
    }
}

val VMVN_r_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMVN_r_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMVN_r_Op_A(d, m, regs)
}

val VMVN_i_Op_A : forall ('d : Int) ('regs : Int).
  (int('d), bits(64), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VMVN_i_Op_A (d, imm64, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            D(d + r) = ~(imm64)
        }
    }
}

val VMVN_i_T3A3_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMVN_i_T3A3_A_decode (i, D, imm3, Vd, cmode, Q, imm4) = {
    __unconditional = false;
    if [cmode[0]] == 0b1 & slice(cmode, 2, 2) != 0b11 | slice(cmode, 1, 3) == 0b111 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let imm64 = AdvSIMDExpandImm(0b1, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMVN_i_Op_A(d, imm64, regs)
}

val VMVN_i_T2A2_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMVN_i_T2A2_A_decode (i, D, imm3, Vd, cmode, Q, imm4) = {
    __unconditional = false;
    if [cmode[0]] == 0b1 & slice(cmode, 2, 2) != 0b11 | slice(cmode, 1, 3) == 0b111 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let imm64 = AdvSIMDExpandImm(0b1, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMVN_i_Op_A(d, imm64, regs)
}

val VMVN_i_T1A1_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMVN_i_T1A1_A_decode (i, D, imm3, Vd, cmode, Q, imm4) = {
    __unconditional = false;
    if [cmode[0]] == 0b1 & slice(cmode, 2, 2) != 0b11 | slice(cmode, 1, 3) == 0b111 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let imm64 = AdvSIMDExpandImm(0b1, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMVN_i_Op_A(d, imm64, regs)
}

val VMUL_s_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'index ('long_destination : Bool) 'm 'n 'regs ('unsigned : Bool),
  ('m >= 0 & 'm <= 31 & 'index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('elements), int('esize), bool('floating_point), int('index), bool('long_destination), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_s_Op_A (d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op1val : int = undefined : int;
        op2 : bits('esize) = undefined : bits('esize);
        op2val : int = undefined : int;
        CheckAdvSIMDEnabled();
        op2 = aget_Elem(Din(m), index, esize);
        op2val = asl_Int(op2, unsigned);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 64)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(Din(n + r), e, esize);
                op1val = asl_Int(op1, unsigned);
                if floating_point then {
                    assert(d + r >= 0 & d + r <= 31 | ~(floating_point));
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPMul(op1, op2, StandardFPSCRValue()))
                } else {
                    if long_destination then {
                        Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, __GetSlice_int(2 * esize, op1val * op2val, 0))
                    } else {
                        assert(d + r >= 0 & d + r <= 31);
                        D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, op1val * op2val, 0))
                    }
                }
            }
        }
    }
}

val VMUL_s_T2A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_s_T2A2_A_decode (U, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let unsigned : bool = U == 0b1;
    let long_destination : bool(true) = true;
    let floating_point : bool(false) = false;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : int(1) = 1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let m = m;
    let esize = esize;
    let index = index;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= d & d <= 31);
    VMUL_s_Op_A(d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned)
}

val VMUL_s_T1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_s_T1_A_decode (Q, D, size, Vn, Vd, F, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if size == 0b00 | (F == 0b1 & size == 0b01) & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned : bool(false) = false;
    let floating_point : bool = F == 0b1;
    let long_destination : bool(false) = false;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let m = m;
    let esize = esize;
    let index = index;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= d & d <= 31);
    VMUL_s_Op_A(d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned)
}

val VMUL_s_A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_s_A1_A_decode (Q, D, size, Vn, Vd, F, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | (F == 0b1 & size == 0b01) & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned : bool(false) = false;
    let floating_point : bool = F == 0b1;
    let long_destination : bool(false) = false;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let m = m;
    let esize = esize;
    let index = index;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= d & d <= 31);
    VMUL_s_Op_A(d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned)
}

val VMUL_i_Op_A : forall 'd 'elements 'esize ('long_destination : Bool) 'm 'n ('polynomial : Bool) 'regs ('unsigned : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('elements), int('esize), bool('long_destination), int('m), int('n), bool('polynomial), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_i_Op_A (d, elements, esize, long_destination, m, n, polynomial, regs, unsigned) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op1val : int = undefined : int;
        op2 : bits('esize) = undefined : bits('esize);
        op2val : int = undefined : int;
        product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(Din(n + r), e, esize);
                op1val = asl_Int(op1, unsigned);
                op2 = aget_Elem(Din(m + r), e, esize);
                op2val = asl_Int(op2, unsigned);
                if polynomial then {
                    product = PolynomialMult(op1, op2)
                } else {
                    product = __GetSlice_int(2 * esize, op1val * op2val, 0)
                };
                if long_destination then {
                    Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, product)
                } else {
                    assert(d + r >= 0 & d + r <= 31);
                    D(d + r) = aset_Elem(D(d + r), e, esize, slice(product, 0, esize))
                }
            }
        }
    }
}

val VMUL_i_T2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_i_T2_A_decode (U, D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    let unsigned = U == 0b1;
    let polynomial = op == 0b1;
    let long_destination = true;
    esize : int = undefined : int;
    esize = shl_int(8, UInt(size));
    elements : int = undefined : int;
    elements = 64 / esize;
    if polynomial then {
        if U == 0b1 | size == 0b01 then {
            throw(Error_Undefined())
        };
        if size == 0b10 then {
            if InITBlock() then {
                throw(Error_Unpredictable())
            };
            if ~(HaveBit128PMULLExt()) then {
                throw(Error_Undefined())
            };
            esize = 64;
            elements = 1
        }
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = 1;
    __PostDecode();
    VMUL_i_Op_A(d, elements, esize, long_destination, m, n, polynomial, regs, unsigned)
}

val VMUL_i_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_i_T1A1_A_decode (op, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 | op == 0b1 & size != 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = false;
    let polynomial = op == 0b1;
    let long_destination = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMUL_i_Op_A(d, elements, esize, long_destination, m, n, polynomial, regs, unsigned)
}

val VMUL_i_A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMUL_i_A2_A_decode (U, D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    let unsigned = U == 0b1;
    let polynomial = op == 0b1;
    let long_destination = true;
    esize : int = undefined : int;
    esize = shl_int(8, UInt(size));
    elements : int = undefined : int;
    elements = 64 / esize;
    if polynomial then {
        if U == 0b1 | size == 0b01 then {
            throw(Error_Undefined())
        };
        if size == 0b10 then {
            if ~(HaveBit128PMULLExt()) then {
                throw(Error_Undefined())
            };
            esize = 64;
            elements = 1
        }
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = 1;
    __PostDecode();
    VMUL_i_Op_A(d, elements, esize, long_destination, m, n, polynomial, regs, unsigned)
}

val VMOVN_Op_A : forall 'd 'elements 'esize 'm,
  ('d >= 0 & 'd <= 31 & 'm >= 0 & 'm <= 31 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VMOVN_Op_A (d, elements, esize, m) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & 2 * esize >= 0 & (e + 1) * (2 * esize) <= 128);
            D(d) = aset_Elem(D(d), e, esize, slice(aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize), 0, esize))
        }
    }
}

val VMOVN_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMOVN_T1A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    VMOVN_Op_A(d, elements, esize, m)
}

val VMOVL_Op_A : forall 'd 'elements 'esize 'm ('unsigned : Bool),
  ('m >= 0 & 'm <= 31 & 0 <= 'd & 'd <= 31 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VMOVL_Op_A (d, elements, esize, m, unsigned) = {
    if ConditionPassed() then {
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & (e + 1) * esize <= 64);
            result = asl_Int(aget_Elem(Din(m), e, esize), unsigned);
            Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, __GetSlice_int(2 * esize, result, 0))
        }
    }
}

val VMOVL_T1A1_A_decode__0 : (bits(1), bits(1), bits(3), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMOVL_T1A1_A_decode__1 : (bits(1), bits(1), bits(3), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMOVL_T1A1_A_decode = {VMOVL_T1A1_A_decode__0, VMOVL_T1A1_A_decode__1}

function VMOVL_T1A1_A_decode__0 (U, D, imm3H, Vd, M, Vm) = {
    __unconditional = false;
    if imm3H == 0b000 then {
        throw(Error_See("Related encodings"))
    };
    if (imm3H != 0b001 & imm3H != 0b010) & imm3H != 0b100 then {
        throw(Error_See("VSHLL"))
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = 8 * UInt(imm3H);
    let unsigned = U == 0b1;
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    VMOVL_Op_A(d, elements, esize, m, unsigned)
}

function VMOVL_T1A1_A_decode__1 (U, D, imm3H, Vd, L, M, Vm) = {
    __unconditional = false;
    if imm3H == 0b000 then {
        throw(Error_See("Related encodings"))
    };
    if (imm3H != 0b001 & imm3H != 0b010) & imm3H != 0b100 then {
        throw(Error_See("VSHLL"))
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = 8 * UInt(imm3H);
    let unsigned = U == 0b1;
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    VMOVL_Op_A(d, elements, esize, m, unsigned)
}

val VMLA_s_Op_A : forall ('add : Bool) 'd 'elements 'esize ('floating_point : Bool) 'index ('long_destination : Bool) 'm 'n 'regs ('unsigned : Bool),
  ('m >= 0 & 'm <= 31 & 'index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 64 & 0 <= 'd & 'd <= 31).
  (bool('add), int('d), int('elements), int('esize), bool('floating_point), int('index), bool('long_destination), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_s_Op_A (add, d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        addend : int = undefined : int;
        fp_addend : bits('esize) = undefined : bits('esize);
        op1 : bits('esize) = undefined : bits('esize);
        op1val : int = undefined : int;
        op2 : bits('esize) = undefined : bits('esize);
        op2val : int = undefined : int;
        CheckAdvSIMDEnabled();
        op2 = aget_Elem(Din(m), index, esize);
        op2val = asl_Int(op2, unsigned);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 64)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(Din(n + r), e, esize);
                op1val = asl_Int(op1, unsigned);
                if floating_point then {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('floating_point))));
                    fp_addend = if add then FPMul(op1, op2, StandardFPSCRValue()) else FPNeg(FPMul(op1, op2, StandardFPSCRValue()));
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPAdd(aget_Elem(Din(d + r), e, esize), fp_addend, StandardFPSCRValue()))
                } else {
                    addend = if add then op1val * op2val else negate(op1val) * op2val;
                    if long_destination then {
                        Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, aget_Elem(Qin(shr_int(d, 1)), e, 2 * esize) + addend)
                    } else {
                        assert(d + r >= 0 & d + r <= 31);
                        D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(Din(d + r), e, esize) + addend)
                    }
                }
            }
        }
    }
}

val VMLA_s_T2A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_s_T2A2_A_decode (U, D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let unsigned : bool = U == 0b1;
    let add : bool = op == 0b0;
    let floating_point : bool(false) = false;
    let long_destination : bool(true) = true;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : int(1) = 1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let m = m;
    let index = index;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= d & d <= 31);
    VMLA_s_Op_A(add, d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned)
}

val VMLA_s_T1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_s_T1_A_decode (Q, D, size, Vn, Vd, op, F, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | (F == 0b1 & size == 0b01) & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned : bool(false) = false;
    let add : bool = op == 0b0;
    let floating_point : bool = F == 0b1;
    let long_destination : bool(false) = false;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= d & d <= 31);
    VMLA_s_Op_A(add, d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned)
}

val VMLA_s_A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_s_A1_A_decode (Q, D, size, Vn, Vd, op, F, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if size == 0b00 | (F == 0b1 & size == 0b01) & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned : bool(false) = false;
    let add : bool = op == 0b0;
    let floating_point : bool = F == 0b1;
    let long_destination : bool(false) = false;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    m : int = undefined : int;
    if size == 0b01 then {
        esize = 16;
        elements = 4;
        m = UInt(slice(Vm, 0, 3));
        index = UInt(M @ [Vm[3]])
    };
    if size == 0b10 then {
        esize = 32;
        elements = 2;
        m = UInt(Vm);
        index = UInt(M)
    };
    __PostDecode();
    let esize = esize;
    let index = index;
    let m = m;
    assert(m >= 0 & m <= 31 & index >= 0 & esize >= 0 & (index + 1) * esize <= 64 & 0 <= d & d <= 31);
    VMLA_s_Op_A(add, d, elements, esize, floating_point, index, long_destination, m, n, regs, unsigned)
}

val VMLA_i_Op_A : forall ('add : Bool) 'd 'elements 'esize ('long_destination : Bool) 'm 'n 'regs ('unsigned : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (bool('add), int('d), int('elements), int('esize), bool('long_destination), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_i_Op_A (add, d, elements, esize, long_destination, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        addend : int = undefined : int;
        product : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                product = asl_Int(aget_Elem(Din(n + r), e, esize), unsigned) * asl_Int(aget_Elem(Din(m + r), e, esize), unsigned);
                addend = if add then product else negate(product);
                if long_destination then {
                    Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, aget_Elem(Qin(shr_int(d, 1)), e, 2 * esize) + addend)
                } else {
                    assert(d + r >= 0 & d + r <= 31);
                    D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(Din(d + r), e, esize) + addend)
                }
            }
        }
    }
}

val VMLA_i_T2A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_i_T2A2_A_decode (U, D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let add = op == 0b0;
    let long_destination = true;
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = 1;
    __PostDecode();
    VMLA_i_Op_A(add, d, elements, esize, long_destination, m, n, regs, unsigned)
}

val VMLA_i_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMLA_i_T1A1_A_decode (op, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let add = op == 0b0;
    let long_destination = false;
    let unsigned = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMLA_i_Op_A(add, d, elements, esize, long_destination, m, n, regs, unsigned)
}

val VMAX_i_Op_A : forall 'd 'elements 'esize 'm ('maximum : Bool) 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), bool('maximum), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VMAX_i_Op_A (d, elements, esize, m, maximum, n, regs, unsigned) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = asl_Int(aget_Elem(D(n + r), e, esize), unsigned);
                op2 = asl_Int(aget_Elem(D(m + r), e, esize), unsigned);
                result = if maximum then max(op1, op2) else min(op1, op2);
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 0))
            }
        }
    }
}

val VMAX_i_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMAX_i_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, op, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let maximum = op == 0b0;
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VMAX_i_Op_A(d, elements, esize, m, maximum, n, regs, unsigned)
}

val VMAX_f_Op_A : forall 'd 'elements 'esize 'm ('maximum : Bool) 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), bool('maximum), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VMAX_f_Op_A (d, elements, esize, m, maximum, n, regs) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(D(n + r), e, esize);
                op2 = aget_Elem(D(m + r), e, esize);
                if maximum then {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('maximum))));
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPMax(op1, op2, StandardFPSCRValue()))
                } else {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('maximum)))));
                    D(d + r) = aset_Elem(D(d + r), e, esize, FPMin(op1, op2, StandardFPSCRValue()))
                }
            }
        }
    }
}

val VMAX_f_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMAX_f_T1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let maximum = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VMAX_f_Op_A(d, elements, esize, m, maximum, n, regs)
}

val VMAX_f_A1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VMAX_f_A1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let maximum = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VMAX_f_Op_A(d, elements, esize, m, maximum, n, regs)
}

val VHADD_Op_A : forall ('add : Bool) 'd 'elements 'esize 'm 'n 'regs ('unsigned : Bool),
  'esize >= 0.
  (bool('add), int('d), int('elements), int('esize), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VHADD_Op_A (add, d, elements, esize, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        op2 : int = undefined : int;
        result : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = asl_Int(aget_Elem(D(n + r), e, esize), unsigned);
                op2 = asl_Int(aget_Elem(D(m + r), e, esize), unsigned);
                result = if add then op1 + op2 else op1 - op2;
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, result, 1))
            }
        }
    }
}

val VHADD_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VHADD_T1A1_A_decode (U, D, size, Vn, Vd, op, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let add = op == 0b0;
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VHADD_Op_A(add, d, elements, esize, m, n, regs, unsigned)
}

val VFMAL_i_Op_A : forall 'd 'datasize 'esize 'index 'm 'n 'regs ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('m >= 0 & 'm <= 31) & div('esize, 2) >= 0.
  (bits(1), int('d), int('datasize), int('esize), int('index), int('m), int('n), int('regs), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function VFMAL_i_Op_A (Q, d, datasize, esize, index, m, n, regs, sub_op) = {
    CheckAdvSIMDEnabled();
    operand1 : bits('datasize) = undefined : bits('datasize);
    operand2 : bits('datasize) = undefined : bits('datasize);
    operand3 : bits(64) = undefined : bits(64);
    result : bits(64) = undefined : bits(64);
    element1 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    element2 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    if Q == 0b0 then {
        operand1 = slice(S(n), 0, datasize);
        operand2 = slice(S(m), 0, datasize)
    } else {
        operand1 = slice(D(n), 0, datasize);
        operand2 = slice(D(m), 0, datasize)
    };
    let element2 = aget_Elem(operand2, index, esize / 2);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
        operand3 = D(d + r);
        foreach (e from 0 to 1 by 1 in inc) {
            element1 = aget_Elem(operand1, 2 * r + e, esize / 2);
            if sub_op then {
                element1 = FPNeg(element1)
            };
            result = aset_Elem(result, e, esize, FPMulAddH(aget_Elem(operand3, e, esize), element1, element2, StandardFPSCRValue()))
        };
        D(d + r) = result
    }
}

val VFMAL_i_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFMAL_i_T1_A_decode (D, S, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(D @ Vd);
    let 'n = if Q == 0b1 then UInt(N @ Vn) else UInt(Vn @ N);
    let 'm = if Q == 0b1 then UInt(slice(Vm, 0, 3)) else UInt(slice(Vm, 0, 3) @ M);
    let 'index = if Q == 0b1 then UInt(M @ [Vm[3]]) else UInt([Vm[3]]);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    let 'datasize = if Q == 0b1 then 64 else 32;
    let sub_op = S == 0b1;
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint('_datasize >= 0));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    VFMAL_i_Op_A(Q, d, datasize, esize, index, m, n, regs, sub_op)
}

val VFMAL_i_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFMAL_i_A1_A_decode (D, S, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(D @ Vd);
    let 'n = if Q == 0b1 then UInt(N @ Vn) else UInt(Vn @ N);
    let 'm = if Q == 0b1 then UInt(slice(Vm, 0, 3)) else UInt(slice(Vm, 0, 3) @ M);
    let 'index = if Q == 0b1 then UInt(M @ [Vm[3]]) else UInt([Vm[3]]);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    let 'datasize = if Q == 0b1 then 64 else 32;
    let sub_op = S == 0b1;
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint('_datasize >= 0));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    VFMAL_i_Op_A(Q, d, datasize, esize, index, m, n, regs, sub_op)
}

val VFMAL_Op_A : forall 'd 'datasize 'esize 'm 'n 'regs ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('m >= 0 & 'm <= 31) & div('esize, 2) >= 0.
  (bits(1), int('d), int('datasize), int('esize), int('m), int('n), int('regs), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function VFMAL_Op_A (Q, d, datasize, esize, m, n, regs, sub_op) = {
    CheckAdvSIMDEnabled();
    operand1 : bits('datasize) = undefined : bits('datasize);
    operand2 : bits('datasize) = undefined : bits('datasize);
    operand3 : bits(64) = undefined : bits(64);
    result : bits(64) = undefined : bits(64);
    element1 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    element2 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    if Q == 0b0 then {
        operand1 = slice(S(n), 0, datasize);
        operand2 = slice(S(m), 0, datasize)
    } else {
        operand1 = slice(D(n), 0, datasize);
        operand2 = slice(D(m), 0, datasize)
    };
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
        operand3 = D(d + r);
        foreach (e from 0 to 1 by 1 in inc) {
            element1 = aget_Elem(operand1, 2 * r + e, esize / 2);
            element2 = aget_Elem(operand2, 2 * r + e, esize / 2);
            if sub_op then {
                element1 = FPNeg(element1)
            };
            result = aset_Elem(result, e, esize, FPMulAddH(aget_Elem(operand3, e, esize), element1, element2, StandardFPSCRValue()))
        };
        D(d + r) = result
    }
}

val VFMAL_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFMAL_T1_A_decode (S, D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(D @ Vd);
    let 'n = if Q == 0b1 then UInt(N @ Vn) else UInt(Vn @ N);
    let 'm = if Q == 0b1 then UInt(M @ Vm) else UInt(Vm @ M);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    let 'datasize = if Q == 0b1 then 64 else 32;
    let sub_op = S == 0b1;
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint('_datasize >= 0));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    VFMAL_Op_A(Q, d, datasize, esize, m, n, regs, sub_op)
}

val VFMAL_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VFMAL_A1_A_decode (S, D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'd = UInt(D @ Vd);
    let 'n = if Q == 0b1 then UInt(N @ Vn) else UInt(Vn @ N);
    let 'm = if Q == 0b1 then UInt(M @ Vm) else UInt(Vm @ M);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    let 'datasize = if Q == 0b1 then 64 else 32;
    let sub_op = S == 0b1;
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint('_datasize >= 0));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    VFMAL_Op_A(Q, d, datasize, esize, m, n, regs, sub_op)
}

val VEXT_Op_A : forall 'd 'm 'n 'position ('quadword_operation : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n), int('position), bool('quadword_operation)) -> unit effect {escape, rreg, undef, wreg}

function VEXT_Op_A (d, m, n, position, quadword_operation) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        if quadword_operation then {
            Q(shr_int(d, 1)) = slice(Q(shr_int(m, 1)) @ Q(shr_int(n, 1)), position, 128)
        } else {
            D(d) = slice(D(m) @ D(n), position, 64)
        }
    }
}

val VEXT_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VEXT_T1A1_A_decode (D, Vn, Vd, imm4, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if Q == 0b0 & [imm4[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let quadword_operation = Q == 0b1;
    let position = 8 * UInt(imm4);
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VEXT_Op_A(d, m, n, position, quadword_operation)
}

val VEOR_Op_A : forall ('d : Int) ('m : Int) ('n : Int) ('regs : Int).
  (int('d), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VEOR_Op_A (d, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
            D(d + r) = D(n + r) ^ D(m + r)
        }
    }
}

val VEOR_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VEOR_T1A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VEOR_Op_A(d, m, n, regs)
}

val VDUP_s_Op_A : forall 'd 'elements 'esize 'index 'm 'regs,
  ('m >= 0 & 'm <= 31 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('index), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VDUP_s_Op_A (d, elements, esize, index, m, regs) = {
    if ConditionPassed() then {
        scalar : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        scalar = aget_Elem(D(m), index, esize);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, scalar)
            }
        }
    }
}

val VDUP_s_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VDUP_s_T1A1_A_decode (D, imm4, Vd, Q, M, Vm) = {
    __unconditional = false;
    if (imm4 & 0x7) == 0x0 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    index : int = undefined : int;
    match imm4 {
      _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ [bitone] => {
          esize = 8;
          elements = 8;
          index = UInt(slice(imm4, 1, 3))
      },
      _ : bits(1) @ _ : bits(1) @ [bitone] @ [bitzero] => {
          esize = 16;
          elements = 4;
          index = UInt(slice(imm4, 2, 2))
      },
      _ : bits(1) @ [bitone] @ [bitzero] @ [bitzero] => {
          esize = 32;
          elements = 2;
          index = UInt([imm4[3]])
      }
    };
    let index = index;
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint(('_m >= 0 & '_m <= 31 & '_esize >= 0)));
    __PostDecode();
    VDUP_s_Op_A(d, elements, esize, index, m, regs)
}

val VDUP_r_Op_A : forall 'd 'elements 'esize 'regs 't,
  ('t >= 0 & 't <= 15) & 'esize >= 0.
  (int('d), int('elements), int('esize), int('regs), int('t)) -> unit effect {escape, rreg, undef, wreg}

function VDUP_r_Op_A (d, elements, esize, regs, t) = {
    if ConditionPassed() then {
        scalar : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        scalar = slice(R(t), 0, esize);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, scalar)
            }
        }
    }
}

val VDUP_r_T1A1_A_decode__0 : (bits(4), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

val VDUP_r_T1A1_A_decode__1 : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

overload VDUP_r_T1A1_A_decode = {
  VDUP_r_T1A1_A_decode__0,
  VDUP_r_T1A1_A_decode__1
}

function VDUP_r_T1A1_A_decode__0 (cond, B, Q, Vd, Rt, D, E) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let t = UInt(Rt);
    let regs = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match B @ E {
      0b00 => {
          esize = 32;
          elements = 2
      },
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 8;
          elements = 8
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let esize = esize;
    let elements = elements;
    assert(constraint('_esize >= 0));
    assert(constraint(('_t >= 0 & '_t <= 15)));
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VDUP_r_Op_A(d, elements, esize, regs, t)
}

function VDUP_r_T1A1_A_decode__1 (B, Q, Vd, Rt, D, E) = {
    __unconditional = false;
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let t = UInt(Rt);
    let regs = if Q == 0b0 then 1 else 2;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match B @ E {
      0b00 => {
          esize = 32;
          elements = 2
      },
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 8;
          elements = 8
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let esize = esize;
    let elements = elements;
    assert(constraint('_esize >= 0));
    assert(constraint(('_t >= 0 & '_t <= 15)));
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VDUP_r_Op_A(d, elements, esize, regs, t)
}

val VDOT_s_Op_A : forall 'd 'esize 'index 'm 'n 'regs ('signed : Bool),
  ('m >= 0 & 'm <= 31) & (div('esize, 4) >= 0 | not('signed)) & (div('esize, 4) >= 0 | not(not('signed))).
  (int('d), int('esize), int('index), int('m), int('n), int('regs), bool('signed)) -> unit effect {escape, rreg, undef, wreg}

function VDOT_s_Op_A (d, esize, index, m, n, regs, signed) = {
    operand1 : bits(64) = undefined : bits(64);
    let operand2 : bits(64) = D(m);
    result : bits(64) = undefined : bits(64);
    CheckAdvSIMDEnabled();
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
        assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
        operand1 = D(n + r);
        result = D(d + r);
        element1 : int = undefined : int;
        element2 : int = undefined : int;
        foreach (e from 0 to 1 by 1 in inc) {
            res : int = 0;
            foreach (i from 0 to 3 by 1 in inc) {
                if signed then {
                    element1 = SInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                    element2 = SInt(aget_Elem(operand2, 4 * index + i, esize / 4))
                } else {
                    element1 = UInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                    element2 = UInt(aget_Elem(operand2, 4 * index + i, esize / 4))
                };
                res = res + element1 * element2
            };
            result = aset_Elem(result, e, esize, aget_Elem(result, e, esize) + res)
        };
        D(d + r) = result
    }
}

val VDOT_s_T1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VDOT_s_T1_A_decode (op1, D, op2, Vn, Vd, N, Q, M, U, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let signed = U == 0b0;
    let 'd = UInt(D @ Vd);
    let 'n = UInt(N @ Vn);
    let 'm = UInt(slice(Vm, 0, 4));
    let 'index = UInt(M);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    __PostDecode();
    VDOT_s_Op_A(d, esize, index, m, n, regs, signed)
}

val VDOT_s_A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VDOT_s_A1_A_decode (op1, D, op2, Vn, Vd, N, Q, M, U, Vm) = {
    __unconditional = true;
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let signed = U == 0b0;
    let 'd = UInt(D @ Vd);
    let 'n = UInt(N @ Vn);
    let 'm = UInt(slice(Vm, 0, 4));
    let 'index = UInt(M);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    __PostDecode();
    VDOT_s_Op_A(d, esize, index, m, n, regs, signed)
}

val VDOT_Op_A : forall 'd 'esize 'm 'n 'regs ('signed : Bool),
  (div('esize, 4) >= 0 | not('signed)) & (div('esize, 4) >= 0 | not(not('signed))).
  (int('d), int('esize), int('m), int('n), int('regs), bool('signed)) -> unit effect {escape, rreg, undef, wreg}

function VDOT_Op_A (d, esize, m, n, regs, signed) = {
    operand1 : bits(64) = undefined : bits(64);
    operand2 : bits(64) = undefined : bits(64);
    result : bits(64) = undefined : bits(64);
    CheckAdvSIMDEnabled();
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
        assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
        assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
        operand1 = D(n + r);
        operand2 = D(m + r);
        result = D(d + r);
        element1 : int = undefined : int;
        element2 : int = undefined : int;
        foreach (e from 0 to 1 by 1 in inc) {
            res : int = 0;
            foreach (i from 0 to 3 by 1 in inc) {
                if signed then {
                    element1 = SInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                    element2 = SInt(aget_Elem(operand2, 4 * e + i, esize / 4))
                } else {
                    element1 = UInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                    element2 = UInt(aget_Elem(operand2, 4 * e + i, esize / 4))
                };
                res = res + element1 * element2
            };
            result = aset_Elem(result, e, esize, aget_Elem(result, e, esize) + res)
        };
        D(d + r) = result
    }
}

val VDOT_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VDOT_T1_A_decode (D, Vn, Vd, N, Q, M, U, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let signed = U == 0b0;
    let 'd = UInt(D @ Vd);
    let 'n = UInt(N @ Vn);
    let 'm = UInt(M @ Vm);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    __PostDecode();
    VDOT_Op_A(d, esize, m, n, regs, signed)
}

val VDOT_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VDOT_A1_A_decode (D, Vn, Vd, N, Q, M, U, Vm) = {
    __unconditional = true;
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let signed = U == 0b0;
    let 'd = UInt(D @ Vd);
    let 'n = UInt(N @ Vn);
    let 'm = UInt(M @ Vm);
    let 'esize = 32;
    let 'regs = if Q == 0b1 then 2 else 1;
    __PostDecode();
    VDOT_Op_A(d, esize, m, n, regs, signed)
}

val VCVT_xs_Op_A : forall 'd 'elements 'esize 'frac_bits 'm 'regs ('to_fixed : Bool) ('unsigned : Bool),
  'esize >= 0 & ('frac_bits >= 0 | not('to_fixed)).
  (int('d), int('elements), int('esize), int('frac_bits), int('m), int('regs), bool('to_fixed), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_xs_Op_A (d, elements, esize, frac_bits, m, regs, to_fixed, unsigned) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        result : bits('esize) = undefined : bits('esize);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                op1 = aget_Elem(D(m + r), e, esize);
                if to_fixed then {
                    result = FPToFixed(op1, frac_bits, unsigned, StandardFPSCRValue(), FPRounding_ZERO)
                } else {
                    result = FixedToFP(op1, frac_bits, unsigned, StandardFPSCRValue(), FPRounding_TIEEVEN)
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, result)
            }
        }
    }
}

val VCVT_xs_T1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_xs_T1_A_decode (U, D, imm6, Vd, op, Q, M, Vm) = {
    __unconditional = false;
    if (imm6 & 0b111000) == 0b000000 then {
        throw(Error_See("Related encodings"))
    };
    if [op[1]] == 0b0 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if [op[1]] == 0b0 & (imm6 & 0b110000) == 0b100000 then {
        throw(Error_Undefined())
    };
    if (imm6 & 0b100000) == 0b000000 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let to_fixed = [op[0]] == 0b1;
    let frac_bits : {'n, (0 <= 'n & 'n <= 2 ^ 6 - 1). int(64 - 'n)} = 64 - UInt(imm6);
    let unsigned = U == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match [op[1]] {
      0b0 => {
          esize = 16;
          elements = 4
      },
      0b1 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    __PostDecode();
    assert(esize >= 0);
    VCVT_xs_Op_A(d, elements, esize, frac_bits, m, regs, to_fixed, unsigned)
}

val VCVT_xs_A1_A_decode : (bits(1), bits(1), bits(6), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_xs_A1_A_decode (U, D, imm6, Vd, op, Q, M, Vm) = {
    __unconditional = false;
    if (imm6 & 0b111000) == 0b000000 then {
        throw(Error_See("Related encodings"))
    };
    if [op[1]] == 0b0 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if [op[1]] == 0b0 & (imm6 & 0b110000) == 0b100000 then {
        throw(Error_Undefined())
    };
    if (imm6 & 0b100000) == 0b000000 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let to_fixed : bool = [op[0]] == 0b1;
    let frac_bits : {'n, (0 <= 'n & 'n <= 2 ^ 6 - 1). int(64 - 'n)} = 64 - UInt(imm6);
    let unsigned : bool = U == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match [op[1]] {
      0b0 => {
          esize = 16;
          elements = 4
      },
      0b1 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs : {|1, 2|} = if Q == 0b0 then 1 else 2;
    __PostDecode();
    assert(esize >= 0);
    VCVT_xs_Op_A(d, elements, esize, frac_bits, m, regs, to_fixed, unsigned)
}

val VCVT_is_Op_A : forall 'd 'elements 'esize 'm 'regs ('to_integer : Bool) ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), bool('to_integer), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_is_Op_A (d, elements, esize, m, regs, to_integer, unsigned) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        result : bits('esize) = undefined : bits('esize);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                op1 = aget_Elem(D(m + r), e, esize);
                if to_integer then {
                    result = FPToFixed(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_ZERO)
                } else {
                    result = FixedToFP(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_TIEEVEN)
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, result)
            }
        }
    }
}

val VCVT_is_T1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_is_T1_A_decode (D, size, Vd, op, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let to_integer = [op[1]] == 0b1;
    let unsigned = [op[0]] == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCVT_is_Op_A(d, elements, esize, m, regs, to_integer, unsigned)
}

val VCVT_is_A1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_is_A1_A_decode (D, size, Vd, op, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let to_integer = [op[1]] == 0b1;
    let unsigned = [op[0]] == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCVT_is_Op_A(d, elements, esize, m, regs, to_integer, unsigned)
}

val VCVT_hs_Op_A : forall 'd 'elements ('half_to_single : Bool) 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('elements), bool('half_to_single), int('m)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_hs_Op_A (d, elements, half_to_single, m) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            if half_to_single then {
                assert(e >= 0 & 16 >= 0 & (e + 1) * 16 <= 64);
                Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 32, FPConvert(aget_Elem(Din(m), e, 16), StandardFPSCRValue()))
            } else {
                assert(e >= 0 & 32 >= 0 & (e + 1) * 32 <= 128);
                D(d) = aset_Elem(D(d), e, 16, FPConvert(aget_Elem(Qin(shr_int(m, 1)), e, 32), StandardFPSCRValue()))
            }
        }
    }
}

val VCVT_hs_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVT_hs_T1A1_A_decode (D, size, Vd, op, M, Vm) = {
    __unconditional = false;
    if size != 0b01 then {
        throw(Error_Undefined())
    };
    let half_to_single = op == 0b1;
    if half_to_single & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    if ~(half_to_single) & [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = 16;
    let elements = 4;
    let m = UInt(M @ Vm);
    let d = UInt(D @ Vd);
    __PostDecode();
    VCVT_hs_Op_A(d, elements, half_to_single, m)
}

val VCVTA_asimd_Op_A : forall 'd 'elements 'esize 'm 'regs ('unsigned : Bool),
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs), FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VCVTA_asimd_Op_A (d, elements, esize, m, regs, rounding, unsigned) = {
    CheckAdvSIMDEnabled();
    let result = undefined : bits('esize);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            D(d + r) = aset_Elem(D(d + r), e, esize, FPToFixed(aget_Elem(D(m + r), e, esize), 0, unsigned, StandardFPSCRValue(), rounding))
        }
    }
}

val VCVTA_asimd_T1_A_decode : (bits(1), bits(2), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVTA_asimd_T1_A_decode (D, size, Vd, RM, op, Q, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPDecodeRM(RM);
    let unsigned = op == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCVTA_asimd_Op_A(d, elements, esize, m, regs, rounding, unsigned)
}

val VCVTA_asimd_A1_A_decode : (bits(1), bits(2), bits(2), bits(4), bits(2), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCVTA_asimd_A1_A_decode (D, size, OP, Vd, RM, op, Q, M, Vm) = {
    __unconditional = true;
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & ~(HaveFP16Ext()) | size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let rounding = FPDecodeRM(RM);
    let unsigned = op == 0b1;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match size {
      0b01 => {
          esize = 16;
          elements = 4
      },
      0b10 => {
          esize = 32;
          elements = 2
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCVTA_asimd_Op_A(d, elements, esize, m, regs, rounding, unsigned)
}

val VCNT_Op_A : forall 'd 'elements 'esize 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCNT_Op_A (d, elements, esize, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, BitCount(aget_Elem(D(m + r), e, esize)), 0))
            }
        }
    }
}

val VCNT_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCNT_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = 8;
    let elements = 8;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCNT_Op_A(d, elements, esize, m, regs)
}

val VCMLA_idx_Op_A : forall 'd 'elements 'esize 'index 'm 'n 'regs,
  ('m >= 0 & 'm <= 31) & 'esize >= 0.
  (int('d), int('elements), int('esize), int('index), int('m), int('n), int('regs), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function VCMLA_idx_Op_A (d, elements, esize, index, m, n, regs, rot) = {
    CheckAdvSIMDEnabled();
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    element3 : bits('esize) = undefined : bits('esize);
    element4 : bits('esize) = undefined : bits('esize);
    operand1 : bits(64) = undefined : bits(64);
    operand2 : bits(64) = undefined : bits(64);
    operand3 : bits(64) = undefined : bits(64);
    result1 : bits('esize) = undefined : bits('esize);
    result2 : bits('esize) = undefined : bits('esize);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
        assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
        operand1 = D(n + r);
        operand2 = Din(m);
        operand3 = D(d + r);
        foreach (e from 0 to (elements / 2 - 1) by 1 in inc) {
            match rot {
              0b00 => {
                  element1 = aget_Elem(operand2, index * 2, esize);
                  element2 = aget_Elem(operand1, e * 2, esize);
                  element3 = aget_Elem(operand2, index * 2 + 1, esize);
                  element4 = aget_Elem(operand1, e * 2, esize)
              },
              0b01 => {
                  element1 = FPNeg(aget_Elem(operand2, index * 2 + 1, esize));
                  element2 = aget_Elem(operand1, e * 2 + 1, esize);
                  element3 = aget_Elem(operand2, index * 2, esize);
                  element4 = aget_Elem(operand1, e * 2 + 1, esize)
              },
              0b10 => {
                  element1 = FPNeg(aget_Elem(operand2, index * 2, esize));
                  element2 = aget_Elem(operand1, e * 2, esize);
                  element3 = FPNeg(aget_Elem(operand2, index * 2 + 1, esize));
                  element4 = aget_Elem(operand1, e * 2, esize)
              },
              0b11 => {
                  element1 = aget_Elem(operand2, index * 2 + 1, esize);
                  element2 = aget_Elem(operand1, e * 2 + 1, esize);
                  element3 = FPNeg(aget_Elem(operand2, index * 2, esize));
                  element4 = aget_Elem(operand1, e * 2 + 1, esize)
              }
            };
            result1 = FPMulAdd(aget_Elem(operand3, e * 2, esize), element2, element1, StandardFPSCRValue());
            result2 = FPMulAdd(aget_Elem(operand3, e * 2 + 1, esize), element4, element3, StandardFPSCRValue());
            D(d + r) = aset_Elem(D(d + r), e * 2, esize, result1);
            D(d + r) = aset_Elem(D(d + r), e * 2 + 1, esize, result2)
        }
    }
}

val VCMLA_idx_T1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCMLA_idx_T1_A_decode (S, D, rot, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = if S == 0b1 then UInt(M @ Vm) else UInt(Vm);
    let esize = shl_int(16, UInt(S));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let elements : int = 64 / esize;
    let regs = if Q == 0b0 then 1 else 2;
    let index = if S == 0b1 then 0 else UInt(M);
    assert(constraint('_esize >= 0));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    __PostDecode();
    VCMLA_idx_Op_A(d, elements, esize, index, m, n, regs, rot)
}

val VCMLA_idx_A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCMLA_idx_A1_A_decode (S, D, rot, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = if S == 0b1 then UInt(M @ Vm) else UInt(Vm);
    let esize = shl_int(16, UInt(S));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let elements : int = 64 / esize;
    let regs = if Q == 0b0 then 1 else 2;
    let index = if S == 0b1 then 0 else UInt(M);
    assert(constraint('_esize >= 0));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    __PostDecode();
    VCMLA_idx_Op_A(d, elements, esize, index, m, n, regs, rot)
}

val VCMLA_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function VCMLA_Op_A (d, elements, esize, m, n, regs, rot) = {
    CheckAdvSIMDEnabled();
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    element3 : bits('esize) = undefined : bits('esize);
    element4 : bits('esize) = undefined : bits('esize);
    operand1 : bits(64) = undefined : bits(64);
    operand2 : bits(64) = undefined : bits(64);
    operand3 : bits(64) = undefined : bits(64);
    result1 : bits('esize) = undefined : bits('esize);
    result2 : bits('esize) = undefined : bits('esize);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
        assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
        assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
        operand1 = D(n + r);
        operand2 = D(m + r);
        operand3 = D(d + r);
        foreach (e from 0 to (elements / 2 - 1) by 1 in inc) {
            match rot {
              0b00 => {
                  element1 = aget_Elem(operand2, e * 2, esize);
                  element2 = aget_Elem(operand1, e * 2, esize);
                  element3 = aget_Elem(operand2, e * 2 + 1, esize);
                  element4 = aget_Elem(operand1, e * 2, esize)
              },
              0b01 => {
                  element1 = FPNeg(aget_Elem(operand2, e * 2 + 1, esize));
                  element2 = aget_Elem(operand1, e * 2 + 1, esize);
                  element3 = aget_Elem(operand2, e * 2, esize);
                  element4 = aget_Elem(operand1, e * 2 + 1, esize)
              },
              0b10 => {
                  element1 = FPNeg(aget_Elem(operand2, e * 2, esize));
                  element2 = aget_Elem(operand1, e * 2, esize);
                  element3 = FPNeg(aget_Elem(operand2, e * 2 + 1, esize));
                  element4 = aget_Elem(operand1, e * 2, esize)
              },
              0b11 => {
                  element1 = aget_Elem(operand2, e * 2 + 1, esize);
                  element2 = aget_Elem(operand1, e * 2 + 1, esize);
                  element3 = FPNeg(aget_Elem(operand2, e * 2, esize));
                  element4 = aget_Elem(operand1, e * 2 + 1, esize)
              }
            };
            result1 = FPMulAdd(aget_Elem(operand3, e * 2, esize), element2, element1, StandardFPSCRValue());
            result2 = FPMulAdd(aget_Elem(operand3, e * 2 + 1, esize), element4, element3, StandardFPSCRValue());
            D(d + r) = aset_Elem(D(d + r), e * 2, esize, result1);
            D(d + r) = aset_Elem(D(d + r), e * 2 + 1, esize, result2)
        }
    }
}

val VCMLA_T1_A_decode : (bits(2), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCMLA_T1_A_decode (rot, D, S, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let esize = shl_int(16, UInt(S));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let elements : int = 64 / esize;
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCMLA_Op_A(d, elements, esize, m, n, regs, rot)
}

val VCMLA_A1_A_decode : (bits(2), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCMLA_A1_A_decode (rot, D, S, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let esize = shl_int(16, UInt(S));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let elements : int = 64 / esize;
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCMLA_Op_A(d, elements, esize, m, n, regs, rot)
}

val VCLZ_Op_A : forall 'd 'elements 'esize 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCLZ_Op_A (d, elements, esize, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, CountLeadingZeroBits(aget_Elem(D(m + r), e, esize)), 0))
            }
        }
    }
}

val VCLZ_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCLZ_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCLZ_Op_A(d, elements, esize, m, regs)
}

val VCLT_i_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCLT_i_Op_A (d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                if floating_point then {
                    let zero : bits('esize) = FPZero(0b0);
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point))));
                    test_passed = FPCompareGT(zero, aget_Elem(D(m + r), e, esize), StandardFPSCRValue())
                } else {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('floating_point)))));
                    test_passed = SInt(aget_Elem(D(m + r), e, esize)) < 0
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCLT_i_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCLT_i_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCLT_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCLT_i_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCLT_i_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCLT_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCLS_Op_A : forall 'd 'elements 'esize 'm 'regs,
  'esize >= 0 & 'esize >= 1.
  (int('d), int('elements), int('esize), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCLS_Op_A (d, elements, esize, m, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, CountLeadingSignBits(aget_Elem(D(m + r), e, esize)), 0))
            }
        }
    }
}

val VCLS_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCLS_T1A1_A_decode (D, size, Vd, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCLS_Op_A(d, elements, esize, m, regs)
}

val VCLE_i_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCLE_i_Op_A (d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                if floating_point then {
                    let zero : bits('esize) = FPZero(0b0);
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point))));
                    test_passed = FPCompareGE(zero, aget_Elem(D(m + r), e, esize), StandardFPSCRValue())
                } else {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('floating_point)))));
                    test_passed = SInt(aget_Elem(D(m + r), e, esize)) <= 0
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCLE_i_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCLE_i_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCLE_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCLE_i_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCLE_i_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCLE_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCGT_r_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), VCGTtype) -> unit effect {escape, rreg, undef, wreg}

function VCGT_r_Op_A (d, elements, esize, m, n, regs, typ) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(D(n + r), e, esize);
                op2 = aget_Elem(D(m + r), e, esize);
                match typ {
                  VCGTtype_signed => {
                      test_passed = SInt(op1) > SInt(op2)
                  },
                  VCGTtype_unsigned => {
                      test_passed = UInt(op1) > UInt(op2)
                  },
                  VCGTtype_fp => {
                      test_passed = FPCompareGT(op1, op2, StandardFPSCRValue())
                  }
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCGT_r_T2_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGT_r_T2_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let typ = VCGTtype_fp;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCGT_r_Op_A(d, elements, esize, m, n, regs, typ)
}

val VCGT_r_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGT_r_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let typ = if U == 0b1 then VCGTtype_unsigned else VCGTtype_signed;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCGT_r_Op_A(d, elements, esize, m, n, regs, typ)
}

val VCGT_r_A2_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGT_r_A2_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let typ = VCGTtype_fp;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCGT_r_Op_A(d, elements, esize, m, n, regs, typ)
}

val VCGT_i_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  ('esize >= 0 | not('floating_point)) & ('esize >= 0 | not(not('floating_point))).
  (int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCGT_i_Op_A (d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                if floating_point then {
                    let zero : bits('esize) = FPZero(0b0);
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point))));
                    test_passed = FPCompareGT(aget_Elem(D(m + r), e, esize), zero, StandardFPSCRValue())
                } else {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('floating_point)))));
                    test_passed = SInt(aget_Elem(D(m + r), e, esize)) > 0
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCGT_i_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGT_i_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCGT_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCGT_i_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGT_i_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCGT_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCGE_r_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), VCGEtype) -> unit effect {escape, rreg, undef, wreg}

function VCGE_r_Op_A (d, elements, esize, m, n, regs, typ) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(D(n + r), e, esize);
                op2 = aget_Elem(D(m + r), e, esize);
                match typ {
                  VCGEtype_signed => {
                      test_passed = SInt(op1) >= SInt(op2)
                  },
                  VCGEtype_unsigned => {
                      test_passed = UInt(op1) >= UInt(op2)
                  },
                  VCGEtype_fp => {
                      test_passed = FPCompareGE(op1, op2, StandardFPSCRValue())
                  }
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCGE_r_T2_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGE_r_T2_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let typ = VCGEtype_fp;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCGE_r_Op_A(d, elements, esize, m, n, regs, typ)
}

val VCGE_r_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGE_r_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let typ = if U == 0b1 then VCGEtype_unsigned else VCGEtype_signed;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCGE_r_Op_A(d, elements, esize, m, n, regs, typ)
}

val VCGE_r_A2_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGE_r_A2_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let typ = VCGEtype_fp;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCGE_r_Op_A(d, elements, esize, m, n, regs, typ)
}

val VCGE_i_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  ('esize >= 0 | not('floating_point)) & ('esize >= 0 | not(not('floating_point))).
  (int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCGE_i_Op_A (d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                if floating_point then {
                    let zero : bits('esize) = FPZero(0b0);
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point))));
                    test_passed = FPCompareGE(aget_Elem(D(m + r), e, esize), zero, StandardFPSCRValue())
                } else {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('floating_point)))));
                    test_passed = SInt(aget_Elem(D(m + r), e, esize)) >= 0
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCGE_i_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGE_i_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCGE_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCGE_i_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCGE_i_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCGE_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCEQ_r_Op_A : forall 'd 'elements 'esize ('int_operation : Bool) 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), bool('int_operation), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCEQ_r_Op_A (d, elements, esize, int_operation, m, n, regs) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(D(n + r), e, esize);
                op2 = aget_Elem(D(m + r), e, esize);
                if int_operation then {
                    test_passed = op1 == op2
                } else {
                    test_passed = FPCompareEQ(op1, op2, StandardFPSCRValue())
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCEQ_r_T2_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCEQ_r_T2_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let int_operation = false;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCEQ_r_Op_A(d, elements, esize, int_operation, m, n, regs)
}

val VCEQ_r_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCEQ_r_T1A1_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let int_operation = true;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCEQ_r_Op_A(d, elements, esize, int_operation, m, n, regs)
}

val VCEQ_r_A2_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCEQ_r_A2_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let int_operation = false;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCEQ_r_Op_A(d, elements, esize, int_operation, m, n, regs)
}

val VCEQ_i_Op_A : forall 'd 'elements 'esize ('floating_point : Bool) 'm 'regs,
  ('esize >= 0 | not('floating_point)) & ('esize >= 0 | not(not('floating_point))).
  (int('d), int('elements), int('esize), bool('floating_point), int('m), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VCEQ_i_Op_A (d, elements, esize, floating_point, m, regs) = {
    if ConditionPassed() then {
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                if floating_point then {
                    let zero : bits('esize) = FPZero(0b0);
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not('floating_point))));
                    test_passed = FPCompareEQ(aget_Elem(D(m + r), e, esize), zero, StandardFPSCRValue())
                } else {
                    assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31 | not(not('floating_point)))));
                    test_passed = aget_Elem(D(m + r), e, esize) == Zeros(esize)
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VCEQ_i_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCEQ_i_T1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if (F == 0b1 & size == 0b01) & InITBlock() then {
        throw(Error_Unpredictable())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCEQ_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCEQ_i_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCEQ_i_A1_A_decode (D, size, Vd, F, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if F == 0b1 & (size == 0b01 & ~(HaveFP16Ext()) | size == 0b00) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & ([Vd[0]] == 0b1 | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let floating_point = F == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VCEQ_i_Op_A(d, elements, esize, floating_point, m, regs)
}

val VCADD_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function VCADD_Op_A (d, elements, esize, m, n, regs, rot) = {
    CheckAdvSIMDEnabled();
    element1 : bits('esize) = undefined : bits('esize);
    element3 : bits('esize) = undefined : bits('esize);
    operand1 : bits(64) = undefined : bits(64);
    operand2 : bits(64) = undefined : bits(64);
    operand3 : bits(64) = undefined : bits(64);
    result1 : bits('esize) = undefined : bits('esize);
    result2 : bits('esize) = undefined : bits('esize);
    foreach (r from 0 to (regs - 1) by 1 in inc) {
        assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
        assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
        assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
        operand1 = D(n + r);
        operand2 = D(m + r);
        operand3 = D(d + r);
        foreach (e from 0 to (elements / 2 - 1) by 1 in inc) {
            match rot {
              0b0 => {
                  element1 = FPNeg(aget_Elem(operand2, e * 2 + 1, esize));
                  element3 = aget_Elem(operand2, e * 2, esize)
              },
              0b1 => {
                  element1 = aget_Elem(operand2, e * 2 + 1, esize);
                  element3 = FPNeg(aget_Elem(operand2, e * 2, esize))
              }
            };
            result1 = FPAdd(aget_Elem(operand1, e * 2, esize), element1, StandardFPSCRValue());
            result2 = FPAdd(aget_Elem(operand1, e * 2 + 1, esize), element3, StandardFPSCRValue());
            D(d + r) = aset_Elem(D(d + r), e * 2, esize, result1);
            D(d + r) = aset_Elem(D(d + r), e * 2 + 1, esize, result2)
        }
    }
}

val VCADD_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCADD_T1_A_decode (rot, D, S, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let esize = shl_int(16, UInt(S));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let elements : int = 64 / esize;
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCADD_Op_A(d, elements, esize, m, n, regs, rot)
}

val VCADD_A1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VCADD_A1_A_decode (rot, D, S, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = true;
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let esize = shl_int(16, UInt(S));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let elements : int = 64 / esize;
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VCADD_Op_A(d, elements, esize, m, n, regs, rot)
}

val VBIC_r_Op_A : forall ('d : Int) ('m : Int) ('n : Int) ('regs : Int).
  (int('d), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VBIC_r_Op_A (d, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
            D(d + r) = D(n + r) & ~(D(m + r))
        }
    }
}

val VBIC_r_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VBIC_r_T1A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VBIC_r_Op_A(d, m, n, regs)
}

val VBIC_i_Op_A : forall ('d : Int) ('regs : Int).
  (int('d), bits(64), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VBIC_i_Op_A (d, imm64, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            D(d + r) = D(d + r) & ~(imm64)
        }
    }
}

val VBIC_i_T2A2_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VBIC_i_T2A2_A_decode (i, D, imm3, Vd, cmode, Q, imm4) = {
    __unconditional = false;
    if [cmode[0]] == 0b0 | slice(cmode, 2, 2) == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let imm64 = AdvSIMDExpandImm(0b1, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VBIC_i_Op_A(d, imm64, regs)
}

val VBIC_i_T1A1_A_decode : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VBIC_i_T1A1_A_decode (i, D, imm3, Vd, cmode, Q, imm4) = {
    __unconditional = false;
    if [cmode[0]] == 0b0 | slice(cmode, 2, 2) == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if Q == 0b1 & [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let imm64 = AdvSIMDExpandImm(0b1, cmode, (i @ imm3) @ imm4);
    let d = UInt(D @ Vd);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VBIC_i_Op_A(d, imm64, regs)
}

val VAND_r_Op_A : forall ('d : Int) ('m : Int) ('n : Int) ('regs : Int).
  (int('d), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VAND_r_Op_A (d, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
            assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
            D(d + r) = D(n + r) & D(m + r)
        }
    }
}

val VAND_r_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VAND_r_T1A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VAND_r_Op_A(d, m, n, regs)
}

val VADD_i_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VADD_i_Op_A (d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(D(n + r), e, esize) + aget_Elem(D(m + r), e, esize))
            }
        }
    }
}

val VADD_i_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VADD_i_T1A1_A_decode (D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VADD_i_Op_A(d, elements, esize, m, n, regs)
}

val VADDL_Op_A : forall 'd 'elements 'esize ('is_vaddw : Bool) 'm 'n ('unsigned : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize >= 0).
  (int('d), int('elements), int('esize), bool('is_vaddw), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VADDL_Op_A (d, elements, esize, is_vaddw, m, n, unsigned) = {
    if ConditionPassed() then {
        op1 : int = undefined : int;
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & (e + 1) * esize <= 64);
            if is_vaddw then {
                assert((e + 1) * (2 * esize) <= 128);
                op1 = asl_Int(aget_Elem(Qin(shr_int(n, 1)), e, 2 * esize), unsigned)
            } else {
                assert((e + 1) * esize <= 64);
                op1 = asl_Int(aget_Elem(Din(n), e, esize), unsigned)
            };
            let result = op1 + asl_Int(aget_Elem(Din(m), e, esize), unsigned);
            Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, __GetSlice_int(2 * esize, result, 0))
        }
    }
}

val VADDL_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VADDL_T1A1_A_decode (U, D, size, Vn, Vd, op, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vd[0]] == 0b1 | op == 0b1 & [Vn[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let is_vaddw = op == 0b1;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VADDL_Op_A(d, elements, esize, is_vaddw, m, n, unsigned)
}

val VADDHN_Op_A : forall 'd 'elements 'esize 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31 & 'esize >= 0).
  (int('d), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function VADDHN_Op_A (d, elements, esize, m, n) = {
    if ConditionPassed() then {
        result : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        CheckAdvSIMDEnabled();
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            assert(e >= 0 & 2 * esize >= 0 & (e + 1) * (2 * esize) <= 128);
            result = aget_Elem(Qin(shr_int(n, 1)), e, 2 * esize) + aget_Elem(Qin(shr_int(m, 1)), e, 2 * esize);
            D(d) = aset_Elem(D(d), e, esize, slice(result, esize, esize))
        }
    }
}

val VADDHN_T1A1_A_decode : (bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VADDHN_T1A1_A_decode (D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vn[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    VADDHN_Op_A(d, elements, esize, m, n)
}

val VACGE_Op_A : forall 'd 'elements 'esize 'm 'n ('or_equal : Bool) 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), bool('or_equal), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VACGE_Op_A (d, elements, esize, m, n, or_equal, regs) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        test_passed : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = FPAbs(aget_Elem(D(n + r), e, esize));
                op2 = FPAbs(aget_Elem(D(m + r), e, esize));
                if or_equal then {
                    test_passed = FPCompareGE(op1, op2, StandardFPSCRValue())
                } else {
                    test_passed = FPCompareGT(op1, op2, StandardFPSCRValue())
                };
                D(d + r) = aset_Elem(D(d + r), e, esize, if test_passed then Ones(esize) else Zeros(esize))
            }
        }
    }
}

val VACGE_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VACGE_T1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let or_equal = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VACGE_Op_A(d, elements, esize, m, n, or_equal, regs)
}

val VACGE_A1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VACGE_A1_A_decode (D, op, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let or_equal = op == 0b0;
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VACGE_Op_A(d, elements, esize, m, n, or_equal, regs)
}

val VABD_i_Op_A : forall 'd 'elements 'esize ('long_destination : Bool) 'm 'n 'regs ('unsigned : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('elements), int('esize), bool('long_destination), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VABD_i_Op_A (d, elements, esize, long_destination, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        absdiff : int = undefined : int;
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(Din(n + r), e, esize);
                op2 = aget_Elem(Din(m + r), e, esize);
                absdiff = abs(asl_Int(op1, unsigned) - asl_Int(op2, unsigned));
                if long_destination then {
                    Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, __GetSlice_int(2 * esize, absdiff, 0))
                } else {
                    assert(d + r >= 0 & d + r <= 31);
                    D(d + r) = aset_Elem(D(d + r), e, esize, __GetSlice_int(esize, absdiff, 0))
                }
            }
        }
    }
}

val VABD_i_T2A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABD_i_T2A2_A_decode (U, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let long_destination = true;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = 1;
    __PostDecode();
    VABD_i_Op_A(d, elements, esize, long_destination, m, n, regs, unsigned)
}

val VABD_i_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABD_i_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let long_destination = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VABD_i_Op_A(d, elements, esize, long_destination, m, n, regs, unsigned)
}

val VABD_f_Op_A : forall 'd 'elements 'esize 'm 'n 'regs,
  'esize >= 0.
  (int('d), int('elements), int('esize), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function VABD_f_Op_A (d, elements, esize, m, n, regs) = {
    if ConditionPassed() then {
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(D(n + r), e, esize);
                op2 = aget_Elem(D(m + r), e, esize);
                D(d + r) = aset_Elem(D(d + r), e, esize, FPAbs(FPSub(op1, op2, StandardFPSCRValue())))
            }
        }
    }
}

val VABD_f_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABD_f_T1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VABD_f_Op_A(d, elements, esize, m, n, regs)
}

val VABD_f_A1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABD_f_A1_A_decode (D, sz, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    if sz == 0b1 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    elements : int = undefined : int;
    esize : int = undefined : int;
    match sz {
      0b0 => {
          esize = 32;
          elements = 2
      },
      0b1 => {
          esize = 16;
          elements = 4
      }
    };
    let esize = esize;
    let elements = elements;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    assert(constraint('_esize >= 0));
    __PostDecode();
    VABD_f_Op_A(d, elements, esize, m, n, regs)
}

val VABA_Op_A : forall 'd 'elements 'esize ('long_destination : Bool) 'm 'n 'regs ('unsigned : Bool),
  (0 <= 'd & 'd <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('elements), int('esize), bool('long_destination), int('m), int('n), int('regs), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function VABA_Op_A (d, elements, esize, long_destination, m, n, regs, unsigned) = {
    if ConditionPassed() then {
        absdiff : int = undefined : int;
        op1 : bits('esize) = undefined : bits('esize);
        op2 : bits('esize) = undefined : bits('esize);
        CheckAdvSIMDEnabled();
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('m + 'loop_r >= 0 & 'm + 'loop_r <= 31)));
                assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 64)));
                assert(constraint(('n + 'loop_r >= 0 & 'n + 'loop_r <= 31)));
                op1 = aget_Elem(Din(n + r), e, esize);
                op2 = aget_Elem(Din(m + r), e, esize);
                absdiff = abs(asl_Int(op1, unsigned) - asl_Int(op2, unsigned));
                if long_destination then {
                    Q(shr_int(d, 1)) = aset_Elem(Q(shr_int(d, 1)), e, 2 * esize, aget_Elem(Qin(shr_int(d, 1)), e, 2 * esize) + absdiff)
                } else {
                    assert(d + r >= 0 & d + r <= 31);
                    D(d + r) = aset_Elem(D(d + r), e, esize, aget_Elem(Din(d + r), e, esize) + absdiff)
                }
            }
        }
    }
}

val VABA_T2A2_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABA_T2A2_A_decode (U, D, size, Vn, Vd, N, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("Related encodings"))
    };
    if [Vd[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let long_destination = true;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = 1;
    __PostDecode();
    VABA_Op_A(d, elements, esize, long_destination, m, n, regs, unsigned)
}

val VABA_T1A1_A_decode : (bits(1), bits(1), bits(2), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function VABA_T1A1_A_decode (U, D, size, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if Q == 0b1 & (([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1) then {
        throw(Error_Undefined())
    };
    let unsigned = U == 0b1;
    let long_destination = false;
    let esize = shl_int(8, UInt(size));
    let elements : int = 64 / esize;
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    let regs = if Q == 0b0 then 1 else 2;
    __PostDecode();
    VABA_Op_A(d, elements, esize, long_destination, m, n, regs, unsigned)
}

val CheckCryptoEnabled32 : unit -> unit effect {escape, rreg, undef, wreg}

function CheckCryptoEnabled32 () = {
    CheckAdvSIMDEnabled();
    return()
}

val SHA256SU1_Op_A : forall 'd 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHA256SU1_Op_A (d, m, n) = {
    if ConditionPassed() then {
        T0 : bits(128) = undefined : bits(128);
        T1 : bits(64) = undefined : bits(64);
        X : bits(128) = undefined : bits(128);
        Y : bits(128) = undefined : bits(128);
        Z : bits(128) = undefined : bits(128);
        elt : bits(32) = undefined : bits(32);
        result : bits(128) = undefined : bits(128);
        CheckCryptoEnabled32();
        X = aget_Q(shr_int(d, 1));
        Y = aget_Q(shr_int(n, 1));
        Z = aget_Q(shr_int(m, 1));
        T0 = slice(Z, 0, 32) @ slice(Y, 32, 96);
        T1 = slice(Z, 64, 64);
        foreach (e from 0 to 1 by 1 in inc) {
            elt = aget_Elem(T1, e, 32);
            elt = (ROR(elt, 17) ^ ROR(elt, 19)) ^ LSR(elt, 10);
            elt = elt + aget_Elem(X, e, 32) + aget_Elem(T0, e, 32);
            result = aset_Elem(result, e, 32, elt)
        };
        T1 = slice(result, 0, 64);
        foreach (e from 2 to 3 by 1 in inc) {
            elt = aget_Elem(T1, e - 2, 32);
            elt = (ROR(elt, 17) ^ ROR(elt, 19)) ^ LSR(elt, 10);
            elt = elt + aget_Elem(X, e, 32) + aget_Elem(T0, e, 32);
            result = aset_Elem(result, e, 32, elt)
        };
        aset_Q(shr_int(d, 1), result)
    }
}

val SHA256SU1_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256SU1_T1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256SU1_Op_A(d, m, n)
}

val SHA256SU1_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256SU1_A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256SU1_Op_A(d, m, n)
}

val SHA256SU0_Op_A : forall 'd 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function SHA256SU0_Op_A (d, m) = {
    if ConditionPassed() then {
        T : bits(128) = undefined : bits(128);
        X : bits(128) = undefined : bits(128);
        Y : bits(128) = undefined : bits(128);
        elt : bits(32) = undefined : bits(32);
        result : bits(128) = undefined : bits(128);
        CheckCryptoEnabled32();
        X = Q(shr_int(d, 1));
        Y = Q(shr_int(m, 1));
        T = slice(Y, 0, 32) @ slice(X, 32, 96);
        foreach (e from 0 to 3 by 1 in inc) {
            elt = aget_Elem(T, e, 32);
            elt = (ROR(elt, 7) ^ ROR(elt, 18)) ^ LSR(elt, 3);
            result = aset_Elem(result, e, 32, elt + aget_Elem(X, e, 32))
        };
        Q(shr_int(d, 1)) = result
    }
}

val SHA256SU0_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256SU0_T1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256SU0_Op_A(d, m)
}

val SHA256SU0_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256SU0_A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256SU0_Op_A(d, m)
}

val SHA256H2_Op_A : forall 'd 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHA256H2_Op_A (d, m, n) = {
    if ConditionPassed() then {
        W : bits(128) = undefined : bits(128);
        X : bits(128) = undefined : bits(128);
        Y : bits(128) = undefined : bits(128);
        part1 : bool = undefined : bool;
        CheckCryptoEnabled32();
        X = Q(shr_int(n, 1));
        Y = Q(shr_int(d, 1));
        W = Q(shr_int(m, 1));
        part1 = false;
        Q(shr_int(d, 1)) = SHA256hash(X, Y, W, part1)
    }
}

val SHA256H2_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256H2_T1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256H2_Op_A(d, m, n)
}

val SHA256H2_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256H2_A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256H2_Op_A(d, m, n)
}

val SHA256H_Op_A : forall 'd 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHA256H_Op_A (d, m, n) = {
    if ConditionPassed() then {
        W : bits(128) = undefined : bits(128);
        X : bits(128) = undefined : bits(128);
        Y : bits(128) = undefined : bits(128);
        part1 : bool = undefined : bool;
        CheckCryptoEnabled32();
        X = Q(shr_int(d, 1));
        Y = Q(shr_int(n, 1));
        W = Q(shr_int(m, 1));
        part1 = true;
        Q(shr_int(d, 1)) = SHA256hash(X, Y, W, part1)
    }
}

val SHA256H_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256H_T1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256H_Op_A(d, m, n)
}

val SHA256H_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA256H_A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA256H_Op_A(d, m, n)
}

val SHA1SU1_Op_A : forall 'd 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function SHA1SU1_Op_A (d, m) = {
    if ConditionPassed() then {
        T : bits(128) = undefined : bits(128);
        W0 : bits(32) = undefined : bits(32);
        W1 : bits(32) = undefined : bits(32);
        W2 : bits(32) = undefined : bits(32);
        W3 : bits(32) = undefined : bits(32);
        X : bits(128) = undefined : bits(128);
        Y : bits(128) = undefined : bits(128);
        CheckCryptoEnabled32();
        X = Q(shr_int(d, 1));
        Y = Q(shr_int(m, 1));
        T = X ^ LSR(Y, 32);
        W0 = ROL(slice(T, 0, 32), 1);
        W1 = ROL(slice(T, 32, 32), 1);
        W2 = ROL(slice(T, 64, 32), 1);
        W3 = ROL(slice(T, 96, 32), 1) ^ ROL(slice(T, 0, 32), 2);
        Q(shr_int(d, 1)) = ((W3 @ W2) @ W1) @ W0
    }
}

val SHA1SU1_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1SU1_T1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1SU1_Op_A(d, m)
}

val SHA1SU1_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1SU1_A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1SU1_Op_A(d, m)
}

val SHA1SU0_Op_A : forall 'd 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHA1SU0_Op_A (d, m, n) = {
    if ConditionPassed() then {
        op1 : bits(128) = undefined : bits(128);
        op2 : bits(128) = undefined : bits(128);
        op3 : bits(128) = undefined : bits(128);
        CheckCryptoEnabled32();
        op1 = Q(shr_int(d, 1));
        op2 = Q(shr_int(n, 1));
        op3 = Q(shr_int(m, 1));
        op2 = slice(op2, 0, 64) @ slice(op1, 64, 64);
        Q(shr_int(d, 1)) = (op1 ^ op2) ^ op3
    }
}

val SHA1SU0_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1SU0_T1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1SU0_Op_A(d, m, n)
}

val SHA1SU0_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1SU0_A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1SU0_Op_A(d, m, n)
}

val SHA1P_Op_A : forall 'd 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHA1P_Op_A (d, m, n) = {
    if ConditionPassed() then {
        W : bits(128) = undefined : bits(128);
        X : bits(128) = undefined : bits(128);
        Y : bits(32) = undefined : bits(32);
        t : bits(32) = undefined : bits(32);
        CheckCryptoEnabled32();
        X = Q(shr_int(d, 1));
        Y = slice(Q(shr_int(n, 1)), 0, 32);
        W = Q(shr_int(m, 1));
        foreach (e from 0 to 3 by 1 in inc) {
            t = SHAparity(slice(X, 32, 32), slice(X, 64, 32), slice(X, 96, 32));
            Y = Y + ROL(slice(X, 0, 32), 5) + t + aget_Elem(W, e, 32);
            X = __SetSlice_bits(128, 32, X, 32, ROL(slice(X, 32, 32), 30));
            let __tc1 : bits(160) = ROL(Y @ X, 32);
            Y = slice(__tc1, 128, 32);
            X = slice(__tc1, 0, 128)
        };
        Q(shr_int(d, 1)) = X
    }
}

val SHA1P_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1P_T1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1P_Op_A(d, m, n)
}

val SHA1P_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1P_A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1P_Op_A(d, m, n)
}

val SHA1M_Op_A : forall 'd 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHA1M_Op_A (d, m, n) = {
    if ConditionPassed() then {
        W : bits(128) = undefined : bits(128);
        X : bits(128) = undefined : bits(128);
        Y : bits(32) = undefined : bits(32);
        t : bits(32) = undefined : bits(32);
        CheckCryptoEnabled32();
        X = Q(shr_int(d, 1));
        Y = slice(Q(shr_int(n, 1)), 0, 32);
        W = Q(shr_int(m, 1));
        foreach (e from 0 to 3 by 1 in inc) {
            t = SHAmajority(slice(X, 32, 32), slice(X, 64, 32), slice(X, 96, 32));
            Y = Y + ROL(slice(X, 0, 32), 5) + t + aget_Elem(W, e, 32);
            X = __SetSlice_bits(128, 32, X, 32, ROL(slice(X, 32, 32), 30));
            let __tc1 : bits(160) = ROL(Y @ X, 32);
            Y = slice(__tc1, 128, 32);
            X = slice(__tc1, 0, 128)
        };
        Q(shr_int(d, 1)) = X
    }
}

val SHA1M_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1M_T1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1M_Op_A(d, m, n)
}

val SHA1M_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1M_A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1M_Op_A(d, m, n)
}

val SHA1H_Op_A : forall 'd 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function SHA1H_Op_A (d, m) = {
    if ConditionPassed() then {
        CheckCryptoEnabled32();
        Q(shr_int(d, 1)) = ZeroExtend(ROL(slice(Q(shr_int(m, 1)), 0, 32), 30), 128)
    }
}

val SHA1H_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1H_T1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1H_Op_A(d, m)
}

val SHA1H_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1H_A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1H_Op_A(d, m)
}

val SHA1C_Op_A : forall 'd 'm 'n,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'n & 'n <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function SHA1C_Op_A (d, m, n) = {
    if ConditionPassed() then {
        W : bits(128) = undefined : bits(128);
        X : bits(128) = undefined : bits(128);
        Y : bits(32) = undefined : bits(32);
        t : bits(32) = undefined : bits(32);
        CheckCryptoEnabled32();
        X = Q(shr_int(d, 1));
        Y = slice(Q(shr_int(n, 1)), 0, 32);
        W = Q(shr_int(m, 1));
        foreach (e from 0 to 3 by 1 in inc) {
            t = SHAchoose(slice(X, 32, 32), slice(X, 64, 32), slice(X, 96, 32));
            Y = Y + ROL(slice(X, 0, 32), 5) + t + aget_Elem(W, e, 32);
            X = __SetSlice_bits(128, 32, X, 32, ROL(slice(X, 32, 32), 30));
            let __tc1 : bits(160) = ROL(Y @ X, 32);
            Y = slice(__tc1, 128, 32);
            X = slice(__tc1, 0, 128)
        };
        Q(shr_int(d, 1)) = X
    }
}

val SHA1C_T1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1C_T1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1C_Op_A(d, m, n)
}

val SHA1C_A1_A_decode : (bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function SHA1C_A1_A_decode (D, Vn, Vd, N, Q, M, Vm) = {
    __unconditional = false;
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    if Q != 0b1 then {
        throw(Error_Undefined())
    };
    if ([Vd[0]] == 0b1 | [Vn[0]] == 0b1) | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let n = UInt(N @ Vn);
    let m = UInt(M @ Vm);
    __PostDecode();
    SHA1C_Op_A(d, m, n)
}

val AESMC_Op_A : forall 'd 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function AESMC_Op_A (d, m) = {
    if ConditionPassed() then {
        CheckCryptoEnabled32();
        Q(shr_int(d, 1)) = AESMixColumns(Q(shr_int(m, 1)))
    }
}

val AESMC_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESMC_T1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESMC_Op_A(d, m)
}

val AESMC_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESMC_A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESMC_Op_A(d, m)
}

val AESIMC_Op_A : forall 'd 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function AESIMC_Op_A (d, m) = {
    if ConditionPassed() then {
        CheckCryptoEnabled32();
        Q(shr_int(d, 1)) = AESInvMixColumns(Q(shr_int(m, 1)))
    }
}

val AESIMC_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESIMC_T1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESIMC_Op_A(d, m)
}

val AESIMC_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESIMC_A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESIMC_Op_A(d, m)
}

val AESE_Op_A : forall 'd 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function AESE_Op_A (d, m) = {
    if ConditionPassed() then {
        op1 : bits(128) = undefined : bits(128);
        op2 : bits(128) = undefined : bits(128);
        CheckCryptoEnabled32();
        op1 = Q(shr_int(d, 1));
        op2 = Q(shr_int(m, 1));
        Q(shr_int(d, 1)) = AESSubBytes(AESShiftRows(op1 ^ op2))
    }
}

val AESE_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESE_T1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESE_Op_A(d, m)
}

val AESE_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESE_A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESE_Op_A(d, m)
}

val AESD_Op_A : forall 'd 'm,
  (0 <= 'd & 'd <= 31 & 0 <= 'm & 'm <= 31).
  (int('d), int('m)) -> unit effect {escape, rreg, undef, wreg}

function AESD_Op_A (d, m) = {
    if ConditionPassed() then {
        op1 : bits(128) = undefined : bits(128);
        op2 : bits(128) = undefined : bits(128);
        CheckCryptoEnabled32();
        op1 = Q(shr_int(d, 1));
        op2 = Q(shr_int(m, 1));
        Q(shr_int(d, 1)) = AESInvSubBytes(AESInvShiftRows(op1 ^ op2))
    }
}

val AESD_T1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESD_T1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESD_Op_A(d, m)
}

val AESD_A1_A_decode : (bits(1), bits(2), bits(4), bits(1), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function AESD_A1_A_decode (D, size, Vd, M, Vm) = {
    __unconditional = false;
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    if [Vd[0]] == 0b1 | [Vm[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let d = UInt(D @ Vd);
    let m = UInt(M @ Vm);
    __PostDecode();
    AESD_Op_A(d, m)
}

val AArch32_CallHypervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CallHypervisor immediate = {
    assert(HaveEL(EL2));
    if ~(ELUsingAArch32(EL2)) then {
        AArch64_CallHypervisor(immediate)
    } else {
        AArch32_TakeHVCException(immediate)
    }
}

val HVC_Op_AS : bits(16) -> unit effect {escape, rreg, undef, wreg}

function HVC_Op_AS imm16 = {
    if (~(HaveEL(EL2)) | PSTATE.EL == EL0) | IsSecure() & ~(IsSecureEL2Enabled()) then {
        throw(Error_Undefined())
    };
    hvc_enable : bits(1) = undefined : bits(1);
    if HaveEL(EL3) then {
        if (ELUsingAArch32(EL3) & [get_SCR()[8]] == 0b0) & PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        } else {
            hvc_enable = [SCR_GEN()[8]]
        }
    } else {
        hvc_enable = if ELUsingAArch32(EL2) then ~([get_HCR()[29]]) else ~([HCR_EL2[29]])
    };
    if hvc_enable == 0b0 then {
        throw(Error_Undefined())
    } else {
        AArch32_CallHypervisor(imm16)
    }
}

val HVC_T1_A_decode : (bits(4), bits(12)) -> unit effect {escape, rreg, undef, wreg}

function HVC_T1_A_decode (imm4, imm12) = {
    __unconditional = true;
    let imm16 = imm4 @ imm12;
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    HVC_Op_AS(imm16)
}

val HVC_A1_A_decode : (bits(4), bits(12), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function HVC_A1_A_decode (cond, imm12, imm4) = {
    __unconditional = true;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let imm16 = imm12 @ imm4;
    __PostDecode();
    HVC_Op_AS(imm16)
}

val AArch32_AutoGen_SysRegTrap64 : (bits(2), bits(4), bits(4), bits(4), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch32_AutoGen_SysRegTrap64 (el, coproc, opc1, CRm, read) = {
    let __CNTHCTL_EL2_EL1PTEN = [CNTHCTL_EL2[11]];
    let __CNTHCTL_EL2_EL0PCTEN = [CNTHCTL_EL2[0]];
    let __SCR_FIQ = [get_SCR()[2]];
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let __MDCR_EL3_TDA = [MDCR_EL3[9]];
    let __ICH_HCR_TC = [get_ICH_HCR()[10]];
    let __HCR_TRVM = [get_HCR()[30]];
    let __SCR_IRQ = [get_SCR()[1]];
    let __CNTKCTL_EL1_EL0VCTEN = [CNTKCTL_EL1[1]];
    let __SCR_EL3_IRQ = [SCR_EL3[1]];
    let __ICC_SRE_SRE = [get_ICC_SRE()[0]];
    let __HCR_TVM = [get_HCR()[26]];
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __HSTR_T2 = [get_HSTR()[2]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    let __HCR_EL2_TRVM = [HCR_EL2[30]];
    let __HSTR_T7 = [get_HSTR()[7]];
    let __ICC_MSRE_SRE = [get_ICC_MSRE()[0]];
    let __HDCR_TDRA = [get_HDCR()[11]];
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let __CNTKCTL_EL1_EL0PTEN = [CNTKCTL_EL1[9]];
    let ___ELUsingAArch32_EL3_ = ~(ELUsingAArch32(EL3));
    let __HSTR_T9 = [get_HSTR()[9]];
    let __CNTHCTL_EL2_EL1PCEN = [CNTHCTL_EL2[1]];
    let __PMUSERENR_EL0_EN = [PMUSERENR_EL0[0]];
    let __CNTHCTL_PL1PCTEN = [get_CNTHCTL()[0]];
    let __HCR_FMO = [get_HCR()[3]];
    let __PMUSERENR_CR = [get_PMUSERENR()[2]];
    let __PMUSERENR_EL0_CR = [PMUSERENR_EL0[2]];
    let __CNTKCTL_PL0PCTEN = [get_CNTKCTL()[0]];
    let __SCR_EL3_FIQ = [SCR_EL3[2]];
    let __HCR_IMO = [get_HCR()[4]];
    let __ELUsingAArch32_EL2_ = ELUsingAArch32(EL2);
    let __CNTHCTL_EL2_EL0VTEN = [CNTHCTL_EL2[8]];
    let __ICC_HSRE_SRE = [get_ICC_HSRE()[0]];
    let __HSTR_EL2_T9 = [HSTR_EL2[9]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __HDCR_TPM = [get_HDCR()[6]];
    let __HSTR_EL2_T2 = [HSTR_EL2[2]];
    let __DBGDSCRext_UDCCdis = [get_DBGDSCRext()[12]];
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __CNTHCTL_EL2_EL0PTEN = [CNTHCTL_EL2[9]];
    let __PMUSERENR_EN = [get_PMUSERENR()[0]];
    let __MDCR_EL3_TPM = [MDCR_EL3[6]];
    let __CNTKCTL_EL1_EL0PCTEN = [CNTKCTL_EL1[0]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __CNTKCTL_EL1_EL0VTEN = [CNTKCTL_EL1[8]];
    let __MDCR_EL2_TDRA = [MDCR_EL2[11]];
    let __HSTR_EL2_T7 = [HSTR_EL2[7]];
    let __MDCR_EL2_TPM = [MDCR_EL2[6]];
    let __SCR_GEN___NS = [SCR_GEN()[0]];
    let __CNTKCTL_PL0PTEN = [get_CNTKCTL()[9]];
    let ___ELUsingAArch32_EL2_ = ~(ELUsingAArch32(EL2));
    let __CNTHCTL_EL2_EL1PCTEN = [CNTHCTL_EL2[if [HCR_EL2[34]] == 0 then 0 else 10]];
    let __CNTKCTL_PL0VTEN = [get_CNTKCTL()[8]];
    let __CNTKCTL_PL0VCTEN = [get_CNTKCTL()[1]];
    let __HSTR_T12 = [get_HSTR()[12]];
    let __HCR_EL2_TVM = [HCR_EL2[26]];
    let __MDSCR_EL1_TDCC = [MDSCR_EL1[12]];
    let __ICH_HCR_EL2_TC = [ICH_HCR_EL2[10]];
    let __HSTR_EL2_T12 = [HSTR_EL2[12]];
    let __CNTHCTL_PL1PCEN = [get_CNTHCTL()[1]];
    if coproc == 0xF then {
        if CRm == 0xE then {
            if opc1 == 0x1 then {
                if ((__HCR_EL2_E2H == 0 & __CNTKCTL_PL0VCTEN == 0) & el == EL0) & read == 1 then {
                    throw(Error_Undefined())
                };
                if ((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                    return((true, EL1))
                };
                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0VCTEN == 0) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                    throw(Error_Undefined())
                };
                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                    return((true, EL1))
                };
                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                    return((true, EL2))
                }
            } else {
                if opc1 == 0x6 then {
                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                        return((true, EL2))
                    }
                } else {
                    if opc1 == 0x3 then {
                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                            return((true, EL2))
                        };
                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                            return((true, EL1))
                        };
                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_PL0VTEN == 0) & el == EL0 then {
                            throw(Error_Undefined())
                        };
                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                            return((true, EL1))
                        };
                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0VTEN == 0) & __SCR_GEN___NS == 1) & el == EL0 then {
                            throw(Error_Undefined())
                        };
                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                            return((true, EL2))
                        }
                    } else {
                        if opc1 == 0x2 then {
                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                return((true, EL2))
                            };
                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                return((true, EL1))
                            };
                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_PL0PTEN == 0) & el == EL0 then {
                                throw(Error_Undefined())
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                return((true, EL1))
                            };
                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0PTEN == 0) & __SCR_GEN___NS == 1) & el == EL0 then {
                                throw(Error_Undefined())
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __CNTHCTL_PL1PCEN == 0) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                return((true, EL2))
                            }
                        } else {
                            if opc1 == 0x0 then {
                                if ((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                    return((true, EL1))
                                };
                                if ((__HCR_EL2_E2H == 0 & __CNTKCTL_PL0PCTEN == 0) & el == EL0) & read == 1 then {
                                    throw(Error_Undefined())
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & __CNTKCTL_EL1_EL0PCTEN == 1) & el == EL0) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & __CNTKCTL_EL1_EL0PCTEN == 1) & el == EL0) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                    return((true, EL1))
                                };
                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0PCTEN == 0) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                                    throw(Error_Undefined())
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __CNTHCTL_PL1PCTEN == 0) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                    return((true, EL2))
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRm == 0x2 then {
                if opc1 == 0x1 then {
                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                        return((true, EL2))
                    };
                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                        return((true, EL2))
                    };
                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                        return((true, EL2))
                    };
                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                        return((true, EL2))
                    };
                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                        return((true, EL2))
                    };
                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                        return((true, EL2))
                    };
                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                        return((true, EL2))
                    };
                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                        return((true, EL2))
                    };
                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                        return((true, EL2))
                    }
                } else {
                    if opc1 == 0x4 then {
                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                            return((true, EL2))
                        }
                    } else {
                        if opc1 == 0x6 then {
                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if opc1 == 0x0 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            }
                        }
                    }
                }
            } else {
                if opc1 == 0x0 then {
                    if CRm == 0xC then {
                        if (__ICC_SRE_SRE == 0 & el == EL1) & read == 0 then {
                            throw(Error_Undefined())
                        };
                        if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 0 then {
                            throw(Error_Undefined())
                        };
                        if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 0 then {
                            throw(Error_Undefined())
                        };
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_FMO == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_IMO == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__ELUsingAArch32_EL3_ & __SCR_FIQ == 1) & __SCR_IRQ == 1) & (el == EL2 | el == EL3)) & read == 0 then {
                            throw(Error_Undefined())
                        };
                        if ((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                            return((true, EL3))
                        };
                        if (((~(__ELUsingAArch32_EL3_) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                            return((true, EL3))
                        };
                        if ((((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & el == EL1) & read == 0 then {
                            return((true, EL3))
                        };
                        if ((((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                            return((true, EL3))
                        }
                    } else {
                        if CRm == 0x7 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRm == 0x9 then {
                                if ((__PMUSERENR_CR == 0 & __PMUSERENR_EN == 0) & el == EL0) & read == 1 then {
                                    throw(Error_Undefined())
                                };
                                if (((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                    return((true, EL1))
                                };
                                if ((((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (__PMUSERENR_EN == 0 & el == EL0) & read == 0 then {
                                    throw(Error_Undefined())
                                };
                                if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                    return((true, EL1))
                                };
                                if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if (~(__ELUsingAArch32_EL3_) & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                    return((true, EL3))
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0xC then {
                        if opc1 == 0x1 then {
                            if (__ICC_SRE_SRE == 0 & el == EL1) & read == 0 then {
                                throw(Error_Undefined())
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_FMO == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_IMO == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                return((true, EL2))
                            };
                            if (((__ELUsingAArch32_EL3_ & __SCR_FIQ == 1) & __SCR_IRQ == 1) & (el == EL2 | el == EL3)) & read == 0 then {
                                throw(Error_Undefined())
                            };
                            if ((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                return((true, EL3))
                            };
                            if (((~(__ELUsingAArch32_EL3_) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                return((true, EL3))
                            };
                            if ((((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & el == EL1) & read == 0 then {
                                return((true, EL3))
                            };
                            if ((((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                return((true, EL3))
                            }
                        } else {
                            if opc1 == 0x2 then {
                                if (__ICC_SRE_SRE == 0 & el == EL1) & read == 0 then {
                                    throw(Error_Undefined())
                                };
                                if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 0 then {
                                    throw(Error_Undefined())
                                };
                                if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 0 then {
                                    throw(Error_Undefined())
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_FMO == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_IMO == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((__ELUsingAArch32_EL3_ & __SCR_FIQ == 1) & __SCR_IRQ == 1) & (el == EL2 | el == EL3)) & read == 0 then {
                                    throw(Error_Undefined())
                                };
                                if ((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                    return((true, EL3))
                                };
                                if (((~(__ELUsingAArch32_EL3_) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                    return((true, EL3))
                                };
                                if ((((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & el == EL1) & read == 0 then {
                                    return((true, EL3))
                                };
                                if ((((((~(__ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                    return((true, EL3))
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if coproc == 0xE then {
            if opc1 == 0x0 then {
                if CRm == 0x2 then {
                    if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 1 then {
                        throw(Error_Undefined())
                    };
                    if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                        return((true, EL1))
                    };
                    if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                        return((true, EL2))
                    };
                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDRA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                        return((true, EL2))
                    };
                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDRA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                        return((true, EL2))
                    };
                    if ((~(__ELUsingAArch32_EL3_) & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                        return((true, EL3))
                    }
                } else {
                    if CRm == 0x1 then {
                        if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 1 then {
                            throw(Error_Undefined())
                        };
                        if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                            return((true, EL1))
                        };
                        if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDRA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDRA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                            return((true, EL2))
                        }
                    }
                }
            }
        }
    };
    return((false, EL0))
}

val AArch32_AutoGen_SysRegTrap32 : (bits(2), bits(4), bits(3), bits(4), bits(3), bits(4), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch32_AutoGen_SysRegTrap32 (el, coproc, opc1, CRn, opc2, CRm, read) = {
    let __CNTHCTL_EL2_EL0PCTEN = [CNTHCTL_EL2[0]];
    let __HaveEL_EL3_ = HaveEL(EL3);
    let __SCTLR_EL1_EnRCTX = [SCTLR_EL1[10]];
    let __MDCR_EL2_TPMCR = [MDCR_EL2[5]];
    let __MDCR_EL2_TTRF = [MDCR_EL2[19]];
    let __HDCR_TPMCR = [get_HDCR()[5]];
    let __EDSCR_TDA = [EDSCR[21]];
    let __MDCR_EL2_TDOSA = [MDCR_EL2[10]];
    let __ICH_HCR_TALL0 = [get_ICH_HCR()[11]];
    let __ICH_HCR_TALL1 = [get_ICH_HCR()[12]];
    let __SCTLR_EnRCTX = [get_SCTLR()[10]];
    let __HCR_EL2_TACR = [HCR_EL2[21]];
    let __CNTKCTL_PL0PCTEN = [get_CNTKCTL()[0]];
    let __SCR_EL3_FIQ = [SCR_EL3[2]];
    let __HSTR_EL2_T8 = [HSTR_EL2[8]];
    let __HSTR_EL2_T9 = [HSTR_EL2[9]];
    let __HSTR_EL2_T0 = [HSTR_EL2[0]];
    let __HSTR_EL2_T1 = [HSTR_EL2[1]];
    let __HSTR_EL2_T2 = [HSTR_EL2[2]];
    let __HSTR_EL2_T3 = [HSTR_EL2[3]];
    let __PMUSERENR_EL0_SW = [PMUSERENR_EL0[1]];
    let __HSTR_EL2_T5 = [HSTR_EL2[5]];
    let __MDCR_EL3_TTRF = [MDCR_EL3[19]];
    let __CNTHCTL_EL2_EL0PTEN = [CNTHCTL_EL2[9]];
    let __ICH_HCR_TDIR = [get_ICH_HCR()[14]];
    let __CNTKCTL_EL1_EL0PCTEN = [CNTKCTL_EL1[0]];
    let __SCTLR_EL2_EnRCTX = [SCTLR_EL2[10]];
    let __MDCR_EL3_TDA = [MDCR_EL3[9]];
    let __HCR_EL2_TID1 = [HCR_EL2[16]];
    let __HCR_EL2_TID2 = [HCR_EL2[17]];
    let __HCR_EL2_TID3 = [HCR_EL2[18]];
    let __MDCR_EL2_TPM = [MDCR_EL2[6]];
    let __CNTKCTL_PL0PTEN = [get_CNTKCTL()[9]];
    let __HCPTR_TCPAC = [get_HCPTR()[31]];
    let __HSTR_T10 = [get_HSTR()[10]];
    let __HSTR_T12 = [get_HSTR()[12]];
    let __HSTR_T13 = [get_HSTR()[13]];
    let __HCR_TSW = [get_HCR()[22]];
    let __HCR_TRVM = [get_HCR()[30]];
    let __HSTR_T2 = [get_HSTR()[2]];
    let __HCR_TID2 = [get_HCR()[17]];
    let __HCR_TID3 = [get_HCR()[18]];
    let __HCR_TID0 = [get_HCR()[15]];
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __MDCR_EL3_TDOSA = [MDCR_EL3[10]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    let __HCR_EL2_TRVM = [HCR_EL2[30]];
    let __HDCR_TDRA = [get_HDCR()[11]];
    let __HCR_TAC = [get_HCR()[21]];
    let ___ELUsingAArch32_EL1_ = ~(ELUsingAArch32(EL1));
    let __MDCR_EL2_TDA = [MDCR_EL2[9]];
    let __HSTR_T7 = [get_HSTR()[7]];
    let __HCR_FMO = [get_HCR()[3]];
    let __ICC_MSRE_SRE = [get_ICC_MSRE()[0]];
    let __CNTHCTL_EL2_EL0VTEN = [CNTHCTL_EL2[8]];
    let __ICC_HSRE_SRE = [get_ICC_HSRE()[0]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __HSCTLR_CP15BEN = [get_HSCTLR()[5]];
    let __ELUsingAArch32_EL1_ = ELUsingAArch32(EL1);
    let __HDCR_TDA = [get_HDCR()[9]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __MDCR_EL2_TDRA = [MDCR_EL2[11]];
    let __DBGOSLSR_OSLK = [get_DBGOSLSR()[1]];
    let __SCR_FIQ = [get_SCR()[2]];
    let __ICC_MSRE_Enable = [get_ICC_MSRE()[3]];
    let __HCR_TTLB = [get_HCR()[25]];
    let __ICC_HSRE_Enable = [get_ICC_HSRE()[3]];
    let __ICH_HCR_EL2_TC = [ICH_HCR_EL2[10]];
    let __ICC_SRE_EL1_SRE = [get_ICC_SRE_EL1()[0]];
    let __SCTLR___CP15BEN = [SCTLR()[5]];
    let __ELUsingAArch32_EL2_ = ELUsingAArch32(EL2);
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let __ICH_HCR_TC = [get_ICH_HCR()[10]];
    let __HCR_TPU = [get_HCR()[24]];
    let __CNTKCTL_EL1_EL0VCTEN = [CNTKCTL_EL1[1]];
    let __HSTR_T8 = [get_HSTR()[8]];
    let __HSTR_T9 = [get_HSTR()[9]];
    let __SCR_EL3_IRQ = [SCR_EL3[1]];
    let __HSTR_T3 = [get_HSTR()[3]];
    let __HSTR_T0 = [get_HSTR()[0]];
    let __HSTR_T1 = [get_HSTR()[1]];
    let __HSTR_T6 = [get_HSTR()[6]];
    let __HCR_TPC = [get_HCR()[23]];
    let __HSTR_T5 = [get_HSTR()[5]];
    let __CNTKCTL_EL1_EL0PTEN = [CNTKCTL_EL1[9]];
    let ___ELUsingAArch32_EL3_ = ~(ELUsingAArch32(EL3));
    let __PMUSERENR_EL0_ER = [PMUSERENR_EL0[3]];
    let __PMUSERENR_EL0_EN = [PMUSERENR_EL0[0]];
    let __CPTR_EL2_TCPAC = [CPTR_EL2[31]];
    let __CNTKCTL_PL0VCTEN = [get_CNTKCTL()[1]];
    let __ICC_SRE_EL3_Enable = [ICC_SRE_EL3[3]];
    let __CNTHCTL_EL2_EL1PCEN = [CNTHCTL_EL2[1]];
    let __CNTHCTL_EL2_EL0VCTEN = [CNTHCTL_EL2[1]];
    let __PMUSERENR_ER = [get_PMUSERENR()[3]];
    let __PMUSERENR_EN = [get_PMUSERENR()[0]];
    let __HCR_EL2_TTLB = [HCR_EL2[25]];
    let __HCR_EL2_TVM = [HCR_EL2[26]];
    let __ICC_SRE_EL2_Enable = [ICC_SRE_EL2[3]];
    let __CNTKCTL_EL1_EL0VTEN = [CNTKCTL_EL1[8]];
    let __SCR_GEN___NS = [SCR_GEN()[0]];
    let __DBGDSCRext_UDCCdis = [get_DBGDSCRext()[12]];
    let ___ELUsingAArch32_EL2_ = ~(ELUsingAArch32(EL2));
    let __HDCR_TDOSA = [get_HDCR()[10]];
    let __ICH_HCR_EL2_TDIR = [ICH_HCR_EL2[14]];
    let __MDCR_EL3_TPM = [MDCR_EL3[6]];
    let __HSTR_EL2_T13 = [HSTR_EL2[13]];
    let __HSTR_EL2_T10 = [HSTR_EL2[10]];
    let __CNTHCTL_EL2_EL1PTEN = [CNTHCTL_EL2[11]];
    let __HSTR_EL2_T12 = [HSTR_EL2[12]];
    let __SCR_IRQ = [get_SCR()[1]];
    let __HCR_TID1 = [get_HCR()[16]];
    let __SCTLR_CP15BEN = [get_SCTLR()[5]];
    let __ICC_SRE_SRE = [get_ICC_SRE()[0]];
    let __HCR_TVM = [get_HCR()[26]];
    let __HCR_EL2_TSW = [HCR_EL2[22]];
    let __HCR_IMO = [get_HCR()[4]];
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let __HDCR_TPM = [get_HDCR()[6]];
    let __PMUSERENR_EL0_CR = [PMUSERENR_EL0[2]];
    let __HaveEL_EL2_ = HaveEL(EL2);
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __HCR_EL2_TPC = [HCR_EL2[23]];
    let __CPTR_EL3_TCPAC = [CPTR_EL3[31]];
    let __HSTR_EL2_T6 = [HSTR_EL2[6]];
    let __HSTR_EL2_T7 = [HSTR_EL2[7]];
    let __HCR_EL2_TPU = [HCR_EL2[24]];
    let __PMUSERENR_CR = [get_PMUSERENR()[2]];
    let __CNTKCTL_PL0VTEN = [get_CNTKCTL()[8]];
    let __ICH_HCR_EL2_TALL0 = [ICH_HCR_EL2[11]];
    let __PMUSERENR_SW = [get_PMUSERENR()[1]];
    let __MDSCR_EL1_TDCC = [MDSCR_EL1[12]];
    let __HCR_EL2_TID0 = [HCR_EL2[15]];
    let __CNTHCTL_PL1PCEN = [get_CNTHCTL()[1]];
    let __ICH_HCR_EL2_TALL1 = [ICH_HCR_EL2[12]];
    if (CRm & 0x0) == 0x0 then {
        if opc1 == 0b000 then {
            if coproc == 0xE then {
                if CRn == 0x0 then {
                    if opc2 == 0b101 then {
                        if ((__EDSCR_TDA == 1 & true) & __DBGOSLSR_OSLK == 0) & (el == EL1 | el == EL3) then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                            return((true, EL3))
                        }
                    } else {
                        if opc2 == 0b100 then {
                            if ((__EDSCR_TDA == 1 & true) & __DBGOSLSR_OSLK == 0) & (el == EL1 | el == EL3) then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                return((true, EL3))
                            }
                        } else {
                            if opc2 == 0b110 then {
                                if ((__EDSCR_TDA == 1 & true) & __DBGOSLSR_OSLK == 0) & (el == EL1 | el == EL3) then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                }
                            } else {
                                if opc2 == 0b111 then {
                                    if ((__EDSCR_TDA == 1 & true) & __DBGOSLSR_OSLK == 0) & (el == EL1 | el == EL3) then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b001 then {
                        if CRn == 0x1 then {
                            if ((__EDSCR_TDA == 1 & true) & __DBGOSLSR_OSLK == 0) & (el == EL1 | el == EL3) then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                return((true, EL3))
                            }
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        if ((__PMUSERENR_EN == 0 & __PMUSERENR_ER == 0) & el == EL0) & read == 1 then {
                            throw(Error_Undefined())
                        };
                        if (__PMUSERENR_EN == 0 & el == EL0) & read == 0 then {
                            throw(Error_Undefined())
                        };
                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                            return((true, EL1))
                        };
                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                            return((true, EL2))
                        };
                        if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                            return((true, EL1))
                        };
                        if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                            return((true, EL3))
                        }
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        if __PMUSERENR_EN == 0 & el == EL0 then {
                            throw(Error_Undefined())
                        };
                        if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                            return((true, EL1))
                        };
                        if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                            return((true, EL3))
                        }
                    }
                }
            }
        };
        if (CRm & 0xE) == 0xC then {
            if CRn == 0xC then {
                if coproc == 0xF then {
                    if opc1 == 0b100 then {
                        if __ICC_HSRE_SRE == 0 & el == EL2 then {
                            throw(Error_Undefined())
                        };
                        if (__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3 then {
                            throw(Error_Undefined())
                        };
                        if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                            return((true, EL2))
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if opc1 == 0b000 then {
                    if coproc == 0xF then {
                        if __ICC_SRE_SRE == 0 & el == EL1 then {
                            throw(Error_Undefined())
                        };
                        if __ICC_HSRE_SRE == 0 & el == EL2 then {
                            throw(Error_Undefined())
                        };
                        if __ICC_MSRE_SRE == 0 & el == EL3 then {
                            throw(Error_Undefined())
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if ((__HaveEL_EL3_ & __ELUsingAArch32_EL3_) & __SCR_FIQ == 1) & (el == EL2 | el == EL3) then {
                            throw(Error_Undefined())
                        };
                        if ((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_FIQ == 1) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                            throw(Error_Undefined())
                        };
                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                            return((true, EL3))
                        };
                        if ((___ELUsingAArch32_EL3_ & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL2 then {
                            return((true, EL3))
                        };
                        if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __HaveEL_EL3_) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & el == EL1 then {
                            return((true, EL3))
                        };
                        if (((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HaveEL_EL2_) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 0) & el == EL1 then {
                            return((true, EL3))
                        };
                        if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                            throw(Error_Undefined())
                        };
                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                            return((true, EL1))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if coproc == 0xF then {
                if opc1 == 0b100 then {
                    if CRm == 0x8 then {
                        if __ICC_HSRE_SRE == 0 & el == EL2 then {
                            throw(Error_Undefined())
                        };
                        if (__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3 then {
                            throw(Error_Undefined())
                        };
                        if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                            return((true, EL2))
                        }
                    } else {
                        if CRm == 0x9 then {
                            if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                throw(Error_Undefined())
                            };
                            if (__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3 then {
                                throw(Error_Undefined())
                            };
                            if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        }
                    }
                } else {
                    if opc1 == 0b000 then {
                        if CRm == 0x9 then {
                            if __ICC_SRE_SRE == 0 & el == EL1 then {
                                throw(Error_Undefined())
                            };
                            if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                throw(Error_Undefined())
                            };
                            if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                throw(Error_Undefined())
                            };
                            if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & (el == EL2 | el == EL3) then {
                                throw(Error_Undefined())
                            };
                            if ((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __HCR_IMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                                throw(Error_Undefined())
                            };
                            if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                return((true, EL3))
                            };
                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                return((true, EL3))
                            };
                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & el == EL1 then {
                                return((true, EL3))
                            };
                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                return((true, EL3))
                            };
                            if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                                throw(Error_Undefined())
                            };
                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                return((true, EL1))
                            };
                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        }
                    }
                }
            }
        }
    };
    if coproc == 0xF then {
        if opc1 == 0b000 then {
            if opc2 == 0b001 then {
                if CRn == 0x7 then {
                    if CRm == 0xE then {
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TPC == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                            return((true, EL2))
                        }
                    } else {
                        if CRm == 0xA then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TPC == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRm == 0x8 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x5 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TPU == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0xB then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x9 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                return((true, EL3))
                            };
                            if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRn == 0x0 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID2 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TAC == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T5 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xD then {
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T13 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if CRn == 0xE then {
                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_PL0PTEN == 0) & el == EL0 then {
                                    throw(Error_Undefined())
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0PTEN == 0) & __SCR_GEN___NS == 1) & el == EL0 then {
                                    throw(Error_Undefined())
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __CNTHCTL_PL1PCEN == 0) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __MDCR_EL2_TTRF == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __MDCR_EL2_TTRF == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TTRF == 1) & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRn == 0x0 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x3 then {
                                if CRn == 0xE then {
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if (__HCR_EL2_E2H == 0 & __CNTKCTL_PL0VTEN == 0) & el == EL0 then {
                                        throw(Error_Undefined())
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0VTEN == 0) & __SCR_GEN___NS == 1) & el == EL0 then {
                                        throw(Error_Undefined())
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x8 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xC then {
                                    if CRm == 0x8 then {
                                        if (__ICC_SRE_SRE == 0 & el == EL1) & read == 0 then {
                                            throw(Error_Undefined())
                                        };
                                        if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 0 then {
                                            throw(Error_Undefined())
                                        };
                                        if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 0 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((__HaveEL_EL3_ & __ELUsingAArch32_EL3_) & __SCR_FIQ == 1) & (el == EL2 | el == EL3)) & read == 0 then {
                                            throw(Error_Undefined())
                                        };
                                        if (((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_FIQ == 1) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 0 then {
                                            return((true, EL3))
                                        };
                                        if (((___ELUsingAArch32_EL3_ & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL2) & read == 0 then {
                                            return((true, EL3))
                                        };
                                        if (((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __HaveEL_EL3_) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & el == EL1) & read == 0 then {
                                            return((true, EL3))
                                        };
                                        if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HaveEL_EL2_) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                            return((true, EL3))
                                        };
                                        if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                            throw(Error_Undefined())
                                        };
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                            return((true, EL1))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xB then {
                                            if (__ICC_SRE_SRE == 0 & el == EL1) & read == 0 then {
                                                throw(Error_Undefined())
                                            };
                                            if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 0 then {
                                                throw(Error_Undefined())
                                            };
                                            if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 0 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & __SCR_FIQ == 1) & (el == EL2 | el == EL3)) & read == 0 then {
                                                throw(Error_Undefined())
                                            };
                                            if (((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __SCR_FIQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & el == EL1) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TDIR == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TDIR == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                throw(Error_Undefined())
                                            };
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TDIR == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TDIR == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0xC then {
                                                if (__ICC_SRE_SRE == 0 & el == EL1) & read == 0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & (el == EL2 | el == EL3)) & read == 0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __HCR_IMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x0 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0x5 then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T5 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xD then {
                                                if __PMUSERENR_EN == 0 & el == EL0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if CRm == 0xE then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                } else {
                                                    if CRm == 0xC then {
                                                        if __PMUSERENR_EN == 0 & el == EL0 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x8 then {
                                                if CRm == 0x5 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRm == 0x7 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if opc2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRn == 0x5 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T5 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0xD then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T13 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x6 then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T6 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x3 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T3 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T3 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T3 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if (((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PCTEN == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if (((__HCR_EL2_E2H == 0 & __CNTKCTL_PL0PCTEN == 0) & __CNTKCTL_PL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PCTEN == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if ((((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0PCTEN == 0) & __CNTKCTL_PL0VCTEN == 0) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & __CNTHCTL_EL2_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0x1 then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRn == 0x0 then {
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRn == 0x2 then {
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xC then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x7 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TPU == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x0 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T5 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if CRm == 0x8 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x9 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x8 then {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_PL0PTEN == 0) & el == EL0 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0PTEN == 0) & __SCR_GEN___NS == 1) & el == EL0 then {
                                                throw(Error_Undefined())
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __CNTHCTL_PL1PCEN == 0) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x0 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xD then {
                                                if ((__PMUSERENR_CR == 0 & __PMUSERENR_EN == 0) & el == EL0) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (__PMUSERENR_EN == 0 & el == EL0) & read == 0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if CRm == 0xE then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                } else {
                                                    if CRm == 0xC then {
                                                        if __PMUSERENR_EN == 0 & el == EL0 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPMCR == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPMCR == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0x8 then {
                                                    if (__ICC_SRE_SRE == 0 & el == EL1) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__HaveEL_EL3_ & __ELUsingAArch32_EL3_) & __SCR_FIQ == 1) & (el == EL2 | el == EL3)) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_FIQ == 1) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((___ELUsingAArch32_EL3_ & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL2) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __HaveEL_EL3_) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HaveEL_EL2_) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0xC then {
                                                        if (__ICC_SRE_SRE == 0 & el == EL1) & read == 1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & (el == EL2 | el == EL3)) & read == 1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __HCR_IMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL3))
                                                        };
                                                        if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                                            return((true, EL3))
                                                        };
                                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & el == EL1) & read == 1 then {
                                                            return((true, EL3))
                                                        };
                                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 1 then {
                                                            return((true, EL3))
                                                        };
                                                        if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if CRn == 0xE then {
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_PL0VTEN == 0) & el == EL0 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_PL0VTEN == 0) & __SCR_GEN___NS == 1) & el == EL0 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRn == 0xA then {
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0x4 then {
                                                            if __ICC_SRE_SRE == 0 & el == EL1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & __SCR_FIQ == 1) & (el == EL2 | el == EL3) then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if ((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __SCR_FIQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                                return((true, EL3))
                                                            };
                                                            if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                                return((true, EL3))
                                                            };
                                                            if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & el == EL1 then {
                                                                return((true, EL3))
                                                            };
                                                            if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                                return((true, EL3))
                                                            };
                                                            if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                                return((true, EL1))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b010 then {
                        if CRm == 0x0 then {
                            if CRn == 0x2 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T6 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCPTR_TCPAC == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRn == 0x0 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID1 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xD then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T13 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T13 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T13 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if CRm == 0x8 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0xA then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TSW == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x8 then {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            if ((__PMUSERENR_EN == 0 & __PMUSERENR_ER == 0) & el == EL0) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if (__PMUSERENR_EN == 0 & el == EL0) & read == 0 then {
                                                throw(Error_Undefined())
                                            };
                                            if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                                return((true, EL1))
                                            };
                                            if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if CRm == 0xC then {
                                                    if __PMUSERENR_EN == 0 & el == EL0 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0x8 then {
                                                if (__ICC_SRE_SRE == 0 & el == EL1) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__HaveEL_EL3_ & __ELUsingAArch32_EL3_) & __SCR_FIQ == 1) & (el == EL2 | el == EL3)) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_FIQ == 1) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL3))
                                                };
                                                if (((___ELUsingAArch32_EL3_ & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL2) & read == 1 then {
                                                    return((true, EL3))
                                                };
                                                if (((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __HaveEL_EL3_) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & el == EL1) & read == 1 then {
                                                    return((true, EL3))
                                                };
                                                if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HaveEL_EL2_) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                                    return((true, EL3))
                                                };
                                                if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0xC then {
                                                    if (__ICC_SRE_SRE == 0 & el == EL1) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & (el == EL2 | el == EL3)) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __HCR_IMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x1 then {
                                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRn == 0x0 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x2 then {
                                                    if CRn == 0x0 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b011 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TRVM == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TAC == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x0 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID1 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xD then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T13 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T13 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T13 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xC then {
                                    if CRm == 0x8 then {
                                        if __ICC_SRE_SRE == 0 & el == EL1 then {
                                            throw(Error_Undefined())
                                        };
                                        if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                            throw(Error_Undefined())
                                        };
                                        if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                            throw(Error_Undefined())
                                        };
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__HaveEL_EL3_ & __ELUsingAArch32_EL3_) & __SCR_FIQ == 1) & (el == EL2 | el == EL3) then {
                                            throw(Error_Undefined())
                                        };
                                        if ((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_FIQ == 1) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            throw(Error_Undefined())
                                        };
                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                                            return((true, EL3))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL2 then {
                                            return((true, EL3))
                                        };
                                        if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __HaveEL_EL3_) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & el == EL1 then {
                                            return((true, EL3))
                                        };
                                        if (((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HaveEL_EL2_) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                            return((true, EL3))
                                        };
                                        if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                                            throw(Error_Undefined())
                                        };
                                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                            return((true, EL1))
                                        };
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xB then {
                                            if (__ICC_SRE_SRE == 0 & el == EL1) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if (__ICC_MSRE_SRE == 0 & el == EL3) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & __SCR_FIQ == 1) & (el == EL2 | el == EL3)) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if (((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __SCR_FIQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & el == EL1) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0xC then {
                                                if __ICC_SRE_SRE == 0 & el == EL1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                                    throw(Error_Undefined())
                                                };
                                                if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & (el == EL2 | el == EL3) then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __HCR_IMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    throw(Error_Undefined())
                                                };
                                                if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                    return((true, EL1))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x8 then {
                                        if CRm == 0x7 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xE then {
                                                if __PMUSERENR_EN == 0 & el == EL0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if CRm == 0xC then {
                                                    if __PMUSERENR_EN == 0 & el == EL0 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x0 then {
                                                if CRm == 0x2 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x1 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x8 then {
                                                    if CRn == 0x7 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if CRm == 0x8 then {
                                    if opc2 == 0b101 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 0 & __ELUsingAArch32_EL1_) & ___ELUsingAArch32_EL3_) & el == EL1 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if opc2 == 0b100 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 0 & __ELUsingAArch32_EL1_) & ___ELUsingAArch32_EL3_) & el == EL1 then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if opc2 == 0b110 then {
                                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 0 & __ELUsingAArch32_EL1_) & ___ELUsingAArch32_EL3_) & el == EL1 then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if opc2 == 0b111 then {
                                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((__SCR_EL3_NS == 0 & ~(__ELUsingAArch32_EL2_)) & __SCR_EL3_EEL2 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 0 & __ELUsingAArch32_EL1_) & ___ELUsingAArch32_EL3_) & el == EL1 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x3 then {
                                        if opc2 == 0b101 then {
                                            if ((((__ELUsingAArch32_EL2_ | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL1_) & __SCTLR_EnRCTX == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & (__HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0)) & ___ELUsingAArch32_EL1_) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((~(__ELUsingAArch32_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & (el == EL1 | el == EL0) then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if opc2 == 0b100 then {
                                                if ((((__ELUsingAArch32_EL2_ | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL1_) & __SCTLR_EnRCTX == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & (__HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0)) & ___ELUsingAArch32_EL1_) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((~(__ELUsingAArch32_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & (el == EL1 | el == EL0) then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if opc2 == 0b111 then {
                                                    if ((((__ELUsingAArch32_EL2_ | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL1_) & __SCTLR_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) & (__HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0)) & ___ELUsingAArch32_EL1_) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((~(__ELUsingAArch32_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & (el == EL1 | el == EL0) then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if opc2 == 0b100 then {
                                                if (if __ELUsingAArch32_EL1_ then __SCTLR_CP15BEN else __SCTLR___CP15BEN) == 0 & ((el == EL0 | el == EL1) | el == EL3) then {
                                                    throw(Error_Undefined())
                                                };
                                                if __SCTLR___CP15BEN == 0 & el == EL0 then {
                                                    throw(Error_Undefined())
                                                };
                                                if __HSCTLR_CP15BEN == 0 & el == EL2 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if opc2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if opc2 == 0b111 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xA then {
                                                if opc2 == 0b101 then {
                                                    if (if __ELUsingAArch32_EL1_ then __SCTLR_CP15BEN else __SCTLR___CP15BEN) == 0 & ((el == EL0 | el == EL1) | el == EL3) then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if __SCTLR___CP15BEN == 0 & el == EL0 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if __HSCTLR_CP15BEN == 0 & el == EL2 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if opc2 == 0b100 then {
                                                        if (if __ELUsingAArch32_EL1_ then __SCTLR_CP15BEN else __SCTLR___CP15BEN) == 0 & ((el == EL0 | el == EL1) | el == EL3) then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if __SCTLR___CP15BEN == 0 & el == EL0 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if __HSCTLR_CP15BEN == 0 & el == EL2 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if opc2 == 0b110 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x0 then {
                                    if CRm == 0x1 then {
                                        if opc2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if opc2 == 0b100 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if opc2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if opc2 == 0b111 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x2 then {
                                            if opc2 == 0b101 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if opc2 == 0b100 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if opc2 == 0b111 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if opc2 == 0b101 then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID1 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if opc2 == 0b100 then {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID3 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0xC then {
                                        if CRn == 0xC then {
                                            if opc2 == 0b101 then {
                                                if (__ELUsingAArch32_EL3_ & __ICC_MSRE_Enable == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __ICC_SRE_EL3_Enable == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                };
                                                if (~(__ELUsingAArch32_EL2_) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__ELUsingAArch32_EL2_ & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (__ELUsingAArch32_EL2_ & __ICC_HSRE_Enable == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (~(__ELUsingAArch32_EL2_) & __ICC_SRE_EL2_Enable == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if opc2 == 0b100 then {
                                                    if __ICC_SRE_SRE == 0 & el == EL1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & __SCR_FIQ == 1) & (el == EL2 | el == EL3) then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __SCR_FIQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & __HCR_FMO == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        if __ICC_SRE_SRE == 0 & el == EL1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__HaveEL_EL3_ & __ELUsingAArch32_EL3_) & __SCR_FIQ == 1) & (el == EL2 | el == EL3) then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if ((((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_FIQ == 1) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                                                            return((true, EL3))
                                                        };
                                                        if ((___ELUsingAArch32_EL3_ & __HaveEL_EL3_) & __SCR_EL3_FIQ == 1) & el == EL2 then {
                                                            return((true, EL3))
                                                        };
                                                        if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __HaveEL_EL3_) & __HaveEL_EL2_) & __ELUsingAArch32_EL2_) & __HCR_FMO == 0) & el == EL1 then {
                                                            return((true, EL3))
                                                        };
                                                        if (((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HaveEL_EL2_) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                            return((true, EL3))
                                                        };
                                                        if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                            return((true, EL1))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if opc2 == 0b111 then {
                                                            if __ICC_SRE_SRE == 0 & el == EL1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (__ELUsingAArch32_EL3_ & __SCR_IRQ == 1) & (el == EL2 | el == EL3) then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if ((((__ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_IRQ == 1) & __HCR_IMO == 0) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                                return((true, EL3))
                                                            };
                                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                                return((true, EL3))
                                                            };
                                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_IMO == 0) & el == EL1 then {
                                                                return((true, EL3))
                                                            };
                                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                                                return((true, EL3))
                                                            };
                                                            if (__ICC_SRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                                return((true, EL1))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_TALL1 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if opc2 == 0b101 then {
                                                    if (__PMUSERENR_EN == 0 & __PMUSERENR_ER == 0) & el == EL0 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                } else {
                                                    if opc2 == 0b100 then {
                                                        if ((__PMUSERENR_EN == 0 & __PMUSERENR_SW == 0) & el == EL0) & read == 0 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_SW == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_SW == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL0) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 0 then {
                                                            return((true, EL3))
                                                        }
                                                    } else {
                                                        if opc2 == 0b110 then {
                                                            if (__PMUSERENR_EN == 0 & el == EL0) & read == 1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                                return((true, EL1))
                                                            };
                                                            if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                                return((true, EL3))
                                                            }
                                                        } else {
                                                            if opc2 == 0b111 then {
                                                                if (__PMUSERENR_EN == 0 & el == EL0) & read == 1 then {
                                                                    throw(Error_Undefined())
                                                                };
                                                                if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                                    return((true, EL1))
                                                                };
                                                                if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                                    return((true, EL3))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x8 then {
                                            if opc2 == 0b111 then {
                                                if CRm == 0x7 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if opc2 == 0b101 then {
                                                    if CRm == 0x7 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if CRn == 0x9 then {
                                                    if opc2 == 0b101 then {
                                                        if (__PMUSERENR_EN == 0 & el == EL0) & read == 1 then {
                                                            throw(Error_Undefined())
                                                        };
                                                        if (__PMUSERENR_EL0_EN == 0 & el == EL0) & read == 1 then {
                                                            return((true, EL1))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                            return((true, EL3))
                                                        }
                                                    } else {
                                                        if opc2 == 0b100 then {
                                                            if (__PMUSERENR_EN == 0 & el == EL0) & read == 1 then {
                                                                throw(Error_Undefined())
                                                            };
                                                            if (__PMUSERENR_EL0_EN == 0 & el == EL0) & read == 1 then {
                                                                return((true, EL1))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL0) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL0) & read == 1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T9 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                                return((true, EL3))
                                                            }
                                                        } else {
                                                            if opc2 == 0b110 then {
                                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T9 == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((__HaveEL_EL3_ & ___ELUsingAArch32_EL3_) & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                                    return((true, EL3))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x0 then {
                                                    if opc2 == 0b100 then {
                                                        if CRn == 0xD then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T13 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    if CRn == 0xE then {
                                                        if opc2 == 0b111 then {
                                                            if CRm == 0xF then {
                                                                if __PMUSERENR_EN == 0 & el == EL0 then {
                                                                    throw(Error_Undefined())
                                                                };
                                                                if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                                    return((true, EL1))
                                                                };
                                                                if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TPM == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1) then {
                                                                    return((true, EL2))
                                                                };
                                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                                    return((true, EL3))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if opc1 == 0b100 then {
                if CRm == 0x0 then {
                    if opc2 == 0b010 then {
                        if CRn == 0xC then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRn == 0x2 then {
                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T6 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T13 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T13 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b000 then {
                            if CRn == 0xC then {
                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T6 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x0 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x8 then {
                                if opc2 == 0b101 then {
                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if opc2 == 0b001 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if opc2 == 0b001 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if opc2 == 0b011 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if opc2 == 0b101 then {
                                        if CRn == 0x0 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if opc2 == 0b100 then {
                                            if CRn == 0x6 then {
                                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T6 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T6 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b001 then {
                        if CRm == 0x2 then {
                            if CRn == 0xE then {
                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TTRF == 1) & el == EL2 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x8 then {
                                if CRm == 0x4 then {
                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x7 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL2 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T5 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x8 then {
                                            if CRn == 0x7 then {
                                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRn == 0xA then {
                                                if CRm == 0x3 then {
                                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b000 then {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T5 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T5 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T5 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x8 then {
                                        if CRm == 0x7 then {
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x8 then {
                                                if CRn == 0x7 then {
                                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T7 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if CRm == 0x3 then {
                                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T10 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T10 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if CRm == 0xB then {
                                    if opc2 == 0b010 then {
                                        if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3) & read == 1 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if opc2 == 0b101 then {
                                            if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3) & read == 1 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if opc2 == 0b111 then {
                                                if __ICC_HSRE_SRE == 0 & el == EL2 then {
                                                    throw(Error_Undefined())
                                                };
                                                if (__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3 then {
                                                    throw(Error_Undefined())
                                                };
                                                if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if opc2 == 0b011 then {
                                                    if (__ICC_HSRE_SRE == 0 & el == EL2) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((__ICC_MSRE_SRE == 0 & __SCR_GEN___NS == 1) & el == EL3) & read == 1 then {
                                                        throw(Error_Undefined())
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if opc2 == 0b101 then {
                                        if CRm == 0x9 then {
                                            if __ICC_MSRE_Enable == 0 & el == EL2 then {
                                                throw(Error_Undefined())
                                            };
                                            if __ICC_SRE_EL3_Enable == 0 & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        if opc2 == 0b010 then {
                                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if opc2 == 0b100 then {
                                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if opc2 == 0b111 then {
                                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if opc2 == 0b011 then {
                                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T1 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T1 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if opc2 == 0b010 then {
                                            if CRn == 0x2 then {
                                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T2 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x8 then {
                                        if opc2 == 0b101 then {
                                            if CRm == 0x4 then {
                                                if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x7 then {
                                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if opc2 == 0b100 then {
                                                if CRm == 0x7 then {
                                                    if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if (((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T8 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRm == 0x0 then {
                    if CRn == 0x0 then {
                        if opc1 == 0b001 then {
                            if opc2 == 0b010 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID2 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if opc2 == 0b000 then {
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID2 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if opc2 == 0b001 then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID2 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if opc2 == 0b111 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID1 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc1 == 0b010 then {
                                if opc2 == 0b000 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HSTR_EL2_T0 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HSTR_EL2_T0 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID2 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T0 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0xC then {
                        if opc1 == 0b110 then {
                            if CRm == 0xC then {
                                if opc2 == 0b101 then {
                                    if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if opc2 == 0b100 then {
                                        if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if opc2 == 0b111 then {
                                            if __ICC_MSRE_SRE == 0 & el == EL3 then {
                                                throw(Error_Undefined())
                                            };
                                            if ((__SCR_EL3_NS == 1 & ~(__ELUsingAArch32_EL2_)) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HSTR_T12 == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if coproc == 0xE then {
            if opc1 == 0b000 then {
                if CRn == 0x0 then {
                    if opc2 == 0b000 then {
                        if CRm == 0x0 then {
                            if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 1 then {
                                throw(Error_Undefined())
                            };
                            if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                return((true, EL1))
                            };
                            if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                return((true, EL2))
                            };
                            if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                return((true, EL3))
                            }
                        } else {
                            if CRm == 0x2 then {
                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                }
                            } else {
                                if CRm == 0x5 then {
                                    if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 1 then {
                                        throw(Error_Undefined())
                                    };
                                    if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                        return((true, EL1))
                                    };
                                    if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    };
                                    if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 0 then {
                                        throw(Error_Undefined())
                                    };
                                    if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                        return((true, EL1))
                                    };
                                    if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 0 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 1 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b010 then {
                            if CRm == 0x2 then {
                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x6 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0x7 then {
                        if opc2 == 0b110 then {
                            if CRm == 0x8 then {
                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                }
                            } else {
                                if CRm == 0xE then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x9 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b111 then {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDA == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDA == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x1 then {
                            if opc2 == 0b100 then {
                                if CRm == 0x0 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDOSA == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDOSA == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2)) & read == 0 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x4 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDOSA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDOSA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDOSA == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDOSA == 1) & __SCR_GEN___NS == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDOSA == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDOSA == 1) & __SCR_GEN___NS == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if opc2 == 0b000 then {
                                        if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 1 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDRA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDRA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if opc2 == 0b000 then {
                                    if CRn == 0x2 then {
                                        if (__DBGDSCRext_UDCCdis == 1 & el == EL0) & read == 1 then {
                                            throw(Error_Undefined())
                                        };
                                        if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __MDCR_EL2_TDRA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HDCR_TDRA == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                            return((true, EL3))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRm == 0x0 then {
                    if opc2 == 0b000 then {
                        if opc1 == 0b111 then {
                            if CRn == 0x0 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID0 == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ~(__ELUsingAArch32_EL2_)) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID0 == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 & __ELUsingAArch32_EL2_) & __HCR_TID0 == 1) & __SCR_GEN___NS == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                    return((true, EL2))
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    return((false, EL0))
}

val AArch32_AutoGen_SysRegRead32 : (bits(2), bits(4), bits(3), bits(4), bits(3), bits(4), bits(1)) -> bits(32) effect {escape, rreg, undef}

function AArch32_AutoGen_SysRegRead32 (el, coproc, opc1, CRn, opc2, CRm, read) = {
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let ___ELUsingAArch32_EL3_ = ~(ELUsingAArch32(EL3));
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    if (CRm & 0x0) == 0x0 then {
        if opc1 == 0b000 then {
            if coproc == 0xE then {
                if CRn == 0x0 then {
                    if opc2 == 0b101 then {
                        return(DBGBCR[UInt(slice(CRm, 0, 4))])
                    } else {
                        if opc2 == 0b100 then {
                            return(DBGBVR[UInt(slice(CRm, 0, 4))])
                        } else {
                            if opc2 == 0b110 then {
                                return(DBGWVR[UInt(slice(CRm, 0, 4))])
                            } else {
                                if opc2 == 0b111 then {
                                    return(DBGWCR[UInt(slice(CRm, 0, 4))])
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b001 then {
                        if CRn == 0x1 then {
                            return(DBGBXVR[UInt(slice(CRm, 0, 4))])
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        return(PMEVCNTR[UInt(slice(CRm, 0, 2) @ slice(opc2, 0, 3))])
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        return(PMEVTYPER[UInt(slice(CRm, 0, 2) @ slice(opc2, 0, 3))])
                    }
                }
            }
        };
        if (CRm & 0xE) == 0xC then {
            if CRn == 0xC then {
                if coproc == 0xF then {
                    if opc1 == 0b100 then {
                        return(ICH_LR[UInt(slice(opc2, 0, 3))])
                    }
                }
            }
        }
    };
    if (opc2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if opc1 == 0b000 then {
                    if coproc == 0xF then {
                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            return(ICV_AP0R[UInt(slice(opc2, 0, 2))])
                        } else {
                            return(ICC_AP0R[UInt(slice(opc2, 0, 2))])
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if coproc == 0xF then {
                if opc1 == 0b100 then {
                    if CRm == 0x8 then {
                        return(ICH_AP0R[UInt(slice(opc2, 0, 2))])
                    } else {
                        if CRm == 0x9 then {
                            return(ICH_AP1R[UInt(slice(opc2, 0, 2))])
                        }
                    }
                } else {
                    if opc1 == 0b000 then {
                        if CRm == 0x9 then {
                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(ICV_AP1R[UInt(slice(opc2, 0, 2))])
                            } else {
                                if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    return(ICC_AP1R[UInt(slice(opc2, 0, 2))])
                                } else {
                                    return(ICC_AP1R[UInt(slice(opc2, 0, 2))])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if coproc == 0xF then {
        if opc1 == 0b000 then {
            if CRm == 0x0 then {
                if opc2 == 0b000 then {
                    if CRn == 0xC then {
                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                            return(VBAR_S)
                        } else {
                            return(get_VBAR_NS())
                        }
                    } else {
                        if CRn == 0x5 then {
                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                return(DFSR_S)
                            } else {
                                return(get_DFSR_NS())
                            }
                        } else {
                            if CRn == 0xD then {
                                return(FCSEIDR)
                            } else {
                                if CRn == 0x6 then {
                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                        return(get_DFAR_S())
                                    } else {
                                        return(get_DFAR_NS())
                                    }
                                } else {
                                    if CRn == 0x3 then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            return(DACR_S)
                                        } else {
                                            return(get_DACR_NS())
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            return(get_CNTFRQ())
                                        } else {
                                            if CRn == 0x1 then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    return(SCTLR_S)
                                                } else {
                                                    return(get_SCTLR_NS())
                                                }
                                            } else {
                                                if CRn == 0x0 then {
                                                    return(get_MIDR())
                                                } else {
                                                    if CRn == 0x2 then {
                                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                            return(slice(TTBR0_S, 0, 32))
                                                        } else {
                                                            return(slice(get_TTBR0_NS(), 0, 32))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b010 then {
                        if CRn == 0xC then {
                            return(get_RMR())
                        } else {
                            if CRn == 0x2 then {
                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    return(TTBCR_S)
                                } else {
                                    return(get_TTBCR_NS())
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                        return(get_IFAR_S())
                                    } else {
                                        return(get_IFAR_NS())
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        return(get_CPACR())
                                    } else {
                                        if CRn == 0x0 then {
                                            return(TCMTR)
                                        } else {
                                            if CRn == 0xD then {
                                                if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    return(TPIDRURW_S)
                                                } else {
                                                    return(get_TPIDRURW_NS())
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b001 then {
                            if CRn == 0xC then {
                                if (el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1 then {
                                    return(MVBAR)
                                } else {
                                    return(RVBAR)
                                }
                            } else {
                                if CRn == 0xD then {
                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                        return(CONTEXTIDR_S)
                                    } else {
                                        return(get_CONTEXTIDR_NS())
                                    }
                                } else {
                                    if CRn == 0x0 then {
                                        return(get_CTR())
                                    } else {
                                        if CRn == 0x1 then {
                                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                return(ACTLR_S)
                                            } else {
                                                return(get_ACTLR_NS())
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    return(IFSR_S)
                                                } else {
                                                    return(get_IFSR_NS())
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        return(slice(TTBR1_S, 0, 32))
                                                    } else {
                                                        return(slice(get_TTBR1_NS(), 0, 32))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b011 then {
                                if CRn == 0x2 then {
                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                        return(TTBCR2_S)
                                    } else {
                                        return(get_TTBCR2_NS())
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            return(ACTLR2_S)
                                        } else {
                                            return(get_ACTLR2_NS())
                                        }
                                    } else {
                                        if CRn == 0x0 then {
                                            return(TLBTR)
                                        } else {
                                            if CRn == 0xD then {
                                                if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    return(TPIDRURO_S)
                                                } else {
                                                    return(get_TPIDRURO_NS())
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x0 then {
                                    if opc2 == 0b101 then {
                                        return(get_MPIDR())
                                    } else {
                                        if opc2 == 0b110 then {
                                            return(get_REVIDR())
                                        }
                                    }
                                } else {
                                    if opc2 == 0b100 then {
                                        if CRn == 0xD then {
                                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                return(TPIDRPRW_S)
                                            } else {
                                                return(get_TPIDRPRW_NS())
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0x0 then {
                    if CRm == 0x1 then {
                        if opc2 == 0b010 then {
                            return(get_ID_DFR0())
                        } else {
                            if opc2 == 0b011 then {
                                return(get_ID_AFR0())
                            } else {
                                if opc2 == 0b110 then {
                                    return(get_ID_MMFR2())
                                } else {
                                    if opc2 == 0b101 then {
                                        return(get_ID_MMFR1())
                                    } else {
                                        if opc2 == 0b000 then {
                                            return(get_ID_PFR0())
                                        } else {
                                            if opc2 == 0b100 then {
                                                return(get_ID_MMFR0())
                                            } else {
                                                if opc2 == 0b001 then {
                                                    return(get_ID_PFR1())
                                                } else {
                                                    if opc2 == 0b111 then {
                                                        return(get_ID_MMFR3())
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if opc2 == 0b010 then {
                                return(get_ID_ISAR2())
                            } else {
                                if opc2 == 0b011 then {
                                    return(get_ID_ISAR3())
                                } else {
                                    if opc2 == 0b110 then {
                                        return(get_ID_MMFR4())
                                    } else {
                                        if opc2 == 0b101 then {
                                            return(get_ID_ISAR5())
                                        } else {
                                            if opc2 == 0b000 then {
                                                return(get_ID_ISAR0())
                                            } else {
                                                if opc2 == 0b100 then {
                                                    return(get_ID_ISAR4())
                                                } else {
                                                    if opc2 == 0b001 then {
                                                        return(get_ID_ISAR1())
                                                    } else {
                                                        if opc2 == 0b111 then {
                                                            return(get_ID_ISAR6())
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b100 then {
                                if CRm == 0x3 then {
                                    return(get_ID_PFR2())
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0x9 then {
                        if CRm == 0xE then {
                            if opc2 == 0b010 then {
                                return(get_PMINTENCLR())
                            } else {
                                if opc2 == 0b011 then {
                                    return(get_PMOVSSET())
                                } else {
                                    if opc2 == 0b101 then {
                                        return(get_PMCEID3())
                                    } else {
                                        if opc2 == 0b000 then {
                                            return(get_PMUSERENR())
                                        } else {
                                            if opc2 == 0b100 then {
                                                return(get_PMCEID2())
                                            } else {
                                                if opc2 == 0b001 then {
                                                    return(get_PMINTENSET())
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        return(PMMIR)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0xC then {
                                if opc2 == 0b010 then {
                                    return(get_PMCNTENCLR())
                                } else {
                                    if opc2 == 0b011 then {
                                        return(get_PMOVSR())
                                    } else {
                                        if opc2 == 0b000 then {
                                            return(get_PMCR())
                                        } else {
                                            if opc2 == 0b101 then {
                                                return(get_PMSELR())
                                            } else {
                                                if opc2 == 0b001 then {
                                                    return(get_PMCNTENSET())
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        return(get_PMCEID0())
                                                    } else {
                                                        if opc2 == 0b111 then {
                                                            return(get_PMCEID1())
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xD then {
                                    if opc2 == 0b010 then {
                                        return(get_PMXEVCNTR())
                                    } else {
                                        if opc2 == 0b000 then {
                                            return(slice(get_PMCCNTR(), 0, 32))
                                        } else {
                                            if opc2 == 0b001 then {
                                                return(get_PMXEVTYPER())
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xC then {
                            if CRm == 0xC then {
                                if opc2 == 0b010 then {
                                    if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(get_ICV_HPPIR1())
                                    } else {
                                        return(get_ICC_HPPIR1())
                                    }
                                } else {
                                    if opc2 == 0b011 then {
                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(get_ICV_BPR1())
                                        } else {
                                            if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                return(get_ICC_BPR1_S())
                                            } else {
                                                return(get_ICC_BPR1_NS())
                                            }
                                        }
                                    } else {
                                        if opc2 == 0b101 then {
                                            if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                return(get_ICC_SRE_S())
                                            } else {
                                                return(get_ICC_SRE_NS())
                                            }
                                        } else {
                                            if opc2 == 0b000 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(get_ICV_IAR1())
                                                } else {
                                                    return(get_ICC_IAR1())
                                                }
                                            } else {
                                                if opc2 == 0b100 then {
                                                    if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        return(get_ICC_CTLR_S())
                                                    } else {
                                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(get_ICV_CTLR())
                                                        } else {
                                                            return(get_ICC_CTLR_NS())
                                                        }
                                                    }
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(get_ICV_IGRPEN0())
                                                        } else {
                                                            return(get_ICC_IGRPEN0())
                                                        }
                                                    } else {
                                                        if opc2 == 0b111 then {
                                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                                return(get_ICV_IGRPEN1())
                                                            } else {
                                                                if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                                    return(get_ICC_IGRPEN1_S())
                                                                } else {
                                                                    return(get_ICC_IGRPEN1_NS())
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x8 then {
                                    if opc2 == 0b010 then {
                                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(get_ICV_HPPIR0())
                                        } else {
                                            return(get_ICC_HPPIR0())
                                        }
                                    } else {
                                        if opc2 == 0b000 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(get_ICV_IAR0())
                                            } else {
                                                return(get_ICC_IAR0())
                                            }
                                        } else {
                                            if opc2 == 0b011 then {
                                                if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(get_ICV_BPR0())
                                                } else {
                                                    return(get_ICC_BPR0())
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if opc2 == 0b000 then {
                                        if CRm == 0x1 then {
                                            return(get_ISR())
                                        }
                                    } else {
                                        if CRm == 0xB then {
                                            if opc2 == 0b011 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(get_ICV_RPR())
                                                } else {
                                                    return(get_ICC_RPR())
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b000 then {
                                if CRm == 0x1 then {
                                    if CRn == 0xE then {
                                        return(get_CNTKCTL())
                                    } else {
                                        if CRn == 0x1 then {
                                            return(get_SCR())
                                        } else {
                                            if CRn == 0x5 then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    return(ADFSR_S)
                                                } else {
                                                    return(get_ADFSR_NS())
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                return(CNTP_TVAL_S)
                                            } else {
                                                if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                    return(get_CNTHP_TVAL())
                                                } else {
                                                    return(get_CNTP_TVAL_NS())
                                                }
                                            }
                                        } else {
                                            if CRn == 0xA then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    return(MAIR0_S);
                                                    return(PRRR_S)
                                                } else {
                                                    return(get_MAIR0_NS());
                                                    return(get_PRRR_NS())
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if CRn == 0xE then {
                                                if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(get_CNTHV_TVAL())
                                                } else {
                                                    return(get_CNTV_TVAL())
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        return(AMAIR0_S)
                                                    } else {
                                                        return(get_AMAIR0_NS())
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0x7 then {
                                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        return(slice(PAR_S, 0, 32))
                                                    } else {
                                                        return(slice(get_PAR_NS(), 0, 32))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if CRn == 0x4 then {
                                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(get_ICV_PMR())
                                                        } else {
                                                            return(get_ICC_PMR())
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if opc2 == 0b001 then {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                return(CNTP_CTL_S)
                                            } else {
                                                if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                    return(get_CNTHP_CTL())
                                                } else {
                                                    return(get_CNTP_CTL_NS())
                                                }
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                return(get_TRFCR())
                                            } else {
                                                if CRn == 0xA then {
                                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        return(MAIR1_S);
                                                        return(NMRR_S)
                                                    } else {
                                                        return(get_MAIR1_NS());
                                                        return(get_NMRR_NS())
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if CRn == 0xE then {
                                                if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(get_CNTHV_CTL())
                                                } else {
                                                    return(get_CNTV_CTL())
                                                }
                                            } else {
                                                if CRn == 0x1 then {
                                                    return(get_SDCR())
                                                } else {
                                                    if CRn == 0xA then {
                                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                            return(AMAIR1_S)
                                                        } else {
                                                            return(get_AMAIR1_NS())
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x1 then {
                                                    return(get_SDER())
                                                } else {
                                                    if CRn == 0x5 then {
                                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                            return(AIFSR_S)
                                                        } else {
                                                            return(get_AIFSR_NS())
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if opc2 == 0b010 then {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                return(NSACR)
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if opc2 == 0b111 then {
                                                if CRm == 0xF then {
                                                    return(get_PMCCFILTR())
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if opc1 == 0b100 then {
                if CRm == 0x0 then {
                    if opc2 == 0b010 then {
                        if CRn == 0xC then {
                            return(get_HRMR())
                        } else {
                            if CRn == 0x2 then {
                                return(get_HTCR())
                            } else {
                                if CRn == 0x6 then {
                                    return(get_HIFAR())
                                } else {
                                    if CRn == 0xD then {
                                        return(get_HTPIDR())
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b000 then {
                            if CRn == 0xC then {
                                return(get_HVBAR())
                            } else {
                                if CRn == 0x6 then {
                                    return(get_HDFAR())
                                } else {
                                    if CRn == 0x1 then {
                                        return(get_HSCTLR())
                                    } else {
                                        if CRn == 0x0 then {
                                            return(get_VPIDR())
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x1 then {
                                if opc2 == 0b001 then {
                                    return(get_HACTLR())
                                } else {
                                    if opc2 == 0b011 then {
                                        return(get_HACTLR2())
                                    }
                                }
                            } else {
                                if opc2 == 0b101 then {
                                    if CRn == 0x0 then {
                                        return(get_VMPIDR())
                                    }
                                } else {
                                    if opc2 == 0b100 then {
                                        if CRn == 0x6 then {
                                            return(get_HPFAR())
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x1 then {
                        if CRn == 0x1 then {
                            if opc2 == 0b010 then {
                                return(get_HCPTR())
                            } else {
                                if opc2 == 0b000 then {
                                    return(get_HCR())
                                } else {
                                    if opc2 == 0b001 then {
                                        return(get_HDCR())
                                    } else {
                                        if opc2 == 0b100 then {
                                            return(get_HCR2())
                                        } else {
                                            if opc2 == 0b111 then {
                                                return(get_HACR())
                                            } else {
                                                if opc2 == 0b011 then {
                                                    return(get_HSTR())
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x5 then {
                                if opc2 == 0b000 then {
                                    return(get_HADFSR())
                                } else {
                                    if opc2 == 0b001 then {
                                        return(get_HAIFSR())
                                    }
                                }
                            } else {
                                if opc2 == 0b010 then {
                                    if CRn == 0x2 then {
                                        return(get_VTCR())
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if opc2 == 0b000 then {
                                            return(get_CNTHCTL())
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xC then {
                            if CRm == 0xB then {
                                if opc2 == 0b010 then {
                                    return(get_ICH_MISR())
                                } else {
                                    if opc2 == 0b000 then {
                                        return(get_ICH_HCR())
                                    } else {
                                        if opc2 == 0b101 then {
                                            return(get_ICH_ELRSR())
                                        } else {
                                            if opc2 == 0b001 then {
                                                return(get_ICH_VTR())
                                            } else {
                                                if opc2 == 0b111 then {
                                                    return(get_ICH_VMCR())
                                                } else {
                                                    if opc2 == 0b011 then {
                                                        return(get_ICH_EISR())
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if opc2 == 0b101 then {
                                    if CRm == 0x9 then {
                                        return(get_ICC_HSRE())
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if opc2 == 0b000 then {
                                    if CRn == 0xE then {
                                        return(get_CNTHP_TVAL())
                                    } else {
                                        if CRn == 0xA then {
                                            return(get_HMAIR0())
                                        } else {
                                            if CRn == 0x5 then {
                                                return(get_HSR())
                                            }
                                        }
                                    }
                                } else {
                                    if opc2 == 0b001 then {
                                        if CRn == 0xE then {
                                            return(get_CNTHP_CTL())
                                        } else {
                                            if CRn == 0x1 then {
                                                return(get_HTRFCR())
                                            } else {
                                                if CRn == 0xA then {
                                                    return(get_HMAIR1())
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x3 then {
                                        if opc2 == 0b000 then {
                                            return(get_HAMAIR0())
                                        } else {
                                            if opc2 == 0b001 then {
                                                return(get_HAMAIR1())
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRm == 0x0 then {
                    if CRn == 0x0 then {
                        if opc1 == 0b001 then {
                            if opc2 == 0b010 then {
                                return(get_CCSIDR2())
                            } else {
                                if opc2 == 0b000 then {
                                    return(get_CCSIDR())
                                } else {
                                    if opc2 == 0b001 then {
                                        return(get_CLIDR())
                                    } else {
                                        if opc2 == 0b111 then {
                                            return(get_AIDR())
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc1 == 0b010 then {
                                if opc2 == 0b000 then {
                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                        return(CSSELR_S)
                                    } else {
                                        return(get_CSSELR_NS())
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0xC then {
                        if opc1 == 0b110 then {
                            if CRm == 0xC then {
                                if opc2 == 0b101 then {
                                    return(get_ICC_MSRE())
                                } else {
                                    if opc2 == 0b100 then {
                                        return(get_ICC_MCTLR())
                                    } else {
                                        if opc2 == 0b111 then {
                                            return(get_ICC_MGRPEN1())
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x5 then {
                            if opc1 == 0b011 then {
                                if CRn == 0x4 then {
                                    if opc2 == 0b000 then {
                                        return(get_DSPSR())
                                    } else {
                                        if opc2 == 0b001 then {
                                            return(get_DLR())
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if coproc == 0xE then {
            if opc1 == 0b000 then {
                if CRn == 0x0 then {
                    if opc2 == 0b000 then {
                        if CRm == 0x0 then {
                            return(DBGDIDR)
                        } else {
                            if CRm == 0x2 then {
                                return(get_DBGDCCINT())
                            } else {
                                if CRm == 0x5 then {
                                    return(get_DBGDTRRXint())
                                } else {
                                    if CRm == 0x1 then {
                                        return(DBGDSCRint)
                                    } else {
                                        if CRm == 0x6 then {
                                            return(DBGWFAR)
                                        } else {
                                            if CRm == 0x7 then {
                                                return(get_DBGVCR())
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b010 then {
                            if CRm == 0x2 then {
                                return(get_DBGDSCRext())
                            } else {
                                if CRm == 0x0 then {
                                    return(get_DBGDTRRXext())
                                } else {
                                    if CRm == 0x6 then {
                                        return(get_DBGOSECCR())
                                    } else {
                                        if CRm == 0x3 then {
                                            return(get_DBGDTRTXext())
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0x7 then {
                        if opc2 == 0b110 then {
                            if CRm == 0x8 then {
                                return(get_DBGCLAIMSET())
                            } else {
                                if CRm == 0xE then {
                                    return(get_DBGAUTHSTATUS())
                                } else {
                                    if CRm == 0x9 then {
                                        return(get_DBGCLAIMCLR())
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b111 then {
                                if CRm == 0x2 then {
                                    return(DBGDEVID)
                                } else {
                                    if CRm == 0x0 then {
                                        return(DBGDEVID2)
                                    } else {
                                        if CRm == 0x1 then {
                                            return(DBGDEVID1)
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x1 then {
                            if opc2 == 0b100 then {
                                if CRm == 0x4 then {
                                    return(get_DBGPRCR())
                                } else {
                                    if CRm == 0x1 then {
                                        return(get_DBGOSLSR())
                                    } else {
                                        if CRm == 0x3 then {
                                            return(get_DBGOSDLR())
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if opc2 == 0b000 then {
                                        return(slice(get_DBGDRAR(), 0, 32))
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if opc2 == 0b000 then {
                                    if CRn == 0x2 then {
                                        return(slice(DBGDSAR, 0, 32))
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRm == 0x0 then {
                    if opc2 == 0b000 then {
                        if opc1 == 0b111 then {
                            if CRn == 0x1 then {
                                return(JOSCR)
                            } else {
                                if CRn == 0x0 then {
                                    return(JIDR)
                                } else {
                                    if CRn == 0x2 then {
                                        return(JMCR)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    undefined : bits(32)
}

val AArch32_SysRegRead : forall ('cp_num : Int).
  (int('cp_num), bits(32)) -> bits(32) effect {escape, rreg, undef}

function AArch32_SysRegRead (cp_num, instr) = {
    __anon1 : bool = undefined : bool;
    el : bits(2) = undefined : bits(2);
    (__anon1, el) = ELFromM32(PSTATE.M);
    let opc1 = slice(instr, 21, 3);
    let CRn = slice(instr, 16, 4);
    let CRm = slice(instr, 0, 4);
    let opc2 = slice(instr, 5, 3);
    if (((cp_num == 15 & opc1 == 0b000) & opc2 == 0b000) & CRn == 0xC) & CRm == 0x1 then {
        return(getISR())
    } else {
        if (((cp_num == 15 & opc1 == 0b000) & (opc2 == 0b000 | opc2 == 0b100 | opc2 == 0b111)) & CRn == 0x0) & CRm == 0x0 then {
            if PSTATE.EL == EL1 & EL2Enabled() then {
                return(get_VPIDR())
            } else {
                return(get_MIDR())
            }
        } else {
            if (((((PSTATE.EL == EL1 & EL2Enabled()) & cp_num == 15) & opc1 == 0b000) & opc2 == 0b101) & CRn == 0x0) & CRm == 0x0 then {
                return(get_VMPIDR())
            } else {
                if ((((PSTATE.EL != EL0 & cp_num == 14) & opc1 == 0b111) & opc2 == 0b000) & CRn == 0x2) & CRm == 0x0 then {
                    return(Zeros())
                } else {
                    if (((cp_num == 14 & opc1 == 0b111) & opc2 == 0b000) & CRn == 0x1) & CRm == 0x0 then {
                        return(Zeros())
                    } else {
                        if ((((((cp_num == 15 & opc1 == 0b000) & opc2 == 0b010) & CRn == 0x1) & CRm == 0x1) & ~(ELUsingAArch32(EL3))) & ~(IsSecure())) & (PSTATE.EL == EL1 | PSTATE.EL == EL2) then {
                            return(__GetSlice_int(32, 3072, 0))
                        } else {
                            return(AArch32_AutoGen_SysRegRead32(el, __GetSlice_int(4, cp_num, 0), opc1, CRn, opc2, CRm, 0b1))
                        }
                    }
                }
            }
        }
    }
}

val AArch32_AutoGen_SysRegAlloc64 : (bits(2), bits(4), bits(4), bits(4), bits(1)) -> bool effect {escape, rreg, undef}

function AArch32_AutoGen_SysRegAlloc64 (el, coproc, opc1, CRm, read) = {
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let ___ELUsingAArch32_EL3_ = ~(ELUsingAArch32(EL3));
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let ___HaveEL_EL3_ = ~(HaveEL(EL3));
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    __cond0 : bool = undefined : bool;
    __cond1 : bool = undefined : bool;
    __cond2 : bool = undefined : bool;
    __cond3 : bool = undefined : bool;
    if coproc == 0xF then {
        if CRm == 0xE then {
            if opc1 == 0x1 then {
                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                return(__cond0)
            } else {
                if opc1 == 0x4 then {
                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                    return(__cond0)
                } else {
                    if opc1 == 0x6 then {
                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                        return(__cond0)
                    } else {
                        if opc1 == 0x3 then {
                            __cond0 = ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            __cond1 = ((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) | ((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) | (((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1;
                            return(__cond0 | __cond1)
                        } else {
                            if opc1 == 0x2 then {
                                __cond0 = ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                __cond1 = (((((((((((((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 0 | (((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | (((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) | ((((el == EL2 | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ___HaveEL_EL3_) | (((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 0) | (((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | (((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL2 | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ~(__ELUsingAArch32_EL3_);
                                __cond2 = (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | ((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                __cond3 = ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                return(((__cond0 | __cond1) | __cond2) | __cond3)
                            } else {
                                if opc1 == 0x0 then {
                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRm == 0x2 then {
                if opc1 == 0x1 then {
                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                    __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                    __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                    return((__cond0 | __cond1) | __cond2)
                } else {
                    if opc1 == 0x4 then {
                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                        return(__cond0)
                    } else {
                        if opc1 == 0x6 then {
                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                            return(__cond0)
                        } else {
                            if opc1 == 0x0 then {
                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                return((__cond0 | __cond1) | __cond2)
                            }
                        }
                    }
                }
            } else {
                if opc1 == 0x0 then {
                    if CRm == 0xC then {
                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                        return(__cond0)
                    } else {
                        if CRm == 0x7 then {
                            __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                            __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                            return((__cond0 | __cond1) | __cond2)
                        } else {
                            if CRm == 0x9 then {
                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            }
                        }
                    }
                } else {
                    if CRm == 0xC then {
                        if opc1 == 0x1 then {
                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if opc1 == 0x2 then {
                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            }
                        }
                    }
                }
            }
        }
    } else {
        if coproc == 0xE then {
            if opc1 == 0x0 then {
                if CRm == 0x2 then {
                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                    return(__cond0)
                } else {
                    if CRm == 0x1 then {
                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                        return(__cond0)
                    }
                }
            }
        }
    };
    false
}

val AArch32_AutoGen_SysRegAlloc32 : (bits(2), bits(4), bits(3), bits(4), bits(3), bits(4), bits(1)) -> bool effect {escape, rreg, undef}

function AArch32_AutoGen_SysRegAlloc32 (el, coproc, opc1, CRn, opc2, CRm, read) = {
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let ___ELUsingAArch32_EL3_ = ~(ELUsingAArch32(EL3));
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let ___HaveEL_EL3_ = ~(HaveEL(EL3));
    let __IsHighestEL_EL1_ = IsHighestEL(EL1);
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    let __IsHighestEL_EL2_ = IsHighestEL(EL2);
    let __IsHighestEL_EL3_ = IsHighestEL(EL3);
    __cond0 : bool = undefined : bool;
    if (CRm & 0x0) == 0x0 then {
        if opc1 == 0b000 then {
            if coproc == 0xE then {
                if CRn == 0x0 then {
                    if opc2 == 0b101 then {
                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    } else {
                        if opc2 == 0b100 then {
                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        } else {
                            if opc2 == 0b110 then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if opc2 == 0b111 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b001 then {
                        if CRn == 0x1 then {
                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        __cond0 = (((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    }
                }
            }
        };
        if (CRm & 0xE) == 0xC then {
            if CRn == 0xC then {
                if coproc == 0xF then {
                    if opc1 == 0b100 then {
                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                        return(__cond0)
                    }
                }
            }
        }
    };
    __cond1 : bool = undefined : bool;
    if (opc2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if opc1 == 0b000 then {
                    if coproc == 0xF then {
                        __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0 | __cond1)
                    }
                }
            }
        }
    };
    __cond2 : bool = undefined : bool;
    __cond3 : bool = undefined : bool;
    if (opc2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if coproc == 0xF then {
                if opc1 == 0b100 then {
                    if CRm == 0x8 then {
                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                        return(__cond0)
                    } else {
                        if CRm == 0x9 then {
                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                            return(__cond0)
                        }
                    }
                } else {
                    if opc1 == 0b000 then {
                        if CRm == 0x9 then {
                            __cond0 = (el == EL1 & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_) | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                            __cond1 = (((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0 | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | (((el == EL2 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1;
                            __cond2 = ((((((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_) | ((((el == EL2 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | (((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_) | (((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_;
                            __cond3 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(((__cond0 | __cond1) | __cond2) | __cond3)
                        }
                    }
                }
            }
        }
    };
    __cond4 : bool = undefined : bool;
    __cond5 : bool = undefined : bool;
    if coproc == 0xF then {
        if opc1 == 0b000 then {
            if opc2 == 0b000 then {
                if CRm == 0x0 then {
                    if CRn == 0xC then {
                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                        return((__cond0 | __cond1) | __cond2)
                    } else {
                        if CRn == 0x5 then {
                            __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                            __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                            return((__cond0 | __cond1) | __cond2)
                        } else {
                            if CRn == 0xD then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRn == 0x6 then {
                                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                    __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                    return((__cond0 | __cond1) | __cond2)
                                } else {
                                    if CRn == 0x3 then {
                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                        return((__cond0 | __cond1) | __cond2)
                                    } else {
                                        if CRn == 0xE then {
                                            __cond0 = read == 0b0 & (((((el == EL1 & __IsHighestEL_EL1_ | ((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & ((((((el == EL0 | el == EL1) & __IsHighestEL_EL1_ | ((((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL0) | el == EL1) & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRn == 0x1 then {
                                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                return((__cond0 | __cond1) | __cond2)
                                            } else {
                                                if CRn == 0x0 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if CRn == 0x2 then {
                                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                        return((__cond0 | __cond1) | __cond2)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x1 then {
                        if CRn == 0xC then {
                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if CRn == 0xE then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRn == 0x7 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRn == 0x1 then {
                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x0 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x5 then {
                                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                return((__cond0 | __cond1) | __cond2)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x7 then {
                            if CRm == 0x8 then {
                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                        return((__cond0 | __cond1) | __cond2)
                                    } else {
                                        if CRm == 0x9 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x8 then {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x6 then {
                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x7 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        __cond0 = ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                        __cond1 = (((((((((((((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 0 | (((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | (((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) | ((((el == EL2 | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ___HaveEL_EL3_) | (((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 0) | (((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | (((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL2 | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ~(__ELUsingAArch32_EL3_);
                                        __cond2 = ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                        __cond3 = (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | ((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                        return(((__cond0 | __cond1) | __cond2) | __cond3)
                                    } else {
                                        if CRn == 0x0 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xA then {
                                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                __cond3 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond4 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond5 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                return(((((__cond0 | __cond1) | __cond2) | __cond3) | __cond4) | __cond5)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xE then {
                                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0x8 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    __cond0 = ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = ((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) | ((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) | (((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1;
                                                    return(__cond0 | __cond1)
                                                } else {
                                                    if CRn == 0xA then {
                                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                        return((__cond0 | __cond1) | __cond2)
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if CRn == 0x4 then {
                                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond1 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0 | __cond1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if opc2 == 0b001 then {
                    if CRn == 0x7 then {
                        if CRm == 0xE then {
                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if CRm == 0xA then {
                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRm == 0x8 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0xB then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x9 then {
                                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                __cond1 = read == 0b1 & ((el == EL1 & __IsHighestEL_EL1_ | ((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & __SCR_EL3_NS == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & __SCR_EL3_NS == 1);
                                return(__cond0 | __cond1)
                            } else {
                                if CRn == 0xD then {
                                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                    __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                    return((__cond0 | __cond1) | __cond2)
                                } else {
                                    if CRn == 0x0 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                            __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                            return((__cond0 | __cond1) | __cond2)
                                        } else {
                                            if CRn == 0x5 then {
                                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                return((__cond0 | __cond1) | __cond2)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                    __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                    return((__cond0 | __cond1) | __cond2)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    __cond0 = ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                    __cond1 = (((((((((((((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 0 | (((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | (((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ___HaveEL_EL3_) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) | ((((el == EL2 | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ___HaveEL_EL3_) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ___HaveEL_EL3_) | (((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 0) | (((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | (((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL2 | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & ~(__ELUsingAArch32_EL3_);
                                    __cond2 = (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | ((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                    __cond3 = ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                    return(((__cond0 | __cond1) | __cond2) | __cond3)
                                } else {
                                    if CRn == 0x1 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x0 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xA then {
                                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                __cond3 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond4 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond5 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                return(((((__cond0 | __cond1) | __cond2) | __cond3) | __cond4) | __cond5)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x3 then {
                                    if CRn == 0xE then {
                                        __cond0 = ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL0 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) | ((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) | (((el == EL0 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1;
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = (el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xA then {
                                                __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                return((__cond0 | __cond1) | __cond2)
                                            } else {
                                                if CRn == 0x8 then {
                                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0x8 then {
                                            __cond0 = read == 0b0 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b0 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0xB then {
                                                __cond0 = read == 0b0 & ((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & (((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = read == 0b0 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    __cond1 = read == 0b0 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                __cond0 = ((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0 | (el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) | (el == EL3 & __ELUsingAArch32_EL3_) & __SCR_EL3_NS == 0) | ((el == EL3 & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_) & __SCR_EL3_NS == 1;
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x0 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if CRn == 0x5 then {
                                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                                        return((__cond0 | __cond1) | __cond2)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if CRm == 0xD then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0xE then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if CRm == 0xC then {
                                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x8 then {
                                                    if CRm == 0x5 then {
                                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    } else {
                                                        if CRm == 0x6 then {
                                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        } else {
                                                            if CRm == 0x7 then {
                                                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                                return(__cond0)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b010 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                __cond0 = ((el == EL1 & __IsHighestEL_EL1_ | (el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0) | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & __SCR_EL3_NS == 1;
                                return(__cond0)
                            } else {
                                if CRn == 0x2 then {
                                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                    __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                    return((__cond0 | __cond1) | __cond2)
                                } else {
                                    if CRn == 0x6 then {
                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                        return((__cond0 | __cond1) | __cond2)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x0 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if CRn == 0xD then {
                                                    __cond0 = (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_ | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_;
                                                    __cond1 = (((((((el == EL0 | el == EL1) & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL0 | el == EL1) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond2 = ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                    return((__cond0 | __cond1) | __cond2)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if CRm == 0x8 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0xA then {
                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xE then {
                                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x8 then {
                                    if CRm == 0x5 then {
                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xE then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0x8 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x1 then {
                                                    __cond0 = read == 0b1 & ((el == EL3 & __SCR_EL3_NS == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                    __cond1 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                    return(__cond0 | __cond1)
                                                } else {
                                                    if CRn == 0x0 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x2 then {
                                                    if CRn == 0x0 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b011 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                    __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                    return((__cond0 | __cond1) | __cond2)
                                } else {
                                    if CRn == 0x1 then {
                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                        __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                        return((__cond0 | __cond1) | __cond2)
                                    } else {
                                        if CRn == 0x0 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = read == 0b1 & ((((((((el == EL0 | el == EL1) & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL0 | el == EL1) & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_);
                                                __cond2 = read == 0b0 & (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond3 = read == 0b0 & (((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond4 = read == 0b1 & ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond5 = read == 0b1 & ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_ | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_);
                                                return(((((__cond0 | __cond1) | __cond2) | __cond3) | __cond4) | __cond5)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xC then {
                                    if CRm == 0x8 then {
                                        __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRm == 0xB then {
                                            __cond0 = read == 0b1 & ((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & (((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0xC then {
                                                __cond0 = ((((((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_) | (((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL2 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_) | (((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = (el == EL1 & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_) | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond2 = (((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0 | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | (((el == EL2 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1;
                                                __cond3 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(((__cond0 | __cond1) | __cond2) | __cond3)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x8 then {
                                        if CRm == 0x7 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xE then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0x0 then {
                                                if CRm == 0x2 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x1 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x8 then {
                                                    if CRn == 0x7 then {
                                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if CRm == 0x8 then {
                                    if opc2 == 0b101 then {
                                        __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                        return(__cond0)
                                    } else {
                                        if opc2 == 0b100 then {
                                            __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                            return(__cond0)
                                        } else {
                                            if opc2 == 0b110 then {
                                                __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                return(__cond0)
                                            } else {
                                                if opc2 == 0b111 then {
                                                    __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x3 then {
                                        if opc2 == 0b101 then {
                                            __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if opc2 == 0b100 then {
                                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if opc2 == 0b111 then {
                                                    __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if opc2 == 0b100 then {
                                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if opc2 == 0b110 then {
                                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if opc2 == 0b111 then {
                                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xA then {
                                                if opc2 == 0b101 then {
                                                    __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if opc2 == 0b100 then {
                                                        __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if opc2 == 0b110 then {
                                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x0 then {
                                    if CRm == 0x1 then {
                                        if opc2 == 0b101 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if opc2 == 0b100 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if opc2 == 0b110 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if opc2 == 0b111 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x2 then {
                                            if opc2 == 0b101 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if opc2 == 0b100 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    } else {
                                                        if opc2 == 0b111 then {
                                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if opc2 == 0b101 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if opc2 == 0b100 then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0xC then {
                                        if CRn == 0xC then {
                                            if opc2 == 0b101 then {
                                                __cond0 = (el == EL1 & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_) | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                __cond1 = (((((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) & ~(__ELUsingAArch32_EL3_) | ((el == EL2 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_;
                                                __cond2 = ((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1;
                                                return((__cond0 | __cond1) | __cond2)
                                            } else {
                                                if opc2 == 0b100 then {
                                                    __cond0 = (el == EL1 & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_) | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                    __cond1 = ((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0 | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | (((((el == EL2 | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | (((el == EL2 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | (((el == EL2 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1;
                                                    __cond2 = ((((((((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_) | (((((el == EL2 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | (((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | (((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_) | ((((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_;
                                                    __cond3 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(((__cond0 | __cond1) | __cond2) | __cond3)
                                                } else {
                                                    if opc2 == 0b110 then {
                                                        __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0 | __cond1)
                                                    } else {
                                                        if opc2 == 0b111 then {
                                                            __cond0 = ((((((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_) | (((el == EL2 & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | ((((el == EL2 | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_) | (((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_;
                                                            __cond1 = (el == EL1 & __SCR_EL3_NS == 0) & ~(__ELUsingAArch32_EL3_) | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                            __cond2 = (((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0 | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | (((el == EL2 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & __SCR_EL3_NS == 1;
                                                            __cond3 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(((__cond0 | __cond1) | __cond2) | __cond3)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if opc2 == 0b101 then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if opc2 == 0b100 then {
                                                        __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    } else {
                                                        if opc2 == 0b110 then {
                                                            __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        } else {
                                                            if opc2 == 0b111 then {
                                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                                return(__cond0)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x8 then {
                                            if opc2 == 0b111 then {
                                                if CRm == 0x7 then {
                                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if opc2 == 0b101 then {
                                                    if CRm == 0x7 then {
                                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if CRn == 0x9 then {
                                                    if opc2 == 0b101 then {
                                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    } else {
                                                        if opc2 == 0b100 then {
                                                            __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        } else {
                                                            if opc2 == 0b110 then {
                                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                                return(__cond0)
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x0 then {
                                                    if opc2 == 0b100 then {
                                                        if CRn == 0xD then {
                                                            __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                                            __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) & __ELUsingAArch32_EL3_;
                                                            return((__cond0 | __cond1) | __cond2)
                                                        }
                                                    }
                                                } else {
                                                    if CRn == 0xE then {
                                                        if opc2 == 0b111 then {
                                                            if CRm == 0xF then {
                                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                                return(__cond0)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if opc1 == 0b100 then {
                if opc2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                            return(__cond0)
                        } else {
                            if CRn == 0x6 then {
                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                return(__cond0)
                            } else {
                                if CRn == 0x1 then {
                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                    return(__cond0)
                                } else {
                                    if CRn == 0x0 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                return(__cond0)
                            } else {
                                if CRn == 0x1 then {
                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                    return(__cond0)
                                } else {
                                    if CRn == 0x5 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                    return(__cond0)
                                } else {
                                    if CRn == 0xA then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x8 then {
                                    if CRm == 0x7 then {
                                        __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x3 then {
                                            __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                            return(__cond0)
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        }
                                    } else {
                                        if CRm == 0x8 then {
                                            if CRn == 0x7 then {
                                                __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRn == 0xA then {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b001 then {
                        if CRn == 0x8 then {
                            if CRm == 0x0 then {
                                __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x4 then {
                                    __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x7 then {
                                        __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x3 then {
                                            __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                    return(__cond0)
                                } else {
                                    if CRn == 0x1 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if CRn == 0xA then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            __cond0 = read == 0b1 & (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                            return(__cond0)
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0x1 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x8 then {
                                                if CRn == 0x7 then {
                                                    __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if opc2 == 0b010 then {
                                if CRn == 0xC then {
                                    __cond0 = ((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x2 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x6 then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if opc2 == 0b101 then {
                                    if CRn == 0x0 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x8 then {
                                            __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                            return(__cond0)
                                        }
                                    }
                                } else {
                                    if opc2 == 0b100 then {
                                        if CRn == 0x6 then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if opc2 == 0b011 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if CRm == 0xB then {
                                    if opc2 == 0b010 then {
                                        __cond0 = read == 0b1 & (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                        return(__cond0)
                                    } else {
                                        if opc2 == 0b101 then {
                                            __cond0 = read == 0b1 & (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                            return(__cond0)
                                        } else {
                                            if opc2 == 0b111 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0)
                                            } else {
                                                if opc2 == 0b011 then {
                                                    __cond0 = read == 0b1 & (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if opc2 == 0b101 then {
                                        if CRm == 0x9 then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        if opc2 == 0b010 then {
                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        } else {
                                            if opc2 == 0b100 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0)
                                            } else {
                                                if opc2 == 0b111 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0)
                                                } else {
                                                    if opc2 == 0b011 then {
                                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if opc2 == 0b010 then {
                                            if CRn == 0x2 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x8 then {
                                        if opc2 == 0b101 then {
                                            if CRm == 0x4 then {
                                                __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x7 then {
                                                    __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if opc2 == 0b100 then {
                                                if CRm == 0x7 then {
                                                    __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = read == 0b0 & ((el == EL3 & __SCR_EL3_NS == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRm == 0x0 then {
                    if CRn == 0x0 then {
                        if opc1 == 0b001 then {
                            if opc2 == 0b010 then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if opc2 == 0b000 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if opc2 == 0b001 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if opc2 == 0b111 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc1 == 0b010 then {
                                if opc2 == 0b000 then {
                                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_;
                                    __cond1 = ((((((el == EL1 & ___HaveEL_EL3_) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ___HaveEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL1 & ~(__ELUsingAArch32_EL3_)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((el == EL2 | el == EL1) & __HCR_EL2_TGE == 0) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & ~(__ELUsingAArch32_EL3_)) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond2 = ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) & __ELUsingAArch32_EL3_ | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1) & __ELUsingAArch32_EL3_;
                                    return((__cond0 | __cond1) | __cond2)
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0xC then {
                        if opc1 == 0b110 then {
                            if CRm == 0xC then {
                                if opc2 == 0b101 then {
                                    __cond0 = (el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                    return(__cond0)
                                } else {
                                    if opc2 == 0b100 then {
                                        __cond0 = (el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0)
                                    } else {
                                        if opc2 == 0b111 then {
                                            __cond0 = (el == EL3 & __SCR_EL3_NS == 0 | (el == EL3 & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (el == EL3 & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x5 then {
                            if opc1 == 0b011 then {
                                if CRn == 0x4 then {
                                    if opc2 == 0b000 then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if opc2 == 0b001 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if coproc == 0xE then {
            if opc1 == 0b000 then {
                if CRn == 0x0 then {
                    if opc2 == 0b000 then {
                        if CRm == 0x0 then {
                            __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if CRm == 0x2 then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    __cond1 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRm == 0x1 then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b010 then {
                            if CRm == 0x2 then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x0 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x6 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x3 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0x7 then {
                        if opc2 == 0b110 then {
                            if CRm == 0x8 then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0xE then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x9 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b111 then {
                                if CRm == 0x2 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x0 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x1 then {
                            if opc2 == 0b100 then {
                                if CRm == 0x0 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if opc2 == 0b000 then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if opc2 == 0b000 then {
                                    if CRn == 0x2 then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRm == 0x0 then {
                    if opc2 == 0b000 then {
                        if opc1 == 0b111 then {
                            if CRn == 0x1 then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRn == 0x0 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRn == 0x2 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    false
}

val AArch32_CheckCoprocInstrAccess : bits(32) -> bool effect {escape, rreg, undef}

function AArch32_CheckCoprocInstrAccess instr = {
    let cp_num : bits(4) = slice(instr, 8, 4);
    let read : bits(1) = [instr[20]];
    CRm : bits(4) = undefined : bits(4);
    CRm_64 : bits(4) = undefined : bits(4);
    CRn : bits(4) = undefined : bits(4);
    opc1 : bits(3) = undefined : bits(3);
    opc1_64 : bits(4) = undefined : bits(4);
    opc2 : bits(3) = undefined : bits(3);
    target_el : bits(2) = undefined : bits(2);
    trap : bool = undefined : bool;
    if (slice(instr, 28, 4) != 0xF & slice(instr, 24, 4) == 0xE) & [instr[4]] == 0b1 then {
        opc1 = slice(instr, 21, 3);
        CRn = slice(instr, 16, 4);
        CRm = slice(instr, 0, 4);
        opc2 = slice(instr, 5, 3);
        if (((((UInt(cp_num) == 15 & opc1 == 0b000) & (opc2 == 0b100 | opc2 == 0b111)) & CRn == 0x0) & CRm == 0x0) & read == 0b1) & PSTATE.EL != EL0 then {
            return(true)
        } else {
            if (((UInt(cp_num) == 15 & opc1 == 0b000) & CRn == 0x0) & CRm == 0x2) & opc2 == 0b111 then {
                return(PSTATE.EL != EL0 & read == 0b1)
            } else {
                if ((UInt(cp_num) == 15 & opc1 == 0b000) & CRn == 0x0) & UInt(CRm) >= 3 then {
                    return(PSTATE.EL != EL0 & read == 0b1)
                } else {
                    if (((UInt(cp_num) == 15 & opc1 == 0b000) & CRn == 0x1) & CRm == 0x1) & opc2 == 0b000 then {
                        return(PSTATE.EL == EL3 | PSTATE.EL == EL1 & IsSecure())
                    }
                }
            }
        };
        try {
            (trap, target_el) = AArch32_AutoGen_SysRegTrap32(PSTATE.EL, cp_num, opc1, CRn, opc2, CRm, read)
        } catch {
          Error_Undefined(()) => {
              return(false)
          }
        };
        return(AArch32_AutoGen_SysRegAlloc32(PSTATE.EL, cp_num, opc1, CRn, opc2, CRm, read))
    } else {
        if slice(instr, 28, 4) != 0xF & slice(instr, 21, 7) == 0b1100010 then {
            opc1_64 = slice(instr, 4, 4);
            CRm_64 = slice(instr, 0, 4);
            try {
                (trap, target_el) = AArch32_AutoGen_SysRegTrap64(PSTATE.EL, cp_num, opc1_64, CRm_64, read)
            } catch {
              Error_Undefined(()) => {
                  return(false)
              }
            };
            return(AArch32_AutoGen_SysRegAlloc64(PSTATE.EL, cp_num, opc1_64, CRm_64, read))
        } else {
            if (slice(instr, 28, 4) != 0xF & slice(instr, 25, 3) == 0b110) & [instr[22]] == 0b0 then {
                return(true)
            } else {
                return(false)
            }
        }
    }
}

val CP15InstrDecode : bits(32) -> bool effect {escape, rreg, undef}

function CP15InstrDecode instr = {
    AArch32_CheckCoprocInstrAccess(instr)
}

val CP14TraceInstrDecode : bits(32) -> bool effect {escape, rreg, undef}

function CP14TraceInstrDecode instr = {
    AArch32_CheckCoprocInstrAccess(instr)
}

val CP14JazelleInstrDecode : bits(32) -> bool effect {escape, rreg, undef}

function CP14JazelleInstrDecode instr = {
    AArch32_CheckCoprocInstrAccess(instr)
}

val CP14DebugInstrDecode : bits(32) -> bool effect {escape, rreg, undef}

function CP14DebugInstrDecode instr = {
    AArch32_CheckCoprocInstrAccess(instr)
}

val AArch64_CheckAArch32SystemAccess : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckAArch32SystemAccess instr = {
    let cp_num = UInt(slice(instr, 8, 4));
    assert(cp_num == 14 | cp_num == 15);
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    allocated : bool = undefined : bool;
    cpdt : bool = undefined : bool;
    cprt : bool = undefined : bool;
    nreg : int = undefined : int;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    if (slice(instr, 28, 4) != 0xF & slice(instr, 24, 4) == 0xE) & [instr[4]] == 0b1 then {
        cprt = true;
        cpdt = false;
        nreg = 1;
        opc1 = UInt(slice(instr, 21, 3));
        opc2 = UInt(slice(instr, 5, 3));
        CRn = UInt(slice(instr, 16, 4));
        CRm = UInt(slice(instr, 0, 4))
    } else {
        if slice(instr, 28, 4) != 0xF & slice(instr, 21, 7) == 0b1100010 then {
            cprt = true;
            cpdt = false;
            nreg = 2;
            opc1 = UInt(slice(instr, 4, 4));
            CRm = UInt(slice(instr, 0, 4))
        } else {
            if (slice(instr, 28, 4) != 0xF & slice(instr, 25, 3) == 0b110) & [instr[22]] == 0b0 then {
                cprt = false;
                cpdt = true;
                nreg = 0;
                opc1 = 0;
                CRn = UInt(slice(instr, 12, 4))
            } else {
                allocated = false
            }
        }
    };
    if cp_num == 14 then {
        if cpdt & CRn != 5 then {
            allocated = false
        } else {
            match opc1 {
              0 => {
                  allocated = CP14DebugInstrDecode(instr)
              },
              1 => {
                  allocated = CP14TraceInstrDecode(instr)
              },
              7 => {
                  allocated = CP14JazelleInstrDecode(instr)
              },
              _ => {
                  allocated = false
              }
            }
        }
    } else {
        if cp_num == 15 then {
            if ~(cprt) then {
                allocated = false
            } else {
                allocated = CP15InstrDecode(instr);
                if AArch64_CheckCP15InstrCoarseTraps(CRn, nreg, CRm) then {
                    if (PSTATE.EL == EL0 & EL2Enabled()) & ~(allocated) then {
                        if __IMPDEF_boolean("UNDEF unallocated CP15 access at EL0") then {
                            throw(Error_Undefined())
                        }
                    };
                    AArch64_AArch32SystemAccessTrap(EL2, instr)
                }
            }
        } else {
            allocated = false
        }
    };
    if ~(allocated) then {
        throw(Error_Undefined())
    };
    AArch64_CheckAArch32SystemAccessTraps(instr);
    return()
}

val AArch32_TranslationTableWalkSDX : forall ('size : Int).
  (bits(32), AccType, bool, int('size)) -> (TLBRecord, bits(1)) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_TranslationTableWalkSDX (vaddress, acctype, iswrite, size) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    result : TLBRecord = undefined : TLBRecord;
    l1descaddr : AddressDescriptor = undefined : AddressDescriptor;
    l2descaddr : AddressDescriptor = undefined : AddressDescriptor;
    outputaddress : bits(40) = undefined : bits(40);
    let ipaddress : bits(40) = undefined : bits(40);
    let secondstage : bool = false;
    let s2fs1walk : bool = false;
    domain : bits(4) = undefined : bits(4);
    domain = undefined : bits(4);
    supersection : bits(1) = undefined : bits(1);
    supersection = 0b0;
    ttbr : bits(64) = undefined : bits(64);
    n : int = undefined : int;
    n = UInt(slice(get_TTBCR(), 0, 3));
    disabled : bool = undefined : bool;
    if n == 0 | IsZero_slice(vaddress, 32 - n, n) then {
        ttbr = get_TTBR0();
        disabled = [get_TTBCR()[4]] == 0b1
    } else {
        ttbr = get_TTBR1();
        disabled = [get_TTBCR()[5]] == 0b1;
        n = 0
    };
    level : int = undefined : int;
    if disabled then {
        level = 1;
        __tc1 : AddressDescriptor = result.addrdesc;
        __tc1.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc1;
        return((result, supersection))
    };
    __tc2 : FullAddress = l1descaddr.paddress;
    {
        let 'n = n;
        assert(negate(n) + 12 >= 0 & n + 18 >= 0);
        __tc2.address = ZeroExtend((slice(ttbr, 14 - n, n + 18) @ slice(vaddress, 20, negate(n) + 12)) @ 0b00)
    };
    l1descaddr.paddress = __tc2;
    __tc3 : FullAddress = l1descaddr.paddress;
    __tc3.NS = if IsSecure() then 0b0 else 0b1;
    l1descaddr.paddress = __tc3;
    let IRGN : bits(2) = [ttbr[0]] @ [ttbr[6]];
    let RGN : bits(2) = slice(ttbr, 3, 2);
    let SH : bits(2) = [ttbr[1]] @ [ttbr[5]];
    l1descaddr.memattrs = WalkAttrDecode(SH, RGN, IRGN, secondstage);
    l1descaddr2 : AddressDescriptor = undefined : AddressDescriptor;
    if ~(HaveEL(EL2)) | ~(IsSecureEL2Enabled()) & IsSecure() then {
        l1descaddr2 = l1descaddr
    } else {
        l1descaddr2 = AArch32_SecondStageWalk(l1descaddr, vaddress, acctype, iswrite, 4);
        if IsFault(l1descaddr2) then {
            __tc4 : AddressDescriptor = result.addrdesc;
            __tc4.fault = l1descaddr2.fault;
            result.addrdesc = __tc4;
            return((result, supersection))
        }
    };
    l1descaddr2.vaddress = ZeroExtend(vaddress);
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
    l1desc : bits(32) = undefined : bits(32);
    l1desc = aget__Mem(l1descaddr2, 4, accdesc);
    if [get_SCTLR()[25]] == 0b1 then {
        l1desc = BigEndianReverse(l1desc)
    };
    NS : bits(1) = undefined : bits(1);
    S : bits(1) = undefined : bits(1);
    ap : bits(3) = undefined : bits(3);
    b : bits(1) = undefined : bits(1);
    blocksize : int = undefined : int;
    c : bits(1) = undefined : bits(1);
    l2desc : bits(32) = undefined : bits(32);
    l2descaddr2 : AddressDescriptor = undefined : AddressDescriptor;
    nG : bits(1) = undefined : bits(1);
    pxn : bits(1) = undefined : bits(1);
    tex : bits(3) = undefined : bits(3);
    xn : bits(1) = undefined : bits(1);
    match slice(l1desc, 0, 2) {
      0b00 => {
          level = 1;
          __tc5 : AddressDescriptor = result.addrdesc;
          __tc5.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
          result.addrdesc = __tc5;
          return((result, supersection))
      },
      0b01 => {
          domain = slice(l1desc, 5, 4);
          level = 2;
          pxn = [l1desc[2]];
          NS = [l1desc[3]];
          __tc6 : FullAddress = l2descaddr.paddress;
          __tc6.address = ZeroExtend((slice(l1desc, 10, 22) @ slice(vaddress, 12, 8)) @ 0b00);
          l2descaddr.paddress = __tc6;
          __tc7 : FullAddress = l2descaddr.paddress;
          __tc7.NS = if IsSecure() then 0b0 else 0b1;
          l2descaddr.paddress = __tc7;
          l2descaddr.memattrs = l1descaddr.memattrs;
          if ~(HaveEL(EL2)) | ~(IsSecureEL2Enabled()) & IsSecure() then {
              l2descaddr2 = l2descaddr
          } else {
              l2descaddr2 = AArch32_SecondStageWalk(l2descaddr, vaddress, acctype, iswrite, 4);
              if IsFault(l2descaddr2) then {
                  __tc8 : AddressDescriptor = result.addrdesc;
                  __tc8.fault = l2descaddr2.fault;
                  result.addrdesc = __tc8;
                  return((result, supersection))
              }
          };
          l2descaddr2.vaddress = ZeroExtend(vaddress);
          accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
          l2desc = aget__Mem(l2descaddr2, 4, accdesc);
          if [get_SCTLR()[25]] == 0b1 then {
              l2desc = BigEndianReverse(l2desc)
          };
          if slice(l2desc, 0, 2) == 0b00 then {
              __tc9 : AddressDescriptor = result.addrdesc;
              __tc9.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
              result.addrdesc = __tc9;
              return((result, supersection))
          };
          nG = [l2desc[11]];
          S = [l2desc[10]];
          ap = l2desc[9 .. 9] @ l2desc[4 .. 3];
          if [get_SCTLR()[29]] == 0b1 & [l2desc[4]] == 0b0 then {
              __tc10 : AddressDescriptor = result.addrdesc;
              __tc10.fault = AArch32_AccessFlagFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
              result.addrdesc = __tc10;
              return((result, supersection))
          };
          if [l2desc[1]] == 0b0 then {
              xn = [l2desc[15]];
              tex = slice(l2desc, 12, 3);
              c = [l2desc[3]];
              b = [l2desc[2]];
              blocksize = 64;
              outputaddress = ZeroExtend(slice(l2desc, 16, 16) @ slice(vaddress, 0, 16))
          } else {
              tex = slice(l2desc, 6, 3);
              c = [l2desc[3]];
              b = [l2desc[2]];
              xn = [l2desc[0]];
              blocksize = 4;
              outputaddress = ZeroExtend(slice(l2desc, 12, 20) @ slice(vaddress, 0, 12))
          }
      },
      [bitone] @ _ : bits(1) => {
          NS = [l1desc[19]];
          nG = [l1desc[17]];
          S = [l1desc[16]];
          ap = l1desc[15 .. 15] @ l1desc[10 .. 9];
          tex = slice(l1desc, 12, 3);
          xn = [l1desc[4]];
          c = [l1desc[3]];
          b = [l1desc[2]];
          pxn = [l1desc[0]];
          level = 1;
          if [get_SCTLR()[29]] == 0b1 & [l1desc[10]] == 0b0 then {
              __tc11 : AddressDescriptor = result.addrdesc;
              __tc11.fault = AArch32_AccessFlagFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
              result.addrdesc = __tc11;
              return((result, supersection))
          };
          if [l1desc[18]] == 0b0 then {
              domain = slice(l1desc, 5, 4);
              blocksize = 1024;
              outputaddress = ZeroExtend(slice(l1desc, 20, 12) @ slice(vaddress, 0, 20))
          } else {
              domain = 0x0;
              blocksize = 16384;
              outputaddress = ((slice(l1desc, 5, 4) @ slice(l1desc, 20, 4)) @ slice(l1desc, 24, 8)) @ slice(vaddress, 0, 24);
              supersection = 0b1
          }
      }
    };
    if [get_SCTLR()[28]] == 0b0 then {
        if RemapRegsHaveResetValues() then {
            __tc12 : AddressDescriptor = result.addrdesc;
            __tc12.memattrs = AArch32_DefaultTEXDecode(tex, c, b, S, acctype);
            result.addrdesc = __tc12
        } else {
            __tc13 : AddressDescriptor = result.addrdesc;
            __tc13.memattrs = undefined;
            result.addrdesc = __tc13
        }
    } else {
        __tc14 : AddressDescriptor = result.addrdesc;
        __tc14.memattrs = AArch32_RemappedTEXDecode(tex, c, b, S, acctype);
        result.addrdesc = __tc14
    };
    __tc15 : Permissions = result.perms;
    __tc15.ap = ap;
    result.perms = __tc15;
    __tc16 : Permissions = result.perms;
    __tc16.xn = xn;
    result.perms = __tc16;
    __tc17 : Permissions = result.perms;
    __tc17.pxn = pxn;
    result.perms = __tc17;
    result.nG = nG;
    result.domain = domain;
    result.level = level;
    result.blocksize = blocksize;
    __tc18 : FullAddress = result.addrdesc.paddress;
    __tc18.address = ZeroExtend(outputaddress);
    __tc19 : AddressDescriptor = result.addrdesc;
    __tc19.paddress = __tc18;
    result.addrdesc = __tc19;
    __tc20 : FullAddress = result.addrdesc.paddress;
    __tc20.NS = if IsSecure() then NS else 0b1;
    __tc21 : AddressDescriptor = result.addrdesc;
    __tc21.paddress = __tc20;
    result.addrdesc = __tc21;
    __tc22 : AddressDescriptor = result.addrdesc;
    __tc22.fault = AArch32_NoFault();
    result.addrdesc = __tc22;
    return((result, supersection))
}

val AArch32_FirstStageTranslateX : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(32), AccType, bool('iswrite), bool('wasaligned), int('size)) -> (AddressDescriptor, bits(1)) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_FirstStageTranslateX (vaddress, acctype, iswrite, wasaligned, size) = {
    dc : bits(1) = undefined : bits(1);
    s1_enabled : bool = undefined : bool;
    tge : bits(1) = undefined : bits(1);
    if PSTATE.EL == EL2 then {
        s1_enabled = [get_HSCTLR()[0]] == 0b1
    } else {
        if EL2Enabled() then {
            tge = if ELUsingAArch32(EL2) then [get_HCR()[27]] else [HCR_EL2[27]];
            dc = if ELUsingAArch32(EL2) then [get_HCR()[12]] else [HCR_EL2[12]];
            s1_enabled = (tge == 0b0 & dc == 0b0) & [get_SCTLR()[0]] == 0b1
        } else {
            s1_enabled = [get_SCTLR()[0]] == 0b1
        }
    };
    let ipaddress = undefined : bits(40);
    let secondstage = false;
    let s2fs1walk = false;
    supersection : bits(1) = undefined : bits(1);
    supersection = 0b0;
    S1 : TLBRecord = undefined : TLBRecord;
    domaincheck : bool = undefined : bool;
    permissioncheck : bool = undefined : bool;
    use_long_descriptor_format : bool = undefined : bool;
    if s1_enabled then {
        use_long_descriptor_format = PSTATE.EL == EL2 | [get_TTBCR()[31]] == 0b1;
        if use_long_descriptor_format then {
            S1 = AArch32_TranslationTableWalk(ipaddress, vaddress, acctype, iswrite, secondstage, s2fs1walk, size);
            permissioncheck = true;
            domaincheck = false
        } else {
            (S1, supersection) = AArch32_TranslationTableWalkSDX(vaddress, acctype, iswrite, size);
            permissioncheck = true;
            domaincheck = true
        }
    } else {
        S1 = AArch32_TranslateAddressS1Off(vaddress, acctype, iswrite);
        permissioncheck = false;
        domaincheck = false
    };
    if ((~(wasaligned) & ~(IsFault(S1.addrdesc))) & S1.addrdesc.memattrs.typ == MemType_Device) & acctype != AccType_IFETCH then {
        __tc1 : AddressDescriptor = S1.addrdesc;
        __tc1.fault = AArch32_AlignmentFault(acctype, iswrite, secondstage);
        S1.addrdesc = __tc1
    };
    abort : FaultRecord = undefined : FaultRecord;
    if ~(IsFault(S1.addrdesc)) & domaincheck then {
        (permissioncheck, abort) = AArch32_CheckDomain(S1.domain, vaddress, S1.level, acctype, iswrite);
        __tc2 : AddressDescriptor = S1.addrdesc;
        __tc2.fault = abort;
        S1.addrdesc = __tc2
    };
    if ~(IsFault(S1.addrdesc)) & permissioncheck then {
        __tc3 : AddressDescriptor = S1.addrdesc;
        __tc3.fault = AArch32_CheckPermission(S1.perms, vaddress, S1.level, S1.domain, S1.addrdesc.paddress.NS, acctype, iswrite);
        S1.addrdesc = __tc3
    };
    if (~(IsFault(S1.addrdesc)) & S1.addrdesc.memattrs.typ == MemType_Device) & acctype == AccType_IFETCH then {
        S1.addrdesc = AArch32_InstructionDevice(S1.addrdesc, vaddress, ipaddress, S1.level, S1.domain, acctype, iswrite, secondstage, s2fs1walk)
    };
    return((S1.addrdesc, supersection))
}

val AArch32_FullTranslateX : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(32), AccType, bool('iswrite), bool('wasaligned), int('size)) -> (AddressDescriptor, bits(1)) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_FullTranslateX (vaddress, acctype, iswrite, wasaligned, size) = {
    S1 : AddressDescriptor = undefined : AddressDescriptor;
    supersection : bits(1) = undefined : bits(1);
    (S1, supersection) = AArch32_FirstStageTranslateX(vaddress, acctype, iswrite, wasaligned, size);
    result : AddressDescriptor = undefined : AddressDescriptor;
    s2fs1walk : bool = undefined : bool;
    if (~(IsFault(S1)) & EL2Enabled()) & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
        s2fs1walk = false;
        result = AArch32_SecondStageTranslate(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size)
    } else {
        result = S1
    };
    return((result, supersection))
}

val AArch32_SetExclusiveMonitors : forall ('size : Int).
  (bits(32), int('size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_SetExclusiveMonitors (address, size) = {
    let acctype = AccType_ATOMIC;
    let iswrite = false;
    let aligned = address == Align(address, size);
    let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        return()
    };
    if memaddrdesc.memattrs.shareable then {
        MarkExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    };
    MarkExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    AArch32_MarkExclusiveVA(address, ProcessorID(), size)
}

val ICIMVAU : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ICIMVAU val_name = {
    IC_IVAU(ZeroExtend(val_name))
}

val DCIMVAC : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DCIMVAC val_name = {
    DC_IVAC(ZeroExtend(val_name))
}

val DCCMVAU : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DCCMVAU val_name = {
    DC_CVAU(ZeroExtend(val_name))
}

val DCCMVAC : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DCCMVAC val_name = {
    DC_CVAC(ZeroExtend(val_name))
}

val DCCIMVAC : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DCCIMVAC val_name = {
    DC_CIVAC(ZeroExtend(val_name))
}

val ATS1Hx : forall ('iswrite : Bool).
  (bits(32), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1Hx (val_name, iswrite) = {
    if PSTATE.M != M32_Monitor & CurrentPL() != PL2 then {
        UndefinedFault()
    };
    statesaved : bool = false;
    if PSTATE.M == M32_Monitor then {
        __tc1 : bits(32) = get_SCR();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b1);
        set_SCR(__tc1);
        __SAVE_EL(EL2);
        statesaved = true
    };
    addrdesc : AddressDescriptor = undefined : AddressDescriptor;
    supersection : bits(1) = undefined : bits(1);
    (addrdesc, supersection) = AArch32_FirstStageTranslateX(val_name, AccType_AT, iswrite, true, 1);
    if statesaved then {
        __tc2 : bits(32) = get_SCR();
        __tc2 = __SetSlice_bits(32, 1, __tc2, 0, 0b0);
        set_SCR(__tc2);
        __RESTORE_EL()
    };
    if IsFault(addrdesc) then {
        if IsExternalAbort(addrdesc.fault) then {
            set_PAR(undefined : bits(64));
            AArch32_Abort(val_name, addrdesc.fault)
        }
    };
    let report_domain_fault = false;
    AArch32_EncodePARLD(addrdesc, report_domain_fault)
}

val ATS1HW : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1HW val_name = {
    ATS1Hx(val_name, false)
}

val ATS1HR : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1HR val_name = {
    ATS1Hx(val_name, false)
}

val ATS1Cxx : forall ('pl0regime : Bool) ('iswrite : Bool).
  (bits(32), bool('pl0regime), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1Cxx (val_name, pl0regime, iswrite) = {
    if CurrentPL() == PL0 then {
        UndefinedFault()
    };
    statesaved : bool = false;
    if PSTATE.EL == EL2 then {
        if pl0regime then {
            __SAVE_EL(EL0)
        } else {
            __SAVE_EL(EL1)
        };
        statesaved = true
    } else {
        if pl0regime then {
            __SAVE_EL(EL0);
            statesaved = true
        }
    };
    addrdesc : AddressDescriptor = undefined : AddressDescriptor;
    supersection : bits(1) = undefined : bits(1);
    (addrdesc, supersection) = AArch32_FirstStageTranslateX(val_name, AccType_AT, iswrite, true, 1);
    if statesaved then {
        __RESTORE_EL()
    };
    if IsFault(addrdesc) then {
        if IsExternalAbort(addrdesc.fault) | (PSTATE.EL == EL1 & ~(IsSecure())) & addrdesc.fault.s2fs1walk then {
            set_PAR(undefined : bits(64));
            AArch32_Abort(val_name, addrdesc.fault)
        }
    };
    report_domain_fault : bool = undefined : bool;
    if [get_TTBCR()[31]] == 0b1 | PSTATE.EL == EL2 then {
        report_domain_fault = if PSTATE.EL == EL2 then true else false;
        AArch32_EncodePARLD(addrdesc, report_domain_fault)
    } else {
        AArch32_EncodePARSD(addrdesc, supersection)
    }
}

val ATS1CUW : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1CUW val_name = {
    ATS1Cxx(val_name, true, true)
}

val ATS1CUR : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1CUR val_name = {
    ATS1Cxx(val_name, true, false)
}

val ATS1CPWP : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1CPWP val_name = {
    ATS1Cxx(val_name, false, true)
}

val ATS1CPW : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1CPW val_name = {
    ATS1Cxx(val_name, false, true)
}

val ATS1CPRP : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1CPRP val_name = {
    ATS1Cxx(val_name, false, false)
}

val ATS1CPR : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS1CPR val_name = {
    ATS1Cxx(val_name, false, false)
}

val ATS12NSOxx : forall ('pl0regime : Bool) ('iswrite : Bool).
  (bits(32), bool('pl0regime), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS12NSOxx (val_name, pl0regime, iswrite) = {
    if ~(CurrentPL() == PL1 & IsSecure()) & CurrentPL() != PL2 then {
        UndefinedFault()
    };
    if ~(HaveEL(EL2)) & HaveEL(EL3) then {
        ATS1Cxx(val_name, pl0regime, iswrite);
        return()
    };
    statesaved : bool = false;
    if PSTATE.EL == EL3 then {
        __tc1 : bits(32) = get_SCR();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b1);
        set_SCR(__tc1);
        if pl0regime then {
            __SAVE_EL(EL0)
        } else {
            __SAVE_EL(EL1)
        };
        statesaved = true
    } else {
        if PSTATE.EL == EL2 then {
            if pl0regime then {
                __SAVE_EL(EL0)
            } else {
                __SAVE_EL(EL1)
            };
            statesaved = true
        } else {
            __tc2 : bits(32) = get_SCR();
            __tc2 = __SetSlice_bits(32, 1, __tc2, 0, 0b1);
            set_SCR(__tc2);
            if pl0regime then {
                __SAVE_EL(EL0);
                statesaved = true
            }
        }
    };
    addrdesc : AddressDescriptor = undefined : AddressDescriptor;
    supersection : bits(1) = undefined : bits(1);
    (addrdesc, supersection) = AArch32_FullTranslateX(val_name, AccType_AT, iswrite, true, 1);
    if statesaved then {
        __RESTORE_EL()
    };
    if PSTATE.EL != EL2 then {
        __tc3 : bits(32) = get_SCR();
        __tc3 = __SetSlice_bits(32, 1, __tc3, 0, 0b0);
        set_SCR(__tc3)
    };
    if IsFault(addrdesc) then {
        if IsExternalAbort(addrdesc.fault) then {
            set_PAR(undefined : bits(64));
            AArch32_Abort(val_name, addrdesc.fault)
        }
    };
    report_domain_fault : bool = undefined : bool;
    if [get_TTBCR()[31]] == 0b1 | HaveEL(EL2) & [get_HCR()[0]] == 0b1 then {
        report_domain_fault = if HaveEL(EL2) & [get_HCR()[0]] == 0b1 then true else false;
        AArch32_EncodePARLD(addrdesc, report_domain_fault)
    } else {
        AArch32_EncodePARSD(addrdesc, supersection)
    }
}

val ATS12NSOUW : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS12NSOUW val_name = {
    ATS12NSOxx(val_name, true, true)
}

val ATS12NSOUR : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS12NSOUR val_name = {
    ATS12NSOxx(val_name, true, false)
}

val ATS12NSOPW : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS12NSOPW val_name = {
    ATS12NSOxx(val_name, false, true)
}

val ATS12NSOPR : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function ATS12NSOPR val_name = {
    ATS12NSOxx(val_name, false, false)
}

val AArch32_AutoGen_SysRegWrite32 : (bits(2), bits(4), bits(3), bits(4), bits(3), bits(4), bits(1), bits(32)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_AutoGen_SysRegWrite32 (el, coproc, opc1, CRn, opc2, CRm, read, val_name) = {
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let ___ELUsingAArch32_EL3_ = ~(ELUsingAArch32(EL3));
    let __ELUsingAArch32_EL3_ = ELUsingAArch32(EL3);
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    if (CRm & 0x0) == 0x0 then {
        if opc1 == 0b000 then {
            if coproc == 0xE then {
                if CRn == 0x0 then {
                    if opc2 == 0b101 then {
                        DBGBCR[UInt(slice(CRm, 0, 4))] = val_name
                    } else {
                        if opc2 == 0b100 then {
                            DBGBVR[UInt(slice(CRm, 0, 4))] = val_name
                        } else {
                            if opc2 == 0b110 then {
                                DBGWVR[UInt(slice(CRm, 0, 4))] = val_name
                            } else {
                                if opc2 == 0b111 then {
                                    DBGWCR[UInt(slice(CRm, 0, 4))] = val_name
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b001 then {
                        if CRn == 0x1 then {
                            DBGBXVR[UInt(slice(CRm, 0, 4))] = val_name
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        PMEVCNTR[UInt(slice(CRm, 0, 2) @ slice(opc2, 0, 3))] = val_name
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if opc1 == 0b000 then {
                if CRn == 0xE then {
                    if coproc == 0xF then {
                        PMEVTYPER[UInt(slice(CRm, 0, 2) @ slice(opc2, 0, 3))] = val_name
                    }
                }
            }
        };
        if (CRm & 0xE) == 0xC then {
            if CRn == 0xC then {
                if coproc == 0xF then {
                    if opc1 == 0b100 then {
                        ICH_LR[UInt(slice(opc2, 0, 3))] = val_name
                    }
                }
            }
        }
    };
    if (opc2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if opc1 == 0b000 then {
                    if coproc == 0xF then {
                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            ICV_AP0R[UInt(slice(opc2, 0, 2))] = val_name
                        } else {
                            ICC_AP0R[UInt(slice(opc2, 0, 2))] = val_name
                        }
                    }
                }
            }
        }
    };
    if (opc2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if coproc == 0xF then {
                if opc1 == 0b100 then {
                    if CRm == 0x8 then {
                        ICH_AP0R[UInt(slice(opc2, 0, 2))] = val_name
                    } else {
                        if CRm == 0x9 then {
                            ICH_AP1R[UInt(slice(opc2, 0, 2))] = val_name
                        }
                    }
                } else {
                    if opc1 == 0b000 then {
                        if CRm == 0x9 then {
                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                ICV_AP1R[UInt(slice(opc2, 0, 2))] = val_name
                            } else {
                                if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    ICC_AP1R[UInt(slice(opc2, 0, 2))] = val_name
                                } else {
                                    ICC_AP1R[UInt(slice(opc2, 0, 2))] = val_name
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if coproc == 0xF then {
        if opc1 == 0b000 then {
            if opc2 == 0b001 then {
                if CRn == 0x7 then {
                    if CRm == 0xE then {
                        DCCIMVAC(ZeroExtend(val_name));
                        return()
                    } else {
                        if CRm == 0xA then {
                            DCCMVAC(ZeroExtend(val_name));
                            return()
                        } else {
                            if CRm == 0x8 then {
                                ATS1CPW(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x5 then {
                                    ICIMVAU(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0xB then {
                                        DCCMVAU(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x6 then {
                                            DCIMVAC(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x9 then {
                                                ATS1CPWP(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            MVBAR = val_name
                        } else {
                            if CRn == 0xD then {
                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    CONTEXTIDR_S = val_name
                                } else {
                                    set_CONTEXTIDR_NS(val_name)
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                        ACTLR_S = val_name
                                    } else {
                                        set_ACTLR_NS(val_name)
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            IFSR_S = val_name
                                        } else {
                                            set_IFSR_NS(val_name)
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                TTBR1_S = __SetSlice_bits(64, 32, TTBR1_S, 0, val_name)
                                            } else {
                                                __tc1 : bits(64) = get_TTBR1_NS();
                                                __tc1 = __SetSlice_bits(64, 32, __tc1, 0, val_name);
                                                set_TTBR1_NS(__tc1)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x3 then {
                            if CRn == 0xE then {
                                if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    set_CNTHV_CTL(val_name)
                                } else {
                                    set_CNTV_CTL(val_name)
                                }
                            } else {
                                if CRn == 0x1 then {
                                    set_SDCR(val_name)
                                } else {
                                    if CRn == 0xA then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            AMAIR1_S = val_name
                                        } else {
                                            set_AMAIR1_NS(val_name)
                                        }
                                    } else {
                                        if CRn == 0x8 then {
                                            TLBIMVAIS(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if CRm == 0x8 then {
                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        set_ICV_EOIR0(val_name)
                                    } else {
                                        set_ICC_EOIR0(val_name)
                                    }
                                } else {
                                    if CRm == 0xB then {
                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            set_ICV_DIR(val_name)
                                        } else {
                                            set_ICC_DIR(val_name)
                                        }
                                    } else {
                                        if CRm == 0xC then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                set_ICV_EOIR1(val_name)
                                            } else {
                                                set_ICC_EOIR1(val_name)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            CNTP_CTL_S = val_name
                                        } else {
                                            if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                set_CNTHP_CTL(val_name)
                                            } else {
                                                set_CNTP_CTL_NS(val_name)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            set_TRFCR(val_name)
                                        } else {
                                            if CRn == 0xA then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    MAIR1_S = val_name;
                                                    NMRR_S = val_name
                                                } else {
                                                    set_MAIR1_NS(val_name);
                                                    set_NMRR_NS(val_name)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            set_PMXEVTYPER(val_name)
                                        } else {
                                            if CRm == 0xE then {
                                                set_PMINTENSET(val_name)
                                            } else {
                                                if CRm == 0xC then {
                                                    set_PMCNTENSET(val_name)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x8 then {
                                            if CRm == 0x5 then {
                                                ITLBIMVA(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x6 then {
                                                    DTLBIMVA(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0x7 then {
                                                        TLBIMVA(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x1 then {
                                                    set_SDER(val_name)
                                                } else {
                                                    if CRn == 0x5 then {
                                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                            AIFSR_S = val_name
                                                        } else {
                                                            set_AIFSR_NS(val_name)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if opc2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                VBAR_S = val_name
                            } else {
                                set_VBAR_NS(val_name)
                            }
                        } else {
                            if CRn == 0x5 then {
                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                    DFSR_S = val_name
                                } else {
                                    set_DFSR_NS(val_name)
                                }
                            } else {
                                if CRn == 0xD then {
                                    FCSEIDR = val_name
                                } else {
                                    if CRn == 0x3 then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            DACR_S = val_name
                                        } else {
                                            set_DACR_NS(val_name)
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            set_CNTFRQ(val_name)
                                        } else {
                                            if CRn == 0x6 then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    set_DFAR_S(val_name)
                                                } else {
                                                    set_DFAR_NS(val_name)
                                                }
                                            } else {
                                                if CRn == 0x1 then {
                                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        SCTLR_S = val_name
                                                    } else {
                                                        set_SCTLR_NS(val_name)
                                                    }
                                                } else {
                                                    if CRn == 0x2 then {
                                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                            TTBR0_S = __SetSlice_bits(64, 32, TTBR0_S, 0, val_name)
                                                        } else {
                                                            __tc2 : bits(64) = get_TTBR0_NS();
                                                            __tc2 = __SetSlice_bits(64, 32, __tc2, 0, val_name);
                                                            set_TTBR0_NS(__tc2)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x7 then {
                            if CRm == 0x8 then {
                                ATS1CPR(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x5 then {
                                    ICIALLU();
                                    return()
                                } else {
                                    if CRm == 0x1 then {
                                        ICIALLUIS();
                                        return()
                                    } else {
                                        if CRm == 0x4 then {
                                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                PAR_S = __SetSlice_bits(64, 32, PAR_S, 0, val_name)
                                            } else {
                                                __tc3 : bits(64) = get_PAR_NS();
                                                __tc3 = __SetSlice_bits(64, 32, __tc3, 0, val_name);
                                                set_PAR_NS(__tc3)
                                            }
                                        } else {
                                            if CRm == 0x9 then {
                                                ATS1CPRP(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x8 then {
                                if CRm == 0x5 then {
                                    ITLBIALL();
                                    return()
                                } else {
                                    if CRm == 0x6 then {
                                        DTLBIALL();
                                        return()
                                    } else {
                                        if CRm == 0x7 then {
                                            TLBIALL();
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                TLBIALLIS();
                                                return()
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0xE then {
                                        set_CNTKCTL(val_name)
                                    } else {
                                        if CRn == 0x1 then {
                                            set_SCR(val_name)
                                        } else {
                                            if CRn == 0x5 then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    ADFSR_S = val_name
                                                } else {
                                                    set_ADFSR_NS(val_name)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            __tc4 : bits(64) = get_PMCCNTR();
                                            __tc4 = __SetSlice_bits(64, 32, __tc4, 0, val_name);
                                            set_PMCCNTR(__tc4)
                                        } else {
                                            if CRm == 0xE then {
                                                set_PMUSERENR(val_name)
                                            } else {
                                                if CRm == 0xC then {
                                                    set_PMCR(val_name)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x2 then {
                                            if CRn == 0xE then {
                                                if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    CNTP_TVAL_S = val_name
                                                } else {
                                                    if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        set_CNTHP_TVAL(val_name)
                                                    } else {
                                                        set_CNTP_TVAL_NS(val_name)
                                                    }
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        MAIR0_S = val_name;
                                                        PRRR_S = val_name
                                                    } else {
                                                        set_MAIR0_NS(val_name);
                                                        set_PRRR_NS(val_name)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    if ((el == EL0 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        set_CNTHV_TVAL(val_name)
                                                    } else {
                                                        set_CNTV_TVAL(val_name)
                                                    }
                                                } else {
                                                    if CRn == 0xA then {
                                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                            AMAIR0_S = val_name
                                                        } else {
                                                            set_AMAIR0_NS(val_name)
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if CRn == 0x4 then {
                                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            set_ICV_PMR(val_name)
                                                        } else {
                                                            set_ICC_PMR(val_name)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0x7 then {
                        if CRm == 0x8 then {
                            if opc2 == 0b010 then {
                                ATS1CUR(ZeroExtend(val_name));
                                return()
                            } else {
                                if opc2 == 0b101 then {
                                    ATS12NSOPW(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if opc2 == 0b100 then {
                                        ATS12NSOPR(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if opc2 == 0b110 then {
                                            ATS12NSOUR(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if opc2 == 0b111 then {
                                                ATS12NSOUW(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if opc2 == 0b011 then {
                                                    ATS1CUW(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b010 then {
                                if CRm == 0xA then {
                                    DCCSW(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x6 then {
                                        DCISW(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0xE then {
                                            DCCISW(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x3 then {
                                    if opc2 == 0b101 then {
                                        DVPRCTX(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if opc2 == 0b100 then {
                                            CFPRCTX(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if opc2 == 0b111 then {
                                                CPPRCTX(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if opc2 == 0b100 then {
                                            CP15ISB();
                                            return()
                                        } else {
                                            if opc2 == 0b110 then {
                                                BPIALL();
                                                return()
                                            } else {
                                                if opc2 == 0b111 then {
                                                    BPIMVA(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0xA then {
                                            if opc2 == 0b101 then {
                                                CP15DMB();
                                                return()
                                            } else {
                                                if opc2 == 0b100 then {
                                                    CP15DSB();
                                                    return()
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if opc2 == 0b110 then {
                                                    BPIALLIS();
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b010 then {
                            if CRm == 0x0 then {
                                if CRn == 0xC then {
                                    set_RMR(val_name)
                                } else {
                                    if CRn == 0x2 then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            TTBCR_S = val_name
                                        } else {
                                            set_TTBCR_NS(val_name)
                                        }
                                    } else {
                                        if CRn == 0x6 then {
                                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                set_IFAR_S(val_name)
                                            } else {
                                                set_IFAR_NS(val_name)
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                set_CPACR(val_name)
                                            } else {
                                                if CRn == 0xD then {
                                                    if ((el == EL3 | el == EL0) & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        TPIDRURW_S = val_name
                                                    } else {
                                                        set_TPIDRURW_NS(val_name)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x8 then {
                                    if CRm == 0x5 then {
                                        ITLBIASID(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x6 then {
                                            DTLBIASID(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBIASID(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBIASIDIS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            set_PMXEVCNTR(val_name)
                                        } else {
                                            if CRm == 0xE then {
                                                set_PMINTENCLR(val_name)
                                            } else {
                                                if CRm == 0xC then {
                                                    set_PMCNTENCLR(val_name)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                NSACR = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if opc2 == 0b011 then {
                                if CRm == 0x0 then {
                                    if CRn == 0x2 then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            TTBCR2_S = val_name
                                        } else {
                                            set_TTBCR2_NS(val_name)
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                ACTLR2_S = val_name
                                            } else {
                                                set_ACTLR2_NS(val_name)
                                            }
                                        } else {
                                            if CRn == 0xD then {
                                                if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    TPIDRURO_S = val_name
                                                } else {
                                                    set_TPIDRURO_NS(val_name)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0x8 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                set_ICV_BPR0(val_name)
                                            } else {
                                                set_ICC_BPR0(val_name)
                                            }
                                        } else {
                                            if CRm == 0xC then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    set_ICV_BPR1(val_name)
                                                } else {
                                                    if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        set_ICC_BPR1_S(val_name)
                                                    } else {
                                                        set_ICC_BPR1_NS(val_name)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xE then {
                                                set_PMOVSSET(val_name)
                                            } else {
                                                if CRm == 0xC then {
                                                    set_PMOVSR(val_name)
                                                }
                                            }
                                        } else {
                                            if CRn == 0x8 then {
                                                if CRm == 0x7 then {
                                                    TLBIMVAA(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0x3 then {
                                                        TLBIMVAAIS(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xC then {
                                    if CRn == 0xC then {
                                        if opc2 == 0b101 then {
                                            if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                set_ICC_SRE_S(val_name)
                                            } else {
                                                set_ICC_SRE_NS(val_name)
                                            }
                                        } else {
                                            if opc2 == 0b100 then {
                                                if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                    set_ICC_CTLR_S(val_name)
                                                } else {
                                                    if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        set_ICV_CTLR(val_name)
                                                    } else {
                                                        set_ICC_CTLR_NS(val_name)
                                                    }
                                                }
                                            } else {
                                                if opc2 == 0b110 then {
                                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        set_ICV_IGRPEN0(val_name)
                                                    } else {
                                                        set_ICC_IGRPEN0(val_name)
                                                    }
                                                } else {
                                                    if opc2 == 0b111 then {
                                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            set_ICV_IGRPEN1(val_name)
                                                        } else {
                                                            if (el == EL1 & __SCR_EL3_NS == 0) & ___ELUsingAArch32_EL3_ | (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                                set_ICC_IGRPEN1_S(val_name)
                                                            } else {
                                                                set_ICC_IGRPEN1_NS(val_name)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if opc2 == 0b101 then {
                                                set_PMSELR(val_name)
                                            } else {
                                                if opc2 == 0b100 then {
                                                    set_PMSWINC(val_name)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x8 then {
                                        if opc2 == 0b111 then {
                                            if CRm == 0x7 then {
                                                TLBIMVAAL(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBIMVAALIS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        } else {
                                            if opc2 == 0b101 then {
                                                if CRm == 0x7 then {
                                                    TLBIMVAL(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0x3 then {
                                                        TLBIMVALIS(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if opc2 == 0b100 then {
                                                if CRn == 0xD then {
                                                    if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                                        TPIDRPRW_S = val_name
                                                    } else {
                                                        set_TPIDRPRW_NS(val_name)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if opc2 == 0b111 then {
                                                    if CRm == 0xF then {
                                                        set_PMCCFILTR(val_name)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if opc1 == 0b100 then {
                if opc2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            set_HVBAR(val_name)
                        } else {
                            if CRn == 0x6 then {
                                set_HDFAR(val_name)
                            } else {
                                if CRn == 0x1 then {
                                    set_HSCTLR(val_name)
                                } else {
                                    if CRn == 0x0 then {
                                        set_VPIDR(val_name)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                set_CNTHCTL(val_name)
                            } else {
                                if CRn == 0x1 then {
                                    set_HCR(val_name)
                                } else {
                                    if CRn == 0x5 then {
                                        set_HADFSR(val_name)
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    set_CNTHP_TVAL(val_name)
                                } else {
                                    if CRn == 0xA then {
                                        set_HMAIR0(val_name)
                                    } else {
                                        if CRn == 0x5 then {
                                            set_HSR(val_name)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x8 then {
                                    if CRm == 0x7 then {
                                        TLBIALLH();
                                        return()
                                    } else {
                                        if CRm == 0x3 then {
                                            TLBIALLHIS();
                                            return()
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            set_ICH_HCR(val_name)
                                        }
                                    } else {
                                        if CRm == 0x8 then {
                                            if CRn == 0x7 then {
                                                ATS1HR(ZeroExtend(val_name));
                                                return()
                                            }
                                        } else {
                                            if CRn == 0xA then {
                                                if CRm == 0x3 then {
                                                    set_HAMAIR0(val_name)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b001 then {
                        if CRn == 0x8 then {
                            if CRm == 0x0 then {
                                TLBIIPAS2IS(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x4 then {
                                    TLBIIPAS2(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x7 then {
                                        TLBIMVAH(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x3 then {
                                            TLBIMVAHIS(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    set_CNTHP_CTL(val_name)
                                } else {
                                    if CRn == 0x1 then {
                                        set_HTRFCR(val_name)
                                    } else {
                                        if CRn == 0xA then {
                                            set_HMAIR1(val_name)
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        set_HDCR(val_name)
                                    } else {
                                        if CRn == 0x5 then {
                                            set_HAIFSR(val_name)
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0x1 then {
                                            set_HACTLR(val_name)
                                        }
                                    } else {
                                        if CRm == 0x8 then {
                                            if CRn == 0x7 then {
                                                ATS1HW(ZeroExtend(val_name));
                                                return()
                                            }
                                        } else {
                                            if CRn == 0xA then {
                                                if CRm == 0x3 then {
                                                    set_HAMAIR1(val_name)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if opc2 == 0b010 then {
                                if CRn == 0xC then {
                                    set_HRMR(val_name)
                                } else {
                                    if CRn == 0x2 then {
                                        set_HTCR(val_name)
                                    } else {
                                        if CRn == 0x6 then {
                                            set_HIFAR(val_name)
                                        } else {
                                            if CRn == 0xD then {
                                                set_HTPIDR(val_name)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if opc2 == 0b101 then {
                                    if CRn == 0x0 then {
                                        set_VMPIDR(val_name)
                                    } else {
                                        if CRn == 0x8 then {
                                            TLBIIPAS2LIS(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                } else {
                                    if opc2 == 0b100 then {
                                        if CRn == 0x6 then {
                                            set_HPFAR(val_name)
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if opc2 == 0b011 then {
                                                set_HACTLR2(val_name)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x1 then {
                                if CRn == 0x1 then {
                                    if opc2 == 0b010 then {
                                        set_HCPTR(val_name)
                                    } else {
                                        if opc2 == 0b100 then {
                                            set_HCR2(val_name)
                                        } else {
                                            if opc2 == 0b111 then {
                                                set_HACR(val_name)
                                            } else {
                                                if opc2 == 0b011 then {
                                                    set_HSTR(val_name)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if opc2 == 0b010 then {
                                        if CRn == 0x2 then {
                                            set_VTCR(val_name)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x8 then {
                                    if opc2 == 0b101 then {
                                        if CRm == 0x4 then {
                                            TLBIIPAS2L(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBIMVALH(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBIMVALHIS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    } else {
                                        if opc2 == 0b100 then {
                                            if CRm == 0x7 then {
                                                TLBIALLNSNH();
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBIALLNSNHIS();
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if opc2 == 0b101 then {
                                            if CRm == 0x9 then {
                                                set_ICC_HSRE(val_name)
                                            }
                                        } else {
                                            if CRm == 0xB then {
                                                if opc2 == 0b111 then {
                                                    set_ICH_VMCR(val_name)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0xC then {
                    if opc1 == 0b110 then {
                        if CRm == 0xC then {
                            if opc2 == 0b101 then {
                                set_ICC_MSRE(val_name)
                            } else {
                                if opc2 == 0b100 then {
                                    set_ICC_MCTLR(val_name)
                                } else {
                                    if opc2 == 0b111 then {
                                        set_ICC_MGRPEN1(val_name)
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0x4 then {
                        if CRm == 0x5 then {
                            if opc1 == 0b011 then {
                                if opc2 == 0b000 then {
                                    set_DSPSR(val_name)
                                } else {
                                    if opc2 == 0b001 then {
                                        set_DLR(val_name)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if opc1 == 0b010 then {
                                if opc2 == 0b000 then {
                                    if CRn == 0x0 then {
                                        if (el == EL3 & __SCR_EL3_NS == 0) & __ELUsingAArch32_EL3_ then {
                                            CSSELR_S = val_name
                                        } else {
                                            set_CSSELR_NS(val_name)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if coproc == 0xE then {
            if opc1 == 0b000 then {
                if CRn == 0x0 then {
                    if opc2 == 0b010 then {
                        if CRm == 0x2 then {
                            set_DBGDSCRext(val_name)
                        } else {
                            if CRm == 0x0 then {
                                set_DBGDTRRXext(val_name)
                            } else {
                                if CRm == 0x6 then {
                                    set_DBGOSECCR(val_name)
                                } else {
                                    if CRm == 0x3 then {
                                        set_DBGDTRTXext(val_name)
                                    }
                                }
                            }
                        }
                    } else {
                        if opc2 == 0b000 then {
                            if CRm == 0x2 then {
                                set_DBGDCCINT(val_name)
                            } else {
                                if CRm == 0x5 then {
                                    set_DBGDTRTXint(val_name)
                                } else {
                                    if CRm == 0x6 then {
                                        DBGWFAR = val_name
                                    } else {
                                        if CRm == 0x7 then {
                                            set_DBGVCR(val_name)
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if opc2 == 0b100 then {
                        if CRn == 0x1 then {
                            if CRm == 0x0 then {
                                set_DBGOSLAR(val_name)
                            } else {
                                if CRm == 0x4 then {
                                    set_DBGPRCR(val_name)
                                } else {
                                    if CRm == 0x3 then {
                                        set_DBGOSDLR(val_name)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x7 then {
                            if opc2 == 0b110 then {
                                if CRm == 0x8 then {
                                    set_DBGCLAIMSET(val_name)
                                } else {
                                    if CRm == 0x9 then {
                                        set_DBGCLAIMCLR(val_name)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRm == 0x0 then {
                    if opc2 == 0b000 then {
                        if opc1 == 0b111 then {
                            if CRn == 0x1 then {
                                JOSCR = val_name
                            } else {
                                if CRn == 0x2 then {
                                    JMCR = val_name
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

val AArch32_SysRegWrite : forall ('cp_num : Int).
  (int('cp_num), bits(32), bits(32)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_SysRegWrite (cp_num, instr, val_name) = {
    __anon1 : bool = undefined : bool;
    el : bits(2) = undefined : bits(2);
    (__anon1, el) = ELFromM32(PSTATE.M);
    let opc1 = slice(instr, 21, 3);
    let CRn = slice(instr, 16, 4);
    let CRm = slice(instr, 0, 4);
    let opc2 = slice(instr, 5, 3);
    if ((((PSTATE.EL != EL0 & cp_num == 14) & opc1 == 0b111) & opc2 == 0b000) & CRn == 0x2) & CRm == 0x0 then {
        return()
    };
    AArch32_AutoGen_SysRegWrite32(el, __GetSlice_int(4, cp_num, 0), opc1, CRn, opc2, CRm, 0b0, val_name);
    if ((((cp_num == 15 & (opc1 == 0b000 | opc1 == 0b100)) & CRn == 0xC) & opc2 == 0b010) & CRm == 0x0) & [val_name[1]] == 0b1 then {
        TakeReset(false)
    } else {
        if (((cp_num == 15 & opc1 == 0b000) & (opc2 == 0b100 | opc2 == 0b111)) & CRn == 0x0) & CRm == 0x0 then {
            set_MIDR(val_name)
        }
    };
    return()
}

val AArch32_aset_MemSingle : forall 'size ('wasaligned : Bool),
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccType, bool('wasaligned), bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_aset_MemSingle (address, size, acctype, wasaligned, value_name) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    assert(address == Align(address, size));
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    let iswrite = true;
    let memaddrdesc = AArch32_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch32_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareable then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    };
    let accdesc = CreateAccessDescriptor(acctype);
    if HaveMTEExt() then {
        if AccessIsTagChecked(ZeroExtend(address, 64), acctype) then {
            let ptag = TransformTag(ZeroExtend(address, 64));
            if ~(CheckTag(memaddrdesc, ptag, iswrite)) then {
                TagCheckFail(ZeroExtend(address, 64), iswrite)
            }
        }
    };
    _Mem(memaddrdesc, size, accdesc) = value_name;
    return()
}

overload MemSingle = {AArch32_aset_MemSingle}

val AArch32_CheckITEnabled : bits(4) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_CheckITEnabled mask = {
    it_disabled : bits(1) = undefined : bits(1);
    if PSTATE.EL == EL2 then {
        it_disabled = [get_HSCTLR()[7]]
    } else {
        it_disabled = if ELUsingAArch32(EL1) then [get_SCTLR()[7]] else [SCTLR()[7]]
    };
    next_instr : bits(16) = undefined : bits(16);
    if it_disabled == 0b1 then {
        if mask != 0x8 then {
            throw(Error_Undefined())
        };
        next_instr = MemSingle(NextInstrAddr(), 2, AccType_IFETCH, true);
        if (next_instr & 0xC000) == 0xC000 | (next_instr & 0xF000) == 0xB000 | (next_instr & 0xF800) == 0xA000 | (next_instr & 0xF800) == 0x4800 | (next_instr & 0xFC78) == 0x4478 | (next_instr & 0xFC87) == 0x4487 then {
            throw(Error_Undefined())
        }
    };
    return()
}

val IT_Op_A : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function IT_Op_A (firstcond, mask) = {
    AArch32_CheckITEnabled(mask);
    __tc1 : bits(8) = PSTATE.IT;
    let __tc1 = __SetSlice_bits(8, 8, __tc1, 0, firstcond @ mask);
    PSTATE.IT = __tc1;
    ShouldAdvanceIT = false
}

val IT_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function IT_T1_A_decode (firstcond, mask) = {
    __unconditional = true;
    if mask == 0x0 then {
        throw(Error_See("Related encodings"))
    };
    if firstcond == 0xF | firstcond == 0xE & BitCount(mask) != 1 then {
        throw(Error_Unpredictable())
    };
    if InITBlock() then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    IT_Op_A(firstcond, mask)
}

val AArch32_SoftwareBreakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch32_SoftwareBreakpoint immediate = {
    if (EL2Enabled() & ~(ELUsingAArch32(EL2))) & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1) | ~(ELUsingAArch32(EL1)) then {
        AArch64_SoftwareBreakpoint(immediate)
    };
    let vaddress = undefined : bits(32);
    let acctype = AccType_IFETCH;
    let iswrite = false;
    let entry = DebugException_BKPT;
    let fault : FaultRecord = AArch32_DebugFault(acctype, iswrite, entry);
    AArch32_Abort(vaddress, fault)
}

val BKPT_Op_A : bits(16) -> unit effect {escape, rreg, undef, wreg}

function BKPT_Op_A imm16 = {
    AArch32_SoftwareBreakpoint(imm16)
}

val BKPT_T1_A_decode : bits(8) -> unit effect {escape, rreg, undef, wreg}

function BKPT_T1_A_decode imm8 = {
    __unconditional = true;
    let imm16 : bits(16) = ZeroExtend(imm8, 16);
    __PostDecode();
    BKPT_Op_A(imm16)
}

val BKPT_A1_A_decode : (bits(4), bits(12), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function BKPT_A1_A_decode (cond, imm12, imm4) = {
    __unconditional = true;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm16 = imm12 @ imm4;
    if cond != 0xE then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    BKPT_Op_A(imm16)
}

val AArch32_ExclusiveMonitorsPass : forall ('size : Int).
  (bits(32), int('size)) -> bool effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_ExclusiveMonitorsPass (address, size) = {
    let acctype = AccType_ATOMIC;
    let iswrite = true;
    let aligned = address == Align(address, size);
    secondstage : bool = undefined : bool;
    if ~(aligned) then {
        secondstage = false;
        AArch32_Abort(address, AArch32_AlignmentFault(acctype, iswrite, secondstage))
    };
    passed : bool = undefined : bool;
    passed = AArch32_IsExclusiveVA(address, ProcessorID(), size);
    if ~(passed) then {
        return(false)
    };
    let memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch32_Abort(address, memaddrdesc.fault)
    };
    passed = IsExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    if passed then {
        ClearExclusiveLocal(ProcessorID());
        if memaddrdesc.memattrs.shareable then {
            passed = IsExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
        }
    };
    passed
}

val AArch32_CheckAlignment : forall ('alignment : Int) ('iswrite : Bool).
  (bits(32), int('alignment), AccType, bool('iswrite)) -> bool effect {escape, rreg, undef, wreg}

function AArch32_CheckAlignment (address, alignment, acctype, iswrite) = {
    A : bits(1) = undefined : bits(1);
    if PSTATE.EL == EL0 & ~(ELUsingAArch32(S1TranslationRegime())) then {
        A = [SCTLR()[1]]
    } else {
        if PSTATE.EL == EL2 then {
            A = [get_HSCTLR()[1]]
        } else {
            A = [get_SCTLR()[1]]
        }
    };
    let aligned = address == Align(address, alignment);
    let atomic = acctype == AccType_ATOMIC | acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    let ordered = acctype == AccType_ORDERED | acctype == AccType_ORDEREDRW | acctype == AccType_LIMITEDORDERED | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    let vector_name = acctype == AccType_VEC;
    let check : bool = ((atomic | ordered) | vector_name) | A == 0b1;
    secondstage : bool = undefined : bool;
    if check & ~(aligned) then {
        secondstage = false;
        AArch32_Abort(address, AArch32_AlignmentFault(acctype, iswrite, secondstage))
    };
    aligned
}

val aset_Mem_with_type : forall 'size,
  8 * 'size >= 0 & 'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccType, bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_Mem_with_type (address, size, acctype, value_name__arg) = {
    value_name = value_name__arg;
    let iswrite = true;
    if BigEndian() then {
        value_name = BigEndianReverse(value_name)
    };
    aligned : bool = undefined : bool;
    aligned = AArch32_CheckAlignment(address, size, acctype, iswrite);
    c : Constraint = undefined : Constraint;
    if ~(aligned) then {
        assert(size > 1);
        MemSingle(address, 1, acctype, aligned) = slice(value_name, 0, 8);
        c = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
        assert(c == Constraint_FAULT | c == Constraint_NONE);
        if c == Constraint_NONE then {
            aligned = true
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            MemSingle(address + i, 1, acctype, aligned) = slice(value_name, 8 * i, 8)
        }
    } else {
        MemSingle(address, size, acctype, aligned) = value_name
    };
    return()
}

overload Mem_with_type = {aset_Mem_with_type}

val aset_MemU_unpriv : forall 'size,
  8 * 'size >= 0 & 'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_MemU_unpriv (address, size, value_name) = {
    let acctype = AccType_UNPRIV;
    Mem_with_type(address, size, acctype) = value_name;
    return()
}

overload MemU_unpriv = {aset_MemU_unpriv}

val STRT_Op_A : forall 'm 'n 'shift_n 't,
  ('m >= 0 & 'm <= 15 & 'n >= 0 & 'n <= 15 & 't >= 0 & 't <= 15).
  (bool, bits(32), int('m), int('n), bool, bool, int('shift_n), SRType, int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRT_Op_A (add, imm32, m, n, postindex, register_form, shift_n, shift_t, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then Shift(aget_R(m), shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then aget_R(n) + offset else aget_R(n) - offset;
        address = if postindex then aget_R(n) else offset_addr;
        if t == 15 then {
            data = PCStoreValue()
        } else {
            data = aget_R(t)
        };
        if ~(postindex) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        aset_MemU_unpriv(address, 4, data);
        if postindex then {
            assert(n <= 14);
            aset_R(n, offset_addr)
        }
    }
}

val STRT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool = false;
    let add : bool = true;
    let register_form : bool = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= m & m <= 15);
    STRT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val STRT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRT_A2pre_A_decode (cond, U, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if (n == 15 | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val STRT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRT_A1pre_A_decode (cond, U, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool = true;
    let add : bool = U == 0b1;
    let register_form : bool = false;
    let imm32 : bits(32) = ZeroExtend(imm12, 32);
    if n == 15 | n == t then {
        throw(Error_Unpredictable())
    };
    assert(0 <= m & m <= 15);
    __PostDecode();
    STRT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val STRHT_Op_A : forall 'm 'n 't,
  ('m >= 0 & 'm <= 15 & 'n >= 0 & 'n <= 15 & 't >= 0 & 't <= 14).
  (bool, bits(32), int('m), int('n), bool, bool, int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRHT_Op_A (add, imm32, m, n, postindex, register_form, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then aget_R(m) else imm32;
        offset_addr = if add then aget_R(n) + offset else aget_R(n) - offset;
        address = if postindex then aget_R(n) else offset_addr;
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        aset_MemU_unpriv(address, 2, slice(aget_R(t), 0, 16));
        if postindex then {
            assert(n <= 14);
            aset_R(n, offset_addr)
        }
    }
}

val STRHT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRHT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool = false;
    let add : bool = true;
    let register_form : bool = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    assert(0 <= m & m <= 15);
    __PostDecode();
    STRHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val STRHT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRHT_A2pre_A_decode (cond, U, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    if ((t == 15 | n == 15) | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val STRHT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRHT_A1pre_A_decode (cond, U, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool = true;
    let add : bool = U == 0b1;
    let register_form : bool = false;
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    if (t == 15 | n == 15) | n == t then {
        throw(Error_Unpredictable())
    };
    assert(0 <= m & m <= 15);
    __PostDecode();
    STRHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val STRBT_Op_A : forall 'm 'n 'shift_n 't,
  ('m >= 0 & 'm <= 15 & 'n >= 0 & 'n <= 15 & 't >= 0 & 't <= 15).
  (bool, bits(32), int('m), int('n), bool, bool, int('shift_n), SRType, int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRBT_Op_A (add, imm32, m, n, postindex, register_form, shift_n, shift_t, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then Shift(aget_R(m), shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then aget_R(n) + offset else aget_R(n) - offset;
        address = if postindex then aget_R(n) else offset_addr;
        if ~(postindex) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        aset_MemU_unpriv(address, 1, slice(aget_R(t), 0, 8));
        if postindex then {
            assert(n <= 14);
            aset_R(n, offset_addr)
        }
    }
}

val STRBT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRBT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool = false;
    let add : bool = true;
    let register_form : bool = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= m & m <= 15);
    STRBT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val STRBT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRBT_A2pre_A_decode (cond, U, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if ((t == 15 | n == 15) | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRBT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val STRBT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRBT_A1pre_A_decode (cond, U, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool = true;
    let add : bool = U == 0b1;
    let register_form : bool = false;
    let imm32 : bits(32) = ZeroExtend(imm12, 32);
    if (t == 15 | n == 15) | n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= m & m <= 15);
    STRBT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val aset_MemU : forall 'size,
  8 * 'size >= 0 & 'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_MemU (address, size, value_name) = {
    let acctype = AccType_NORMAL;
    Mem_with_type(address, size, acctype) = value_name;
    return()
}

overload MemU = {aset_MemU}

val VST3_1_Op_A : forall 'd 'd2 'd3 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 8 * 'ebytes >= 0 & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('d), int('d2), int('d3), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST3_1_Op_A (d, d2, d3, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        CheckAdvSIMDEnabled();
        address = R(n);
        MemU(address, ebytes) = aget_Elem(D(d), index);
        MemU(address + ebytes, ebytes) = aget_Elem(D(d2), index);
        MemU(address + 2 * ebytes, ebytes) = aget_Elem(D(d3), index);
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 3 * ebytes
            }
        }
    }
}

val VST3_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST3_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if slice(index_align, 0, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let inc_name = if [index_align[2]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST3_1_Op_A(d, d2, d3, ebytes, index, m, n, register_index, wback)
}

val VST3_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST3_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if [index_align[0]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let inc_name = if [index_align[1]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST3_1_Op_A(d, d2, d3, ebytes, index, m, n, register_index, wback)
}

val VST3_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST3_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if [index_align[0]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let inc_name = 1;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST3_1_Op_A(d, d2, d3, ebytes, index, m, n, register_index, wback)
}

val STR_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 15 | not(not('t == 15))) & ('n <= 14 | not('wback)).
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_r_Op_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if t == 15 then {
            data = PCStoreValue()
        } else {
            data = R(t)
        };
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        MemU(address, 4) = data;
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STR_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STR_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STR_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    STR_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STR_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_r_A1_A_decode (cond, P, U, W, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("STRT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STR_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STR_i_OpT_A : forall 'n 't,
  ('n >= 0 & 'n <= 15 & 't >= 0 & 't <= 15).
  (bool, bits(32), bool, int('n), int('t), bool) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_i_OpT_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then aget_R(n) + imm32 else aget_R(n) - imm32;
        address = if index then offset_addr else aget_R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        aset_MemU(address, 4, aget_R(t));
        if wback then {
            assert(n <= 14);
            aset_R(n, offset_addr)
        }
    }
}

val STR_i_T4_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_i_T4_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("STRT"))
    };
    if Rn == 0xF | P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = W == 0b1;
    if t == 15 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STR_i_OpT_A(add, imm32, index, n, t, wback)
}

val STR_i_T3_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_i_T3_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STR_i_OpT_A(add, imm32, index, n, t, wback)
}

val STR_i_T2_A_decode : (bits(3), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_i_T2_A_decode (Rt, imm8) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = 13;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    STR_i_OpT_A(add, imm32, index, n, t, wback)
}

val STR_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_i_T1_A_decode (imm5, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm5 @ 0b00, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    STR_i_OpT_A(add, imm32, index, n, t, wback)
}

val STR_i_OpA_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 15 | not(not('t == 15))) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_i_OpA_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        MemU(address, 4) = if t == 15 then PCStoreValue() else R(t);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STR_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STR_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("STRT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STR_i_OpA_A(add, imm32, index, n, t, wback)
}

val STRH_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 15) & ('n <= 14 | not('wback)).
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_r_Op_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        MemU(address, 2) = slice(R(t), 0, 16);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STRH_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STRH_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    STRH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STRH_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_r_A1_A_decode (cond, P, U, W, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("STRHT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STRH_i_OpT_A : forall 'n 't,
  ('n >= 0 & 'n <= 15 & 't >= 0 & 't <= 15).
  (bool, bits(32), bool, int('n), int('t), bool) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_i_OpT_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then aget_R(n) + imm32 else aget_R(n) - imm32;
        address = if index then offset_addr else aget_R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        aset_MemU(address, 2, slice(aget_R(t), 0, 16));
        if wback then {
            assert(n <= 14);
            aset_R(n, offset_addr)
        }
    }
}

val STRH_i_T3_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_i_T3_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("STRHT"))
    };
    if Rn == 0xF | P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = W == 0b1;
    if t == 15 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRH_i_OpT_A(add, imm32, index, n, t, wback)
}

val STRH_i_T2_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_i_T2_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRH_i_OpT_A(add, imm32, index, n, t, wback)
}

val STRH_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_i_T1_A_decode (imm5, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm5 @ 0b0, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    STRH_i_OpT_A(add, imm32, index, n, t, wback)
}

val STRH_i_OpA_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 15) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_i_OpA_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        MemU(address, 2) = slice(R(t), 0, 16);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STRH_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRH_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("STRHT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm4H @ imm4L, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRH_i_OpA_A(add, imm32, index, n, t, wback)
}

val STRB_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 15) & ('n <= 14 | not('wback)).
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_r_Op_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        MemU(address, 1) = slice(R(t), 0, 8);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STRB_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STRB_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    STRB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STRB_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_r_A1_A_decode (cond, P, U, W, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("STRBT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val STRB_i_OpT_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 15) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_i_OpT_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        MemU(address, 1) = slice(R(t), 0, 8);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STRB_i_T3_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_i_T3_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("STRBT"))
    };
    if Rn == 0xF | P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    if t == 15 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(t >= 0 & t <= 14);
    assert(n >= 0 & n <= 14);
    STRB_i_OpT_A(add, imm32, index, n, t, wback)
}

val STRB_i_T2_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_i_T2_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRB_i_OpT_A(add, imm32, index, n, t, wback)
}

val STRB_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_i_T1_A_decode (imm5, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm5, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    STRB_i_OpT_A(add, imm32, index, n, t, wback)
}

val STRB_i_OpA_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 15) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_i_OpA_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        MemU(address, 1) = slice(R(t), 0, 8);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STRB_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRB_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("STRBT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRB_i_OpA_A(add, imm32, index, n, t, wback)
}

val aset_MemO : forall 'size,
  8 * 'size >= 0 & 'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_MemO (address, size, value_name) = {
    let acctype = AccType_ORDERED;
    Mem_with_type(address, size, acctype) = value_name;
    return()
}

overload MemO = {aset_MemO}

val STLH_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLH_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetLSInstructionSyndrome(2, false, t, true);
        MemO(address, 2) = slice(R(t), 0, 16)
    }
}

val STLH_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLH_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLH_Op_A(n, t)
}

val STLH_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLH_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLH_Op_A(n, t)
}

val STLEXH_Op_A : forall 'd 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14) & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXH_Op_A (d, n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        if AArch32_ExclusiveMonitorsPass(address, 2) then {
            AArch32_SetLSInstructionSyndrome(2, false, t, true);
            MemO(address, 2) = slice(R(t), 0, 16);
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STLEXH_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXH_T1_A_decode (Rn, Rt, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLEXH_Op_A(d, n, t)
}

val STLEXH_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXH_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLEXH_Op_A(d, n, t)
}

val STLEXD_Op_A : forall 'd 'n 't 't2,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 15) & ('t2 >= 0 & 't2 <= 15) & 't <= 14 & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('t), int('t2)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXD_Op_A (d, n, t, t2) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        value_name : bits(64) = undefined : bits(64);
        address = R(n);
        value_name = if BigEndian() then R(t) @ R(t2) else R(t2) @ R(t);
        if AArch32_ExclusiveMonitorsPass(address, 8) then {
            AArch32_SetLSInstructionSyndrome(8, false, t, true);
            MemO(address, 8) = value_name;
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STLEXD_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXD_T1_A_decode (Rn, Rt, Rt2, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let n = UInt(Rn);
    if ((d == 15 | t == 15) | t2 == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if (d == n | d == t) | d == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLEXD_Op_A(d, n, t, t2)
}

val STLEXD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXD_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let t2 : int = t + 1;
    let n = UInt(Rn);
    if ((d == 15 | [Rt[0]] == 0b1) | t2 == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if (d == n | d == t) | d == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= d & d <= 14);
    assert(0 <= n & n <= 15);
    assert(0 <= t & t <= 14);
    assert(0 <= t2 & t2 <= 15);
    STLEXD_Op_A(d, n, t, t2)
}

val STLEXB_Op_A : forall 'd 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14) & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXB_Op_A (d, n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        if AArch32_ExclusiveMonitorsPass(address, 1) then {
            AArch32_SetLSInstructionSyndrome(1, false, t, true);
            MemO(address, 1) = slice(R(t), 0, 8);
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STLEXB_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXB_T1_A_decode (Rn, Rt, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLEXB_Op_A(d, n, t)
}

val STLEXB_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEXB_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLEXB_Op_A(d, n, t)
}

val STLEX_Op_A : forall 'd 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14) & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEX_Op_A (d, n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        if AArch32_ExclusiveMonitorsPass(address, 4) then {
            AArch32_SetLSInstructionSyndrome(4, false, t, true);
            MemO(address, 4) = R(t);
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STLEX_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEX_T1_A_decode (Rn, Rt, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLEX_Op_A(d, n, t)
}

val STLEX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLEX_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLEX_Op_A(d, n, t)
}

val STLB_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLB_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetLSInstructionSyndrome(1, false, t, true);
        MemO(address, 1) = slice(R(t), 0, 8)
    }
}

val STLB_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLB_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLB_Op_A(n, t)
}

val STLB_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STLB_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STLB_Op_A(n, t)
}

val STL_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STL_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetLSInstructionSyndrome(4, false, t, true);
        MemO(address, 4) = R(t)
    }
}

val STL_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STL_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STL_Op_A(n, t)
}

val STL_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STL_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STL_Op_A(n, t)
}

val aset_MemA : forall 'size,
  8 * 'size >= 0 & 'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_MemA (address, size, value_name) = {
    let acctype = AccType_ATOMIC;
    Mem_with_type(address, size, acctype) = value_name;
    return()
}

overload MemA = {aset_MemA}

val VSTR_Op_A : forall ('add : Bool) 'd 'esize 'n,
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (bool('add), int('d), int('esize), bits(32), int('n)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VSTR_Op_A (add, d, esize, imm32, n) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        CheckVFPEnabled(true);
        address = if add then R(n) + imm32 else R(n) - imm32;
        match esize {
          16 => {
              MemA(address, 2) = slice(S(d), 0, 16)
          },
          32 => {
              MemA(address, 4) = S(d)
          },
          64 => {
              MemA(address, 4) = if BigEndian() then slice(D(d), 32, 32) else slice(D(d), 0, 32);
              MemA(address + 4, 4) = if BigEndian() then slice(D(d), 0, 32) else slice(D(d), 32, 32)
          }
        }
    }
}

val VSTR_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(2), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VSTR_T1_A_decode (U, D, Rn, Vd, size, imm8) = {
    __unconditional = false;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let esize = shl_int(8, UInt(size));
    let add = U == 0b1;
    let imm32 : bits(32) = if esize == 16 then ZeroExtend(imm8 @ 0b0, 32) else ZeroExtend(imm8 @ 0b00, 32);
    d : int = undefined : int;
    match size {
      0b01 => {
          d = UInt(Vd @ D)
      },
      0b10 => {
          d = UInt(Vd @ D)
      },
      0b11 => {
          d = UInt(D @ Vd)
      }
    };
    let d = d;
    let n = UInt(Rn);
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 64))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 32))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 16))));
    if n == 15 & CurrentInstrSet() != InstrSet_A32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VSTR_Op_A(add, d, esize, imm32, n)
}

val VSTR_A1_A_decode : (bits(4), bits(1), bits(1), bits(4), bits(4), bits(2), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VSTR_A1_A_decode (cond, U, D, Rn, Vd, size, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let esize = shl_int(8, UInt(size));
    let add = U == 0b1;
    let imm32 : bits(32) = if esize == 16 then ZeroExtend(imm8 @ 0b0, 32) else ZeroExtend(imm8 @ 0b00, 32);
    d : int = undefined : int;
    match size {
      0b01 => {
          d = UInt(Vd @ D)
      },
      0b10 => {
          d = UInt(Vd @ D)
      },
      0b11 => {
          d = UInt(D @ Vd)
      }
    };
    let d = d;
    let n = UInt(Rn);
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 64))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 32))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 16))));
    if n == 15 & CurrentInstrSet() != InstrSet_A32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VSTR_Op_A(add, d, esize, imm32, n)
}

val VSTM_Op_A : forall ('add : Bool) 'd 'n 'regs ('single_regs : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('n <= 14 | not('wback)).
  (bool('add), int('d), bits(32), int('n), int('regs), bool('single_regs), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VSTM_Op_A (add, d, imm32, n, regs, single_regs, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        CheckVFPEnabled(true);
        address = if add then R(n) else R(n) - imm32;
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            if single_regs then {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('single_regs))));
                MemA(address, 4) = S(d + r);
                address = address + 4
            } else {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('single_regs)))));
                MemA(address, 4) = if BigEndian() then slice(D(d + r), 32, 32) else slice(D(d + r), 0, 32);
                MemA(address + 4, 4) = if BigEndian() then slice(D(d + r), 0, 32) else slice(D(d + r), 32, 32);
                address = address + 8
            }
        };
        if wback then {
            R(n) = if add then R(n) + imm32 else R(n) - imm32
        }
    }
}

val VSTM_T2A2_A_decode__0 : (bits(4), bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val VSTM_T2A2_A_decode__1 : (bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload VSTM_T2A2_A_decode = {VSTM_T2A2_A_decode__0, VSTM_T2A2_A_decode__1}

function VSTM_T2A2_A_decode__0 (cond, P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VSTR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs = true;
    let add = U == 0b1;
    let wback = W == 0b1;
    let d = UInt(Vd @ D);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let regs = UInt(imm8);
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if regs == 0 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VSTM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

function VSTM_T2A2_A_decode__1 (P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VSTR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs = true;
    let add = U == 0b1;
    let wback = W == 0b1;
    let d = UInt(Vd @ D);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let regs = UInt(imm8);
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if regs == 0 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VSTM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

val VSTM_T1A1_A_decode__0 : (bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val VSTM_T1A1_A_decode__1 : (bits(4), bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload VSTM_T1A1_A_decode = {VSTM_T1A1_A_decode__0, VSTM_T1A1_A_decode__1}

function VSTM_T1A1_A_decode__0 (P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VSTR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs : bool(false) = false;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8 @ 0b00, 32);
    let regs : {'n, (0 <= 'n & 'n <= 127). int('n)} = UInt(imm8) / 2;
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if (regs == 0 | regs > 16) | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    if [imm8[0]] == 0b1 & d + regs > 16 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VSTM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

function VSTM_T1A1_A_decode__1 (cond, P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VSTR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs : bool(false) = false;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8 @ 0b00, 32);
    let regs : {'n, (0 <= 'n & 'n <= 127). int('n)} = UInt(imm8) / 2;
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if (regs == 0 | regs > 16) | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    if [imm8[0]] == 0b1 & d + regs > 16 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VSTM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

val STREXH_Op_A : forall 'd 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXH_Op_A (d, n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        if AArch32_ExclusiveMonitorsPass(address, 2) then {
            MemA(address, 2) = slice(R(t), 0, 16);
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STREXH_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXH_T1_A_decode (Rn, Rt, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STREXH_Op_A(d, n, t)
}

val STREXH_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXH_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STREXH_Op_A(d, n, t)
}

val STREXD_Op_A : forall 'd 'n 't 't2,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 15) & ('t2 >= 0 & 't2 <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('t), int('t2)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXD_Op_A (d, n, t, t2) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        value_name : bits(64) = undefined : bits(64);
        address = R(n);
        value_name = if BigEndian() then R(t) @ R(t2) else R(t2) @ R(t);
        if AArch32_ExclusiveMonitorsPass(address, 8) then {
            MemA(address, 8) = value_name;
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STREXD_T1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXD_T1_A_decode (Rn, Rt, Rt2, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let n = UInt(Rn);
    if ((d == 15 | t == 15) | t2 == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if (d == n | d == t) | d == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STREXD_Op_A(d, n, t, t2)
}

val STREXD_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXD_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let t2 : int = t + 1;
    let n = UInt(Rn);
    if ((d == 15 | [Rt[0]] == 0b1) | t2 == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if (d == n | d == t) | d == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= d & d <= 14);
    assert(0 <= n & n <= 15);
    assert(0 <= t & t <= 15);
    assert(0 <= t2 & t2 <= 15);
    STREXD_Op_A(d, n, t, t2)
}

val STREXB_Op_A : forall 'd 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXB_Op_A (d, n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        if AArch32_ExclusiveMonitorsPass(address, 1) then {
            MemA(address, 1) = slice(R(t), 0, 8);
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STREXB_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXB_T1_A_decode (Rn, Rt, Rd) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STREXB_Op_A(d, n, t)
}

val STREXB_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREXB_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STREXB_Op_A(d, n, t)
}

val STREX_Op_A : forall 'd 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 15) & ('d >= 0 & 'd <= 14).
  (int('d), bits(32), int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREX_Op_A (d, imm32, n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n) + imm32;
        if AArch32_ExclusiveMonitorsPass(address, 4) then {
            MemA(address, 4) = R(t);
            R(d) = ZeroExtend(0b0)
        } else {
            R(d) = ZeroExtend(0b1)
        }
    }
}

val STREX_T1_A_decode : (bits(4), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREX_T1_A_decode (Rn, Rt, Rd, imm8) = {
    __unconditional = false;
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STREX_Op_A(d, imm32, n, t)
}

val STREX_A1_A_decode : (bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STREX_A1_A_decode (cond, Rn, Rd, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let d = UInt(Rd);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = Zeros(32);
    if (d == 15 | t == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    if d == n | d == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STREX_Op_A(d, imm32, n, t)
}

val STRD_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 15 & 'm >= 0 & 'm <= 15 & 't >= 0 & 't <= 15 & 't2 >= 0 & 't2 <= 15 & operator -->('wback, 'n <= 14)).
  (bool('add), bool('index), int('m), int('n), int('t), int('t2), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRD_r_Op_A (add, index, m, n, t, t2, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then aget_R(n) + aget_R(m) else aget_R(n) - aget_R(m);
        address = if index then offset_addr else aget_R(n);
        if address == Align(address, 8) then {
            data : bits(64) = undefined : bits(64);
            if BigEndian() then {
                data = __SetSlice_bits(64, 32, data, 32, aget_R(t));
                data = __SetSlice_bits(64, 32, data, 0, aget_R(t2))
            } else {
                data = __SetSlice_bits(64, 32, data, 0, aget_R(t));
                data = __SetSlice_bits(64, 32, data, 32, aget_R(t2))
            };
            aset_MemA(address, 8, data)
        } else {
            aset_MemA(address, 4, aget_R(t));
            aset_MemA(address + 4, 4, aget_R(t2))
        };
        if wback then {
            aset_R(n, offset_addr)
        }
    }
}

val STRD_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRD_r_A1_A_decode (cond, P, U, W, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    let t = UInt(Rt);
    let t2 = t + 1;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if P == 0b0 & W == 0b1 then {
        throw(Error_Unpredictable())
    };
    if t2 == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & ((n == 15 | n == t) | n == t2) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    if wback then {
        assert(n <= 14 & t2 <= 15);
        STRD_r_Op_A(add, index, m, n, t, t2, true)
    } else {
        assert(t2 <= 15);
        STRD_r_Op_A(add, index, m, n, t, t2, wback)
    }
}

val STRD_i_Op_A : forall ('add : Bool) ('index : Bool) 'n 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 15) & ('t2 >= 0 & 't2 <= 15) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), int('t2), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRD_i_Op_A (add, imm32, index, n, t, t2, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if address == Align(address, 8) then {
            data : bits(64) = undefined : bits(64);
            if BigEndian() then {
                data = __SetSlice_bits(64, 32, data, 32, R(t));
                data = __SetSlice_bits(64, 32, data, 0, R(t2))
            } else {
                data = __SetSlice_bits(64, 32, data, 0, R(t));
                data = __SetSlice_bits(64, 32, data, 32, R(t2))
            };
            MemA(address, 8) = data
        } else {
            MemA(address, 4) = R(t);
            MemA(address + 4, 4) = R(t2)
        };
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STRD_i_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRD_i_T1_A_decode (P, U, W, Rn, Rt, Rt2, imm8) = {
    __unconditional = false;
    if P == 0b0 & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = W == 0b1;
    if wback & (n == t | n == t2) then {
        throw(Error_Unpredictable())
    };
    if (n == 15 | t == 15) | t2 == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STRD_i_Op_A(add, imm32, index, n, t, t2, wback)
}

val STRD_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STRD_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    let t = UInt(Rt);
    let t2 : int = t + 1;
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if P == 0b0 & W == 0b1 then {
        throw(Error_Unpredictable())
    };
    if wback & ((n == 15 | n == t) | n == t2) then {
        throw(Error_Unpredictable())
    };
    if t2 == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= t2 & t2 <= 15);
    assert(0 <= t & t <= 15);
    STRD_i_Op_A(add, imm32, index, n, t, t2, wback)
}

val STM_u_Op_AS : forall ('increment : Bool) 'n ('wordhigher : Bool),
  ('n >= 0 & 'n <= 15 | not('increment)) & ('n >= 0 & 'n <= 15 | not(not('increment))).
  (bool('increment), int('n), bits(16), bool('wordhigher)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STM_u_Op_AS (increment_name, n, registers, wordhigher) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        length : int = undefined : int;
        if PSTATE.EL == EL2 then {
            throw(Error_Undefined())
        } else {
            if PSTATE.M == M32_User | PSTATE.M == M32_System then {
                throw(Error_Unpredictable())
            } else {
                length = 4 * BitCount(registers);
                address = if increment_name then R(n) else R(n) - length;
                if wordhigher then {
                    address = address + 4
                };
                foreach (i from 0 to 14 by 1 in inc) {
                    if [registers[i]] == 0b1 then {
                        MemA(address, 4) = Rmode(i, M32_User);
                        address = address + 4
                    }
                };
                if [registers[15]] == 0b1 then {
                    MemA(address, 4) = PCStoreValue()
                }
            }
        }
    }
}

val STM_u_A1_AS_decode : (bits(4), bits(1), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STM_u_A1_AS_decode (cond, P, U, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let increment_name = U == 0b1;
    let wordhigher = P == U;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STM_u_Op_AS(increment_name, n, registers, wordhigher)
}

val STMIB_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('n <= 14 | not('wback)).
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STMIB_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n) + 4;
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                if (i == n & wback) & i != LowestSetBit(registers) then {
                    MemA(address, 4) = undefined : bits(32)
                } else {
                    MemA(address, 4) = R(i)
                };
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            MemA(address, 4) = PCStoreValue()
        };
        if wback then {
            R(n) = R(n) + 4 * BitCount(registers)
        }
    }
}

val STMIB_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STMIB_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STMIB_Op_A(n, registers, wback)
}

val STMDB_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('n <= 14 | not('wback)).
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STMDB_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n) - 4 * BitCount(registers);
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                if (i == n & wback) & i != LowestSetBit(registers) then {
                    MemA(address, 4) = undefined : bits(32)
                } else {
                    MemA(address, 4) = R(i)
                };
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            MemA(address, 4) = PCStoreValue()
        };
        if wback then {
            R(n) = R(n) - 4 * BitCount(registers)
        }
    }
}

val STMDB_T1_A_decode : (bits(1), bits(4), bits(1), bits(1), bits(14)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STMDB_T1_A_decode (W, Rn, P, M, register_list) = {
    __unconditional = false;
    let n = UInt(Rn);
    let registers = (P @ M) @ register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 2 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if [registers[13]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if [registers[15]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STMDB_Op_A(n, registers, wback)
}

val STMDB_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STMDB_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STMDB_Op_A(n, registers, wback)
}

val STMDA_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('n <= 14 | not('wback)).
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STMDA_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n) - 4 * BitCount(registers) + 4;
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                if (i == n & wback) & i != LowestSetBit(registers) then {
                    MemA(address, 4) = undefined : bits(32)
                } else {
                    MemA(address, 4) = R(i)
                };
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            MemA(address, 4) = PCStoreValue()
        };
        if wback then {
            R(n) = R(n) - 4 * BitCount(registers)
        }
    }
}

val STMDA_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STMDA_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STMDA_Op_A(n, registers, wback)
}

val STM_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('n <= 14 | not('wback)).
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STM_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n);
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                if (i == n & wback) & i != LowestSetBit(registers) then {
                    MemA(address, 4) = undefined : bits(32)
                } else {
                    MemA(address, 4) = R(i)
                };
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            MemA(address, 4) = PCStoreValue()
        };
        if wback then {
            R(n) = R(n) + 4 * BitCount(registers)
        }
    }
}

val STM_T2_A_decode : (bits(1), bits(4), bits(1), bits(1), bits(14)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STM_T2_A_decode (W, Rn, P, M, register_list) = {
    __unconditional = false;
    let n = UInt(Rn);
    let registers = (P @ M) @ register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 2 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if [registers[13]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if [registers[15]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STM_Op_A(n, registers, wback)
}

val STM_T1_A_decode : (bits(3), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STM_T1_A_decode (Rn, register_list) = {
    __unconditional = false;
    let n = UInt(Rn);
    let registers = 0x00 @ register_list;
    let wback = true;
    if BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STM_Op_A(n, registers, wback)
}

val STM_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STM_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STM_Op_A(n, registers, wback)
}

val SRS_OpT_AS : forall ('increment : Bool) ('wback : Bool) ('wordhigher : Bool).
  (bool('increment), bits(5), bool('wback), bool('wordhigher)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function SRS_OpT_AS (increment_name, mode, wback, wordhigher) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        base : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Undefined())
        };
        if PSTATE.M == M32_User | PSTATE.M == M32_System then {
            throw(Error_Unpredictable())
        } else {
            if mode == M32_Hyp then {
                throw(Error_Unpredictable())
            } else {
                if mode == M32_Monitor then {
                    if ~(HaveEL(EL3)) | ~(IsSecure()) then {
                        throw(Error_Unpredictable())
                    } else {
                        if ~(ELUsingAArch32(EL3)) then {
                            AArch64_MonitorModeTrap()
                        }
                    }
                } else {
                    if BadMode(mode) then {
                        throw(Error_Unpredictable())
                    }
                }
            }
        };
        base = Rmode(13, mode);
        address = if increment_name then base else base - 8;
        if wordhigher then {
            address = address + 4
        };
        MemA(address, 4) = get_LR();
        MemA(address + 4, 4) = SPSR();
        if wback then {
            Rmode(13, mode) = if increment_name then base + 8 else base - 8
        }
    }
}

val SRS_T2_AS_decode : (bits(1), bits(5)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function SRS_T2_AS_decode (W, mode) = {
    __unconditional = false;
    let wback = W == 0b1;
    let increment_name = true;
    let wordhigher = false;
    __PostDecode();
    SRS_OpT_AS(increment_name, mode, wback, wordhigher)
}

val SRS_T1_AS_decode : (bits(1), bits(5)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function SRS_T1_AS_decode (W, mode) = {
    __unconditional = false;
    let wback = W == 0b1;
    let increment_name = false;
    let wordhigher = false;
    __PostDecode();
    SRS_OpT_AS(increment_name, mode, wback, wordhigher)
}

val SRS_OpA_AS : forall ('increment : Bool) ('wback : Bool) ('wordhigher : Bool).
  (bool('increment), bits(5), bool('wback), bool('wordhigher)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function SRS_OpA_AS (increment_name, mode, wback, wordhigher) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        base : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Undefined())
        };
        if PSTATE.M == M32_User | PSTATE.M == M32_System then {
            throw(Error_Unpredictable())
        } else {
            if mode == M32_Hyp then {
                throw(Error_Unpredictable())
            } else {
                if mode == M32_Monitor then {
                    if ~(HaveEL(EL3)) | ~(IsSecure()) then {
                        throw(Error_Unpredictable())
                    } else {
                        if ~(ELUsingAArch32(EL3)) then {
                            AArch64_MonitorModeTrap()
                        }
                    }
                } else {
                    if BadMode(mode) then {
                        throw(Error_Unpredictable())
                    }
                }
            }
        };
        base = Rmode(13, mode);
        address = if increment_name then base else base - 8;
        if wordhigher then {
            address = address + 4
        };
        MemA(address, 4) = get_LR();
        MemA(address + 4, 4) = SPSR();
        if wback then {
            Rmode(13, mode) = if increment_name then base + 8 else base - 8
        }
    }
}

val SRS_A1_AS_decode : (bits(1), bits(1), bits(1), bits(5)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function SRS_A1_AS_decode (P, U, W, mode) = {
    __unconditional = false;
    let wback = W == 0b1;
    let increment_name = U == 0b1;
    let wordhigher = P == U;
    __PostDecode();
    SRS_OpA_AS(increment_name, mode, wback, wordhigher)
}

val PUSH_Op_A : forall ('UnalignedAllowed : Bool).
  (bool('UnalignedAllowed), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function PUSH_Op_A (UnalignedAllowed, registers) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = get_SP() - 4 * BitCount(registers);
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                if i == 13 & i != LowestSetBit(registers) then {
                    MemA(address, 4) = undefined : bits(32)
                } else {
                    if UnalignedAllowed then {
                        MemU(address, 4) = R(i)
                    } else {
                        MemA(address, 4) = R(i)
                    }
                };
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            if UnalignedAllowed then {
                MemU(address, 4) = PCStoreValue()
            } else {
                MemA(address, 4) = PCStoreValue()
            }
        };
        set_SP(get_SP() - 4 * BitCount(registers))
    }
}

val PUSH_T1_A_decode : (bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function PUSH_T1_A_decode (M, register_list) = {
    __unconditional = false;
    let registers = ((0b0 @ M) @ 0b000000) @ register_list;
    let UnalignedAllowed = false;
    if BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    PUSH_Op_A(UnalignedAllowed, registers)
}

val aget_Mem_with_type : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccType) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_Mem_with_type (address, size, acctype) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    value_name : bits(8 * 'size) = undefined : bits('size * 8);
    let iswrite = false;
    aligned : bool = undefined : bool;
    aligned = AArch32_CheckAlignment(address, size, acctype, iswrite);
    c : Constraint = undefined : Constraint;
    if ~(aligned) then {
        assert(size > 1);
        value_name = __SetSlice_bits(8 * size, 8, value_name, 0, MemSingle(address, 1, acctype, aligned));
        c = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
        assert(c == Constraint_FAULT | c == Constraint_NONE);
        if c == Constraint_NONE then {
            aligned = true
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            value_name = __SetSlice_bits(8 * size, 8, value_name, 8 * i, MemSingle(address + i, 1, acctype, aligned))
        }
    } else {
        value_name = MemSingle(address, size, acctype, aligned)
    };
    if BigEndian() then {
        value_name = BigEndianReverse(value_name)
    };
    value_name
}

overload Mem_with_type = {aget_Mem_with_type}

val aget_MemU_unpriv : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_MemU_unpriv (address, size) = {
    let acctype = AccType_UNPRIV;
    Mem_with_type(address, size, acctype)
}

overload MemU_unpriv = {aget_MemU_unpriv}

val LDRT_Op_A : forall ('add : Bool) 'm 'n ('postindex : Bool) ('register_form : Bool) 'shift_n 't,
  ('m >= 0 & 'm <= 15 | not('register_form)) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('postindex) & 't != 15))) & ('n <= 14 | not('postindex)) & ('t >= 0 & 't <= 14).
  (bool('add), bits(32), int('m), int('n), bool('postindex), bool('register_form), int('shift_n), SRType, int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRT_Op_A (add, imm32, m, n, postindex, register_form, shift_n, shift_t, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then Shift(R(m), shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if postindex then R(n) else offset_addr;
        if ~(postindex) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        data = MemU_unpriv(address, 4);
        if postindex then {
            R(n) = offset_addr
        };
        R(t) = data
    }
}

val LDRT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_See("LDR (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(false) = false;
    let add : bool(true) = true;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val LDRT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRT_A2pre_A_decode (cond, U, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if ((t == 15 | n == 15) | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val LDRT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRT_A1pre_A_decode (cond, U, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(true) = true;
    let add : bool = U == 0b1;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm12, 32);
    if (t == 15 | n == 15) | n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val LDRSHT_Op_A : forall ('add : Bool) 'm 'n ('postindex : Bool) ('register_form : Bool) 't,
  ('m >= 0 & 'm <= 15 | not('register_form)) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('postindex) & 't != 15))) & ('n <= 14 | not('postindex)) & ('t >= 0 & 't <= 14).
  (bool('add), bits(32), int('m), int('n), bool('postindex), bool('register_form), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSHT_Op_A (add, imm32, m, n, postindex, register_form, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then R(m) else imm32;
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if postindex then R(n) else offset_addr;
        if ~(postindex) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, true, t, false)
        };
        data = MemU_unpriv(address, 2);
        if postindex then {
            R(n) = offset_addr
        };
        R(t) = SignExtend(data, 32)
    }
}

val LDRSHT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSHT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_See("LDRSH (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(false) = false;
    let add : bool(true) = true;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRSHT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSHT_A2pre_A_decode (cond, U, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    if ((t == 15 | n == 15) | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRSHT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSHT_A1pre_A_decode (cond, U, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(true) = true;
    let add : bool = U == 0b1;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    if (t == 15 | n == 15) | n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRSBT_Op_A : forall ('add : Bool) 'm 'n ('postindex : Bool) ('register_form : Bool) 't,
  ('m >= 0 & 'm <= 15 | not('register_form)) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('postindex) & 't != 15))) & ('t >= 0 & 't <= 14) & ('n <= 14 | not('postindex)).
  (bool('add), bits(32), int('m), int('n), bool('postindex), bool('register_form), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSBT_Op_A (add, imm32, m, n, postindex, register_form, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then R(m) else imm32;
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if postindex then R(n) else offset_addr;
        if ~(postindex) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, true, t, false)
        };
        R(t) = SignExtend(MemU_unpriv(address, 1), 32);
        if postindex then {
            R(n) = offset_addr
        }
    }
}

val LDRSBT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSBT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_See("LDRSB (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(false) = false;
    let add : bool(true) = true;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSBT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRSBT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSBT_A2pre_A_decode (cond, U, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    if ((t == 15 | n == 15) | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSBT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRSBT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSBT_A1pre_A_decode (cond, U, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(true) = true;
    let add : bool = U == 0b1;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    if (t == 15 | n == 15) | n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSBT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRHT_Op_A : forall ('add : Bool) 'm 'n ('postindex : Bool) ('register_form : Bool) 't,
  ('m >= 0 & 'm <= 15 | not('register_form)) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('postindex) & 't != 15))) & ('n <= 14 | not('postindex)) & ('t >= 0 & 't <= 14).
  (bool('add), bits(32), int('m), int('n), bool('postindex), bool('register_form), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRHT_Op_A (add, imm32, m, n, postindex, register_form, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then R(m) else imm32;
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if postindex then R(n) else offset_addr;
        if ~(postindex) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        data = MemU_unpriv(address, 2);
        if postindex then {
            R(n) = offset_addr
        };
        R(t) = ZeroExtend(data, 32)
    }
}

val LDRHT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRHT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_See("LDRH (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(false) = false;
    let add : bool(true) = true;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRHT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRHT_A2pre_A_decode (cond, U, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    if ((t == 15 | n == 15) | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRHT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRHT_A1pre_A_decode (cond, U, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(true) = true;
    let add : bool = U == 0b1;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    if (t == 15 | n == 15) | n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRHT_Op_A(add, imm32, m, n, postindex, register_form, t)
}

val LDRBT_Op_A : forall ('add : Bool) 'm 'n ('postindex : Bool) ('register_form : Bool) 'shift_n 't,
  ('m >= 0 & 'm <= 15 | not('register_form)) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('postindex) & 't != 15))) & ('t >= 0 & 't <= 14) & ('n <= 14 | not('postindex)).
  (bool('add), bits(32), int('m), int('n), bool('postindex), bool('register_form), int('shift_n), SRType, int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRBT_Op_A (add, imm32, m, n, postindex, register_form, shift_n, shift_t, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Unpredictable())
        };
        offset = if register_form then Shift(R(m), shift_t, shift_n, PSTATE.C) else imm32;
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if postindex then R(n) else offset_addr;
        if ~(postindex) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        R(t) = ZeroExtend(MemU_unpriv(address, 1), 32);
        if postindex then {
            R(n) = offset_addr
        }
    }
}

val LDRBT_T1pre_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRBT_T1pre_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    if Rn == 0xF then {
        throw(Error_See("LDRB (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(false) = false;
    let add : bool(true) = true;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRBT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val LDRBT_A2pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRBT_A2pre_A_decode (cond, U, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let imm32 = undefined : bits(32);
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let postindex = true;
    let add = U == 0b1;
    let register_form = true;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if ((t == 15 | n == 15) | n == t) | m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRBT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val LDRBT_A1pre_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRBT_A1pre_A_decode (cond, U, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let m = undefined : int;
    let shift_n = undefined : int;
    let shift_t : SRType = undefined : SRType;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let postindex : bool(true) = true;
    let add : bool = U == 0b1;
    let register_form : bool(false) = false;
    let imm32 : bits(32) = ZeroExtend(imm12, 32);
    if (t == 15 | n == 15) | n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRBT_Op_A(add, imm32, m, n, postindex, register_form, shift_n, shift_t, t)
}

val aget_MemU : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_MemU (address, size) = {
    let acctype = AccType_NORMAL;
    Mem_with_type(address, size, acctype)
}

overload MemU = {aget_MemU}

val VLD3_a_Op_A : forall 'd 'd2 'd3 'ebytes 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'ebytes in {1, 2, 4, 8, 16} & mod(64, (8 * 'ebytes)) == 0 & ('d >= 0 & 'd <= 31) & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('d), int('d2), int('d3), int('ebytes), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_a_Op_A (d, d2, d3, ebytes, m, n, register_index, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        CheckAdvSIMDEnabled();
        address = R(n);
        D(d) = Replicate(MemU(address, ebytes));
        D(d2) = Replicate(MemU(address + ebytes, ebytes));
        D(d3) = Replicate(MemU(address + 2 * ebytes, ebytes));
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 3 * ebytes
            }
        }
    }
}

val VLD3_a_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_a_T1A1_A_decode (D, Rn, Vd, size, T, a, Rm) = {
    __unconditional = false;
    if size == 0b11 | a == 0b1 then {
        throw(Error_Undefined())
    };
    let ebytes = shl_int(1, UInt(size));
    let inc_name = if T == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(mod(64, (8 * '_ebytes)) == 0));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD3_a_Op_A(d, d2, d3, ebytes, m, n, register_index, wback)
}

val VLD3_1_Op_A : forall 'd 'd2 'd3 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('d), int('d2), int('d3), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_1_Op_A (d, d2, d3, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        CheckAdvSIMDEnabled();
        address = R(n);
        D(d) = aset_Elem(D(d), index, MemU(address, ebytes));
        D(d2) = aset_Elem(D(d2), index, MemU(address + ebytes, ebytes));
        D(d3) = aset_Elem(D(d3), index, MemU(address + 2 * ebytes, ebytes));
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 3 * ebytes
            }
        }
    }
}

val VLD3_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD3 (single 3-element structure to all lanes)"))
    };
    if slice(index_align, 0, 2) != 0b00 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let inc_name = if [index_align[2]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD3_1_Op_A(d, d2, d3, ebytes, index, m, n, register_index, wback)
}

val VLD3_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD3 (single 3-element structure to all lanes)"))
    };
    if [index_align[0]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let inc_name = if [index_align[1]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD3_1_Op_A(d, d2, d3, ebytes, index, m, n, register_index, wback)
}

val VLD3_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD3 (single 3-element structure to all lanes)"))
    };
    if [index_align[0]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let inc_name = 1;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD3_1_Op_A(d, d2, d3, ebytes, index, m, n, register_index, wback)
}

val TBB_Op_A : forall ('is_tbh : Bool) 'm 'n,
  ('n >= 0 & 'n <= 15 & 'm >= 0 & 'm <= 15).
  (bool('is_tbh), int('m), int('n)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function TBB_Op_A (is_tbh, m, n) = {
    if ConditionPassed() then {
        halfwords : int = undefined : int;
        if is_tbh then {
            halfwords = UInt(aget_MemU(aget_R(n) + LSL(aget_R(m), 1), 2))
        } else {
            halfwords = UInt(aget_MemU(aget_R(n) + aget_R(m), 1))
        };
        BranchWritePC(get_PC() + 2 * halfwords, BranchType_INDIR)
    }
}

val TBB_T1_A_decode : (bits(4), bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function TBB_T1_A_decode (Rn, H, Rm) = {
    __unconditional = false;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let is_tbh = H == 0b1;
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    TBB_Op_A(is_tbh, m, n)
}

val LDR_r_OpT_A : forall 'm 'n 'shift_n 't,
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14 | not('t != 15)).
  (int('m), int('n), int('shift_n), SRType, int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_r_OpT_A (m, n, shift_n, shift_t, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = R(n) + offset;
        address = offset_addr;
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        data = MemU(address, 4);
        if t == 15 then {
            if slice(address, 0, 2) == 0b00 then {
                LoadWritePC(data)
            } else {
                throw(Error_Unpredictable())
            }
        } else {
            R(t) = data
        }
    }
}

val LDR_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDR (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    if (t == 15 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDR_r_OpT_A(m, n, shift_n, shift_t, t)
}

val LDR_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    LDR_r_OpT_A(m, n, shift_n, shift_t, t)
}

val LDR_r_OpA_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('n <= 14 | not('wback)) & ('t >= 0 & 't <= 14 | not(not('t == 15))).
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_r_OpA_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        data = MemU(address, 4);
        if wback then {
            R(n) = offset_addr
        };
        if t == 15 then {
            if slice(address, 0, 2) == 0b00 then {
                LoadWritePC(data)
            } else {
                throw(Error_Unpredictable())
            }
        } else {
            R(t) = data
        }
    }
}

val LDR_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_r_A1_A_decode (cond, P, U, W, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDR_r_OpA_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDR_l_Op_A : forall ('add : Bool) 't,
  ('t >= 0 & 't <= 14 | not('t != 15)).
  (bool('add), bits(32), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_l_Op_A (add, imm32, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        base : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        base = Align(get_PC(), 4);
        address = if add then base + imm32 else base - imm32;
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        data = MemU(address, 4);
        if t == 15 then {
            if slice(address, 0, 2) == 0b00 then {
                LoadWritePC(data)
            } else {
                throw(Error_Unpredictable())
            }
        } else {
            R(t) = data
        }
    }
}

val LDR_l_T2_A_decode : (bits(1), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_l_T2_A_decode (U, Rt, imm12) = {
    __unconditional = false;
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    if (t == 15 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDR_l_Op_A(add, imm32, t)
}

val LDR_l_T1_A_decode : (bits(3), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_l_T1_A_decode (Rt, imm8) = {
    __unconditional = false;
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let add = true;
    __PostDecode();
    LDR_l_Op_A(add, imm32, t)
}

val LDR_l_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_l_A1_A_decode (cond, P, U, W, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRT"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if wback then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDR_l_Op_A(add, imm32, t)
}

val LDR_i_OpT_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('n <= 14 | not('wback)) & ('t >= 0 & 't <= 14 | not(not('t == 15))).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_i_OpT_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        data = MemU(address, 4);
        if wback then {
            R(n) = offset_addr
        };
        if t == 15 then {
            if slice(address, 0, 2) == 0b00 then {
                LoadWritePC(data)
            } else {
                throw(Error_Unpredictable())
            }
        } else {
            R(t) = data
        }
    }
}

val LDR_i_T4_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_i_T4_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDR (literal)"))
    };
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("LDRT"))
    };
    if P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    if wback & n == t | (t == 15 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= t & t <= 15);
    assert(0 <= n & n <= 14);
    LDR_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDR_i_T3_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_i_T3_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDR (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    if (t == 15 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDR_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDR_i_T2_A_decode : (bits(3), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_i_T2_A_decode (Rt, imm8) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = 13;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDR_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDR_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_i_T1_A_decode (imm5, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm5 @ 0b00, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDR_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDR_i_OpA_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('n <= 14 | not('wback)) & ('t >= 0 & 't <= 14 | not(not('t == 15))).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_i_OpA_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(4, false, t, false)
        };
        data = MemU(address, 4);
        if wback then {
            R(n) = offset_addr
        };
        if t == 15 then {
            if slice(address, 0, 2) == 0b00 then {
                LoadWritePC(data)
            } else {
                throw(Error_Unpredictable())
            }
        } else {
            R(t) = data
        }
    }
}

val LDR_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDR_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDR (literal)"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm12, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14);
    LDR_i_OpA_A(add, imm32, index, n, t, wback)
}

val LDRSH_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('n <= 14 | not('wback)) & ('t >= 0 & 't <= 14).
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_r_Op_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, true, t, false)
        };
        data = MemU(address, 2);
        if wback then {
            R(n) = offset_addr
        };
        R(t) = SignExtend(data, 32)
    }
}

val LDRSH_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDRSH (literal)"))
    };
    if Rt == 0xF then {
        throw(Error_See("Related instructions"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRSH_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    LDRSH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRSH_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_r_A1_A_decode (cond, P, U, W, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRSHT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRSH_l_Op_A : forall ('add : Bool) 't,
  ('t >= 0 & 't <= 14 | not('t != 15)) & 't <= 14.
  (bool('add), bits(32), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_l_Op_A (add, imm32, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        base : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        base = Align(get_PC(), 4);
        address = if add then base + imm32 else base - imm32;
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, true, t, false)
        };
        data = MemU(address, 2);
        R(t) = SignExtend(data, 32)
    }
}

val LDRSH_l_T1_A_decode : (bits(1), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_l_T1_A_decode (U, Rt, imm12) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("Related instructions"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    LDRSH_l_Op_A(add, imm32, t)
}

val LDRSH_l_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_l_A1_A_decode (cond, P, U, W, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRSHT"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm4H @ imm4L, 32);
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if t == 15 | wback then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSH_l_Op_A(add, imm32, t)
}

val LDRSH_i_Op_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('n <= 14 | not('wback)) & ('t >= 0 & 't <= 14).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_i_Op_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, true, t, false)
        };
        data = MemU(address, 2);
        if wback then {
            R(n) = offset_addr
        };
        R(t) = SignExtend(data, 32)
    }
}

val LDRSH_i_T2_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_i_T2_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDRSH (literal)"))
    };
    if ((Rt == 0xF & P == 0b1) & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related instructions"))
    };
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("LDRSHT"))
    };
    if P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    if t == 15 & W == 0b1 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= t & t <= 14);
    assert(0 <= n & n <= 14);
    LDRSH_i_Op_A(add, imm32, index, n, t, wback)
}

val LDRSH_i_T1_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_i_T1_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDRSH (literal)"))
    };
    if Rt == 0xF then {
        throw(Error_See("Related instructions"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDRSH_i_Op_A(add, imm32, index, n, t, wback)
}

val LDRSH_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSH_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRSH (literal)"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRSHT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if t == 15 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14);
    LDRSH_i_Op_A(add, imm32, index, n, t, wback)
}

val LDRSB_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 14) & ('n <= 14 | not('wback)).
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_r_Op_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, true, t, false)
        };
        R(t) = SignExtend(MemU(address, 1), 32);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val LDRSB_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLI"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRSB (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRSB_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    LDRSB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRSB_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_r_A1_A_decode (cond, P, U, W, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRSBT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRSB_l_Op_A : forall ('add : Bool) 't,
  ('t >= 0 & 't <= 14 | not('t != 15)) & 't <= 14.
  (bool('add), bits(32), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_l_Op_A (add, imm32, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let base = Align(get_PC(), 4);
        address = if add then base + imm32 else base - imm32;
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, true, t, false)
        };
        R(t) = SignExtend(MemU(address, 1), 32)
    }
}

val LDRSB_l_T1_A_decode : (bits(1), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_l_T1_A_decode (U, Rt, imm12) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLI"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    LDRSB_l_Op_A(add, imm32, t)
}

val LDRSB_l_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_l_A1_A_decode (cond, P, U, W, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRSBT"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm4H @ imm4L, 32);
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if t == 15 | wback then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRSB_l_Op_A(add, imm32, t)
}

val LDRSB_i_Op_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 14) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_i_Op_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, true, t, false)
        };
        R(t) = SignExtend(MemU(address, 1), 32);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val LDRSB_i_T2_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_i_T2_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if ((Rt == 0xF & P == 0b1) & U == 0b0) & W == 0b0 then {
        throw(Error_See("PLI"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRSB (literal)"))
    };
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("LDRSBT"))
    };
    if P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    if t == 15 & W == 0b1 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & t <= 14);
    LDRSB_i_Op_A(add, imm32, index, n, t, wback)
}

val LDRSB_i_T1_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_i_T1_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLI"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRSB (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDRSB_i_Op_A(add, imm32, index, n, t, wback)
}

val LDRSB_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRSB_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRSB (literal)"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRSBT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if t == 15 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & t <= 14);
    LDRSB_i_Op_A(add, imm32, index, n, t, wback)
}

val LDRH_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not('t != 15)) & ('n <= 14 | not('wback)) & 't <= 14.
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_r_Op_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        data = MemU(address, 2);
        if wback then {
            R(n) = offset_addr
        };
        R(t) = ZeroExtend(data, 32)
    }
}

val LDRH_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDRH (literal)"))
    };
    if Rt == 0xF then {
        throw(Error_See("PLDW (register)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRH_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    LDRH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRH_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_r_A1_A_decode (cond, P, U, W, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRHT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRH_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRH_l_Op_A : forall ('add : Bool) 't,
  ('t >= 0 & 't <= 14 | not('t != 15)) & 't <= 14.
  (bool('add), bits(32), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_l_Op_A (add, imm32, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        base : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        base = Align(get_PC(), 4);
        address = if add then base + imm32 else base - imm32;
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        data = MemU(address, 2);
        R(t) = ZeroExtend(data, 32)
    }
}

val LDRH_l_T1_A_decode : (bits(1), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_l_T1_A_decode (U, Rt, imm12) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLD (literal)"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    LDRH_l_Op_A(add, imm32, t)
}

val LDRH_l_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_l_A1_A_decode (cond, P, U, W, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRHT"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm4H @ imm4L, 32);
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if t == 15 | wback then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRH_l_Op_A(add, imm32, t)
}

val LDRH_i_OpT_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('n <= 14 | not('wback)) & ('t >= 0 & 't <= 14).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_i_OpT_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        data = MemU(address, 2);
        if wback then {
            R(n) = offset_addr
        };
        R(t) = ZeroExtend(data, 32)
    }
}

val LDRH_i_T3_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_i_T3_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDRH (literal)"))
    };
    if ((Rt == 0xF & P == 0b1) & U == 0b0) & W == 0b0 then {
        throw(Error_See("PLDW (immediate)"))
    };
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("LDRHT"))
    };
    if P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    if t == 15 & W == 0b1 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & t <= 14);
    LDRH_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDRH_i_T2_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_i_T2_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLD (immediate)"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRH (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDRH_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDRH_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_i_T1_A_decode (imm5, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm5 @ 0b0, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDRH_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDRH_i_OpA_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('n <= 14 | not('wback)) & ('t >= 0 & 't <= 14).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_i_OpA_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(16) = undefined : bits(16);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(2, false, t, false)
        };
        data = MemU(address, 2);
        if wback then {
            R(n) = offset_addr
        };
        R(t) = ZeroExtend(data, 32)
    }
}

val LDRH_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRH_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRH (literal)"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRHT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if t == 15 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & t <= 14);
    LDRH_i_OpA_A(add, imm32, index, n, t, wback)
}

val LDRB_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 'shift_n 't ('wback : Bool),
  ('m >= 0 & 'm <= 15) & ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 14) & ('n <= 14 | not('wback)).
  (bool('add), bool('index), int('m), int('n), int('shift_n), SRType, int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_r_Op_A (add, index, m, n, shift_n, shift_t, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        offset = Shift(R(m), shift_t, shift_n, PSTATE.C);
        offset_addr = if add then R(n) + offset else R(n) - offset;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        R(t) = ZeroExtend(MemU(address, 1), 32);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val LDRB_r_T2_A_decode : (bits(4), bits(4), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_r_T2_A_decode (Rn, Rt, imm2, Rm) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLD"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRB (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, UInt(imm2));
    if m == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRB_r_T1_A_decode : (bits(3), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_r_T1_A_decode (Rm, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = true;
    let add = true;
    let wback = false;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = (SRType_LSL, 0);
    __PostDecode();
    LDRB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRB_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(5), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_r_A1_A_decode (cond, P, U, W, Rn, Rt, imm5, typ, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRBT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    shift_n : int = undefined : int;
    shift_t : SRType = undefined : SRType;
    (shift_t, shift_n) = DecodeImmShift(typ, imm5);
    if t == 15 | m == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == 15 | n == t) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRB_r_Op_A(add, index, m, n, shift_n, shift_t, t, wback)
}

val LDRB_l_Op_A : forall ('add : Bool) 't,
  ('t >= 0 & 't <= 14 | not('t != 15)) & 't <= 14.
  (bool('add), bits(32), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_l_Op_A (add, imm32, t) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let base = Align(get_PC(), 4);
        address = if add then base + imm32 else base - imm32;
        if t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        R(t) = ZeroExtend(MemU(address, 1), 32)
    }
}

val LDRB_l_T1_A_decode : (bits(1), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_l_T1_A_decode (U, Rt, imm12) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLD"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    __PostDecode();
    LDRB_l_Op_A(add, imm32, t)
}

val LDRB_l_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_l_A1_A_decode (cond, P, U, W, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRBT"))
    };
    let t = UInt(Rt);
    let imm32 = ZeroExtend(imm12, 32);
    let add = U == 0b1;
    let wback = P == 0b0 | W == 0b1;
    if t == 15 | wback then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRB_l_Op_A(add, imm32, t)
}

val LDRB_i_OpT_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 14) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_i_OpT_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        R(t) = ZeroExtend(MemU(address, 1), 32);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val LDRB_i_T3_A_decode : (bits(4), bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_i_T3_A_decode (Rn, Rt, P, U, W, imm8) = {
    __unconditional = false;
    if ((Rt == 0xF & P == 0b1) & U == 0b0) & W == 0b0 then {
        throw(Error_See("PLD, PLDW (immediate)"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRB (literal)"))
    };
    if (P == 0b1 & U == 0b1) & W == 0b0 then {
        throw(Error_See("LDRBT"))
    };
    if P == 0b0 & W == 0b0 then {
        throw(Error_Undefined())
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    if t == 15 & W == 0b1 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & t <= 14);
    LDRB_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDRB_i_T2_A_decode : (bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_i_T2_A_decode (Rn, Rt, imm12) = {
    __unconditional = false;
    if Rt == 0xF then {
        throw(Error_See("PLD"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRB (literal)"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm12, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDRB_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDRB_i_T1_A_decode : (bits(5), bits(3), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_i_T1_A_decode (imm5, Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm5, 32);
    let index = true;
    let add = true;
    let wback = false;
    __PostDecode();
    LDRB_i_OpT_A(add, imm32, index, n, t, wback)
}

val LDRB_i_OpA_A : forall ('add : Bool) ('index : Bool) 'n 't ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14 | not((not('wback) & 't != 15))) & ('t >= 0 & 't <= 14) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_i_OpA_A (add, imm32, index, n, t, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if ~(wback) & t != 15 then {
            AArch32_SetLSInstructionSyndrome(1, false, t, false)
        };
        R(t) = ZeroExtend(MemU(address, 1), 32);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val LDRB_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(12)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRB_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm12) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRB (literal)"))
    };
    if P == 0b0 & W == 0b1 then {
        throw(Error_See("LDRBT"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm12, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if t == 15 | wback & n == t then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14);
    LDRB_i_OpA_A(add, imm32, index, n, t, wback)
}

val aget_MemO : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_MemO (address, size) = {
    let acctype = AccType_ORDERED;
    Mem_with_type(address, size, acctype)
}

overload MemO = {aget_MemO}

val LDAH_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAH_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetLSInstructionSyndrome(2, false, t, true);
        R(t) = ZeroExtend(MemO(address, 2), 32)
    }
}

val LDAH_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAH_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAH_Op_A(n, t)
}

val LDAH_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAH_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAH_Op_A(n, t)
}

val LDAEXH_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXH_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetExclusiveMonitors(address, 2);
        AArch32_SetLSInstructionSyndrome(2, false, t, true);
        R(t) = ZeroExtend(MemO(address, 2), 32)
    }
}

val LDAEXH_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXH_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAEXH_Op_A(n, t)
}

val LDAEXH_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXH_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAEXH_Op_A(n, t)
}

val LDAEXD_Op_A : forall 'n 't 't2,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14) & ('t2 >= 0 & 't2 <= 14).
  (int('n), int('t), int('t2)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXD_Op_A (n, t, t2) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        value_name : bits(64) = undefined : bits(64);
        address = R(n);
        AArch32_SetExclusiveMonitors(address, 8);
        AArch32_SetLSInstructionSyndrome(8, false, t, true);
        value_name = MemO(address, 8);
        R(t) = if BigEndian() then slice(value_name, 32, 32) else slice(value_name, 0, 32);
        R(t2) = if BigEndian() then slice(value_name, 0, 32) else slice(value_name, 32, 32)
    }
}

val LDAEXD_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXD_T1_A_decode (Rn, Rt, Rt2) = {
    __unconditional = false;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let n = UInt(Rn);
    if ((t == 15 | t2 == 15) | t == t2) | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAEXD_Op_A(n, t, t2)
}

val LDAEXD_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXD_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let t2 : int = t + 1;
    let n = UInt(Rn);
    if ([Rt[0]] == 0b1 | t2 == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= t & t <= 14);
    assert(0 <= t2 & t2 <= 14);
    LDAEXD_Op_A(n, t, t2)
}

val LDAEXB_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXB_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetExclusiveMonitors(address, 1);
        AArch32_SetLSInstructionSyndrome(1, false, t, true);
        R(t) = ZeroExtend(MemO(address, 1), 32)
    }
}

val LDAEXB_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXB_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAEXB_Op_A(n, t)
}

val LDAEXB_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEXB_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAEXB_Op_A(n, t)
}

val LDAEX_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEX_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetExclusiveMonitors(address, 4);
        AArch32_SetLSInstructionSyndrome(4, false, t, true);
        R(t) = MemO(address, 4)
    }
}

val LDAEX_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEX_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAEX_Op_A(n, t)
}

val LDAEX_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAEX_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAEX_Op_A(n, t)
}

val LDAB_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAB_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetLSInstructionSyndrome(1, false, t, true);
        R(t) = ZeroExtend(MemO(address, 1), 32)
    }
}

val LDAB_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAB_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAB_Op_A(n, t)
}

val LDAB_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDAB_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDAB_Op_A(n, t)
}

val LDA_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDA_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetLSInstructionSyndrome(4, false, t, true);
        R(t) = MemO(address, 4)
    }
}

val LDA_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDA_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDA_Op_A(n, t)
}

val LDA_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDA_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDA_Op_A(n, t)
}

val aget_MemA : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size)) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_MemA (address, size) = {
    let acctype = AccType_ATOMIC;
    Mem_with_type(address, size, acctype)
}

overload MemA = {aget_MemA}

val VLDR_Op_A : forall ('add : Bool) 'd 'esize 'n,
  ('n >= 0 & 'n <= 15 | not(not('n == 15))) & ('d >= 0 & 'd <= 31 | not('esize == 16)) & ('d >= 0 & 'd <= 31 | not('esize == 32)) & ('d >= 0 & 'd <= 31 | not('esize == 64)).
  (bool('add), int('d), int('esize), bits(32), int('n)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLDR_Op_A (add, d, esize, imm32, n) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        base : bits(32) = undefined : bits(32);
        word1 : bits(32) = undefined : bits(32);
        word2 : bits(32) = undefined : bits(32);
        CheckVFPEnabled(true);
        base = if n == 15 then Align(get_PC(), 4) else R(n);
        address = if add then base + imm32 else base - imm32;
        match esize {
          16 => {
              S(d) = Zeros(16) @ MemA(address, 2)
          },
          32 => {
              S(d) = MemA(address, 4)
          },
          64 => {
              word1 = MemA(address, 4);
              word2 = MemA(address + 4, 4);
              D(d) = if BigEndian() then word1 @ word2 else word2 @ word1
          }
        }
    }
}

val VLDR_T1_A_decode : (bits(1), bits(1), bits(4), bits(4), bits(2), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLDR_T1_A_decode (U, D, Rn, Vd, size, imm8) = {
    __unconditional = false;
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & InITBlock() then {
        throw(Error_Unpredictable())
    };
    let esize = shl_int(8, UInt(size));
    let add = U == 0b1;
    let imm32 : bits(32) = if esize == 16 then ZeroExtend(imm8 @ 0b0, 32) else ZeroExtend(imm8 @ 0b00, 32);
    d : int = undefined : int;
    match size {
      0b01 => {
          d = UInt(Vd @ D)
      },
      0b10 => {
          d = UInt(Vd @ D)
      },
      0b11 => {
          d = UInt(D @ Vd)
      }
    };
    let d = d;
    let n = UInt(Rn);
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 64))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 32))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 16))));
    assert(constraint(('_n >= 0 & '_n <= 15 | not(not('_n == 15)))));
    __PostDecode();
    VLDR_Op_A(add, d, esize, imm32, n)
}

val VLDR_A1_A_decode : (bits(4), bits(1), bits(1), bits(4), bits(4), bits(2), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLDR_A1_A_decode (cond, U, D, Rn, Vd, size, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if size == 0b00 | size == 0b01 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if size == 0b01 & cond != 0xE then {
        throw(Error_Unpredictable())
    };
    let esize = shl_int(8, UInt(size));
    let add = U == 0b1;
    let imm32 : bits(32) = if esize == 16 then ZeroExtend(imm8 @ 0b0, 32) else ZeroExtend(imm8 @ 0b00, 32);
    d : int = undefined : int;
    match size {
      0b01 => {
          d = UInt(Vd @ D)
      },
      0b10 => {
          d = UInt(Vd @ D)
      },
      0b11 => {
          d = UInt(D @ Vd)
      }
    };
    let d = d;
    let n = UInt(Rn);
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 64))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 32))));
    assert(constraint(('_d >= 0 & '_d <= 31 | not('_esize == 16))));
    assert(constraint(('_n >= 0 & '_n <= 15 | not(not('_n == 15)))));
    __PostDecode();
    VLDR_Op_A(add, d, esize, imm32, n)
}

val VLDM_Op_A : forall ('add : Bool) 'd 'n 'regs ('single_regs : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('n <= 14 | not('wback)).
  (bool('add), int('d), bits(32), int('n), int('regs), bool('single_regs), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLDM_Op_A (add, d, imm32, n, regs, single_regs, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        word1 : bits(32) = undefined : bits(32);
        word2 : bits(32) = undefined : bits(32);
        CheckVFPEnabled(true);
        address = if add then R(n) else R(n) - imm32;
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            if single_regs then {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('single_regs))));
                S(d + r) = MemA(address, 4);
                address = address + 4
            } else {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('single_regs)))));
                word1 = MemA(address, 4);
                word2 = MemA(address + 4, 4);
                address = address + 8;
                D(d + r) = if BigEndian() then word1 @ word2 else word2 @ word1
            }
        };
        if wback then {
            R(n) = if add then R(n) + imm32 else R(n) - imm32
        }
    }
}

val VLDM_T2A2_A_decode__0 : (bits(4), bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val VLDM_T2A2_A_decode__1 : (bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload VLDM_T2A2_A_decode = {VLDM_T2A2_A_decode__0, VLDM_T2A2_A_decode__1}

function VLDM_T2A2_A_decode__0 (cond, P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VLDR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs = true;
    let add = U == 0b1;
    let wback = W == 0b1;
    let d = UInt(Vd @ D);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let regs = UInt(imm8);
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if regs == 0 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLDM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

function VLDM_T2A2_A_decode__1 (P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VLDR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs = true;
    let add = U == 0b1;
    let wback = W == 0b1;
    let d = UInt(Vd @ D);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let regs = UInt(imm8);
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if regs == 0 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLDM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

val VLDM_T1A1_A_decode__0 : (bits(4), bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val VLDM_T1A1_A_decode__1 : (bits(1), bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload VLDM_T1A1_A_decode = {VLDM_T1A1_A_decode__0, VLDM_T1A1_A_decode__1}

function VLDM_T1A1_A_decode__0 (cond, P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VLDR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs : bool(false) = false;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8 @ 0b00, 32);
    let regs : {'n, (0 <= 'n & 'n <= 127). int('n)} = UInt(imm8) / 2;
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if (regs == 0 | regs > 16) | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    if [imm8[0]] == 0b1 & d + regs > 16 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLDM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

function VLDM_T1A1_A_decode__1 (P, U, D, W, Rn, Vd, imm8) = {
    __unconditional = false;
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if P == 0b1 & W == 0b0 then {
        throw(Error_See("VLDR"))
    };
    if P == U & W == 0b1 then {
        throw(Error_Undefined())
    };
    let single_regs : bool(false) = false;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8 @ 0b00, 32);
    let regs : {'n, (0 <= 'n & 'n <= 127). int('n)} = UInt(imm8) / 2;
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    if (regs == 0 | regs > 16) | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    if [imm8[0]] == 0b1 & d + regs > 16 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLDM_Op_A(add, d, imm32, n, regs, single_regs, wback)
}

val RFE_Op_AS : forall ('increment : Bool) 'n ('wback : Bool) ('wordhigher : Bool),
  ('n >= 0 & 'n <= 15 | not('increment)) & ('n >= 0 & 'n <= 15 | not(not('increment))) & ('n <= 14 | not('wback)).
  (bool('increment), int('n), bool('wback), bool('wordhigher)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function RFE_Op_AS (increment_name, n, wback, wordhigher) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        new_pc_value : bits(32) = undefined : bits(32);
        spsr : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Undefined())
        } else {
            if PSTATE.EL == EL0 then {
                throw(Error_Unpredictable())
            } else {
                address = if increment_name then R(n) else R(n) - 8;
                if wordhigher then {
                    address = address + 4
                };
                new_pc_value = MemA(address, 4);
                spsr = MemA(address + 4, 4);
                if wback then {
                    R(n) = if increment_name then R(n) + 8 else R(n) - 8
                };
                AArch32_ExceptionReturn(new_pc_value, spsr)
            }
        }
    }
}

val RFE_T2_AS_decode : (bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function RFE_T2_AS_decode (W, Rn) = {
    __unconditional = false;
    let n = UInt(Rn);
    let wback = W == 0b1;
    let increment_name = true;
    let wordhigher = false;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RFE_Op_AS(increment_name, n, wback, wordhigher)
}

val RFE_T1_AS_decode : (bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function RFE_T1_AS_decode (W, Rn) = {
    __unconditional = false;
    let n = UInt(Rn);
    let wback = W == 0b1;
    let increment_name = false;
    let wordhigher = false;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    if InITBlock() & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RFE_Op_AS(increment_name, n, wback, wordhigher)
}

val RFE_A1_AS_decode : (bits(1), bits(1), bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function RFE_A1_AS_decode (P, U, W, Rn) = {
    __unconditional = false;
    let n = UInt(Rn);
    let wback = W == 0b1;
    let increment_name = U == 0b1;
    let wordhigher = P == U;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    RFE_Op_AS(increment_name, n, wback, wordhigher)
}

val POP_Op_A : forall ('UnalignedAllowed : Bool).
  (bool('UnalignedAllowed), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function POP_Op_A (UnalignedAllowed, registers) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = get_SP();
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                R(i) = if UnalignedAllowed then MemU(address, 4) else MemA(address, 4);
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            if UnalignedAllowed then {
                if slice(address, 0, 2) == 0b00 then {
                    LoadWritePC(MemU(address, 4))
                } else {
                    throw(Error_Unpredictable())
                }
            } else {
                LoadWritePC(MemA(address, 4))
            }
        };
        if [registers[13]] == 0b0 then {
            set_SP(get_SP() + 4 * BitCount(registers))
        };
        if [registers[13]] == 0b1 then {
            set_SP(undefined : bits(32))
        }
    }
}

val POP_T1_A_decode : (bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function POP_T1_A_decode (P, register_list) = {
    __unconditional = false;
    let registers = (P @ 0b0000000) @ register_list;
    let UnalignedAllowed = false;
    if BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    if ([registers[15]] == 0b1 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    POP_Op_A(UnalignedAllowed, registers)
}

val LDREXH_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXH_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetExclusiveMonitors(address, 2);
        R(t) = ZeroExtend(MemA(address, 2), 32)
    }
}

val LDREXH_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXH_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDREXH_Op_A(n, t)
}

val LDREXH_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXH_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDREXH_Op_A(n, t)
}

val LDREXD_Op_A : forall 'n 't 't2,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14) & ('t2 >= 0 & 't2 <= 14).
  (int('n), int('t), int('t2)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXD_Op_A (n, t, t2) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        value_name : bits(64) = undefined : bits(64);
        address = R(n);
        AArch32_SetExclusiveMonitors(address, 8);
        value_name = MemA(address, 8);
        R(t) = if BigEndian() then slice(value_name, 32, 32) else slice(value_name, 0, 32);
        R(t2) = if BigEndian() then slice(value_name, 0, 32) else slice(value_name, 32, 32)
    }
}

val LDREXD_T1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXD_T1_A_decode (Rn, Rt, Rt2) = {
    __unconditional = false;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let n = UInt(Rn);
    if ((t == 15 | t2 == 15) | t == t2) | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDREXD_Op_A(n, t, t2)
}

val LDREXD_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXD_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let t2 : int = t + 1;
    let n = UInt(Rn);
    if ([Rt[0]] == 0b1 | t2 == 15) | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(0 <= t & t <= 14);
    assert(0 <= t2 & t2 <= 14);
    LDREXD_Op_A(n, t, t2)
}

val LDREXB_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXB_Op_A (n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n);
        AArch32_SetExclusiveMonitors(address, 1);
        R(t) = ZeroExtend(MemA(address, 1), 32)
    }
}

val LDREXB_T1_A_decode : (bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXB_T1_A_decode (Rn, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDREXB_Op_A(n, t)
}

val LDREXB_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREXB_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDREXB_Op_A(n, t)
}

val LDREX_Op_A : forall 'n 't,
  ('n >= 0 & 'n <= 15) & ('t >= 0 & 't <= 14).
  (bits(32), int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREX_Op_A (imm32, n, t) = {
    if ConditionPassed() then {
        let address : bits(32) = R(n) + imm32;
        AArch32_SetExclusiveMonitors(address, 4);
        R(t) = MemA(address, 4)
    }
}

val LDREX_T1_A_decode : (bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREX_T1_A_decode (Rn, Rt, imm8) = {
    __unconditional = false;
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDREX_Op_A(imm32, n, t)
}

val LDREX_A1_A_decode : (bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDREX_A1_A_decode (cond, Rn, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let n = UInt(Rn);
    let imm32 = Zeros(32);
    if t == 15 | n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDREX_Op_A(imm32, n, t)
}

val LDRD_r_Op_A : forall ('add : Bool) ('index : Bool) 'm 'n 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 15 & 'm >= 0 & 'm <= 15 & 't >= 0 & 't <= 14 & 't2 >= 0 & 't2 <= 14 & operator -->('wback, 'n <= 14)).
  (bool('add), bool('index), int('m), int('n), int('t), int('t2), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_r_Op_A (add, index, m, n, t, t2, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(64) = undefined : bits(64);
        let offset_addr : bits(32) = if add then aget_R(n) + aget_R(m) else aget_R(n) - aget_R(m);
        address = if index then offset_addr else aget_R(n);
        if address == Align(address, 8) then {
            data = aget_MemA(address, 8);
            if BigEndian() then {
                aset_R(t, slice(data, 32, 32));
                aset_R(t2, slice(data, 0, 32))
            } else {
                aset_R(t, slice(data, 0, 32));
                aset_R(t2, slice(data, 32, 32))
            }
        } else {
            aset_R(t, aget_MemA(address, 4));
            aset_R(t2, aget_MemA(address + 4, 4))
        };
        if wback then {
            aset_R(n, offset_addr)
        }
    }
}

val LDRD_r_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_r_A1_A_decode (cond, P, U, W, Rn, Rt, Rm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    let t = UInt(Rt);
    assert(t <= 7);
    let t2 = t + 1;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if P == 0b0 & W == 0b1 then {
        throw(Error_Unpredictable())
    };
    if ((t2 == 15 | m == 15) | m == t) | m == t2 then {
        throw(Error_Unpredictable())
    };
    if wback & ((n == 15 | n == t) | n == t2) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & m <= 14);
    LDRD_r_Op_A(add, index, m, n, t, t2, wback)
}

val LDRD_l_Op_A : forall ('add : Bool) 't 't2,
  ('t >= 0 & 't <= 14) & ('t2 >= 0 & 't2 <= 14).
  (bool('add), bits(32), int('t), int('t2)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_l_Op_A (add, imm32, t, t2) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(64) = undefined : bits(64);
        address = if add then Align(get_PC(), 4) + imm32 else Align(get_PC(), 4) - imm32;
        if address == Align(address, 8) then {
            data = MemA(address, 8);
            if BigEndian() then {
                R(t) = slice(data, 32, 32);
                R(t2) = slice(data, 0, 32)
            } else {
                R(t) = slice(data, 0, 32);
                R(t2) = slice(data, 32, 32)
            }
        } else {
            R(t) = MemA(address, 4);
            R(t2) = MemA(address + 4, 4)
        }
    }
}

val LDRD_l_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_l_T1_A_decode (P, U, W, Rt, Rt2, imm8) = {
    __unconditional = false;
    if P == 0b0 & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let add = U == 0b1;
    if (t == 15 | t2 == 15) | t == t2 then {
        throw(Error_Unpredictable())
    };
    if W == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDRD_l_Op_A(add, imm32, t, t2)
}

val LDRD_l_A1_A_decode : (bits(4), bits(1), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_l_A1_A_decode (cond, U, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    let t = UInt(Rt);
    assert(t <= 14);
    let t2 = t + 1;
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    let add : bool = U == 0b1;
    if t2 == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(t <= 14);
    LDRD_l_Op_A(add, imm32, t, t2)
}

val LDRD_i_Op_A : forall ('add : Bool) ('index : Bool) 'n 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('t >= 0 & 't <= 14) & ('t2 >= 0 & 't2 <= 14) & ('n <= 14 | not('wback)).
  (bool('add), bits(32), bool('index), int('n), int('t), int('t2), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_i_Op_A (add, imm32, index, n, t, t2, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        data : bits(64) = undefined : bits(64);
        let offset_addr : bits(32) = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        if address == Align(address, 8) then {
            data = MemA(address, 8);
            if BigEndian() then {
                R(t) = slice(data, 32, 32);
                R(t2) = slice(data, 0, 32)
            } else {
                R(t) = slice(data, 0, 32);
                R(t2) = slice(data, 32, 32)
            }
        } else {
            R(t) = MemA(address, 4);
            R(t2) = MemA(address + 4, 4)
        };
        if wback then {
            R(n) = offset_addr
        }
    }
}

val LDRD_i_T1_A_decode : (bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_i_T1_A_decode (P, U, W, Rn, Rt, Rt2, imm8) = {
    __unconditional = false;
    if P == 0b0 & W == 0b0 then {
        throw(Error_See("Related encodings"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRD (literal)"))
    };
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm8 @ 0b00, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = W == 0b1;
    if wback & (n == t | n == t2) then {
        throw(Error_Unpredictable())
    };
    if (t == 15 | t2 == 15) | t == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & t <= 14 & t2 <= 14);
    LDRD_i_Op_A(add, imm32, index, n, t, t2, wback)
}

val LDRD_i_A1_A_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(4), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDRD_i_A1_A_decode (cond, P, U, W, Rn, Rt, imm4H, imm4L) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDRD (literal)"))
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    let t = UInt(Rt);
    let t2 = t + 1;
    let n = UInt(Rn);
    let imm32 : bits(32) = ZeroExtend(imm4H @ imm4L, 32);
    let index : bool = P == 0b1;
    let add : bool = U == 0b1;
    let wback : bool = P == 0b0 | W == 0b1;
    if P == 0b0 & W == 0b1 then {
        throw(Error_Unpredictable())
    };
    if wback & (n == t | n == t2) then {
        throw(Error_Unpredictable())
    };
    if t2 == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    assert(n <= 14 & t <= 14 & t2 <= 14);
    LDRD_i_Op_A(add, imm32, index, n, t, t2, wback)
}

val LDM_u_Op_AS : forall ('increment : Bool) 'n ('wordhigher : Bool),
  ('n >= 0 & 'n <= 15 | not('increment)) & ('n >= 0 & 'n <= 15 | not(not('increment))).
  (bool('increment), int('n), bits(15), bool('wordhigher)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_u_Op_AS (increment_name, n, registers, wordhigher) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        length : int = undefined : int;
        if PSTATE.EL == EL2 then {
            throw(Error_Undefined())
        } else {
            if PSTATE.M == M32_User | PSTATE.M == M32_System then {
                throw(Error_Unpredictable())
            } else {
                length = 4 * BitCount(registers);
                address = if increment_name then R(n) else R(n) - length;
                if wordhigher then {
                    address = address + 4
                };
                foreach (i from 0 to 14 by 1 in inc) {
                    if [registers[i]] == 0b1 then {
                        Rmode(i, M32_User) = MemA(address, 4);
                        address = address + 4
                    }
                }
            }
        }
    }
}

val LDM_u_A1_AS_decode : (bits(4), bits(1), bits(1), bits(4), bits(15)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_u_A1_AS_decode (cond, P, U, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let increment_name = U == 0b1;
    let wordhigher = P == U;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDM_u_Op_AS(increment_name, n, registers, wordhigher)
}

val LDM_e_Op_AS : forall ('increment : Bool) 'n ('wback : Bool) ('wordhigher : Bool),
  ('n >= 0 & 'n <= 15 | not('increment)) & ('n >= 0 & 'n <= 15 | not(not('increment))) & 'n <= 14.
  (bool('increment), int('n), bits(15), bool('wback), bool('wordhigher)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_e_Op_AS (increment_name, n, registers, wback, wordhigher) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        length : int = undefined : int;
        new_pc_value : bits(32) = undefined : bits(32);
        if PSTATE.EL == EL2 then {
            throw(Error_Undefined())
        } else {
            if PSTATE.M == M32_User | PSTATE.M == M32_System then {
                throw(Error_Unpredictable())
            } else {
                length = 4 * BitCount(registers) + 4;
                address = if increment_name then R(n) else R(n) - length;
                if wordhigher then {
                    address = address + 4
                };
                foreach (i from 0 to 14 by 1 in inc) {
                    if [registers[i]] == 0b1 then {
                        R(i) = MemA(address, 4);
                        address = address + 4
                    }
                };
                new_pc_value = MemA(address, 4);
                if wback & [registers[n]] == 0b0 then {
                    R(n) = if increment_name then R(n) + length else R(n) - length
                };
                if wback & [registers[n]] == 0b1 then {
                    R(n) = undefined : bits(32)
                };
                AArch32_ExceptionReturn(new_pc_value, SPSR())
            }
        }
    }
}

val LDM_e_A1_AS_decode : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(15)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_e_A1_AS_decode (cond, P, U, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    let increment_name = U == 0b1;
    let wordhigher = P == U;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDM_e_Op_AS(increment_name, n, registers, wback, wordhigher)
}

val LDMIB_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'n <= 14.
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDMIB_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n) + 4;
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                R(i) = MemA(address, 4);
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            LoadWritePC(MemA(address, 4))
        };
        if wback & [registers[n]] == 0b0 then {
            R(n) = R(n) + 4 * BitCount(registers)
        };
        if wback & [registers[n]] == 0b1 then {
            R(n) = undefined : bits(32)
        }
    }
}

val LDMIB_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDMIB_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDMIB_Op_A(n, registers, wback)
}

val LDMDB_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'n <= 14.
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDMDB_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n) - 4 * BitCount(registers);
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                R(i) = MemA(address, 4);
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            LoadWritePC(MemA(address, 4))
        };
        if wback & [registers[n]] == 0b0 then {
            R(n) = R(n) - 4 * BitCount(registers)
        };
        if wback & [registers[n]] == 0b1 then {
            R(n) = undefined : bits(32)
        }
    }
}

val LDMDB_T1_A_decode : (bits(1), bits(4), bits(1), bits(1), bits(14)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDMDB_T1_A_decode (W, Rn, P, M, register_list) = {
    __unconditional = false;
    let n = UInt(Rn);
    let registers = (P @ M) @ register_list;
    let wback = W == 0b1;
    if (n == 15 | BitCount(registers) < 2) | P == 0b1 & M == 0b1 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if [registers[13]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if ([registers[15]] == 0b1 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDMDB_Op_A(n, registers, wback)
}

val LDMDB_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDMDB_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDMDB_Op_A(n, registers, wback)
}

val LDMDA_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'n <= 14.
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDMDA_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n) - 4 * BitCount(registers) + 4;
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                R(i) = MemA(address, 4);
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            LoadWritePC(MemA(address, 4))
        };
        if wback & [registers[n]] == 0b0 then {
            R(n) = R(n) - 4 * BitCount(registers)
        };
        if wback & [registers[n]] == 0b1 then {
            R(n) = undefined : bits(32)
        }
    }
}

val LDMDA_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDMDA_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDMDA_Op_A(n, registers, wback)
}

val LDM_Op_A : forall 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'n <= 14.
  (int('n), bits(16), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_Op_A (n, registers, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        address = R(n);
        foreach (i from 0 to 14 by 1 in inc) {
            if [registers[i]] == 0b1 then {
                R(i) = MemA(address, 4);
                address = address + 4
            }
        };
        if [registers[15]] == 0b1 then {
            LoadWritePC(MemA(address, 4))
        };
        if wback & [registers[n]] == 0b0 then {
            R(n) = R(n) + 4 * BitCount(registers)
        };
        if wback & [registers[n]] == 0b1 then {
            R(n) = undefined : bits(32)
        }
    }
}

val LDM_T2_A_decode : (bits(1), bits(4), bits(1), bits(1), bits(14)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_T2_A_decode (W, Rn, P, M, register_list) = {
    __unconditional = false;
    let n = UInt(Rn);
    let registers = (P @ M) @ register_list;
    let wback = W == 0b1;
    if (n == 15 | BitCount(registers) < 2) | P == 0b1 & M == 0b1 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if [registers[13]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    if ([registers[15]] == 0b1 & InITBlock()) & ~(LastInITBlock()) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDM_Op_A(n, registers, wback)
}

val LDM_T1_A_decode : (bits(3), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_T1_A_decode (Rn, register_list) = {
    __unconditional = false;
    let n = UInt(Rn);
    let registers = 0x00 @ register_list;
    let wback : bool = [registers[n]] == 0b0;
    if BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDM_Op_A(n, registers, wback)
}

val LDM_A1_A_decode : (bits(4), bits(1), bits(4), bits(16)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDM_A1_A_decode (cond, W, Rn, register_list) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let n = UInt(Rn);
    let registers = register_list;
    let wback = W == 0b1;
    if n == 15 | BitCount(registers) < 1 then {
        throw(Error_Unpredictable())
    };
    if wback & [registers[n]] == 0b1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDM_Op_A(n, registers, wback)
}

val VST4_m_Op_A : forall 'alignment 'd 'd2 'd3 'd4 'ebytes 'elements 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 8 * 'ebytes >= 0 & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('d4 >= 0 & 'd4 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('d3), int('d4), int('ebytes), int('elements), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST4_m_Op_A (alignment, d, d2, d3, d4, ebytes, elements, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = true;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            MemU(address, ebytes) = aget_Elem(D(d), e);
            MemU(address + ebytes, ebytes) = aget_Elem(D(d2), e);
            MemU(address + 2 * ebytes, ebytes) = aget_Elem(D(d3), e);
            MemU(address + 3 * ebytes, ebytes) = aget_Elem(D(d4), e);
            address = address + 4 * ebytes
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 32
            }
        }
    }
}

val VST4_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST4_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    inc_name : int = undefined : int;
    match typ {
      0x0 => {
          inc_name = 1
      },
      0x1 => {
          inc_name = 2
      },
      _ => {
          throw(Error_See("Related encodings"))
      }
    };
    let inc_name = inc_name;
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(8 * '_ebytes >= 0));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST4_m_Op_A(alignment, d, d2, d3, d4, ebytes, elements, m, n, register_index, wback)
}

val VST4_1_Op_A : forall 'alignment 'd 'd2 'd3 'd4 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 8 * 'ebytes >= 0 & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('d4 >= 0 & 'd4 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('d3), int('d4), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST4_1_Op_A (alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = true;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        MemU(address, ebytes) = aget_Elem(D(d), index);
        MemU(address + ebytes, ebytes) = aget_Elem(D(d2), index);
        MemU(address + 2 * ebytes, ebytes) = aget_Elem(D(d3), index);
        MemU(address + 3 * ebytes, ebytes) = aget_Elem(D(d4), index);
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 4 * ebytes
            }
        }
    }
}

val VST4_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST4_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_See("Related encodings"))
    };
    if slice(index_align, 0, 2) == 0b11 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let inc_name = if [index_align[2]] == 0b0 then 1 else 2;
    let alignment = if slice(index_align, 0, 2) == 0b00 then 1 else shl_int(4, UInt(slice(index_align, 0, 2)));
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST4_1_Op_A(alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback)
}

val VST4_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST4_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if size != 0b01 then {
        throw(Error_See("Related encodings"))
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let inc_name = if [index_align[1]] == 0b0 then 1 else 2;
    let alignment = if [index_align[0]] == 0b0 then 1 else 8;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST4_1_Op_A(alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback)
}

val VST4_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST4_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if size != 0b00 then {
        throw(Error_See("Related encodings"))
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let inc_name = 1;
    let alignment = if [index_align[0]] == 0b0 then 1 else 4;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST4_1_Op_A(alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback)
}

val VST3_m_Op_A : forall 'alignment 'd 'd2 'd3 'ebytes 'elements 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 8 * 'ebytes >= 0 & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('d3), int('ebytes), int('elements), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST3_m_Op_A (alignment, d, d2, d3, ebytes, elements, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = true;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            MemU(address, ebytes) = aget_Elem(D(d), e);
            MemU(address + ebytes, ebytes) = aget_Elem(D(d2), e);
            MemU(address + 2 * ebytes, ebytes) = aget_Elem(D(d3), e);
            address = address + 3 * ebytes
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 24
            }
        }
    }
}

val VST3_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST3_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    if size == 0b11 | [align[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    inc_name : int = undefined : int;
    match typ {
      0x4 => {
          inc_name = 1
      },
      0x5 => {
          inc_name = 2
      },
      _ => {
          throw(Error_See("Related encodings"))
      }
    };
    let inc_name = inc_name;
    let alignment = if [align[0]] == 0b0 then 1 else 8;
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(8 * '_ebytes >= 0));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST3_m_Op_A(alignment, d, d2, d3, ebytes, elements, m, n, register_index, wback)
}

val VST2_m_Op_A : forall 'alignment 'd 'd2 'ebytes 'elements 'm 'n ('register_index : Bool) 'regs ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 8 * 'ebytes >= 0 & 'ebytes in {1, 2, 4, 8, 16} & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('ebytes), int('elements), int('m), int('n), bool('register_index), int('regs), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST2_m_Op_A (alignment, d, d2, ebytes, elements, m, n, register_index, regs, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = true;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d2 + 'loop_r >= 0 & 'd2 + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                MemU(address, ebytes) = aget_Elem(D(d + r), e);
                MemU(address + ebytes, ebytes) = aget_Elem(D(d2 + r), e);
                address = address + 2 * ebytes
            }
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 16 * regs
            }
        }
    }
}

val VST2_m_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST2_m_T2A2_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 2;
    let inc_name = 2;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(8 * '_ebytes >= 0));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST2_m_Op_A(alignment, d, d2, ebytes, elements, m, n, register_index, regs, wback)
}

val VST2_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST2_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 1;
    if align == 0b11 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let inc_name = if typ == 0x9 then 2 else 1;
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(8 * '_ebytes >= 0));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST2_m_Op_A(alignment, d, d2, ebytes, elements, m, n, register_index, regs, wback)
}

val VST2_1_Op_A : forall 'alignment 'd 'd2 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 8 * 'ebytes >= 0 & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST2_1_Op_A (alignment, d, d2, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = true;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        MemU(address, ebytes) = aget_Elem(D(d), index);
        MemU(address + ebytes, ebytes) = aget_Elem(D(d2), index);
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 2 * ebytes
            }
        }
    }
}

val VST2_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST2_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if [index_align[1]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let inc_name = if [index_align[2]] == 0b0 then 1 else 2;
    let alignment = if [index_align[0]] == 0b0 then 1 else 8;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST2_1_Op_A(alignment, d, d2, ebytes, index, m, n, register_index, wback)
}

val VST2_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST2_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let inc_name = if [index_align[1]] == 0b0 then 1 else 2;
    let alignment = if [index_align[0]] == 0b0 then 1 else 4;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST2_1_Op_A(alignment, d, d2, ebytes, index, m, n, register_index, wback)
}

val VST2_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST2_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let inc_name = 1;
    let alignment = if [index_align[0]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST2_1_Op_A(alignment, d, d2, ebytes, index, m, n, register_index, wback)
}

val VST1_m_Op_A : forall 'alignment 'd 'ebytes 'elements 'm 'n ('register_index : Bool) 'regs ('wback : Bool),
  ('n >= 0 & 'n <= 15) & (8 * 'ebytes >= 0 | not('ebytes != 8)) & ('ebytes == 1 | 'ebytes == 2 | 'ebytes == 4 | 'ebytes == 8 | 'ebytes == 16 | not('ebytes != 8)) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('ebytes), int('elements), int('m), int('n), bool('register_index), int('regs), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_m_Op_A (alignment, d, ebytes, elements, m, n, register_index, regs, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        __anon2 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = true;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                if ebytes != 8 then {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not('ebytes != 8))));
                    MemU(address, ebytes) = aget_Elem(D(d + r), e)
                } else {
                    assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31 | not(not('ebytes != 8)))));
                    __anon2 = AArch32_CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
                    let data : bits(64) = aget_Elem(D(d + r), e);
                    MemU(address, 4) = if BigEndian() then slice(data, 32, 32) else slice(data, 0, 32);
                    MemU(address + 4, 4) = if BigEndian() then slice(data, 0, 32) else slice(data, 32, 32)
                };
                address = address + ebytes
            }
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 8 * regs
            }
        }
    }
}

val VST1_m_T4A4_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_m_T4A4_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 4;
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint((8 * '_ebytes >= 0 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VST1_m_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_m_T3A3_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 3;
    if [align[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint((8 * '_ebytes >= 0 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VST1_m_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_m_T2A2_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 2;
    if align == 0b11 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint((8 * '_ebytes >= 0 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VST1_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 1;
    if [align[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint((8 * '_ebytes >= 0 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VST1_1_Op_A : forall 'alignment 'd 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 8 * 'ebytes >= 0 & 'ebytes in {1, 2, 4, 8, 16} & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_1_Op_A (alignment, d, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = true;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        MemU(address, ebytes) = aget_Elem(D(d), index);
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + ebytes
            }
        }
    }
}

val VST1_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if [index_align[2]] != 0b0 then {
        throw(Error_Undefined())
    };
    if slice(index_align, 0, 2) != 0b00 & slice(index_align, 0, 2) != 0b11 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let alignment = if slice(index_align, 0, 2) == 0b00 then 1 else 4;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST1_1_Op_A(alignment, d, ebytes, index, m, n, register_index, wback)
}

val VST1_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if [index_align[1]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let alignment = if [index_align[0]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST1_1_Op_A(alignment, d, ebytes, index, m, n, register_index, wback)
}

val VST1_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VST1_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    if [index_align[0]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let alignment = 1;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VST1_1_Op_A(alignment, d, ebytes, index, m, n, register_index, wback)
}

val VLD4_m_Op_A : forall 'alignment 'd 'd2 'd3 'd4 'ebytes 'elements 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('d4 >= 0 & 'd4 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('d3), int('d4), int('ebytes), int('elements), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_m_Op_A (alignment, d, d2, d3, d4, ebytes, elements, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            D(d) = aset_Elem(D(d), e, MemU(address, ebytes));
            D(d2) = aset_Elem(D(d2), e, MemU(address + ebytes, ebytes));
            D(d3) = aset_Elem(D(d3), e, MemU(address + 2 * ebytes, ebytes));
            D(d4) = aset_Elem(D(d4), e, MemU(address + 3 * ebytes, ebytes));
            address = address + 4 * ebytes
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 32
            }
        }
    }
}

val VLD4_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    inc_name : int = undefined : int;
    match typ {
      0x0 => {
          inc_name = 1
      },
      0x1 => {
          inc_name = 2
      },
      _ => {
          throw(Error_See("Related encodings"))
      }
    };
    let inc_name = inc_name;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD4_m_Op_A(alignment, d, d2, d3, d4, ebytes, elements, m, n, register_index, wback)
}

val VLD4_a_Op_A : forall 'alignment 'd 'd2 'd3 'd4 'ebytes 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'ebytes in {1, 2, 4, 8, 16} & mod(64, (8 * 'ebytes)) == 0 & ('d >= 0 & 'd <= 31) & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('d4 >= 0 & 'd4 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('d3), int('d4), int('ebytes), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_a_Op_A (alignment, d, d2, d3, d4, ebytes, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        D(d) = Replicate(MemU(address, ebytes));
        D(d2) = Replicate(MemU(address + ebytes, ebytes));
        D(d3) = Replicate(MemU(address + 2 * ebytes, ebytes));
        D(d4) = Replicate(MemU(address + 3 * ebytes, ebytes));
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 4 * ebytes
            }
        }
    }
}

val VLD4_a_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_a_T1A1_A_decode (D, Rn, Vd, size, T, a, Rm) = {
    __unconditional = false;
    if size == 0b11 & a == 0b0 then {
        throw(Error_Undefined())
    };
    alignment : int = undefined : int;
    ebytes : int = undefined : int;
    if size == 0b11 then {
        ebytes = 4;
        alignment = 16
    } else {
        ebytes = shl_int(1, UInt(size));
        if size == 0b10 then {
            alignment = if a == 0b0 then 1 else 8
        } else {
            alignment = if a == 0b0 then 1 else 4 * ebytes
        }
    };
    let inc_name : {|1, 2|} = if T == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 = d + inc_name;
    let d3 = d2 + inc_name;
    let d4 = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    let ebytes = ebytes;
    assert(constraint(('_d + '_inc_name + '_inc_name + '_inc_name >= 0 & '_d + '_inc_name + '_inc_name + '_inc_name <= 31)));
    assert(constraint(('_d + '_inc_name + '_inc_name >= 0 & '_d + '_inc_name + '_inc_name <= 31)));
    assert(constraint(('_d + '_inc_name >= 0 & '_d + '_inc_name <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(mod(64, (8 * '_ebytes)) == 0));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    assert(ebytes == 1 | ebytes == 2 | ebytes == 4 | ebytes == 8 | ebytes == 16);
    assert(n <= 14 & d4 <= 31);
    VLD4_a_Op_A(alignment, d, d2, d3, d4, ebytes, m, n, register_index, wback)
}

val VLD4_1_Op_A : forall 'alignment 'd 'd2 'd3 'd4 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('d4 >= 0 & 'd4 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('d3), int('d4), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_1_Op_A (alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        D(d) = aset_Elem(D(d), index, MemU(address, ebytes));
        D(d2) = aset_Elem(D(d2), index, MemU(address + ebytes, ebytes));
        D(d3) = aset_Elem(D(d3), index, MemU(address + 2 * ebytes, ebytes));
        D(d4) = aset_Elem(D(d4), index, MemU(address + 3 * ebytes, ebytes));
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 4 * ebytes
            }
        }
    }
}

val VLD4_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD4 (single 4-element structure to all lanes)"))
    };
    if slice(index_align, 0, 2) == 0b11 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let inc_name = if [index_align[2]] == 0b0 then 1 else 2;
    let alignment = if slice(index_align, 0, 2) == 0b00 then 1 else shl_int(4, UInt(slice(index_align, 0, 2)));
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD4_1_Op_A(alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback)
}

val VLD4_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD4 (single 4-element structure to all lanes)"))
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let inc_name = if [index_align[1]] == 0b0 then 1 else 2;
    let alignment = if [index_align[0]] == 0b0 then 1 else 8;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD4_1_Op_A(alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback)
}

val VLD4_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD4_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD4 (single 4-element structure to all lanes)"))
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let inc_name = 1;
    let alignment = if [index_align[0]] == 0b0 then 1 else 4;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let d4 : int = d3 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d4 >= 0 & '_d4 <= 31)));
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d4 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD4_1_Op_A(alignment, d, d2, d3, d4, ebytes, index, m, n, register_index, wback)
}

val VLD3_m_Op_A : forall 'alignment 'd 'd2 'd3 'ebytes 'elements 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('d3 >= 0 & 'd3 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('d3), int('ebytes), int('elements), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_m_Op_A (alignment, d, d2, d3, ebytes, elements, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            D(d) = aset_Elem(D(d), e, MemU(address, ebytes));
            D(d2) = aset_Elem(D(d2), e, MemU(address + ebytes, ebytes));
            D(d3) = aset_Elem(D(d3), e, MemU(address + 2 * ebytes, ebytes));
            address = address + 3 * ebytes
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 24
            }
        }
    }
}

val VLD3_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD3_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    inc_name : int = undefined : int;
    match typ {
      0x4 => {
          inc_name = 1
      },
      0x5 => {
          inc_name = 2
      },
      _ => {
          throw(Error_See("Related encodings"))
      }
    };
    let inc_name = inc_name;
    if size == 0b11 | [align[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let alignment = if [align[0]] == 0b0 then 1 else 8;
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let d3 : int = d2 + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d3 >= 0 & '_d3 <= 31)));
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d3 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD3_m_Op_A(alignment, d, d2, d3, ebytes, elements, m, n, register_index, wback)
}

val VLD2_m_Op_A : forall 'alignment 'd 'd2 'ebytes 'elements 'm 'n ('register_index : Bool) 'regs ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'ebytes in {1, 2, 4, 8, 16} & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('ebytes), int('elements), int('m), int('n), bool('register_index), int('regs), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_m_Op_A (alignment, d, d2, ebytes, elements, m, n, register_index, regs, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d2 + 'loop_r >= 0 & 'd2 + 'loop_r <= 31)));
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                D(d + r) = aset_Elem(D(d + r), e, MemU(address, ebytes));
                D(d2 + r) = aset_Elem(D(d2 + r), e, MemU(address + ebytes, ebytes));
                address = address + 2 * ebytes
            }
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 16 * regs
            }
        }
    }
}

val VLD2_m_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_m_T2A2_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 2;
    let inc_name = 2;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD2_m_Op_A(alignment, d, d2, ebytes, elements, m, n, register_index, regs, wback)
}

val VLD2_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 1;
    if align == 0b11 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let inc_name = if typ == 0x9 then 2 else 1;
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD2_m_Op_A(alignment, d, d2, ebytes, elements, m, n, register_index, regs, wback)
}

val VLD2_a_Op_A : forall 'alignment 'd 'd2 'ebytes 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'ebytes in {1, 2, 4, 8, 16} & mod(64, (8 * 'ebytes)) == 0 & ('d >= 0 & 'd <= 31) & ('d2 >= 0 & 'd2 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('ebytes), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_a_Op_A (alignment, d, d2, ebytes, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        D(d) = Replicate(MemU(address, ebytes));
        D(d2) = Replicate(MemU(address + ebytes, ebytes));
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 2 * ebytes
            }
        }
    }
}

val VLD2_a_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_a_T1A1_A_decode (D, Rn, Vd, size, T, a, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let ebytes = shl_int(1, UInt(size));
    let alignment : int = if a == 0b0 then 1 else 2 * ebytes;
    let inc_name = if T == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(mod(64, (8 * '_ebytes)) == 0));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD2_a_Op_A(alignment, d, d2, ebytes, m, n, register_index, wback)
}

val VLD2_1_Op_A : forall 'alignment 'd 'd2 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 'ebytes in {1, 2, 4, 8, 16} & ('d2 >= 0 & 'd2 <= 31) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('d2), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_1_Op_A (alignment, d, d2, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        D(d) = aset_Elem(D(d), index, MemU(address, ebytes));
        D(d2) = aset_Elem(D(d2), index, MemU(address + ebytes, ebytes));
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 2 * ebytes
            }
        }
    }
}

val VLD2_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD2 (single 2-element structure to all lanes)"))
    };
    if [index_align[1]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let inc_name = if [index_align[2]] == 0b0 then 1 else 2;
    let alignment = if [index_align[0]] == 0b0 then 1 else 8;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD2_1_Op_A(alignment, d, d2, ebytes, index, m, n, register_index, wback)
}

val VLD2_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD2 (single 2-element structure to all lanes)"))
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let inc_name = if [index_align[1]] == 0b0 then 1 else 2;
    let alignment = if [index_align[0]] == 0b0 then 1 else 4;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD2_1_Op_A(alignment, d, d2, ebytes, index, m, n, register_index, wback)
}

val VLD2_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD2_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD2 (single 2-element structure to all lanes)"))
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let inc_name = 1;
    let alignment = if [index_align[0]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let d2 : int = d + inc_name;
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_d2 >= 0 & '_d2 <= 31)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d2 > 31 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD2_1_Op_A(alignment, d, d2, ebytes, index, m, n, register_index, wback)
}

val VLD1_m_Op_A : forall 'alignment 'd 'ebytes 'elements 'm 'n ('register_index : Bool) 'regs ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('ebytes == 1 | 'ebytes == 2 | 'ebytes == 4 | 'ebytes == 8 | 'ebytes == 16 | not('ebytes != 8)) & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('ebytes), int('elements), int('m), int('n), bool('register_index), int('regs), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_m_Op_A (alignment, d, ebytes, elements, m, n, register_index, regs, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        __anon2 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            foreach (e from 0 to (elements - 1) by 1 in inc) {
                assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
                data : bits(8 * 'ebytes) = undefined : bits('ebytes * 8);
                if ebytes != 8 then {
                    data = MemU(address, ebytes)
                } else {
                    __anon2 = AArch32_CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
                    data = __SetSlice_bits(8 * ebytes, 32, data, 0, if BigEndian() then MemU(address + 4, 4) else MemU(address, 4));
                    data = __SetSlice_bits(8 * ebytes, 32, data, 32, if BigEndian() then MemU(address, 4) else MemU(address + 4, 4))
                };
                D(d + r) = aset_Elem(D(d + r), e, data);
                address = address + ebytes
            }
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + 8 * regs
            }
        }
    }
}

val VLD1_m_T4A4_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_m_T4A4_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 4;
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VLD1_m_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_m_T3A3_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 3;
    if [align[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VLD1_m_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_m_T2A2_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 2;
    if align == 0b11 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VLD1_m_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(4), bits(2), bits(2), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_m_T1A1_A_decode (D, Rn, Vd, typ, size, align, Rm) = {
    __unconditional = false;
    let regs = 1;
    if [align[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let alignment = if align == 0b00 then 1 else shl_int(4, UInt(align));
    let ebytes = shl_int(1, UInt(size));
    let elements : int = 8 / ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(('_ebytes == 1 | '_ebytes == 2 | '_ebytes == 4 | '_ebytes == 8 | '_ebytes == 16 | not('_ebytes != 8))));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_m_Op_A(alignment, d, ebytes, elements, m, n, register_index, regs, wback)
}

val VLD1_a_Op_A : forall 'alignment 'd 'ebytes 'm 'n ('register_index : Bool) 'regs ('wback : Bool),
  ('n >= 0 & 'n <= 15) & 'ebytes in {1, 2, 4, 8, 16} & mod(64, (8 * 'ebytes)) == 0 & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('ebytes), int('m), int('n), bool('register_index), int('regs), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_a_Op_A (alignment, d, ebytes, m, n, register_index, regs, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        let replicated_element : bits(64) = Replicate(MemU(address, ebytes));
        foreach (r from 0 to (regs - 1) by 1 in inc) {
            assert(constraint(('d + 'loop_r >= 0 & 'd + 'loop_r <= 31)));
            D(d + r) = replicated_element
        };
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + ebytes
            }
        }
    }
}

val VLD1_a_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(1), bits(1), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_a_T1A1_A_decode (D, Rn, Vd, size, T, a, Rm) = {
    __unconditional = false;
    if size == 0b11 | size == 0b00 & a == 0b1 then {
        throw(Error_Undefined())
    };
    let ebytes = shl_int(1, UInt(size));
    let regs = if T == 0b0 then 1 else 2;
    let alignment : int = if a == 0b0 then 1 else ebytes;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    assert(constraint(mod(64, (8 * '_ebytes)) == 0));
    assert(constraint('_ebytes in {1, 2, 4, 8, 16}));
    assert(constraint(('_n >= 0 & '_n <= 15)));
    if n == 15 | d + regs > 32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_a_Op_A(alignment, d, ebytes, m, n, register_index, regs, wback)
}

val VLD1_1_Op_A : forall 'alignment 'd 'ebytes 'index 'm 'n ('register_index : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 15) & ('d >= 0 & 'd <= 31) & 'ebytes in {1, 2, 4, 8, 16} & ('m >= 0 & 'm <= 15 | not('register_index) | not('wback)) & ('n <= 14 | not('register_index) | not('wback)) & ('n <= 14 | not(not('register_index)) | not('wback)).
  (int('alignment), int('d), int('ebytes), int('index), int('m), int('n), bool('register_index), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_1_Op_A (alignment, d, ebytes, index, m, n, register_index, wback) = {
    if ConditionPassed() then {
        __anon1 : bool = undefined : bool;
        address : bits(32) = undefined : bits(32);
        iswrite : bool = undefined : bool;
        CheckAdvSIMDEnabled();
        address = R(n);
        iswrite = false;
        __anon1 = AArch32_CheckAlignment(address, alignment, AccType_VEC, iswrite);
        D(d) = aset_Elem(D(d), index, MemU(address, ebytes));
        if wback then {
            if register_index then {
                R(n) = R(n) + R(m)
            } else {
                R(n) = R(n) + ebytes
            }
        }
    }
}

val VLD1_1_T3A3_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_1_T3A3_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD1 (single element to all lanes)"))
    };
    if [index_align[2]] != 0b0 then {
        throw(Error_Undefined())
    };
    if slice(index_align, 0, 2) != 0b00 & slice(index_align, 0, 2) != 0b11 then {
        throw(Error_Undefined())
    };
    let ebytes = 4;
    let index = UInt([index_align[3]]);
    let alignment = if slice(index_align, 0, 2) == 0b00 then 1 else 4;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_1_Op_A(alignment, d, ebytes, index, m, n, register_index, wback)
}

val VLD1_1_T2A2_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_1_T2A2_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD1 (single element to all lanes)"))
    };
    if [index_align[1]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 2;
    let index = UInt(slice(index_align, 2, 2));
    let alignment = if [index_align[0]] == 0b0 then 1 else 2;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_1_Op_A(alignment, d, ebytes, index, m, n, register_index, wback)
}

val VLD1_1_T1A1_A_decode : (bits(1), bits(4), bits(4), bits(2), bits(4), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function VLD1_1_T1A1_A_decode (D, Rn, Vd, size, index_align, Rm) = {
    __unconditional = false;
    if size == 0b11 then {
        throw(Error_See("VLD1 (single element to all lanes)"))
    };
    if [index_align[0]] != 0b0 then {
        throw(Error_Undefined())
    };
    let ebytes = 1;
    let index = UInt(slice(index_align, 1, 3));
    let alignment = 1;
    let d = UInt(D @ Vd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let wback : bool = m != 15;
    let register_index : bool = m != 15 & m != 13;
    if n == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VLD1_1_Op_A(alignment, d, ebytes, index, m, n, register_index, wback)
}

val AArch32_AArch32SystemAccessTrap : (bits(2), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_AArch32SystemAccessTrap (target_el, instr) = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    if ~(ELUsingAArch32(target_el)) | AArch32_GeneralExceptionsToAArch64() then {
        AArch64_AArch32SystemAccessTrap(target_el, instr)
    };
    assert(target_el == EL1 | target_el == EL2);
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if target_el == EL2 then {
        exception = AArch32_AArch32SystemAccessTrapSyndrome(instr);
        AArch32_TakeHypTrapException(exception)
    } else {
        AArch32_TakeUndefInstrException()
    }
}

val AArch32_CheckSystemAccessEL2Traps : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckSystemAccessEL2Traps instr = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2));
    if EL2Enabled() & ~(ELUsingAArch32(EL2)) then {
        AArch64_CheckAArch32SystemAccessEL2Traps(instr);
        return()
    };
    trap : bool = undefined : bool;
    trap = false;
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    cp_num : int = undefined : int;
    op : SystemAccessType = undefined : SystemAccessType;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    write : bool = undefined : bool;
    (op, cp_num, opc1, CRn, CRm, opc2, write) = AArch32_DecodeSysRegAccess(instr);
    if cp_num == 14 & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
        if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 0 | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 0) | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 2 then {
            trap = ([get_HDCR()[11]] == 0b1 | [get_HDCR()[8]] == 0b1) | [get_HCR()[27]] == 0b1
        } else {
            if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 4 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 4) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 3) & opc2 == 4) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 4) & opc2 == 4 then {
                trap = ([get_HDCR()[10]] == 0b1 | [get_HDCR()[8]] == 0b1) | [get_HCR()[27]] == 0b1
            } else {
                if opc1 == 0 & (~(Halted()) | ~(((op == SystemAccessType_RT & CRn == 0) & CRm == 5) & opc2 == 0)) then {
                    trap = ([get_HDCR()[9]] == 0b1 | [get_HDCR()[8]] == 0b1) | [get_HCR()[27]] == 0b1
                } else {
                    if opc1 == 1 then {
                        trap = [get_HCPTR()[20]] == 0b1;
                        if (HaveEL(EL3) & ELUsingAArch32(EL3)) & [NSACR[20]] == 0b1 then {
                            trap = true
                        }
                    } else {
                        if (((op == SystemAccessType_RT & opc1 == 7) & CRn == 0) & CRm == 0) & opc2 == 0 then {
                            trap = [get_HCR()[15]] == 0b1
                        }
                    }
                }
            }
        }
    } else {
        if cp_num == 14 & PSTATE.EL == EL2 then {
            if opc1 == 1 then {
                trap = [get_HCPTR()[20]] == 0b1
            }
        } else {
            if cp_num == 15 & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
                if ((((((((((((((((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 0 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 0) | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 1) | (op == SystemAccessType_RRT & opc1 == 1) & CRm == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 2) & CRm == 0) & opc2 == 3) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 3) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 0) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 6) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 6) & CRm == 0) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 1) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 5) & CRm == 1) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 2) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 2) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 3) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 10) & CRm == 3) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 13) & CRm == 0) & opc2 == 1 then {
                    trap = if write then [get_HCR()[26]] == 0b1 else [get_HCR()[30]] == 0b1
                } else {
                    if (op == SystemAccessType_RT & opc1 == 0) & CRn == 8 then {
                        trap = write & [get_HCR()[25]] == 0b1
                    } else {
                        if ((((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 6) & opc2 == 2 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 10) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 14) & opc2 == 2 then {
                            trap = write & [get_HCR()[22]] == 0b1
                        } else {
                            if ((((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 6) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 10) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 14) & opc2 == 1 then {
                                trap = write & [get_HCR()[23]] == 0b1
                            } else {
                                if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 5) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 5) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 1) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 11) & opc2 == 1 then {
                                    trap = write & [get_HCR()[24]] == 0b1
                                } else {
                                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 3 then {
                                        trap = [get_HCR()[21]] == 0b1
                                    } else {
                                        if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 2 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 3) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 6) | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 7 then {
                                            trap = [get_HCR()[16]] == 0b1
                                        } else {
                                            if ((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 0) & opc2 == 1 | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 0) | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 1) & CRn == 0) & CRm == 0) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 2) & CRn == 0) & CRm == 0) & opc2 == 0 then {
                                                trap = [get_HCR()[17]] == 0b1
                                            } else {
                                                if (((((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 1 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 2) & opc2 <= 7) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm >= 3) & opc2 <= 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 3) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 5) & (opc2 == 4 | opc2 == 5) then {
                                                    trap = [get_HCR()[18]] == 0b1
                                                } else {
                                                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 0) & opc2 == 2 then {
                                                        trap = [get_HCPTR()[31]] == 0b1
                                                    } else {
                                                        if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 0 then {
                                                            trap = [get_HDCR()[5]] == 0b1 | [get_HDCR()[6]] == 0b1
                                                        } else {
                                                            if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm >= 8 | ((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & (CRm == 12 | CRm == 13 | CRm == 14)) | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 9 then {
                                                                trap = [get_HDCR()[6]] == 0b1
                                                            } else {
                                                                if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm == 2) & (opc2 == 0 | opc2 == 1 | opc2 == 2) then {
                                                                    trap = [get_CNTHCTL()[1]] == 0b0
                                                                } else {
                                                                    if (op == SystemAccessType_RRT & opc1 == 0) & CRm == 14 then {
                                                                        trap = [get_CNTHCTL()[0]] == 0b0
                                                                    } else {
                                                                        if ((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 0 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 1) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 12) & CRm == 0) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 1) & CRm == 3) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 7) & CRm == 8) & opc2 >= 4 then {
                                                                            trap = ((IsSecureEL2Enabled() & PSTATE.EL == EL1) & IsSecure()) & ELUsingAArch32(EL1)
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if trap then {
        AArch32_AArch32SystemAccessTrap(EL2, instr)
    }
}

val AArch32_CheckSystemAccessEL1Traps : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckSystemAccessEL1Traps instr = {
    assert(PSTATE.EL == EL0);
    if (HaveEL(EL1) & IsSecure()) & ~(ELUsingAArch32(EL1)) | IsInHost() then {
        AArch64_CheckAArch32SystemAccessEL1Traps(instr);
        return()
    };
    trap : bool = undefined : bool;
    trap = false;
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    cp_num : int = undefined : int;
    op : SystemAccessType = undefined : SystemAccessType;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    write : bool = undefined : bool;
    (op, cp_num, opc1, CRn, CRm, opc2, write) = AArch32_DecodeSysRegAccess(instr);
    if cp_num == 14 then {
        if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 0) & CRm == 5) & opc2 == 0 | (op == SystemAccessType_DT & CRn == 5) & opc2 == 0 then {
            trap = ~(Halted()) & [get_DBGDSCRext()[12]] == 0b1
        } else {
            if opc1 == 0 then {
                trap = [get_DBGDSCRext()[12]] == 0b1
            } else {
                if opc1 == 1 then {
                    trap = [get_CPACR()[28]] == 0b1;
                    if (HaveEL(EL3) & ELUsingAArch32(EL3)) & [NSACR[20]] == 0b1 then {
                        trap = true
                    }
                }
            }
        }
    } else {
        if cp_num == 15 then {
            if ((((((((((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 0 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 2) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 3) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 6) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 7) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 13) & opc2 == 1) | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 14) & opc2 == 3) | ((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm >= 12 then {
                trap = [get_PMUSERENR()[0]] == 0b0
            } else {
                if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 14) & opc2 == 4 then {
                    trap = [get_PMUSERENR()[0]] == 0b0 & [get_PMUSERENR()[1]] == 0b0
                } else {
                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 13) & opc2 == 0 | (op == SystemAccessType_RRT & opc1 == 0) & CRm == 9 then {
                        trap = [get_PMUSERENR()[0]] == 0b0 & (write | [get_PMUSERENR()[2]] == 0b0)
                    } else {
                        if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 13) & opc2 == 2 | (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm >= 8) & CRm <= 11 then {
                            trap = [get_PMUSERENR()[0]] == 0b0 & (write | [get_PMUSERENR()[3]] == 0b0)
                        } else {
                            if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 9) & CRm == 12) & opc2 == 5 then {
                                trap = [get_PMUSERENR()[0]] == 0b0 & [get_PMUSERENR()[3]] == 0b0
                            } else {
                                if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm == 2) & (opc2 == 0 | opc2 == 1 | opc2 == 2) then {
                                    trap = [get_CNTKCTL()[9]] == 0b0
                                } else {
                                    if (((op == SystemAccessType_RT & opc1 == 0) & CRn == 14) & CRm == 0) & opc2 == 0 then {
                                        trap = [get_CNTKCTL()[0]] == 0b0 & [get_CNTKCTL()[1]] == 0b0
                                    } else {
                                        if (op == SystemAccessType_RRT & opc1 == 1) & CRm == 14 then {
                                            trap = [get_CNTKCTL()[1]] == 0b0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if trap then {
        AArch32_AArch32SystemAccessTrap(EL1, instr)
    }
}

val AArch32_CheckSystemAccessTraps : bits(32) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckSystemAccessTraps instr = {
    if PSTATE.EL == EL0 then {
        AArch32_CheckSystemAccessEL1Traps(instr)
    };
    if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2)) & ~(IsInHost()) then {
        AArch32_CheckSystemAccessEL2Traps(instr)
    };
    if (HaveEL(EL3) & ~(ELUsingAArch32(EL3))) & (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) then {
        AArch64_CheckAArch32SystemAccessEL3Traps(instr)
    }
}

val AArch32_CheckSystemAccess : forall ('cp_num : Int).
  (int('cp_num), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckSystemAccess (cp_num, instr) = {
    assert(cp_num == UInt(slice(instr, 8, 4)) & (cp_num == 14 | cp_num == 15));
    if PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1)) then {
        AArch64_CheckAArch32SystemAccess(instr);
        return()
    };
    CRm : int = undefined : int;
    CRn : int = undefined : int;
    allocated : bool = undefined : bool;
    cpdt : bool = undefined : bool;
    cprt : bool = undefined : bool;
    nreg : int = undefined : int;
    opc1 : int = undefined : int;
    opc2 : int = undefined : int;
    if (slice(instr, 28, 4) != 0xF & slice(instr, 24, 4) == 0xE) & [instr[4]] == 0b1 then {
        cprt = true;
        cpdt = false;
        nreg = 1;
        opc1 = UInt(slice(instr, 21, 3));
        opc2 = UInt(slice(instr, 5, 3));
        CRn = UInt(slice(instr, 16, 4));
        CRm = UInt(slice(instr, 0, 4))
    } else {
        if slice(instr, 28, 4) != 0xF & slice(instr, 21, 7) == 0b1100010 then {
            cprt = true;
            cpdt = false;
            nreg = 2;
            opc1 = UInt(slice(instr, 4, 4));
            CRm = UInt(slice(instr, 0, 4))
        } else {
            if (slice(instr, 28, 4) != 0xF & slice(instr, 25, 3) == 0b110) & [instr[22]] == 0b0 then {
                cprt = false;
                cpdt = true;
                nreg = 0;
                opc1 = 0;
                CRn = UInt(slice(instr, 12, 4))
            } else {
                allocated = false
            }
        }
    };
    if cp_num == 14 then {
        if cpdt & CRn != 5 then {
            allocated = false
        } else {
            match opc1 {
              0 => {
                  allocated = CP14DebugInstrDecode(instr)
              },
              1 => {
                  allocated = CP14TraceInstrDecode(instr)
              },
              7 => {
                  allocated = CP14JazelleInstrDecode(instr)
              },
              _ => {
                  allocated = false
              }
            }
        }
    } else {
        if cp_num == 15 then {
            if ~(cprt) then {
                allocated = false
            } else {
                allocated = CP15InstrDecode(instr);
                if AArch32_CheckCP15InstrCoarseTraps(CRn, nreg, CRm) then {
                    if (PSTATE.EL == EL0 & EL2Enabled()) & ~(allocated) then {
                        if __IMPDEF_boolean("UNDEF unallocated CP15 access at EL0") then {
                            throw(Error_Undefined())
                        }
                    };
                    AArch32_AArch32SystemAccessTrap(EL2, instr)
                }
            }
        } else {
            allocated = false
        }
    };
    if ~(allocated) then {
        throw(Error_Undefined())
    };
    AArch32_CheckSystemAccessTraps(instr);
    return()
}

val STC_Op_A : forall ('add : Bool) 'cp ('index : Bool) 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('n <= 14 | not('wback)).
  (bool('add), int('cp), bits(32), bool('index), int('n), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function STC_Op_A (add, cp, imm32, index, n, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        AArch32_CheckSystemAccess(cp, ThisInstr());
        offset_addr = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        MemA(address, 4) = DBGDTR_EL0();
        if wback then {
            R(n) = offset_addr
        }
    }
}

val STC_T1A1_A_decode__0 : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val STC_T1A1_A_decode__1 : (bits(1), bits(1), bits(1), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload STC_T1A1_A_decode = {STC_T1A1_A_decode__0, STC_T1A1_A_decode__1}

function STC_T1A1_A_decode__0 (cond, P, U, W, Rn, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_Undefined())
    };
    let n = UInt(Rn);
    let cp = 14;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = W == 0b1;
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STC_Op_A(add, cp, imm32, index, n, wback)
}

function STC_T1A1_A_decode__1 (P, U, W, Rn, imm8) = {
    __unconditional = false;
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_Undefined())
    };
    let n = UInt(Rn);
    let cp = 14;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = W == 0b1;
    if n == 15 & (wback | CurrentInstrSet() != InstrSet_A32) then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    STC_Op_A(add, cp, imm32, index, n, wback)
}

val MRRC_Op_A : forall 'cp 't 't2,
  ('t >= 0 & 't <= 14) & ('t2 >= 0 & 't2 <= 14).
  (int('cp), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function MRRC_Op_A (cp, t, t2) = {
    if ConditionPassed() then {
        value_name : bits(64) = undefined : bits(64);
        AArch32_CheckSystemAccess(cp, ThisInstr());
        value_name = AArch32_SysRegRead64(cp, ThisInstr());
        R(t) = slice(value_name, 0, 32);
        R(t2) = slice(value_name, 32, 32)
    }
}

val MRRC_T1A1_A_decode__0 : (bits(4), bits(4), bits(4), bits(1), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val MRRC_T1A1_A_decode__1 : (bits(4), bits(4), bits(1), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload MRRC_T1A1_A_decode = {MRRC_T1A1_A_decode__0, MRRC_T1A1_A_decode__1}

function MRRC_T1A1_A_decode__0 (cond, Rt2, Rt, coproc, opc1, CRm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    if (t == 15 | t2 == 15) | t == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MRRC_Op_A(cp, t, t2)
}

function MRRC_T1A1_A_decode__1 (Rt2, Rt, coproc, opc1, CRm) = {
    __unconditional = false;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    if (t == 15 | t2 == 15) | t == t2 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MRRC_Op_A(cp, t, t2)
}

val MRC_Op_A : forall 'cp 't,
  ('t >= 0 & 't <= 14 | not('t != 15)) & ('cp == 14 | 'cp == 15 | not(not('t != 15))).
  (int('cp), int('t)) -> unit effect {escape, rreg, undef, wreg}

function MRC_Op_A (cp, t) = {
    if ConditionPassed() then {
        AArch32_CheckSystemAccess(cp, ThisInstr());
        let value_name = AArch32_SysRegRead(cp, ThisInstr());
        if t != 15 then {
            R(t) = value_name
        } else {
            if AArch32_SysRegReadCanWriteAPSR(cp, ThisInstr()) then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = slice(value_name, 28, 4)
            } else {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = undefined : bits(4)
            }
        }
    }
}

val MRC_T1A1_A_decode__0 : (bits(4), bits(3), bits(4), bits(4), bits(1), bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val MRC_T1A1_A_decode__1 : (bits(3), bits(4), bits(4), bits(1), bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload MRC_T1A1_A_decode = {MRC_T1A1_A_decode__0, MRC_T1A1_A_decode__1}

function MRC_T1A1_A_decode__0 (cond, opc1, CRn, Rt, coproc, opc2, CRm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    __PostDecode();
    MRC_Op_A(cp, t)
}

function MRC_T1A1_A_decode__1 (opc1, CRn, Rt, coproc, opc2, CRm) = {
    __unconditional = false;
    let t = UInt(Rt);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    __PostDecode();
    MRC_Op_A(cp, t)
}

val MCRR_Op_A : forall 'cp 't 't2,
  ('t2 >= 0 & 't2 <= 15) & ('t >= 0 & 't <= 15).
  (int('cp), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function MCRR_Op_A (cp, t, t2) = {
    if ConditionPassed() then {
        value_name : bits(64) = undefined : bits(64);
        AArch32_CheckSystemAccess(cp, ThisInstr());
        value_name = R(t2) @ R(t);
        AArch32_SysRegWrite64(cp, ThisInstr(), value_name)
    }
}

val MCRR_T1A1_A_decode__0 : (bits(4), bits(4), bits(4), bits(1), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val MCRR_T1A1_A_decode__1 : (bits(4), bits(4), bits(1), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload MCRR_T1A1_A_decode = {MCRR_T1A1_A_decode__0, MCRR_T1A1_A_decode__1}

function MCRR_T1A1_A_decode__0 (cond, Rt2, Rt, coproc, opc1, CRm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    if t == 15 | t2 == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MCRR_Op_A(cp, t, t2)
}

function MCRR_T1A1_A_decode__1 (Rt2, Rt, coproc, opc1, CRm) = {
    __unconditional = false;
    let t = UInt(Rt);
    let t2 = UInt(Rt2);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    if t == 15 | t2 == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MCRR_Op_A(cp, t, t2)
}

val MCR_Op_A : forall ('cp : Int) ('t : Int), ('t >= 0 & 't <= 15).
  (int('cp), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function MCR_Op_A (cp, t) = {
    if ConditionPassed() then {
        AArch32_CheckSystemAccess(cp, ThisInstr());
        AArch32_SysRegWrite(cp, ThisInstr(), R(t))
    }
}

val MCR_T1A1_A_decode__0 : (bits(3), bits(4), bits(4), bits(1), bits(3), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val MCR_T1A1_A_decode__1 : (bits(4), bits(3), bits(4), bits(4), bits(1), bits(3), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload MCR_T1A1_A_decode = {MCR_T1A1_A_decode__0, MCR_T1A1_A_decode__1}

function MCR_T1A1_A_decode__0 (opc1, CRn, Rt, coproc, opc2, CRm) = {
    __unconditional = false;
    let t = UInt(Rt);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MCR_Op_A(cp, t)
}

function MCR_T1A1_A_decode__1 (cond, opc1, CRn, Rt, coproc, opc2, CRm) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    let cp = if [coproc[0]] == 0b0 then 14 else 15;
    if t == 15 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    MCR_Op_A(cp, t)
}

val LDC_l_Op_A : forall ('add : Bool) ('cp : Int) ('index : Bool).
  (bool('add), int('cp), bits(32), bool('index)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDC_l_Op_A (add, cp, imm32, index) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        AArch32_CheckSystemAccess(cp, ThisInstr());
        offset_addr = if add then Align(get_PC(), 4) + imm32 else Align(get_PC(), 4) - imm32;
        address = if index then offset_addr else Align(get_PC(), 4);
        DBGDTR_EL0() = MemA(address, 4)
    }
}

val LDC_l_T1A1_A_decode__0 : (bits(4), bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val LDC_l_T1A1_A_decode__1 : (bits(1), bits(1), bits(1), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload LDC_l_T1A1_A_decode = {LDC_l_T1A1_A_decode__0, LDC_l_T1A1_A_decode__1}

function LDC_l_T1A1_A_decode__0 (cond, P, U, W, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_Undefined())
    };
    let index = P == 0b1;
    let add = U == 0b1;
    let cp = 14;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    if W == 0b1 | P == 0b0 & CurrentInstrSet() != InstrSet_A32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDC_l_Op_A(add, cp, imm32, index)
}

function LDC_l_T1A1_A_decode__1 (P, U, W, imm8) = {
    __unconditional = false;
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_Undefined())
    };
    let index = P == 0b1;
    let add = U == 0b1;
    let cp = 14;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    if W == 0b1 | P == 0b0 & CurrentInstrSet() != InstrSet_A32 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    LDC_l_Op_A(add, cp, imm32, index)
}

val LDC_i_Op_A : forall ('add : Bool) 'cp ('index : Bool) 'n ('wback : Bool),
  ('n >= 0 & 'n <= 15 | not('add)) & ('n >= 0 & 'n <= 15 | not(not('add))) & ('n <= 14 | not('wback)).
  (bool('add), int('cp), bits(32), bool('index), int('n), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function LDC_i_Op_A (add, cp, imm32, index, n, wback) = {
    if ConditionPassed() then {
        address : bits(32) = undefined : bits(32);
        offset_addr : bits(32) = undefined : bits(32);
        AArch32_CheckSystemAccess(cp, ThisInstr());
        offset_addr = if add then R(n) + imm32 else R(n) - imm32;
        address = if index then offset_addr else R(n);
        DBGDTR_EL0() = MemA(address, 4);
        if wback then {
            R(n) = offset_addr
        }
    }
}

val LDC_i_T1A1_A_decode__0 : (bits(4), bits(1), bits(1), bits(1), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

val LDC_i_T1A1_A_decode__1 : (bits(1), bits(1), bits(1), bits(4), bits(8)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

overload LDC_i_T1A1_A_decode = {LDC_i_T1A1_A_decode__0, LDC_i_T1A1_A_decode__1}

function LDC_i_T1A1_A_decode__0 (cond, P, U, W, Rn, imm8) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    if Rn == 0xF then {
        throw(Error_See("LDC (literal)"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_Undefined())
    };
    let n = UInt(Rn);
    let cp = 14;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = W == 0b1;
    __PostDecode();
    LDC_i_Op_A(add, cp, imm32, index, n, wback)
}

function LDC_i_T1A1_A_decode__1 (P, U, W, Rn, imm8) = {
    __unconditional = false;
    if Rn == 0xF then {
        throw(Error_See("LDC (literal)"))
    };
    if (P == 0b0 & U == 0b0) & W == 0b0 then {
        throw(Error_Undefined())
    };
    let n = UInt(Rn);
    let cp = 14;
    let imm32 = ZeroExtend(imm8 @ 0b00, 32);
    let index = P == 0b1;
    let add = U == 0b1;
    let wback = W == 0b1;
    __PostDecode();
    LDC_i_Op_A(add, cp, imm32, index, n, wback)
}

val AArch32_CheckAdvSIMDOrFPRegisterTraps : bits(4) -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckAdvSIMDOrFPRegisterTraps reg = {
    tid0 : bits(1) = undefined : bits(1);
    tid3 : bits(1) = undefined : bits(1);
    if PSTATE.EL == EL1 & EL2Enabled() then {
        tid0 = if ELUsingAArch32(EL2) then [get_HCR()[15]] else [HCR_EL2[15]];
        tid3 = if ELUsingAArch32(EL2) then [get_HCR()[18]] else [HCR_EL2[18]];
        if tid0 == 0b1 & reg == 0x0 | tid3 == 0b1 & (reg == 0x5 | reg == 0x6 | reg == 0x7) then {
            if ELUsingAArch32(EL2) then {
                AArch32_AArch32SystemAccessTrap(EL2, ThisInstr())
            } else {
                AArch64_AArch32SystemAccessTrap(EL2, ThisInstr())
            }
        }
    }
}

val VMRS_Op_AS : forall 't,
  ('t >= 0 & 't <= 14 | not(not('t == 15))) & 't <= 14.
  (bits(4), int('t)) -> unit effect {escape, rreg, undef, wreg}

function VMRS_Op_AS (reg, t) = {
    if ConditionPassed() then {
        if reg == 0x1 then {
            CheckVFPEnabled(true);
            if t == 15 then {
                (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = FPSR[31 .. 31] @ (FPSR[30 .. 30] @ (FPSR[29 .. 29] @ FPSR[28 .. 28]))
            } else {
                R(t) = FPSCR
            }
        } else {
            if PSTATE.EL == EL0 then {
                throw(Error_Undefined())
            } else {
                CheckVFPEnabled(false);
                AArch32_CheckAdvSIMDOrFPRegisterTraps(reg);
                match reg {
                  0x0 => {
                      R(t) = FPSID
                  },
                  0x5 => {
                      R(t) = get_MVFR2()
                  },
                  0x6 => {
                      R(t) = get_MVFR1()
                  },
                  0x7 => {
                      R(t) = get_MVFR0()
                  },
                  0x8 => {
                      R(t) = get_FPEXC()
                  },
                  _ => {
                      Unreachable()
                  }
                }
            }
        }
    }
}

val VMRS_T1A1_AS_decode__0 : (bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

val VMRS_T1A1_AS_decode__1 : (bits(4), bits(4), bits(4)) -> unit effect {escape, rreg, undef, wreg}

overload VMRS_T1A1_AS_decode = {VMRS_T1A1_AS_decode__0, VMRS_T1A1_AS_decode__1}

function VMRS_T1A1_AS_decode__0 (reg, Rt) = {
    __unconditional = false;
    let t = UInt(Rt);
    assert(constraint('_t <= 14));
    assert(constraint(('_t >= 0 & '_t <= 14 | not(not('_t == 15)))));
    if ~((reg & 0xE) == 0x0 | reg == 0x5 | (reg & 0xE) == 0x6 | reg == 0x8) then {
        throw(Error_Unpredictable())
    };
    if t == 15 & reg != 0x1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMRS_Op_AS(reg, t)
}

function VMRS_T1A1_AS_decode__1 (cond, reg, Rt) = {
    __unconditional = false;
    if cond == 0xF then {
        throw(Error_See("cond=='1111'"))
    };
    let t = UInt(Rt);
    assert(constraint('_t <= 14));
    assert(constraint(('_t >= 0 & '_t <= 14 | not(not('_t == 15)))));
    if ~((reg & 0xE) == 0x0 | reg == 0x5 | (reg & 0xE) == 0x6 | reg == 0x8) then {
        throw(Error_Unpredictable())
    };
    if t == 15 & reg != 0x1 then {
        throw(Error_Unpredictable())
    };
    __PostDecode();
    VMRS_Op_AS(reg, t)
}

/**************************************************************************/
/* BSD 3-clause Clear License                                             */
/*                                                                        */
/* Copyright (c) 2019                                                     */
/*   Arm Limited (or its affiliates),                                     */
/*   Alasdair Armstrong,                                                  */
/*   Alastair Reid,                                                       */
/*   Thomas Bauereiss,                                                    */
/*   Peter Sewell,                                                        */
/*   Kathryn Gray,                                                        */
/*   Anthony Fox                                                          */
/*                                                                        */
/* All rights reserved.                                                   */
/*                                                                        */
/* Redistribution and use in source and binary forms, with or without     */
/* modification, are permitted (subject to the limitations in the         */
/* disclaimer below) provided that the following conditions are met:      */
/*                                                                        */
/* 	* Redistributions of source code must retain the above            */
/*        copyright notice, this list of conditions and the following     */
/* 	  disclaimer.                                                     */
/*      * Redistributions in binary form must reproduce the above         */
/*        copyright notice, this list of conditions and the following     */
/*        disclaimer in the documentation and/or other materials          */
/* 	  provided with the distribution.                                 */
/* 	* Neither the name of ARM Limited nor the names of its            */
/*        contributors may be used to endorse or promote products         */
/*        derived from this software without specific prior written       */
/*        permission.                                                     */
/*                                                                        */
/* NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE        */
/* GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT    */
/* HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED            */
/* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF   */
/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE               */
/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  */
/* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    */
/* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   */
/* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        */
/* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  */
/* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE   */
/* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN */
/* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                          */
/**************************************************************************/

enum boolean = {FALSE, TRUE}

enum signal = {LOW, HIGH}

enum __RetCode = {
  __RC_OK,
  __RC_UNDEFINED,
  __RC_UNPREDICTABLE,
  __RC_SEE,
  __RC_IMPLEMENTATION_DEFINED,
  __RC_EXCEPTION_TAKEN,
  __RC_ASSERT_FAILED,
  __RC_UNMATCHED_CASE
}

type TUBE_Type = bits(32)

type ScheduleIRQ_Type = bits(32)

type ClearIRQ_Type = bits(32)

type ScheduleFIQ_Type = bits(32)

type ClearFIQ_Type = bits(32)

type TargetCPU_Type = bits(32)

type AbortRgn64Lo1_Type = bits(32)

type AbortRgn64Lo1_Hi_Type = bits(32)

type AbortRgn64Hi1_Type = bits(32)

type AbortRgn64Hi1_Hi_Type = bits(32)

type AbortRgn64Lo2_Type = bits(32)

type AbortRgn64Lo2_Hi_Type = bits(32)

type AbortRgn64Hi2_Type = bits(32)

type AbortRgn64Hi2_Hi_Type = bits(32)

type AXIAbortCtl_Type = bits(32)

type GTE_API_Type = bits(32)

type GTE_API_PARAM_Type = bits(32)

type GTE_API_STATUS_Type = bits(32)

type PPURBAR_Type = bits(32)

type PPURSER_Type = bits(32)

type PPURACR_Type = bits(32)

type GTE_API_STATUS_64_Type = bits(32)

type GTE_API_STATUS_64_HI_Type = bits(32)

type GTE_API_PARAM_64_Type = bits(32)

type GTE_API_PARAM_64_HI_Type = bits(32)

type SCRType = bits(32)

type SCTLRType = bits(64)

type MAIRType = bits(64)

type ESRType = bits(32)

type FPCRType = bits(32)

type FPSRType = bits(32)

type FPSCRType = bits(32)

type CPSRType = bits(32)

type APSRType = bits(32)

type ITSTATEType = bits(8)

type CPACRType = bits(32)

type CNTKCTLType = bits(32)

enum GTEParamType = {GTEParam_WORD, GTEParam_LIST, GTEParam_EOACCESS}

type GTE_PPU_SizeEn_Type = bits(32)

type GTEExtObsAccess_Type = bits(16)

type GTEASAccess_Type = bits(32)

type GTEASRecordedAccess_Type = bits(32)

enum AccType = {
  AccType_NORMAL,
  AccType_VEC,
  AccType_STREAM,
  AccType_VECSTREAM,
  AccType_ATOMIC,
  AccType_ATOMICRW,
  AccType_ORDERED,
  AccType_ORDEREDRW,
  AccType_ORDEREDATOMIC,
  AccType_ORDEREDATOMICRW,
  AccType_LIMITEDORDERED,
  AccType_UNPRIV,
  AccType_IFETCH,
  AccType_PTW,
  AccType_NV2REGISTER,
  AccType_DC,
  AccType_DC_UNPRIV,
  AccType_IC,
  AccType_DCZVA,
  AccType_AT
}

enum MemType = {MemType_Normal, MemType_Device}

enum DeviceType = {
  DeviceType_GRE,
  DeviceType_nGRE,
  DeviceType_nGnRE,
  DeviceType_nGnRnE
}

struct MemAttrHints = {attrs : bits(2), hints : bits(2), transient : bool}

struct MemoryAttributes = {
  typ : MemType,
  device : DeviceType,
  inner : MemAttrHints,
  outer : MemAttrHints,
  tagged : bool,
  shareable : bool,
  outershareable : bool
}

struct FullAddress = {address : bits(52), NS : bits(1)}

enum Fault = {
  Fault_None,
  Fault_AccessFlag,
  Fault_Alignment,
  Fault_Background,
  Fault_Domain,
  Fault_Permission,
  Fault_Translation,
  Fault_AddressSize,
  Fault_SyncExternal,
  Fault_SyncExternalOnWalk,
  Fault_SyncParity,
  Fault_SyncParityOnWalk,
  Fault_AsyncParity,
  Fault_AsyncExternal,
  Fault_Debug,
  Fault_TLBConflict,
  Fault_BranchTarget,
  Fault_HWUpdateAccessFlag,
  Fault_Lockdown,
  Fault_Exclusive,
  Fault_ICacheMaint
}

struct FaultRecord = {
  typ : Fault,
  acctype : AccType,
  ipaddress : FullAddress,
  s2fs1walk : bool,
  write : bool,
  level : int,
  extflag : bits(1),
  secondstage : bool,
  domain : bits(4),
  errortype : bits(2),
  debugmoe : bits(4)
}

type PARTIDtype = bits(16)

type PMGtype = bits(8)

struct MPAMinfo = {mpam_ns : bits(1), partid : bits(16), pmg : bits(8)}

struct AddressDescriptor = {
  fault : FaultRecord,
  memattrs : MemoryAttributes,
  paddress : FullAddress,
  vaddress : bits(64)
}

struct AccessDescriptor = {
  acctype : AccType,
  mpam : MPAMinfo,
  page_table_walk : bool,
  secondstage : bool,
  s2fs1walk : bool,
  level : int
}

struct Permissions = {ap : bits(3), xn : bits(1), xxn : bits(1), pxn : bits(1)}

struct DescriptorUpdate = {AF : bool, AP : bool, descaddr : AddressDescriptor}

struct TLBRecord = {
  perms : Permissions,
  nG : bits(1),
  domain : bits(4),
  GP : bits(1),
  contiguous : bool,
  level : int,
  blocksize : int,
  descupdate : DescriptorUpdate,
  CnP : bits(1),
  addrdesc : AddressDescriptor
}

enum MBReqDomain = {
  MBReqDomain_Nonshareable,
  MBReqDomain_InnerShareable,
  MBReqDomain_OuterShareable,
  MBReqDomain_FullSystem
}

enum MBReqTypes = {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}

enum PrefetchHint = {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}

struct ProcState = {
  N : bits(1),
  Z : bits(1),
  C : bits(1),
  V : bits(1),
  D : bits(1),
  A : bits(1),
  I : bits(1),
  F : bits(1),
  PAN : bits(1),
  UAO : bits(1),
  DIT : bits(1),
  TCO : bits(1),
  BTYPE : bits(2),
  SS : bits(1),
  IL : bits(1),
  EL : bits(2),
  nRW : bits(1),
  SP : bits(1),
  Q : bits(1),
  GE : bits(4),
  SSBS : bits(1),
  IT : bits(8),
  J : bits(1),
  T : bits(1),
  E : bits(1),
  M : bits(5)
}

enum PrivilegeLevel = {PL3, PL2, PL1, PL0}

enum InstrSet = {InstrSet_A64, InstrSet_A32, InstrSet_T32}

enum ArchVersion = {ARMv8p0, ARMv8p1, ARMv8p2, ARMv8p3, ARMv8p4, ARMv8p5}

enum Unpredictable = {
  Unpredictable_WBOVERLAPLD,
  Unpredictable_WBOVERLAPST,
  Unpredictable_LDPOVERLAP,
  Unpredictable_BASEOVERLAP,
  Unpredictable_DATAOVERLAP,
  Unpredictable_DEVPAGE2,
  Unpredictable_INSTRDEVICE,
  Unpredictable_RESCPACR,
  Unpredictable_RESMAIR,
  Unpredictable_RESTEXCB,
  Unpredictable_RESPRRR,
  Unpredictable_RESDACR,
  Unpredictable_RESVTCRS,
  Unpredictable_RESTnSZ,
  Unpredictable_OORTnSZ,
  Unpredictable_LARGEIPA,
  Unpredictable_ESRCONDPASS,
  Unpredictable_ILZEROIT,
  Unpredictable_ILZEROT,
  Unpredictable_BPVECTORCATCHPRI,
  Unpredictable_VCMATCHHALF,
  Unpredictable_VCMATCHDAPA,
  Unpredictable_WPMASKANDBAS,
  Unpredictable_WPBASCONTIGUOUS,
  Unpredictable_RESWPMASK,
  Unpredictable_WPMASKEDBITS,
  Unpredictable_RESBPWPCTRL,
  Unpredictable_BPNOTIMPL,
  Unpredictable_RESBPTYPE,
  Unpredictable_BPNOTCTXCMP,
  Unpredictable_BPMATCHHALF,
  Unpredictable_BPMISMATCHHALF,
  Unpredictable_RESTARTALIGNPC,
  Unpredictable_RESTARTZEROUPPERPC,
  Unpredictable_ZEROUPPER,
  Unpredictable_ERETZEROUPPERPC,
  Unpredictable_A32FORCEALIGNPC,
  Unpredictable_SMD,
  Unpredictable_AFUPDATE,
  Unpredictable_IESBinDebug,
  Unpredictable_ZEROPMSEVFR,
  Unpredictable_NOOPTYPES,
  Unpredictable_ZEROMINLATENCY,
  Unpredictable_ZEROBTYPE,
  Unpredictable_CLEARERRITEZERO
}

enum Constraint = {
  Constraint_NONE,
  Constraint_UNKNOWN,
  Constraint_UNDEF,
  Constraint_UNDEFEL0,
  Constraint_NOP,
  Constraint_TRUE,
  Constraint_FALSE,
  Constraint_DISABLED,
  Constraint_UNCOND,
  Constraint_COND,
  Constraint_ADDITIONAL_DECODE,
  Constraint_WBSUPPRESS,
  Constraint_FAULT,
  Constraint_FORCE,
  Constraint_FORCENOSLCHECK
}

enum FPExc = {
  FPExc_InvalidOp,
  FPExc_DivideByZero,
  FPExc_Overflow,
  FPExc_Underflow,
  FPExc_Inexact,
  FPExc_InputDenorm
}

enum FPRounding = {
  FPRounding_TIEEVEN,
  FPRounding_POSINF,
  FPRounding_NEGINF,
  FPRounding_ZERO,
  FPRounding_TIEAWAY,
  FPRounding_ODD
}

enum FPType = {
  FPType_Nonzero,
  FPType_Zero,
  FPType_Infinity,
  FPType_QNaN,
  FPType_SNaN
}

enum BranchType = {
  BranchType_DIRCALL,
  BranchType_INDCALL,
  BranchType_ERET,
  BranchType_DBGEXIT,
  BranchType_RET,
  BranchType_DIR,
  BranchType_INDIR,
  BranchType_EXCEPTION,
  BranchType_RESET,
  BranchType_UNKNOWN
}

struct TLBContext = {
  twostage : bool,
  secondstage : bool,
  asid : bits(16),
  vmid : bits(16),
  el : bits(2),
  secure : bool,
  t_sz : bits(6),
  granule_size : int
}

struct TLBLine = {
  address : bits(64),
  context : TLBContext,
  data : TLBRecord,
  valid_name : bool
}

enum Exception = {
  Exception_Uncategorized,
  Exception_WFxTrap,
  Exception_CP15RTTrap,
  Exception_CP15RRTTrap,
  Exception_CP14RTTrap,
  Exception_CP14DTTrap,
  Exception_AdvSIMDFPAccessTrap,
  Exception_FPIDTrap,
  Exception_PACTrap,
  Exception_CP14RRTTrap,
  Exception_IllegalState,
  Exception_SupervisorCall,
  Exception_HypervisorCall,
  Exception_MonitorCall,
  Exception_SystemRegisterTrap,
  Exception_ERetTrap,
  Exception_InstructionAbort,
  Exception_PCAlignment,
  Exception_DataAbort,
  Exception_NV2DataAbort,
  Exception_SPAlignment,
  Exception_FPTrappedException,
  Exception_SError,
  Exception_Breakpoint,
  Exception_SoftwareStep,
  Exception_Watchpoint,
  Exception_SoftwareBreakpoint,
  Exception_VectorCatch,
  Exception_IRQ,
  Exception_BranchTarget,
  Exception_FIQ
}

struct ExceptionRecord = {
  typ : Exception,
  syndrome : bits(25),
  vaddress : bits(64),
  ipavalid : bool,
  NS : bits(1),
  ipaddress : bits(52)
}

enum SystemAccessType = {
  SystemAccessType_RT,
  SystemAccessType_RRT,
  SystemAccessType_DT
}

enum SysRegAccess = {
  SysRegAccess_OK,
  SysRegAccess_UNDEFINED,
  SysRegAccess_TrapToEL1,
  SysRegAccess_TrapToEL2,
  SysRegAccess_TrapToEL3
}

enum OpType = {
  OpType_Load,
  OpType_Store,
  OpType_LoadAtomic,
  OpType_Branch,
  OpType_Other
}

enum TimeStamp = {TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical}

enum CountOp = {CountOp_CLZ, CountOp_CLS, CountOp_CNT}

enum ExtendType = {
  ExtendType_SXTB,
  ExtendType_SXTH,
  ExtendType_SXTW,
  ExtendType_SXTX,
  ExtendType_UXTB,
  ExtendType_UXTH,
  ExtendType_UXTW,
  ExtendType_UXTX
}

enum FPMaxMinOp = {
  FPMaxMinOp_MAX,
  FPMaxMinOp_MIN,
  FPMaxMinOp_MAXNUM,
  FPMaxMinOp_MINNUM
}

enum FPUnaryOp = {FPUnaryOp_ABS, FPUnaryOp_MOV, FPUnaryOp_NEG, FPUnaryOp_SQRT}

enum FPConvOp = {
  FPConvOp_CVT_FtoI,
  FPConvOp_CVT_ItoF,
  FPConvOp_MOV_FtoI,
  FPConvOp_MOV_ItoF,
  FPConvOp_CVT_FtoI_JS
}

enum MoveWideOp = {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K}

enum ShiftType = {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}

enum LogicalOp = {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR}

enum MemOp = {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}

enum MemAtomicOp = {
  MemAtomicOp_ADD,
  MemAtomicOp_BIC,
  MemAtomicOp_EOR,
  MemAtomicOp_ORR,
  MemAtomicOp_SMAX,
  MemAtomicOp_SMIN,
  MemAtomicOp_UMAX,
  MemAtomicOp_UMIN,
  MemAtomicOp_SWP
}

enum MemBarrierOp = {
  MemBarrierOp_DSB,
  MemBarrierOp_DMB,
  MemBarrierOp_ISB,
  MemBarrierOp_SSBB,
  MemBarrierOp_PSSBB,
  MemBarrierOp_SB
}

enum SystemHintOp = {
  SystemHintOp_NOP,
  SystemHintOp_YIELD,
  SystemHintOp_WFE,
  SystemHintOp_WFI,
  SystemHintOp_SEV,
  SystemHintOp_SEVL,
  SystemHintOp_ESB,
  SystemHintOp_PSB,
  SystemHintOp_TSB,
  SystemHintOp_BTI,
  SystemHintOp_CSDB
}

enum PSTATEField = {
  PSTATEField_DAIFSet,
  PSTATEField_DAIFClr,
  PSTATEField_PAN,
  PSTATEField_UAO,
  PSTATEField_DIT,
  PSTATEField_SP
}

enum SystemOp = {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}

enum VBitOp = {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}

enum CompareOp = {
  CompareOp_GT,
  CompareOp_GE,
  CompareOp_EQ,
  CompareOp_LE,
  CompareOp_LT
}

enum ImmediateOp = {
  ImmediateOp_MOVI,
  ImmediateOp_MVNI,
  ImmediateOp_ORR,
  ImmediateOp_BIC
}

enum ReduceOp = {
  ReduceOp_FMINNUM,
  ReduceOp_FMAXNUM,
  ReduceOp_FMIN,
  ReduceOp_FMAX,
  ReduceOp_FADD,
  ReduceOp_ADD
}

enum SRType = {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}

struct AArch32_SErrorSyndrome = {AET : bits(2), ExT : bits(1)}

enum CrossTriggerOut = {
  CrossTriggerOut_DebugRequest,
  CrossTriggerOut_RestartRequest,
  CrossTriggerOut_IRQ,
  CrossTriggerOut_RSVD3,
  CrossTriggerOut_TraceExtIn0,
  CrossTriggerOut_TraceExtIn1,
  CrossTriggerOut_TraceExtIn2,
  CrossTriggerOut_TraceExtIn3
}

enum CrossTriggerIn = {
  CrossTriggerIn_CrossHalt,
  CrossTriggerIn_PMUOverflow,
  CrossTriggerIn_RSVD2,
  CrossTriggerIn_RSVD3,
  CrossTriggerIn_TraceExtOut0,
  CrossTriggerIn_TraceExtOut1,
  CrossTriggerIn_TraceExtOut2,
  CrossTriggerIn_TraceExtOut3
}

enum InterruptID = {
  InterruptID_PMUIRQ,
  InterruptID_COMMIRQ,
  InterruptID_CTIIRQ,
  InterruptID_COMMRX,
  InterruptID_COMMTX
}

struct PCSample = {
  valid_name : bool,
  pc : bits(64),
  el : bits(2),
  rw : bits(1),
  ns : bits(1),
  has_el2 : bool,
  contextidr : bits(32),
  contextidr_el2 : bits(32),
  el0h : bool,
  vmid : bits(16)
}

enum VCGEtype = {VCGEtype_signed, VCGEtype_unsigned, VCGEtype_fp}

enum VCGTtype = {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp}

enum VFPNegMul = {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL}

struct InterruptReq = {
  take_SE : bool,
  take_vSE : bool,
  take_IRQ : bool,
  take_vIRQ : bool,
  take_FIQ : bool,
  take_vFIQ : bool,
  iesb_req : bool
}

enum AsyncErrorType = {
  AsyncErrorType_UC,
  AsyncErrorType_UEU,
  AsyncErrorType_UEO,
  AsyncErrorType_UER,
  AsyncErrorType_CE
}

val TakePendingInterrupts : InterruptReq -> bool effect {undef, escape, rreg, wreg}

val AArch64_TranslationTableWalk : forall ('size : Int).
  (bits(52), bits(1), bits(64), AccType, bool, bool, bool, int('size)) -> TLBRecord effect {escape, undef, rmem, rreg, wreg, wmem}

val IsZero_slice : forall ('n : Int), 'n >= 0.
  (bits('n), int, int) -> bool effect {escape}

val IsOnes_slice : forall ('n : Int), 'n >= 0.
  (bits('n), int, int) -> bool effect {escape}

val ZeroExtend_slice_append : forall 'n 'm 'o,
  ('n >= 0 & 'o >= 0).
  (bits('n), int, int, bits('m)) -> bits('o) effect {escape}

val AArch64_CheckAndUpdateDescriptor : (DescriptorUpdate, FaultRecord, bool, bits(64), AccType, bool, bool, bool) -> FaultRecord effect {undef, escape, rmem, rreg, wmem, wreg}

val AArch32_TranslationTableWalk : forall ('size : Int).
  (bits(40), bits(32), AccType, bool, bool, bool, int('size)) -> TLBRecord effect {escape, rmem, rreg, undef, wmem, wreg}

val println : unit -> unit

function println () = {
    prerr("\n")
}

register __unconditional : bool

register __saved_exception_level : bits(2)

register __highest_el_aarch32 : bool

register configuration __exclusive_granule_size : bits(4) = 0x4

register __exclusive_block_address : bits(52)

register __defaultRAM : bits(56)

register __currentInstrLength : int

register __currentInstr : bits(32)

register __currentCond : bits(4)

register configuration __crypto_aes_implemented : int = 2

register configuration __block_bbm_implemented : int = 2

val __UNKNOWN_string : unit -> string

function __UNKNOWN_string () = {
    "UNKNOWN"
}

val __UNKNOWN_real : unit -> real

function __UNKNOWN_real () = {
    0.0
}

val __UNKNOWN_integer : unit -> int

function __UNKNOWN_integer () = {
    0
}

register __PC_changed : bool

register __LSISyndrome : bits(11)

val __IMPDEF_MemType : string -> MemType effect {escape}

function __IMPDEF_MemType x = {
    throw(Error_Implementation_Defined(""))
}

val __IMPDEF_DeviceType : string -> DeviceType effect {escape}

function __IMPDEF_DeviceType x = {
    throw(Error_Implementation_Defined(""))
}

register configuration semihost_clock : bits(64) = __GetSlice_int(64, 0, 0)

register configuration __trickbox_mask_v8 : bits(52) = __GetSlice_int(52, 4503599627304960, 0)

register configuration __trickbox_base_v8 : bits(52) = __GetSlice_int(52, 318767104, 0)

register configuration __CNTControlMask : bits(52) = __GetSlice_int(52, 4503599627366400, 0)

register __CNTControlBase : bits(52)

register _V : vector(32, dec, bits(128))

register _TargetCPU : bits(32)

register _TLB : vector(1024, dec, TLBLine)

register _ScheduleIRQ : bits(32)

register _ScheduleFIQ : bits(32)

register _R : vector(31, dec, bits(64))

register _PendingPhysicalSE : bool

register _PPURSER : bits(32)

register _PPURBAR : bits(64)

register _PPURACR : bits(32)

register _PC : bits(64)

val aget_PC : unit -> bits(64) effect {rreg}

function aget_PC () = {
    _PC
}

overload PC = {aget_PC}

register _IRQPending : bool

register _GTE_AS_Size : bits(64)

register _GTE_AS_Address : bits(64)

register _GTE_AS_AccessCount : int

register _GTE_AS_Access : bits(32)

register _GTEStatus : bits(64)

register _GTEParamsComplete : bool

register _GTEParamType : GTEParamType

register _GTEParamLo : bits(32)

val set_GTE_API_PARAM_64 : bits(32) -> unit effect {wreg}

function set_GTE_API_PARAM_64 val_name = {
    _GTEParamLo = slice(val_name, 0, 32);
    return()
}

register _GTEParamCount : int

register _GTEListParamTerminators : int

register _GTEListParamTerminatorCount : int

register _GTEListParamTerminator : bits(64)

register _GTEListParamIndex : int

register _GTEListParam : int

register _GTEHaveParamLo : bool

register _GTECurrentAPI : bits(32)

register _GTEActive : bool

register _FIQPending : bool

register _ClearIRQ : bits(32)

val get_ClearIRQ : unit -> bits(32) effect {rreg}

function get_ClearIRQ () = {
    slice(_ClearIRQ, 0, 32)
}

register _ClearFIQ : bits(32)

val get_ClearFIQ : unit -> bits(32) effect {rreg}

function get_ClearFIQ () = {
    slice(_ClearFIQ, 0, 32)
}

register _AXIAbortCtl : bits(32)

register VTTBR_EL2 : bits(64)

val set_VTTBR : bits(64) -> unit effect {rreg, wreg}

function set_VTTBR val_name = {
    let r : bits(64) = val_name;
    VTTBR_EL2 = __SetSlice_bits(64, 64, VTTBR_EL2, 0, slice(r, 0, 64));
    return()
}

val get_VTTBR : unit -> bits(64) effect {rreg, undef}

function get_VTTBR () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(VTTBR_EL2, 0, 64));
    r
}

register VTCR_EL2 : bits(32)

val set_VTCR : bits(32) -> unit effect {rreg, wreg}

function set_VTCR val_name = {
    let r : bits(32) = val_name;
    VTCR_EL2 = __SetSlice_bits(32, 32, VTCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_VTCR : unit -> bits(32) effect {rreg, undef}

function get_VTCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(VTCR_EL2, 0, 32));
    r
}

register VSTTBR_EL2 : bits(64)

register VSTCR_EL2 : bits(32)

register VSESR_EL2 : bits(64)

val get_VDFSR : unit -> bits(32) effect {rreg}

function get_VDFSR () = {
    slice(VSESR_EL2, 0, 32)
}

register VPIDR_EL2 : bits(32)

register VNCR_EL2 : bits(64)

register VMPIDR_EL2 : bits(64)

val set_VMPIDR : bits(32) -> unit effect {rreg, wreg}

function set_VMPIDR val_name = {
    let r : bits(32) = val_name;
    VMPIDR_EL2 = __SetSlice_bits(64, 32, VMPIDR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_VMPIDR : unit -> bits(32) effect {rreg, undef}

function get_VMPIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(VMPIDR_EL2, 0, 32));
    r
}

register VDISR_EL2 : bits(64)

val set_VDISR : bits(32) -> unit effect {rreg, wreg}

function set_VDISR val_name = {
    VDISR_EL2 = __SetSlice_bits(64, 32, VDISR_EL2, 0, val_name)
}

val __UNKNOWN_VBitOp : unit -> VBitOp

function __UNKNOWN_VBitOp () = {
    VBitOp_VBIF
}

register VBAR_S : bits(32)

register VBAR_EL3 : bits(64)

register VBAR_EL2 : bits(64)

val set_HVBAR : bits(32) -> unit effect {rreg, wreg}

function set_HVBAR val_name = {
    let r : bits(32) = val_name;
    VBAR_EL2 = __SetSlice_bits(64, 32, VBAR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HVBAR : unit -> bits(32) effect {rreg, undef}

function get_HVBAR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(VBAR_EL2, 0, 32));
    r
}

register VBAR_EL1 : bits(64)

val set_VBAR_NS : bits(32) -> unit effect {rreg, wreg}

function set_VBAR_NS val_name = {
    let r : bits(32) = val_name;
    VBAR_EL1 = __SetSlice_bits(64, 32, VBAR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_VBAR_NS : unit -> bits(32) effect {rreg, undef}

function get_VBAR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(VBAR_EL1, 0, 32));
    r
}

register VBAR_EL0 : bits(64)

let VAL_SET_PPU_REGION : vector(32, dec, bit) = __GetSlice_int(32, 10, 0)

let VAL_SET_CRITICAL_EVENT : vector(32, dec, bit) = __GetSlice_int(32, 17, 0)

let VAL_SETUP_EXT_OBS_64 : vector(32, dec, bit) = __GetSlice_int(32, 25, 0)

let VAL_SETUP_EXT_OBS : vector(32, dec, bit) = __GetSlice_int(32, 13, 0)

let VAL_RETURN_OBS_DATA_64 : vector(32, dec, bit) = __GetSlice_int(32, 28, 0)

let VAL_RELEASE_EXT_OBS : vector(32, dec, bit) = __GetSlice_int(32, 16, 0)

let VAL_RANDNUM : vector(32, dec, bit) = __GetSlice_int(32, 20, 0)

let VAL_PPU_CONTROL : vector(32, dec, bit) = __GetSlice_int(32, 12, 0)

let VAL_PERFORM_EXT_OBS_64 : vector(32, dec, bit) = __GetSlice_int(32, 27, 0)

let VAL_PERFORM_EXT_OBS : vector(32, dec, bit) = __GetSlice_int(32, 15, 0)

let VAL_OBSERVER_PIN_VALUE : vector(32, dec, bit) = __GetSlice_int(32, 22, 0)

let VAL_GET_PPU_REGION : vector(32, dec, bit) = __GetSlice_int(32, 11, 0)

let VAL_GET_PPU_ID : vector(32, dec, bit) = __GetSlice_int(32, 9, 0)

let VAL_EVENTGEN_SETUP : vector(32, dec, bit) = __GetSlice_int(32, 1, 0)

let VAL_EVENTGEN_QUERY : vector(32, dec, bit) = __GetSlice_int(32, 4, 0)

let VAL_EVENTGEN_PRIME : vector(32, dec, bit) = __GetSlice_int(32, 2, 0)

let VAL_EVENTGEN_FREE : vector(32, dec, bit) = __GetSlice_int(32, 6, 0)

let VAL_EVENTGEN_DISABLE : vector(32, dec, bit) = __GetSlice_int(32, 5, 0)

let VAL_EVENTGEN_CLEAR : vector(32, dec, bit) = __GetSlice_int(32, 3, 0)

let VAL_EN_ACCESS_SENSITIVE_BEH : vector(32, dec, bit) = __GetSlice_int(32, 23, 0)

let VAL_ENABLE_EXT_OBS_64 : vector(32, dec, bit) = __GetSlice_int(32, 26, 0)

let VAL_ENABLE_EXT_OBS : vector(32, dec, bit) = __GetSlice_int(32, 14, 0)

let VAL_DEFINE_NO_ABORTING_REGIONS : vector(32, dec, bit) = __GetSlice_int(32, 21, 0)

let VAL_DEASSERT : vector(32, dec, bit) = __GetSlice_int(32, 8, 0)

let VAL_CRITICAL_SECTION_START : vector(32, dec, bit) = __GetSlice_int(32, 18, 0)

let VAL_CRITICAL_SECTION_END : vector(32, dec, bit) = __GetSlice_int(32, 19, 0)

let VAL_CHK_ACCESS_SENSITIVE_BEH : vector(32, dec, bit) = __GetSlice_int(32, 24, 0)

let VAL_ASSERT : vector(32, dec, bit) = __GetSlice_int(32, 7, 0)

val TraceSynchronizationBarrier : unit -> unit effect {escape}

function TraceSynchronizationBarrier () = {
    throw(Error_Implementation_Defined("TraceSynchronizationBarrier unimplemented"))
}

val ThisInstr : unit -> bits(32) effect {rreg}

function ThisInstr () = {
    __currentInstr
}

register TTBR1_S : bits(64)

register TTBR1_EL2 : bits(64)

register TTBR1_EL1 : bits(64)

val set_TTBR1_NS : bits(64) -> unit effect {rreg, wreg}

function set_TTBR1_NS val_name = {
    let r : bits(64) = val_name;
    TTBR1_EL1 = __SetSlice_bits(64, 64, TTBR1_EL1, 0, slice(r, 0, 64));
    return()
}

val get_TTBR1_NS : unit -> bits(64) effect {rreg, undef}

function get_TTBR1_NS () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(TTBR1_EL1, 0, 64));
    r
}

register TTBR0_S : bits(64)

register TTBR0_EL3 : bits(64)

register TTBR0_EL2 : bits(64)

val set_HTTBR : bits(64) -> unit effect {rreg, wreg}

function set_HTTBR val_name = {
    let r : bits(64) = val_name;
    TTBR0_EL2 = __SetSlice_bits(64, 64, TTBR0_EL2, 0, slice(r, 0, 64));
    return()
}

val get_HTTBR : unit -> bits(64) effect {rreg, undef}

function get_HTTBR () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(TTBR0_EL2, 0, 64));
    r
}

register TTBR0_EL1 : bits(64)

val set_TTBR0_NS : bits(64) -> unit effect {rreg, wreg}

function set_TTBR0_NS val_name = {
    let r : bits(64) = val_name;
    TTBR0_EL1 = __SetSlice_bits(64, 64, TTBR0_EL1, 0, slice(r, 0, 64));
    return()
}

val get_TTBR0_NS : unit -> bits(64) effect {rreg, undef}

function get_TTBR0_NS () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(TTBR0_EL1, 0, 64));
    r
}

register TTBCR_S : bits(32)

register TTBCR2_S : bits(32)

register configuration __vmid16_implemented : bool = true

register configuration __v85_implemented : bool = true

register configuration __v84_implemented : bool = true

register configuration __v83_implemented : bool = true

register configuration __v82_implemented : bool = true

register configuration __v81_implemented : bool = true

val __ConfigureV81Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV81Features enabled = {
    __v81_implemented = enabled
}

val __ConfigureV82Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV82Features enabled = {
    __v82_implemented = enabled;
    if enabled then {
        __ConfigureV81Features(enabled)
    }
}

val __ConfigureV83Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV83Features enabled = {
    __v83_implemented = enabled;
    if enabled then {
        __ConfigureV82Features(enabled)
    }
}

val __ConfigureV84Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV84Features enabled = {
    __v84_implemented = enabled;
    if enabled then {
        __ConfigureV83Features(enabled)
    }
}

val __ConfigureV85Features : forall ('enabled : Bool).
  bool('enabled) -> unit effect {configuration}

function __ConfigureV85Features enabled = {
    __v85_implemented = enabled;
    if enabled then {
        __ConfigureV84Features(enabled)
    }
}

register configuration __unpred_tsize_aborts : bool = true

register configuration __trickbox_enabled : bool = true

register configuration __tlb_enabled : bool = true

register configuration __syncAbortOnTTWNonCache : bool = true

register configuration __syncAbortOnTTWCache : bool = true

register configuration __syncAbortOnSoWrite : bool = true

register configuration __syncAbortOnSoRead : bool = true

register configuration __syncAbortOnReadNormNonCache : bool = true

register configuration __syncAbortOnReadNormCache : bool = true

register configuration __syncAbortOnPrefetch : bool = true

register configuration __syncAbortOnDeviceRead : bool = true

register configuration __support_52bit_pa : bool = true

register configuration __pan_implemented : bool = true

register configuration __mte_implemented : bool = true

register configuration __mpam_has_hcr : bool = true

register configuration __fp16_implemented : bool = true

register configuration __dot_product_implemented : bool = true

register configuration __crypto_sha256_implemented : bool = true

register configuration __crypto_sha1_implemented : bool = true

register configuration __crc32_implemented : bool = true

register configuration __aa32_hpd_implemented : bool = true

register TRFCR_EL2 : bits(32)

val set_HTRFCR : bits(32) -> unit effect {rreg, wreg}

function set_HTRFCR val_name = {
    let r : bits(32) = val_name;
    TRFCR_EL2 = __SetSlice_bits(32, 32, TRFCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HTRFCR : unit -> bits(32) effect {rreg, undef}

function get_HTRFCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TRFCR_EL2, 0, 32));
    r
}

register TRFCR_EL1 : bits(32)

val set_TRFCR : bits(32) -> unit effect {rreg, wreg}

function set_TRFCR val_name = {
    let r : bits(32) = val_name;
    TRFCR_EL1 = __SetSlice_bits(32, 32, TRFCR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_TRFCR : unit -> bits(32) effect {rreg, undef}

function get_TRFCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TRFCR_EL1, 0, 32));
    r
}

register TPIDR_EL3 : bits(64)

register TPIDR_EL2 : bits(64)

register TPIDR_EL1 : bits(64)

register TPIDR_EL0 : bits(64)

register TPIDRRO_EL0 : bits(64)

register TLBTR : bits(32)

register TLBMisses : int

val TLBI_RVALE3OS : bits(64) -> unit

function TLBI_RVALE3OS val_name = ()

register TLBHits : int

register TFSR_EL3 : bits(32)

register TFSR_EL2 : bits(32)

register TFSR_EL1 : bits(32)

register TFSRE0_EL1 : bits(32)

register TCR_EL3 : bits(32)

register TCR_EL1 : bits(64)

val set_TTBCR_NS : bits(32) -> unit effect {rreg, wreg}

function set_TTBCR_NS val_name = {
    let r : bits(32) = val_name;
    TCR_EL1 = __SetSlice_bits(64, 32, TCR_EL1, 0, slice(r, 0, 32));
    return()
}

val set_TTBCR2_NS : bits(32) -> unit effect {rreg, wreg}

function set_TTBCR2_NS val_name = {
    let r : bits(32) = val_name;
    TCR_EL1 = __SetSlice_bits(64, 32, TCR_EL1, 32, slice(r, 0, 32));
    return()
}

val get_TTBCR_NS : unit -> bits(32) effect {rreg, undef}

function get_TTBCR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TCR_EL1, 0, 32));
    r
}

val get_TTBCR2_NS : unit -> bits(32) effect {rreg, undef}

function get_TTBCR2_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TCR_EL1, 32, 32));
    r
}

register configuration TAG_STORE_AREA : bits(56) = __GetSlice_int(56, 4503599627370496, 0)

val __UNKNOWN_SystemHintOp : unit -> SystemHintOp

function __UNKNOWN_SystemHintOp () = {
    SystemHintOp_NOP
}

val SynchronizeErrors : unit -> unit

function SynchronizeErrors () = {
    return()
}

val SynchronizeContext : unit -> unit

function SynchronizeContext () = {
    return()
}

val StopInstructionPrefetchAndEnableITR : unit -> unit effect {escape}

function StopInstructionPrefetchAndEnableITR () = {
    throw(Error_Implementation_Defined("StopInstructionPrefetchAndEnableITR unimplemented"))
}

val SpeculativeSynchronizationBarrierToVA : unit -> unit

function SpeculativeSynchronizationBarrierToVA () = {
    return()
}

val SpeculativeSynchronizationBarrierToPA : unit -> unit

function SpeculativeSynchronizationBarrierToPA () = {
    return()
}

val SpeculationBarrier : unit -> unit

function SpeculationBarrier () = {
    return()
}

val SoftwareStep_SteppedEX : unit -> bool effect {escape}

function SoftwareStep_SteppedEX () = {
    throw(Error_Implementation_Defined("SoftwareStep_SteppedEX unimplemented"))
}

val SoftwareStep_DidNotStep : unit -> bool effect {escape}

function SoftwareStep_DidNotStep () = {
    throw(Error_Implementation_Defined("SoftwareStep_DidNotStep unimplemented"))
}

register ShouldAdvanceIT : bool

val SetPendingPhysicalSE : forall ('val : Bool).
  bool('val) -> unit effect {wreg}

function SetPendingPhysicalSE val_name = {
    _PendingPhysicalSE = val_name
}

register ScheduledIRQ : bool

val set_ScheduleIRQ : bits(32) -> unit effect {wreg}

function set_ScheduleIRQ val_name = {
    _ScheduleIRQ = val_name;
    ScheduledIRQ = true;
    return()
}

register ScheduledFIQ : bool

val set_ScheduleFIQ : bits(32) -> unit effect {wreg}

function set_ScheduleFIQ val_name = {
    _ScheduleFIQ = val_name;
    ScheduledFIQ = true;
    return()
}

let STDOUT_HANDLE : int(2) = 2

let STDIN_HANDLE : int(1) = 1

let STDERR_HANDLE : int(3) = 3

let STACK_LIMIT : vector(64, dec, bit) = __GetSlice_int(64, 251658240, 0)

let STACK_BASE : vector(64, dec, bit) = __GetSlice_int(64, 268435456, 0)

register SP_mon : bits(32)

register SP_EL3 : bits(64)

register SP_EL2 : bits(64)

register SP_EL1 : bits(64)

register SP_EL0 : bits(64)

register SPSR_und : bits(32)

register SPSR_irq : bits(32)

register SPSR_fiq : bits(32)

register SPSR_abt : bits(32)

register SPSR_EL3 : bits(32)

val set_SPSR_mon : bits(32) -> unit effect {rreg, wreg}

function set_SPSR_mon val_name = {
    let r : bits(32) = val_name;
    SPSR_EL3 = __SetSlice_bits(32, 32, SPSR_EL3, 0, slice(r, 0, 32));
    return()
}

val get_SPSR_mon : unit -> bits(32) effect {rreg, undef}

function get_SPSR_mon () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SPSR_EL3, 0, 32));
    r
}

register SPSR_EL2 : bits(32)

val set_SPSR_hyp : bits(32) -> unit effect {rreg, wreg}

function set_SPSR_hyp val_name = {
    let r : bits(32) = val_name;
    SPSR_EL2 = __SetSlice_bits(32, 32, SPSR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_SPSR_hyp : unit -> bits(32) effect {rreg, undef}

function get_SPSR_hyp () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SPSR_EL2, 0, 32));
    r
}

register SPSR_EL1 : bits(32)

val set_SPSR_svc : bits(32) -> unit effect {rreg, wreg}

function set_SPSR_svc val_name = {
    let r : bits(32) = val_name;
    SPSR_EL1 = __SetSlice_bits(32, 32, SPSR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_SPSR_svc : unit -> bits(32) effect {rreg, undef}

function get_SPSR_svc () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SPSR_EL1, 0, 32));
    r
}

register SPSR_EL0 : bits(32)

register SPIDEN : signal

register SDER32_EL3 : bits(32)

val set_SDER : bits(32) -> unit effect {rreg, wreg}

function set_SDER val_name = {
    let r : bits(32) = val_name;
    SDER32_EL3 = __SetSlice_bits(32, 32, SDER32_EL3, 0, slice(r, 0, 32));
    return()
}

val get_SDER : unit -> bits(32) effect {rreg, undef}

function get_SDER () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SDER32_EL3, 0, 32));
    r
}

register SDER32_EL2 : bits(32)

register SCXTNUM_EL3 : bits(64)

register SCXTNUM_EL2 : bits(64)

register SCXTNUM_EL1 : bits(64)

register SCXTNUM_EL0 : bits(64)

register SCTLR_S : bits(32)

register SCTLR_EL3 : bits(64)

register SCTLR_EL2 : bits(64)

val set_HSCTLR : bits(32) -> unit effect {rreg, wreg}

function set_HSCTLR val_name = {
    let r : bits(32) = val_name;
    SCTLR_EL2 = __SetSlice_bits(64, 32, SCTLR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HSCTLR : unit -> bits(32) effect {rreg, undef}

function get_HSCTLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SCTLR_EL2, 0, 32));
    r
}

register SCTLR_EL1 : bits(64)

val set_SCTLR_NS : bits(32) -> unit effect {rreg, wreg}

function set_SCTLR_NS val_name = {
    let r : bits(32) = val_name;
    SCTLR_EL1 = __SetSlice_bits(64, 32, SCTLR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_SCTLR_NS : unit -> bits(32) effect {rreg, undef}

function get_SCTLR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SCTLR_EL1, 0, 32));
    r
}

register SCR_EL3 : bits(32)

val set_SCR : bits(32) -> unit effect {rreg, wreg}

function set_SCR val_name = {
    let r : bits(32) = val_name;
    SCR_EL3 = __SetSlice_bits(32, 32, SCR_EL3, 0, slice(r, 0, 32));
    return()
}

val get_SCR : unit -> bits(32) effect {rreg, undef}

function get_SCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SCR_EL3, 0, 32));
    r
}

val ResetExternalDebugRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit

function ResetExternalDebugRegisters cold_reset = {
    return()
}

val RemapRegsHaveResetValues : unit -> bool

function RemapRegsHaveResetValues () = {
    true
}

register RVBAR_EL3 : bits(64)

register RVBAR_EL2 : bits(64)

register RVBAR_EL1 : bits(64)

register RVBAR : bits(32)

register RNDRRS : bits(64)

register RNDR : bits(64)

register RMUID_EL0 : bits(32)

register RMR_EL3 : bits(32)

register RMR_EL2 : bits(32)

val set_HRMR : bits(32) -> unit effect {rreg, wreg}

function set_HRMR val_name = {
    let r : bits(32) = val_name;
    RMR_EL2 = __SetSlice_bits(32, 32, RMR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HRMR : unit -> bits(32) effect {rreg, undef}

function get_HRMR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(RMR_EL2, 0, 32));
    r
}

register RMR_EL1 : bits(32)

val set_RMR : bits(32) -> unit effect {rreg, wreg}

function set_RMR val_name = {
    let r : bits(32) = val_name;
    RMR_EL1 = __SetSlice_bits(32, 32, RMR_EL1, 0, slice(r, 0, 32));
    RMR_EL3 = __SetSlice_bits(32, 32, RMR_EL3, 0, slice(r, 0, 32));
    return()
}

val get_RMR : unit -> bits(32) effect {rreg, undef}

function get_RMR () = {
    r : bits(32) = undefined : bits(32);
    r = __SetSlice_bits(32, 32, r, 0, slice(RMR_EL1, 0, 32));
    let r = __SetSlice_bits(32, 32, r, 0, slice(RMR_EL3, 0, 32));
    r
}

register RGSR_EL1 : bits(32)

register REVIDR_EL1 : bits(32)

register RD_EL0 : bits(64)

register RC : vector(5, dec, bits(64))

val ProfilingSynchronizationBarrier : unit -> unit effect {escape}

function ProfilingSynchronizationBarrier () = {
    throw(Error_Implementation_Defined("ProfilingSynchronizationBarrier unimplemented"))
}

val __UNKNOWN_PrefetchHint : unit -> PrefetchHint

function __UNKNOWN_PrefetchHint () = {
    Prefetch_READ
}

val __UNKNOWN_PSTATEField : unit -> PSTATEField

function __UNKNOWN_PSTATEField () = {
    PSTATEField_DAIFSet
}

register PSTATE : ProcState

val set_UAO : bits(32) -> unit effect {rreg, wreg}

function set_UAO val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.UAO;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[23]]);
    PSTATE.UAO = __tc1;
    return()
}

val set_TCO : bits(32) -> unit effect {rreg, wreg}

function set_TCO val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.TCO;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[25]]);
    PSTATE.TCO = __tc1;
    return()
}

val set_SSBS : bits(32) -> unit effect {rreg, wreg}

function set_SSBS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.SSBS;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[12]]);
    PSTATE.SSBS = __tc1;
    return()
}

val set_SPSel : bits(32) -> unit effect {rreg, wreg}

function set_SPSel val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.SP;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[0]]);
    PSTATE.SP = __tc1;
    return()
}

val set_PAN : bits(32) -> unit effect {rreg, wreg}

function set_PAN val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.PAN;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[22]]);
    PSTATE.PAN = __tc1;
    return()
}

val set_NZCV : bits(32) -> unit effect {rreg, wreg}

function set_NZCV val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.C;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[29]]);
    PSTATE.C = __tc1;
    __tc2 : bits(1) = PSTATE.V;
    let __tc2 = __SetSlice_bits(1, 1, __tc2, 0, [r[28]]);
    PSTATE.V = __tc2;
    __tc3 : bits(1) = PSTATE.N;
    let __tc3 = __SetSlice_bits(1, 1, __tc3, 0, [r[31]]);
    PSTATE.N = __tc3;
    __tc4 : bits(1) = PSTATE.Z;
    let __tc4 = __SetSlice_bits(1, 1, __tc4, 0, [r[30]]);
    PSTATE.Z = __tc4;
    return()
}

val set_DIT : bits(32) -> unit effect {rreg, wreg}

function set_DIT val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.DIT;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[24]]);
    PSTATE.DIT = __tc1;
    return()
}

val set_DAIF : bits(32) -> unit effect {rreg, wreg}

function set_DAIF val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.I;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[7]]);
    PSTATE.I = __tc1;
    __tc2 : bits(1) = PSTATE.D;
    let __tc2 = __SetSlice_bits(1, 1, __tc2, 0, [r[9]]);
    PSTATE.D = __tc2;
    __tc3 : bits(1) = PSTATE.F;
    let __tc3 = __SetSlice_bits(1, 1, __tc3, 0, [r[6]]);
    PSTATE.F = __tc3;
    __tc4 : bits(1) = PSTATE.A;
    let __tc4 = __SetSlice_bits(1, 1, __tc4, 0, [r[8]]);
    PSTATE.A = __tc4;
    return()
}

val get_UAO : unit -> bits(32) effect {rreg, undef}

function get_UAO () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 23, [PSTATE.UAO[0]]);
    r
}

val get_TCO : unit -> bits(32) effect {rreg, undef}

function get_TCO () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 25, [PSTATE.TCO[0]]);
    r
}

val get_SSBS : unit -> bits(32) effect {rreg, undef}

function get_SSBS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 12, [PSTATE.SSBS[0]]);
    r
}

val get_SPSel : unit -> bits(32) effect {rreg, undef}

function get_SPSel () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 0, [PSTATE.SP[0]]);
    r
}

val get_PAN : unit -> bits(32) effect {rreg, undef}

function get_PAN () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 22, [PSTATE.PAN[0]]);
    r
}

val get_NZCV : unit -> bits(32) effect {rreg, undef}

function get_NZCV () = {
    r : bits(32) = undefined : bits(32);
    r = __SetSlice_bits(32, 1, r, 29, [PSTATE.C[0]]);
    r = __SetSlice_bits(32, 1, r, 28, [PSTATE.V[0]]);
    r = __SetSlice_bits(32, 1, r, 31, [PSTATE.N[0]]);
    let r = __SetSlice_bits(32, 1, r, 30, [PSTATE.Z[0]]);
    r
}

val get_DIT : unit -> bits(32) effect {rreg, undef}

function get_DIT () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 24, [PSTATE.DIT[0]]);
    r
}

val get_DAIF : unit -> bits(32) effect {rreg, undef}

function get_DAIF () = {
    r : bits(32) = undefined : bits(32);
    r = __SetSlice_bits(32, 1, r, 7, [PSTATE.I[0]]);
    r = __SetSlice_bits(32, 1, r, 9, [PSTATE.D[0]]);
    r = __SetSlice_bits(32, 1, r, 6, [PSTATE.F[0]]);
    let r = __SetSlice_bits(32, 1, r, 8, [PSTATE.A[0]]);
    r
}

val get_CurrentEL : unit -> bits(32) effect {rreg, undef}

function get_CurrentEL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 2, r, 2, slice(PSTATE.EL, 0, 2));
    r
}

val __SAVE_EL : bits(2) -> unit effect {rreg, wreg}

function __SAVE_EL __new_exception_level = {
    __saved_exception_level = PSTATE.EL;
    PSTATE.EL = __new_exception_level
}

val __RESTORE_EL : unit -> unit effect {rreg, wreg}

function __RESTORE_EL () = {
    PSTATE.EL = __saved_exception_level
}

register PRRR_S : bits(32)

register PMXEVTYPER_EL0 : bits(32)

register PMXEVCNTR_EL0 : bits(32)

register PMVIDSR : bits(32)

register PMUSERENR_EL0 : bits(32)

val set_PMUSERENR : bits(32) -> unit effect {rreg, wreg}

function set_PMUSERENR val_name = {
    let r : bits(32) = val_name;
    PMUSERENR_EL0 = __SetSlice_bits(32, 32, PMUSERENR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMUSERENR : unit -> bits(32) effect {rreg, undef}

function get_PMUSERENR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMUSERENR_EL0, 0, 32));
    r
}

register PMSWINC_EL0 : bits(32)

val set_PMSWINC : bits(32) -> unit effect {rreg, wreg}

function set_PMSWINC val_name = {
    let r : bits(32) = val_name;
    PMSWINC_EL0 = __SetSlice_bits(32, 32, PMSWINC_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMSWINC : unit -> bits(32) effect {rreg, undef}

function get_PMSWINC () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMSWINC_EL0, 0, 32));
    r
}

register PMSELR_EL0 : bits(32)

val set_PMSELR : bits(32) -> unit effect {rreg, wreg}

function set_PMSELR val_name = {
    let r : bits(32) = val_name;
    PMSELR_EL0 = __SetSlice_bits(32, 32, PMSELR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMSELR : unit -> bits(32) effect {rreg, undef}

function get_PMSELR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMSELR_EL0, 0, 32));
    r
}

register PMPCSR : bits(64)

register PMOVSSET_EL0 : bits(32)

register PMOVSCLR_EL0 : bits(32)

register PMMIR_EL1 : bits(32)

register PMMIR : bits(32)

register PMLSR : bits(32)

register PMINTENSET_EL1 : bits(32)

register PMINTENCLR_EL1 : bits(32)

register PMEVTYPER_EL0 : vector(33, dec, bits(32))

register PMEVCNTR_EL0 : vector(33, dec, bits(32))

register PMCR_EL0 : bits(32)

val set_PMCR : bits(32) -> unit effect {rreg, wreg}

function set_PMCR val_name = {
    let r : bits(32) = val_name;
    PMCR_EL0 = __SetSlice_bits(32, 32, PMCR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMCR : unit -> bits(32) effect {rreg, undef}

function get_PMCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCR_EL0, 0, 32));
    r
}

register PMCNTENSET_EL0 : bits(32)

register PMCNTENCLR_EL0 : bits(32)

register PMCEID1_EL0 : bits(64)

register PMCEID0_EL0 : bits(64)

val set_PMCEID0 : bits(32) -> unit effect {rreg, wreg}

function set_PMCEID0 val_name = {
    let r : bits(32) = val_name;
    PMCEID0_EL0 = __SetSlice_bits(64, 32, PMCEID0_EL0, 0, slice(r, 0, 32));
    return()
}

register PMCCNTR_EL0 : bits(64)

register PMCCFILTR_EL0 : bits(32)

val set_PMCCFILTR : bits(32) -> unit effect {rreg, wreg}

function set_PMCCFILTR val_name = {
    let r : bits(32) = val_name;
    PMCCFILTR_EL0 = __SetSlice_bits(32, 32, PMCCFILTR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMCCFILTR : unit -> bits(32) effect {rreg, undef}

function get_PMCCFILTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCCFILTR_EL0, 0, 32));
    r
}

register PAR_S : bits(64)

register PAR_EL1 : bits(64)

val set_PAR_NS : bits(64) -> unit effect {rreg, wreg}

function set_PAR_NS val_name = {
    let r : bits(64) = val_name;
    PAR_EL1 = __SetSlice_bits(64, 64, PAR_EL1, 0, slice(r, 0, 64));
    return()
}

val get_PAR_NS : unit -> bits(64) effect {rreg, undef}

function get_PAR_NS () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(PAR_EL1, 0, 64));
    r
}

val PACCellShuffle : bits(64) -> bits(64) effect {undef}

function PACCellShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 24, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, slice(indata, 44, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 0, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, slice(indata, 28, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 48, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 28, slice(indata, 40, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 32, slice(indata, 32, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 36, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 40, slice(indata, 56, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 44, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 48, slice(indata, 8, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 36, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, slice(indata, 16, 4));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, slice(indata, 60, 4));
    outdata
}

val PACCellInvShuffle : bits(64) -> bits(64) effect {undef}

function PACCellInvShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 24, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, slice(indata, 48, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 36, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, slice(indata, 56, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 44, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 28, slice(indata, 16, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 32, slice(indata, 32, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 36, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 40, slice(indata, 28, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 44, slice(indata, 8, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 48, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 0, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, slice(indata, 40, 4));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, slice(indata, 60, 4));
    outdata
}

register OSLSR_EL1 : bits(32)

val set_DBGOSLSR : bits(32) -> unit effect {rreg, wreg}

function set_DBGOSLSR val_name = {
    let r : bits(32) = val_name;
    OSLSR_EL1 = __SetSlice_bits(32, 32, OSLSR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGOSLSR : unit -> bits(32) effect {rreg, undef}

function get_DBGOSLSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(OSLSR_EL1, 0, 32));
    r
}

register OSLAR_EL1 : bits(32)

register OSECCR_EL1 : bits(32)

register OSDTRTX_EL1 : bits(32)

register OSDTRRX_EL1 : bits(32)

register OSDLR_EL1 : bits(32)

val set_DBGOSDLR : bits(32) -> unit effect {rreg, wreg}

function set_DBGOSDLR val_name = {
    let r : bits(32) = val_name;
    OSDLR_EL1 = __SetSlice_bits(32, 32, OSDLR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGOSDLR : unit -> bits(32) effect {rreg, undef}

function get_DBGOSDLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(OSDLR_EL1, 0, 32));
    r
}

let NUM_GTE_REGIONS : int(6) = 6

let NUM_GTE_PARAMS : int(8) = 8

let NUM_GTE_EXT_OBS_OBSERVERS : int(4) = 4

let NUM_GTE_EXT_OBS_OBSERVATIONS_PER_OBSERVER : int(64) = 64

let NUM_GTE_AS_ACCESSES : int(8) = 8

register NSACR : bits(32)

val integer_flags_cfinv : unit -> unit effect {rreg, wreg}

function integer_flags_cfinv () = {
    PSTATE.C = ~(PSTATE.C)
}

register NMRR_S : bits(32)

val __UNKNOWN_MoveWideOp : unit -> MoveWideOp

function __UNKNOWN_MoveWideOp () = {
    MoveWideOp_N
}

val __UNKNOWN_MemType : unit -> MemType

function __UNKNOWN_MemType () = {
    MemType_Normal
}

val __UNKNOWN_MemOp : unit -> MemOp

function __UNKNOWN_MemOp () = {
    MemOp_LOAD
}

let MemHint_RWA : vector(2, dec, bit) = 0b11

let MemHint_RA : vector(2, dec, bit) = 0b10

let MemHint_No : vector(2, dec, bit) = 0b00

val __UNKNOWN_MemBarrierOp : unit -> MemBarrierOp

function __UNKNOWN_MemBarrierOp () = {
    MemBarrierOp_DSB
}

let MemAttr_WT : vector(2, dec, bit) = 0b10

let MemAttr_WB : vector(2, dec, bit) = 0b11

let MemAttr_NC : vector(2, dec, bit) = 0b00

val __UNKNOWN_MemAtomicOp : unit -> MemAtomicOp

function __UNKNOWN_MemAtomicOp () = {
    MemAtomicOp_ADD
}

val MarkExclusiveGlobal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> unit

function MarkExclusiveGlobal (paddress, processorid, size) = {
    return()
}

register MVFR2_EL1 : bits(32)

val set_MVFR2 : bits(32) -> unit effect {rreg, wreg}

function set_MVFR2 val_name = {
    let r : bits(32) = val_name;
    MVFR2_EL1 = __SetSlice_bits(32, 32, MVFR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MVFR2 : unit -> bits(32) effect {rreg, undef}

function get_MVFR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MVFR2_EL1, 0, 32));
    r
}

register MVFR1_EL1 : bits(32)

val set_MVFR1 : bits(32) -> unit effect {rreg, wreg}

function set_MVFR1 val_name = {
    let r : bits(32) = val_name;
    MVFR1_EL1 = __SetSlice_bits(32, 32, MVFR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MVFR1 : unit -> bits(32) effect {rreg, undef}

function get_MVFR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MVFR1_EL1, 0, 32));
    r
}

register MVFR0_EL1 : bits(32)

val set_MVFR0 : bits(32) -> unit effect {rreg, wreg}

function set_MVFR0 val_name = {
    let r : bits(32) = val_name;
    MVFR0_EL1 = __SetSlice_bits(32, 32, MVFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MVFR0 : unit -> bits(32) effect {rreg, undef}

function get_MVFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MVFR0_EL1, 0, 32));
    r
}

register MVBAR : bits(32)

register MPIDR_EL1 : bits(64)

val set_MPIDR : bits(32) -> unit effect {rreg, wreg}

function set_MPIDR val_name = {
    let r : bits(32) = val_name;
    MPIDR_EL1 = __SetSlice_bits(64, 32, MPIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MPIDR : unit -> bits(32) effect {rreg, undef}

function get_MPIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MPIDR_EL1, 0, 32));
    r
}

register MPAMVPMV_EL2 : bits(32)

register MPAMVPM7_EL2 : bits(64)

register MPAMVPM6_EL2 : bits(64)

register MPAMVPM5_EL2 : bits(64)

register MPAMVPM4_EL2 : bits(64)

register MPAMVPM3_EL2 : bits(64)

register MPAMVPM2_EL2 : bits(64)

register MPAMVPM1_EL2 : bits(64)

register MPAMVPM0_EL2 : bits(64)

register MPAMIDR_EL1 : bits(64)

register MPAMHCR_EL2 : bits(32)

register MPAM3_EL3 : bits(64)

register MPAM2_EL2 : bits(64)

register MPAM1_EL1 : bits(64)

register MPAM0_EL1 : bits(64)

let MODE_W : vector(2, dec, bit) = 0b01

let MODE_R : vector(2, dec, bit) = 0b00

let MODE_A : vector(2, dec, bit) = 0b10

register MIDR_EL1 : bits(32)

val set_MIDR : bits(32) -> unit effect {rreg, wreg}

function set_MIDR val_name = {
    let r : bits(32) = val_name;
    MIDR_EL1 = __SetSlice_bits(32, 32, MIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MIDR : unit -> bits(32) effect {rreg, undef}

function get_MIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MIDR_EL1, 0, 32));
    r
}

register MDSCR_EL1 : bits(32)

val set_DBGDSCRext : bits(32) -> unit effect {rreg, wreg}

function set_DBGDSCRext val_name = {
    let r : bits(32) = val_name;
    MDSCR_EL1 = __SetSlice_bits(32, 32, MDSCR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGDSCRext : unit -> bits(32) effect {rreg, undef}

function get_DBGDSCRext () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MDSCR_EL1, 0, 32));
    r
}

register MDRAR_EL1 : bits(64)

val set_DBGDRAR : bits(64) -> unit effect {rreg, wreg}

function set_DBGDRAR val_name = {
    let r : bits(64) = val_name;
    MDRAR_EL1 = __SetSlice_bits(64, 64, MDRAR_EL1, 0, slice(r, 0, 64));
    return()
}

val get_DBGDRAR : unit -> bits(64) effect {rreg, undef}

function get_DBGDRAR () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(MDRAR_EL1, 0, 64));
    r
}

register MDCR_EL3 : bits(32)

val set_SDCR : bits(32) -> unit effect {rreg, wreg}

function set_SDCR val_name = {
    let r : bits(32) = val_name;
    MDCR_EL3 = __SetSlice_bits(32, 32, MDCR_EL3, 0, slice(r, 0, 32));
    return()
}

val get_SDCR : unit -> bits(32) effect {rreg, undef}

function get_SDCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MDCR_EL3, 0, 32));
    r
}

register MDCR_EL2 : bits(32)

val set_HDCR : bits(32) -> unit effect {rreg, wreg}

function set_HDCR val_name = {
    let r : bits(32) = val_name;
    MDCR_EL2 = __SetSlice_bits(32, 32, MDCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HDCR : unit -> bits(32) effect {rreg, undef}

function get_HDCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MDCR_EL2, 0, 32));
    r
}

register MDCCSR_EL0 : bits(32)

register MDCCINT_EL1 : bits(32)

val set_DBGDCCINT : bits(32) -> unit effect {rreg, wreg}

function set_DBGDCCINT val_name = {
    let r : bits(32) = val_name;
    MDCCINT_EL1 = __SetSlice_bits(32, 32, MDCCINT_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGDCCINT : unit -> bits(32) effect {rreg, undef}

function get_DBGDCCINT () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MDCCINT_EL1, 0, 32));
    r
}

val __UNKNOWN_MBReqTypes : unit -> MBReqTypes

function __UNKNOWN_MBReqTypes () = {
    MBReqTypes_Reads
}

val __UNKNOWN_MBReqDomain : unit -> MBReqDomain

function __UNKNOWN_MBReqDomain () = {
    MBReqDomain_Nonshareable
}

register MAIR_EL3 : bits(64)

register MAIR_EL2 : bits(64)

val get_HMAIR1 : unit -> bits(32) effect {rreg, undef}

function get_HMAIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MAIR_EL2, 32, 32));
    r
}

val get_HMAIR0 : unit -> bits(32) effect {rreg, undef}

function get_HMAIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MAIR_EL2, 0, 32));
    r
}

register MAIR_EL1 : bits(64)

val set_PRRR_NS : bits(32) -> unit effect {rreg, wreg}

function set_PRRR_NS val_name = {
    let r : bits(32) = val_name;
    MAIR_EL1 = __SetSlice_bits(64, 32, MAIR_EL1, 0, slice(r, 0, 32));
    return()
}

val set_NMRR_NS : bits(32) -> unit effect {rreg, wreg}

function set_NMRR_NS val_name = {
    let r : bits(32) = val_name;
    MAIR_EL1 = __SetSlice_bits(64, 32, MAIR_EL1, 32, slice(r, 0, 32));
    return()
}

val get_PRRR_NS : unit -> bits(32) effect {rreg, undef}

function get_PRRR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MAIR_EL1, 0, 32));
    r
}

val get_NMRR_NS : unit -> bits(32) effect {rreg, undef}

function get_NMRR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MAIR_EL1, 32, 32));
    r
}

val get_MAIR1_NS : unit -> bits(32) effect {rreg, undef}

function get_MAIR1_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MAIR_EL1, 32, 32));
    r
}

val get_MAIR0_NS : unit -> bits(32) effect {rreg, undef}

function get_MAIR0_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MAIR_EL1, 0, 32));
    r
}

register MAIR1_S : bits(32)

register MAIR0_S : bits(32)

let M32_User : vector(5, dec, bit) = 0b10000

let M32_Undef : vector(5, dec, bit) = 0b11011

let M32_System : vector(5, dec, bit) = 0b11111

let M32_Svc : vector(5, dec, bit) = 0b10011

let M32_Monitor : vector(5, dec, bit) = 0b10110

let M32_IRQ : vector(5, dec, bit) = 0b10010

let M32_Hyp : vector(5, dec, bit) = 0b11010

let M32_FIQ : vector(5, dec, bit) = 0b10001

let M32_Abort : vector(5, dec, bit) = 0b10111

val __UNKNOWN_LogicalOp : unit -> LogicalOp

function __UNKNOWN_LogicalOp () = {
    LogicalOp_AND
}

val LSInstructionSyndrome : unit -> bits(11) effect {rreg}

function LSInstructionSyndrome () = {
    __LSISyndrome
}

register LR_mon : bits(32)

register LORSA_EL1 : bits(64)

register LORN_EL1 : bits(32)

register LORID_EL1 : bits(32)

register LOREA_EL1 : bits(64)

register LORC_EL1 : bits(32)

let LOG2_TAG_GRANULE_DEFAULT : int(4) = 4

register configuration LOG2_TAG_GRANULE : int = LOG2_TAG_GRANULE_DEFAULT

val IsPhysicalSErrorPending : unit -> bool effect {rreg}

function IsPhysicalSErrorPending () = {
    _PendingPhysicalSE
}

val IsExclusiveGlobal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> bool

function IsExclusiveGlobal (paddress, processorid, size) = {
    true
}

val asl_Int : forall ('N : Int) ('unsigned : Bool), 'N >= 0.
  (bits('N), bool('unsigned)) -> int

function asl_Int (x, unsigned) = {
    let result : int = if unsigned then UInt(x) else SInt(x);
    result
}

val InstructionSynchronizationBarrier : unit -> unit

function InstructionSynchronizationBarrier () = {
    return()
}

val __UNKNOWN_InstrSet : unit -> InstrSet

function __UNKNOWN_InstrSet () = {
    InstrSet_A64
}

register InGuardedPage : bool

val __UNKNOWN_ImmediateOp : unit -> ImmediateOp

function __UNKNOWN_ImmediateOp () = {
    ImmediateOp_MOVI
}

register ISR_EL1 : bits(32)

val set_ISR : bits(32) -> unit effect {rreg, wreg}

function set_ISR val_name = {
    let r : bits(32) = val_name;
    ISR_EL1 = __SetSlice_bits(32, 32, ISR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ISR : unit -> bits(32) effect {rreg, undef}

function get_ISR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ISR_EL1, 0, 32));
    r
}

val IRQPending : unit -> bool effect {rreg}

function IRQPending () = {
    _IRQPending
}

register IFSR_S : bits(32)

register IFSR32_EL2 : bits(32)

val set_IFSR_NS : bits(32) -> unit effect {rreg, wreg}

function set_IFSR_NS val_name = {
    let r : bits(32) = val_name;
    IFSR32_EL2 = __SetSlice_bits(32, 32, IFSR32_EL2, 0, slice(r, 0, 32));
    return()
}

val get_IFSR_NS : unit -> bits(32) effect {rreg, undef}

function get_IFSR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(IFSR32_EL2, 0, 32));
    r
}

register ID_PFR2_EL1 : bits(32)

val set_ID_PFR2 : bits(32) -> unit effect {rreg, wreg}

function set_ID_PFR2 val_name = {
    let r : bits(32) = val_name;
    ID_PFR2_EL1 = __SetSlice_bits(32, 32, ID_PFR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_PFR2 : unit -> bits(32) effect {rreg, undef}

function get_ID_PFR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_PFR2_EL1, 0, 32));
    r
}

register ID_PFR1_EL1 : bits(32)

val set_ID_PFR1 : bits(32) -> unit effect {rreg, wreg}

function set_ID_PFR1 val_name = {
    let r : bits(32) = val_name;
    ID_PFR1_EL1 = __SetSlice_bits(32, 32, ID_PFR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_PFR1 : unit -> bits(32) effect {rreg, undef}

function get_ID_PFR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_PFR1_EL1, 0, 32));
    r
}

register ID_PFR0_EL1 : bits(32)

val set_ID_PFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_PFR0 val_name = {
    let r : bits(32) = val_name;
    ID_PFR0_EL1 = __SetSlice_bits(32, 32, ID_PFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_PFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_PFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_PFR0_EL1, 0, 32));
    r
}

register ID_MMFR4_EL1 : bits(32)

val set_ID_MMFR4 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR4 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR4_EL1 = __SetSlice_bits(32, 32, ID_MMFR4_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR4 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR4 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR4_EL1, 0, 32));
    r
}

register ID_MMFR3_EL1 : bits(32)

val set_ID_MMFR3 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR3 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR3_EL1 = __SetSlice_bits(32, 32, ID_MMFR3_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR3 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR3 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR3_EL1, 0, 32));
    r
}

register ID_MMFR2_EL1 : bits(32)

val set_ID_MMFR2 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR2 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR2_EL1 = __SetSlice_bits(32, 32, ID_MMFR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR2 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR2_EL1, 0, 32));
    r
}

register ID_MMFR1_EL1 : bits(32)

val set_ID_MMFR1 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR1 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR1_EL1 = __SetSlice_bits(32, 32, ID_MMFR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR1 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR1_EL1, 0, 32));
    r
}

register ID_MMFR0_EL1 : bits(32)

val set_ID_MMFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR0 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR0_EL1 = __SetSlice_bits(32, 32, ID_MMFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR0_EL1, 0, 32));
    r
}

register ID_ISAR6_EL1 : bits(32)

val set_ID_ISAR6 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR6 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR6_EL1 = __SetSlice_bits(32, 32, ID_ISAR6_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR6 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR6 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR6_EL1, 0, 32));
    r
}

register ID_ISAR5_EL1 : bits(32)

val set_ID_ISAR5 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR5 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR5_EL1 = __SetSlice_bits(32, 32, ID_ISAR5_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR5 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR5 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR5_EL1, 0, 32));
    r
}

register ID_ISAR4_EL1 : bits(32)

val set_ID_ISAR4 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR4 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR4_EL1 = __SetSlice_bits(32, 32, ID_ISAR4_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR4 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR4 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR4_EL1, 0, 32));
    r
}

register ID_ISAR3_EL1 : bits(32)

val set_ID_ISAR3 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR3 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR3_EL1 = __SetSlice_bits(32, 32, ID_ISAR3_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR3 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR3 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR3_EL1, 0, 32));
    r
}

register ID_ISAR2_EL1 : bits(32)

val set_ID_ISAR2 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR2 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR2_EL1 = __SetSlice_bits(32, 32, ID_ISAR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR2 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR2_EL1, 0, 32));
    r
}

register ID_ISAR1_EL1 : bits(32)

val set_ID_ISAR1 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR1 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR1_EL1 = __SetSlice_bits(32, 32, ID_ISAR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR1 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR1_EL1, 0, 32));
    r
}

register ID_ISAR0_EL1 : bits(32)

val set_ID_ISAR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR0 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR0_EL1 = __SetSlice_bits(32, 32, ID_ISAR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR0_EL1, 0, 32));
    r
}

register ID_DFR0_EL1 : bits(32)

val set_ID_DFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_DFR0 val_name = {
    let r : bits(32) = val_name;
    ID_DFR0_EL1 = __SetSlice_bits(32, 32, ID_DFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_DFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_DFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_DFR0_EL1, 0, 32));
    r
}

register ID_AFR0_EL1 : bits(32)

val set_ID_AFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_AFR0 val_name = {
    let r : bits(32) = val_name;
    ID_AFR0_EL1 = __SetSlice_bits(32, 32, ID_AFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_AFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_AFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_AFR0_EL1, 0, 32));
    r
}

register ID_AA64PFR1_EL1 : bits(32)

register ID_AA64PFR0_EL1 : bits(64)

register ID_AA64MMFR2_EL1 : bits(64)

register ID_AA64MMFR1_EL1 : bits(32)

register ID_AA64MMFR0_EL1 : bits(64)

register ID_AA64ISAR1_EL1 : bits(64)

register ID_AA64ISAR0_EL1 : bits(64)

register ID_AA64DFR1_EL1 : bits(32)

register ID_AA64DFR0_EL1 : bits(64)

register ID_AA64AFR1_EL1 : bits(32)

register ID_AA64AFR0_EL1 : bits(32)

register ICV_RPR_EL1 : bits(32)

val set_ICV_RPR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_RPR val_name = {
    let r : bits(32) = val_name;
    ICV_RPR_EL1 = __SetSlice_bits(32, 32, ICV_RPR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_RPR : unit -> bits(32) effect {rreg, undef}

function get_ICV_RPR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_RPR_EL1, 0, 32));
    r
}

register ICV_PMR_EL1 : bits(32)

val set_ICV_PMR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_PMR val_name = {
    let r : bits(32) = val_name;
    ICV_PMR_EL1 = __SetSlice_bits(32, 32, ICV_PMR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_PMR : unit -> bits(32) effect {rreg, undef}

function get_ICV_PMR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_PMR_EL1, 0, 32));
    r
}

register ICV_IGRPEN1_EL1 : bits(32)

val set_ICV_IGRPEN1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IGRPEN1 val_name = {
    let r : bits(32) = val_name;
    ICV_IGRPEN1_EL1 = __SetSlice_bits(32, 32, ICV_IGRPEN1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IGRPEN1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IGRPEN1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IGRPEN1_EL1, 0, 32));
    r
}

register ICV_IGRPEN0_EL1 : bits(32)

val set_ICV_IGRPEN0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IGRPEN0 val_name = {
    let r : bits(32) = val_name;
    ICV_IGRPEN0_EL1 = __SetSlice_bits(32, 32, ICV_IGRPEN0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IGRPEN0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IGRPEN0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IGRPEN0_EL1, 0, 32));
    r
}

register ICV_IAR1_EL1 : bits(32)

val set_ICV_IAR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IAR1 val_name = {
    let r : bits(32) = val_name;
    ICV_IAR1_EL1 = __SetSlice_bits(32, 32, ICV_IAR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IAR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IAR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IAR1_EL1, 0, 32));
    r
}

register ICV_IAR0_EL1 : bits(32)

val set_ICV_IAR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IAR0 val_name = {
    let r : bits(32) = val_name;
    ICV_IAR0_EL1 = __SetSlice_bits(32, 32, ICV_IAR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IAR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IAR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IAR0_EL1, 0, 32));
    r
}

register ICV_HPPIR1_EL1 : bits(32)

val set_ICV_HPPIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_HPPIR1 val_name = {
    let r : bits(32) = val_name;
    ICV_HPPIR1_EL1 = __SetSlice_bits(32, 32, ICV_HPPIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_HPPIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_HPPIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_HPPIR1_EL1, 0, 32));
    r
}

register ICV_HPPIR0_EL1 : bits(32)

val set_ICV_HPPIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_HPPIR0 val_name = {
    let r : bits(32) = val_name;
    ICV_HPPIR0_EL1 = __SetSlice_bits(32, 32, ICV_HPPIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_HPPIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_HPPIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_HPPIR0_EL1, 0, 32));
    r
}

register ICV_EOIR1_EL1 : bits(32)

val set_ICV_EOIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_EOIR1 val_name = {
    let r : bits(32) = val_name;
    ICV_EOIR1_EL1 = __SetSlice_bits(32, 32, ICV_EOIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_EOIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_EOIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_EOIR1_EL1, 0, 32));
    r
}

register ICV_EOIR0_EL1 : bits(32)

val set_ICV_EOIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_EOIR0 val_name = {
    let r : bits(32) = val_name;
    ICV_EOIR0_EL1 = __SetSlice_bits(32, 32, ICV_EOIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_EOIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_EOIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_EOIR0_EL1, 0, 32));
    r
}

register ICV_DIR_EL1 : bits(32)

val set_ICV_DIR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_DIR val_name = {
    let r : bits(32) = val_name;
    ICV_DIR_EL1 = __SetSlice_bits(32, 32, ICV_DIR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_DIR : unit -> bits(32) effect {rreg, undef}

function get_ICV_DIR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_DIR_EL1, 0, 32));
    r
}

register ICV_CTLR_EL1 : bits(32)

val set_ICV_CTLR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_CTLR val_name = {
    let r : bits(32) = val_name;
    ICV_CTLR_EL1 = __SetSlice_bits(32, 32, ICV_CTLR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_CTLR : unit -> bits(32) effect {rreg, undef}

function get_ICV_CTLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_CTLR_EL1, 0, 32));
    r
}

register ICV_BPR1_EL1 : bits(32)

val set_ICV_BPR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_BPR1 val_name = {
    let r : bits(32) = val_name;
    ICV_BPR1_EL1 = __SetSlice_bits(32, 32, ICV_BPR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_BPR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_BPR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_BPR1_EL1, 0, 32));
    r
}

register ICV_BPR0_EL1 : bits(32)

val set_ICV_BPR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_BPR0 val_name = {
    let r : bits(32) = val_name;
    ICV_BPR0_EL1 = __SetSlice_bits(32, 32, ICV_BPR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_BPR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_BPR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_BPR0_EL1, 0, 32));
    r
}

register ICV_AP1R_EL1 : vector(5, dec, bits(32))

register ICV_AP0R_EL1 : vector(5, dec, bits(32))

register ICH_VTR_EL2 : bits(32)

val set_ICH_VTR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_VTR val_name = {
    let r : bits(32) = val_name;
    ICH_VTR_EL2 = __SetSlice_bits(32, 32, ICH_VTR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_VTR : unit -> bits(32) effect {rreg, undef}

function get_ICH_VTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_VTR_EL2, 0, 32));
    r
}

register ICH_VMCR_EL2 : bits(32)

val set_ICH_VMCR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_VMCR val_name = {
    let r : bits(32) = val_name;
    ICH_VMCR_EL2 = __SetSlice_bits(32, 32, ICH_VMCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_VMCR : unit -> bits(32) effect {rreg, undef}

function get_ICH_VMCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_VMCR_EL2, 0, 32));
    r
}

register ICH_MISR_EL2 : bits(32)

val set_ICH_MISR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_MISR val_name = {
    let r : bits(32) = val_name;
    ICH_MISR_EL2 = __SetSlice_bits(32, 32, ICH_MISR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_MISR : unit -> bits(32) effect {rreg, undef}

function get_ICH_MISR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_MISR_EL2, 0, 32));
    r
}

register ICH_HCR_EL2 : bits(32)

val set_ICH_HCR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_HCR val_name = {
    let r : bits(32) = val_name;
    ICH_HCR_EL2 = __SetSlice_bits(32, 32, ICH_HCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_HCR : unit -> bits(32) effect {rreg, undef}

function get_ICH_HCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_HCR_EL2, 0, 32));
    r
}

register ICH_ELRSR_EL2 : bits(32)

val set_ICH_ELRSR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_ELRSR val_name = {
    let r : bits(32) = val_name;
    ICH_ELRSR_EL2 = __SetSlice_bits(32, 32, ICH_ELRSR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_ELRSR : unit -> bits(32) effect {rreg, undef}

function get_ICH_ELRSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_ELRSR_EL2, 0, 32));
    r
}

register ICH_EISR_EL2 : bits(32)

val set_ICH_EISR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_EISR val_name = {
    let r : bits(32) = val_name;
    ICH_EISR_EL2 = __SetSlice_bits(32, 32, ICH_EISR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_EISR : unit -> bits(32) effect {rreg, undef}

function get_ICH_EISR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_EISR_EL2, 0, 32));
    r
}

register ICH_AP1R_EL2 : vector(5, dec, bits(32))

register ICH_AP0R_EL2 : vector(5, dec, bits(32))

register ICC_SRE_EL3 : bits(32)

val set_ICC_MSRE : bits(32) -> unit effect {rreg, wreg}

function set_ICC_MSRE val_name = {
    let r : bits(32) = val_name;
    ICC_SRE_EL3 = __SetSlice_bits(32, 32, ICC_SRE_EL3, 0, slice(r, 0, 32));
    return()
}

val get_ICC_MSRE : unit -> bits(32) effect {rreg, undef}

function get_ICC_MSRE () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_SRE_EL3, 0, 32));
    r
}

register ICC_SRE_EL2 : bits(32)

val set_ICC_HSRE : bits(32) -> unit effect {rreg, wreg}

function set_ICC_HSRE val_name = {
    let r : bits(32) = val_name;
    ICC_SRE_EL2 = __SetSlice_bits(32, 32, ICC_SRE_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICC_HSRE : unit -> bits(32) effect {rreg, undef}

function get_ICC_HSRE () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_SRE_EL2, 0, 32));
    r
}

register ICC_SRE_EL1_S : bits(32)

register ICC_SRE_EL1_NS : bits(32)

register ICC_SGI1R_EL1 : bits(64)

val set_ICC_SGI1R : bits(64) -> unit effect {rreg, wreg}

function set_ICC_SGI1R val_name = {
    let r : bits(64) = val_name;
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 64, ICC_SGI1R_EL1, 0, slice(r, 0, 64));
    return()
}

val get_ICC_SGI1R : unit -> bits(64) effect {rreg, undef}

function get_ICC_SGI1R () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(ICC_SGI1R_EL1, 0, 64));
    r
}

register ICC_SGI0R_EL1 : bits(64)

val set_ICC_SGI0R : bits(64) -> unit effect {rreg, wreg}

function set_ICC_SGI0R val_name = {
    let r : bits(64) = val_name;
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 64, ICC_SGI0R_EL1, 0, slice(r, 0, 64));
    return()
}

val get_ICC_SGI0R : unit -> bits(64) effect {rreg, undef}

function get_ICC_SGI0R () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(ICC_SGI0R_EL1, 0, 64));
    r
}

register ICC_RPR_EL1 : bits(32)

val set_ICC_RPR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_RPR val_name = {
    let r : bits(32) = val_name;
    ICC_RPR_EL1 = __SetSlice_bits(32, 32, ICC_RPR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_RPR : unit -> bits(32) effect {rreg, undef}

function get_ICC_RPR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_RPR_EL1, 0, 32));
    r
}

register ICC_PMR_EL1 : bits(32)

val set_ICC_PMR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_PMR val_name = {
    let r : bits(32) = val_name;
    ICC_PMR_EL1 = __SetSlice_bits(32, 32, ICC_PMR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_PMR : unit -> bits(32) effect {rreg, undef}

function get_ICC_PMR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_PMR_EL1, 0, 32));
    r
}

register ICC_IGRPEN1_EL3 : bits(32)

val set_ICC_MGRPEN1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_MGRPEN1 val_name = {
    let r : bits(32) = val_name;
    ICC_IGRPEN1_EL3 = __SetSlice_bits(32, 32, ICC_IGRPEN1_EL3, 0, slice(r, 0, 32));
    return()
}

val get_ICC_MGRPEN1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_MGRPEN1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IGRPEN1_EL3, 0, 32));
    r
}

register ICC_IGRPEN1_EL1_S : bits(32)

register ICC_IGRPEN1_EL1_NS : bits(32)

register ICC_IGRPEN0_EL1 : bits(32)

val set_ICC_IGRPEN0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_IGRPEN0 val_name = {
    let r : bits(32) = val_name;
    ICC_IGRPEN0_EL1 = __SetSlice_bits(32, 32, ICC_IGRPEN0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_IGRPEN0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_IGRPEN0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IGRPEN0_EL1, 0, 32));
    r
}

register ICC_IAR1_EL1 : bits(32)

val set_ICC_IAR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_IAR1 val_name = {
    let r : bits(32) = val_name;
    ICC_IAR1_EL1 = __SetSlice_bits(32, 32, ICC_IAR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_IAR1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_IAR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IAR1_EL1, 0, 32));
    r
}

register ICC_IAR0_EL1 : bits(32)

val set_ICC_IAR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_IAR0 val_name = {
    let r : bits(32) = val_name;
    ICC_IAR0_EL1 = __SetSlice_bits(32, 32, ICC_IAR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_IAR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_IAR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IAR0_EL1, 0, 32));
    r
}

register ICC_HPPIR1_EL1 : bits(32)

val set_ICC_HPPIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_HPPIR1 val_name = {
    let r : bits(32) = val_name;
    ICC_HPPIR1_EL1 = __SetSlice_bits(32, 32, ICC_HPPIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_HPPIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_HPPIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_HPPIR1_EL1, 0, 32));
    r
}

register ICC_HPPIR0_EL1 : bits(32)

val set_ICC_HPPIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_HPPIR0 val_name = {
    let r : bits(32) = val_name;
    ICC_HPPIR0_EL1 = __SetSlice_bits(32, 32, ICC_HPPIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_HPPIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_HPPIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_HPPIR0_EL1, 0, 32));
    r
}

register ICC_EOIR1_EL1 : bits(32)

val set_ICC_EOIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_EOIR1 val_name = {
    let r : bits(32) = val_name;
    ICC_EOIR1_EL1 = __SetSlice_bits(32, 32, ICC_EOIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_EOIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_EOIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_EOIR1_EL1, 0, 32));
    r
}

register ICC_EOIR0_EL1 : bits(32)

val set_ICC_EOIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_EOIR0 val_name = {
    let r : bits(32) = val_name;
    ICC_EOIR0_EL1 = __SetSlice_bits(32, 32, ICC_EOIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_EOIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_EOIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_EOIR0_EL1, 0, 32));
    r
}

register ICC_DIR_EL1 : bits(32)

val set_ICC_DIR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_DIR val_name = {
    let r : bits(32) = val_name;
    ICC_DIR_EL1 = __SetSlice_bits(32, 32, ICC_DIR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_DIR : unit -> bits(32) effect {rreg, undef}

function get_ICC_DIR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_DIR_EL1, 0, 32));
    r
}

register ICC_CTLR_EL3 : bits(32)

val set_ICC_MCTLR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_MCTLR val_name = {
    let r : bits(32) = val_name;
    ICC_CTLR_EL3 = __SetSlice_bits(32, 32, ICC_CTLR_EL3, 0, slice(r, 0, 32));
    return()
}

val get_ICC_MCTLR : unit -> bits(32) effect {rreg, undef}

function get_ICC_MCTLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_CTLR_EL3, 0, 32));
    r
}

register ICC_CTLR_EL1_S : bits(32)

register ICC_CTLR_EL1_NS : bits(32)

register ICC_BPR1_EL1_S : bits(32)

register ICC_BPR1_EL1_NS : bits(32)

register ICC_BPR0_EL1 : bits(32)

val set_ICC_BPR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_BPR0 val_name = {
    let r : bits(32) = val_name;
    ICC_BPR0_EL1 = __SetSlice_bits(32, 32, ICC_BPR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_BPR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_BPR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_BPR0_EL1, 0, 32));
    r
}

register ICC_ASGI1R_EL1 : bits(64)

val set_ICC_ASGI1R : bits(64) -> unit effect {rreg, wreg}

function set_ICC_ASGI1R val_name = {
    let r : bits(64) = val_name;
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 64, ICC_ASGI1R_EL1, 0, slice(r, 0, 64));
    return()
}

val get_ICC_ASGI1R : unit -> bits(64) effect {rreg, undef}

function get_ICC_ASGI1R () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(ICC_ASGI1R_EL1, 0, 64));
    r
}

register ICC_AP1R_EL1 : vector(5, dec, bits(32))

register ICC_AP0R_EL1 : vector(5, dec, bits(32))

val Hint_Yield : unit -> unit

function Hint_Yield () = {
    return()
}

val Hint_Branch : BranchType -> unit

function Hint_Branch hint = {
    return()
}

val HighestELUsingAArch32 : unit -> bool effect {rreg}

function HighestELUsingAArch32 () = {
    __highest_el_aarch32
}

val HaveFP16Ext : unit -> bool

function HaveFP16Ext () = {
    true
}

val Have52BitPAExt : unit -> bool

function Have52BitPAExt () = {
    __support_52bit_pa
}

register HSTR_EL2 : bits(32)

val set_HSTR : bits(32) -> unit effect {rreg, wreg}

function set_HSTR val_name = {
    let r : bits(32) = val_name;
    HSTR_EL2 = __SetSlice_bits(32, 32, HSTR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HSTR : unit -> bits(32) effect {rreg, undef}

function get_HSTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(HSTR_EL2, 0, 32));
    r
}

register HPFAR_EL2 : bits(64)

val set_HPFAR : bits(32) -> unit effect {rreg, wreg}

function set_HPFAR val_name = {
    let r : bits(32) = val_name;
    HPFAR_EL2 = __SetSlice_bits(64, 32, HPFAR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HPFAR : unit -> bits(32) effect {rreg, undef}

function get_HPFAR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(HPFAR_EL2, 0, 32));
    r
}

let HEAP_LIMIT : vector(64, dec, bit) = __GetSlice_int(64, 251658240, 0)

let HEAP_BASE : vector(64, dec, bit) = __GetSlice_int(64, 0, 0)

register HCR_EL2 : bits(64)

val set_HCR2 : bits(32) -> unit effect {rreg, wreg}

function set_HCR2 val_name = {
    let r : bits(32) = val_name;
    HCR_EL2 = __SetSlice_bits(64, 32, HCR_EL2, 32, slice(r, 0, 32));
    return()
}

val set_HCR : bits(32) -> unit effect {rreg, wreg}

function set_HCR val_name = {
    let r : bits(32) = val_name;
    HCR_EL2 = __SetSlice_bits(64, 32, HCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HCR2 : unit -> bits(32) effect {rreg, undef}

function get_HCR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(HCR_EL2, 32, 32));
    r
}

val get_HCR : unit -> bits(32) effect {rreg, undef}

function get_HCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(HCR_EL2, 0, 32));
    r
}

register HACR_EL2 : bits(32)

let GTE_ST_REQUEST_GRANTED : vector(64, dec, bit) = __GetSlice_int(64, 0, 0)

let GTE_ST_REQUEST_FAIL : vector(64, dec, bit) = __GetSlice_int(64, 1, 0)

let GTE_LIST_PARAM_LEN : int(64) = 64

let GTE_EXT_OBS_RESULTS_ADDRESS : vector(64, dec, bit) = __GetSlice_int(64, 318775296, 0)

let GTE_EXT_OBS_OUTER_S : vector(3, dec, bit) = 0b011

let GTE_EXT_OBS_OUTER_NS : vector(3, dec, bit) = 0b101

let GTE_EXT_OBS_INNER_S : vector(3, dec, bit) = 0b100

let GTE_EXT_OBS_INNER_NS : vector(3, dec, bit) = 0b110

let GTE_EXT_OBS_ACC_WRITE : vector(3, dec, bit) = 0b010

let GTE_EXT_OBS_ACC_SIZE8 : vector(3, dec, bit) = 0b011

let GTE_EXT_OBS_ACC_SIZE64 : vector(3, dec, bit) = 0b000

let GTE_EXT_OBS_ACC_SIZE32 : vector(3, dec, bit) = 0b001

let GTE_EXT_OBS_ACC_SIZE16 : vector(3, dec, bit) = 0b010

let GTE_EXT_OBS_ACC_READ : vector(3, dec, bit) = 0b001

val GTEGetPPUID : unit -> unit effect {wreg}

function GTEGetPPUID () = {
    prerr("GTEGetPPUID()\n");
    _GTEStatus = __GetSlice_int(64, NUM_GTE_REGIONS, 0);
    return()
}

val GTECriticalSectionStart : unit -> unit

function GTECriticalSectionStart () = {
    prerr("TODO: implement GTECriticalSectionStart\n");
    return()
}

val GTECriticalSectionEnd : unit -> unit

function GTECriticalSectionEnd () = {
    prerr("TODO: implement GTECriticalSectionEnd\n");
    return()
}

register GCR_EL1 : bits(32)

val __UNKNOWN_Fault : unit -> Fault

function __UNKNOWN_Fault () = {
    Fault_None
}

val __UNKNOWN_FPUnaryOp : unit -> FPUnaryOp

function __UNKNOWN_FPUnaryOp () = {
    FPUnaryOp_ABS
}

val __UNKNOWN_FPType : unit -> FPType

function __UNKNOWN_FPType () = {
    FPType_Nonzero
}

register FPSR : bits(32)

register FPSID : bits(32)

register FPSCR : bits(32)

val __UNKNOWN_FPRounding : unit -> FPRounding

function __UNKNOWN_FPRounding () = {
    FPRounding_TIEEVEN
}

val __UNKNOWN_FPMaxMinOp : unit -> FPMaxMinOp

function __UNKNOWN_FPMaxMinOp () = {
    FPMaxMinOp_MAX
}

register FPEXC32_EL2 : bits(32)

val set_FPEXC : bits(32) -> unit effect {rreg, wreg}

function set_FPEXC val_name = {
    let r : bits(32) = val_name;
    FPEXC32_EL2 = __SetSlice_bits(32, 32, FPEXC32_EL2, 0, slice(r, 0, 32));
    return()
}

val get_FPEXC : unit -> bits(32) effect {rreg, undef}

function get_FPEXC () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FPEXC32_EL2, 0, 32));
    r
}

val FPDecodeRounding : bits(2) -> FPRounding

function FPDecodeRounding rmode = {
    match rmode {
      0b00 => {
          return(FPRounding_TIEEVEN)
      },
      0b01 => {
          return(FPRounding_POSINF)
      },
      0b10 => {
          return(FPRounding_NEGINF)
      },
      0b11 => {
          return(FPRounding_ZERO)
      }
    }
}

val FPRoundingMode : bits(32) -> FPRounding

function FPRoundingMode fpcr = {
    FPDecodeRounding(slice(fpcr, 22, 2))
}

val __UNKNOWN_FPConvOp : unit -> FPConvOp

function __UNKNOWN_FPConvOp () = {
    FPConvOp_CVT_FtoI
}

register FPCR : bits(32)

val FIQPending : unit -> bool effect {rreg}

function FIQPending () = {
    _FIQPending
}

register FCSEIDR : bits(32)

register FAR_EL3 : bits(64)

register FAR_EL2 : bits(64)

val set_IFAR_S : bits(32) -> unit effect {rreg, wreg}

function set_IFAR_S val_name = {
    let r : bits(32) = val_name;
    FAR_EL2 = __SetSlice_bits(64, 32, FAR_EL2, 32, slice(r, 0, 32));
    return()
}

val set_HIFAR : bits(32) -> unit effect {rreg, wreg}

function set_HIFAR val_name = {
    let r : bits(32) = val_name;
    FAR_EL2 = __SetSlice_bits(64, 32, FAR_EL2, 32, slice(r, 0, 32));
    return()
}

val set_HDFAR : bits(32) -> unit effect {rreg, wreg}

function set_HDFAR val_name = {
    let r : bits(32) = val_name;
    FAR_EL2 = __SetSlice_bits(64, 32, FAR_EL2, 0, slice(r, 0, 32));
    return()
}

val set_DFAR_S : bits(32) -> unit effect {rreg, wreg}

function set_DFAR_S val_name = {
    let r : bits(32) = val_name;
    FAR_EL2 = __SetSlice_bits(64, 32, FAR_EL2, 0, slice(r, 0, 32));
    return()
}

register FAR_EL1 : bits(64)

val set_IFAR_NS : bits(32) -> unit effect {rreg, wreg}

function set_IFAR_NS val_name = {
    let r : bits(32) = val_name;
    FAR_EL1 = __SetSlice_bits(64, 32, FAR_EL1, 32, slice(r, 0, 32));
    return()
}

val set_DFAR_NS : bits(32) -> unit effect {rreg, wreg}

function set_DFAR_NS val_name = {
    let r : bits(32) = val_name;
    FAR_EL1 = __SetSlice_bits(64, 32, FAR_EL1, 0, slice(r, 0, 32));
    return()
}

register FAR_EL0 : bits(64)

register configuration __syncAbortOnWriteNormNonCache : bool = false

register configuration __syncAbortOnWriteNormCache : bool = false

register configuration __syncAbortOnDeviceWrite : bool = false

register configuration __mpam_implemented : bool = false

register configuration __crypto_sm4_implemented : bool = false

register configuration __crypto_sm3_implemented : bool = false

register configuration __crypto_sha512_implemented : bool = false

register configuration __crypto_sha3_implemented : bool = false

val __UNKNOWN_boolean : unit -> bool

function __UNKNOWN_boolean () = {
    false
}

val Unreachable : unit -> unit effect {escape}

function Unreachable () = {
    assert(false)
}

val RBankSelect : forall 'usr 'fiq 'irq 'svc 'abt 'und 'hyp.
  (bits(5), int('usr), int('fiq), int('irq), int('svc), int('abt), int('und), int('hyp)) -> {'n, ('n == 'usr | 'n == 'fiq | 'n == 'irq | 'n == 'svc | 'n == 'abt | 'n == 'und | 'n == 'hyp). int('n)}

function RBankSelect (mode, usr, fiq, irq, svc, abt, und, hyp) = {
    match mode {
      ? if ? == M32_User => usr,
      ? if ? == M32_FIQ => fiq,
      ? if ? == M32_IRQ => irq,
      ? if ? == M32_Svc => svc,
      ? if ? == M32_Abort => abt,
      ? if ? == M32_Hyp => hyp,
      ? if ? == M32_Undef => und,
      ? if ? == M32_System => usr
    }
}

val TakeUnmaskedSErrorInterrupts : unit -> unit effect {escape, rreg, undef, wreg}

function TakeUnmaskedSErrorInterrupts () = {
    interrupt_req : InterruptReq = undefined : InterruptReq;
    interrupt_req.take_SE = false;
    interrupt_req.take_vSE = false;
    interrupt_req.take_FIQ = false;
    interrupt_req.take_vFIQ = false;
    interrupt_req.take_IRQ = false;
    interrupt_req.take_vIRQ = false;
    interrupt_req.iesb_req = false;
    interrupt_req.take_SE = true;
    interrupt_req.take_vSE = true;
    let interrupt_taken : bool = TakePendingInterrupts(interrupt_req);
    return()
}

val TakeUnmaskedPhysicalSErrorInterrupts : forall ('iesb_req : Bool).
  bool('iesb_req) -> unit effect {escape, rreg, undef, wreg}

function TakeUnmaskedPhysicalSErrorInterrupts iesb_req = {
    interrupt_req : InterruptReq = undefined : InterruptReq;
    interrupt_req.take_SE = false;
    interrupt_req.take_vSE = false;
    interrupt_req.take_FIQ = false;
    interrupt_req.take_vFIQ = false;
    interrupt_req.take_IRQ = false;
    interrupt_req.take_vIRQ = false;
    interrupt_req.iesb_req = false;
    interrupt_req.take_SE = true;
    interrupt_req.iesb_req = iesb_req;
    let interrupt_taken : bool = TakePendingInterrupts(interrupt_req);
    return()
}

val ExclusiveMonitorsStatus : unit -> bits(1)

function ExclusiveMonitorsStatus () = {
    0b0
}

val __UNKNOWN_Exception : unit -> Exception

function __UNKNOWN_Exception () = {
    Exception_Uncategorized
}

register EventRegister : bits(1)

val SendEventLocal : unit -> unit effect {wreg}

function SendEventLocal () = {
    EventRegister = 0b1;
    return()
}

val SendEvent : unit -> unit effect {wreg}

function SendEvent () = {
    SendEventLocal();
    return()
}

val EndOfInstruction : unit -> unit effect {escape}

function EndOfInstruction () = {
    throw(Error_ExceptionTaken())
}

register ESR_EL3 : bits(32)

register ESR_EL2 : bits(32)

val set_HSR : bits(32) -> unit effect {rreg, wreg}

function set_HSR val_name = {
    let r : bits(32) = val_name;
    ESR_EL2 = __SetSlice_bits(32, 32, ESR_EL2, 0, slice(r, 0, 32));
    return()
}

register ESR_EL1 : bits(32)

val set_DFSR_NS : bits(32) -> unit effect {rreg, wreg}

function set_DFSR_NS val_name = {
    let r : bits(32) = val_name;
    ESR_EL1 = __SetSlice_bits(32, 32, ESR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DFSR_NS : unit -> bits(32) effect {rreg, undef}

function get_DFSR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ESR_EL1, 0, 32));
    r
}

register ESR_EL0 : bits(32)

register ESP_EL0 : bits(64)

val TweakCellRot : bits(4) -> bits(4) effect {undef}

function TweakCellRot incell_name = {
    outcell : bits(4) = undefined : bits(4);
    outcell = __SetSlice_bits(4, 1, outcell, 3, [incell_name[0]] ^ [incell_name[1]]);
    outcell = __SetSlice_bits(4, 1, outcell, 2, [incell_name[3]]);
    outcell = __SetSlice_bits(4, 1, outcell, 1, [incell_name[2]]);
    let outcell = __SetSlice_bits(4, 1, outcell, 0, [incell_name[1]]);
    outcell
}

val TweakShuffle : bits(64) -> bits(64) effect {undef}

function TweakShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, slice(indata, 16, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, TweakCellRot(slice(indata, 24, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 28, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, TweakCellRot(slice(indata, 44, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 8, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 28, TweakCellRot(slice(indata, 32, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 32, slice(indata, 48, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 36, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 40, slice(indata, 56, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 44, TweakCellRot(slice(indata, 60, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 48, TweakCellRot(slice(indata, 0, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, TweakCellRot(slice(indata, 40, 4)));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, TweakCellRot(slice(indata, 36, 4)));
    outdata
}

val TweakCellInvRot : bits(4) -> bits(4) effect {undef}

function TweakCellInvRot incell_name = {
    outcell : bits(4) = undefined : bits(4);
    outcell = __SetSlice_bits(4, 1, outcell, 3, [incell_name[2]]);
    outcell = __SetSlice_bits(4, 1, outcell, 2, [incell_name[1]]);
    outcell = __SetSlice_bits(4, 1, outcell, 1, [incell_name[0]]);
    let outcell = __SetSlice_bits(4, 1, outcell, 0, [incell_name[0]] ^ [incell_name[3]]);
    outcell
}

val TweakInvShuffle : bits(64) -> bits(64) effect {undef}

function TweakInvShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, TweakCellInvRot(slice(indata, 48, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 24, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, slice(indata, 0, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, TweakCellInvRot(slice(indata, 8, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 28, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 32, TweakCellInvRot(slice(indata, 28, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 36, TweakCellInvRot(slice(indata, 60, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 40, TweakCellInvRot(slice(indata, 56, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 44, TweakCellInvRot(slice(indata, 16, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 48, slice(indata, 32, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 36, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, slice(indata, 40, 4));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, TweakCellInvRot(slice(indata, 44, 4)));
    outdata
}

val TLBIndex : (bits(64), TLBContext) -> bits(10) effect {undef}

function TLBIndex (address, context) = {
    res : bits(10) = undefined : bits(10);
    res = slice(address, context.granule_size, 10);
    if context.secondstage then {
        res = res ^ __GetSlice_int(10, 144, 0)
    };
    res
}

val SHAparity : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAparity (x, y, z) = {
    (x ^ y) ^ z
}

register ELR_EL3 : bits(64)

register ELR_EL2 : bits(64)

val set_ELR_hyp : bits(32) -> unit effect {rreg, wreg}

function set_ELR_hyp val_name = {
    let r : bits(32) = val_name;
    ELR_EL2 = __SetSlice_bits(64, 32, ELR_EL2, 0, slice(r, 0, 32));
    return()
}

register ELR_EL1 : bits(64)

register ELR_EL0 : bits(64)

let EL3 : vector(2, dec, bit) = 0b11

let EL2 : vector(2, dec, bit) = 0b10

let EL1 : vector(2, dec, bit) = 0b01

let EL0 : vector(2, dec, bit) = 0b00

register EDVIDSR : bits(32)

register EDSCR : bits(32)

register EDPRSR : bits(32)

register EDPRCR : bits(32)

register EDPFR : bits(64)

register EDPCSR : bits(64)

register EDLSR : bits(32)

register EDESR : bits(32)

register EDECR : bits(32)

register EDECCR : bits(32)

val __UNKNOWN_DeviceType : unit -> DeviceType

function __UNKNOWN_DeviceType () = {
    DeviceType_GRE
}

let DefaultPMG : vector(8, dec, bit) = __GetSlice_int(8, 0, 0)

let DefaultPARTID : vector(16, dec, bit) = __GetSlice_int(16, 0, 0)

val DefaultMPAMinfo : forall ('secure : Bool).
  bool('secure) -> MPAMinfo effect {undef}

function DefaultMPAMinfo secure = {
    DefaultInfo : MPAMinfo = undefined : MPAMinfo;
    DefaultInfo.mpam_ns = if secure then 0b0 else 0b1;
    DefaultInfo.partid = DefaultPARTID;
    DefaultInfo.pmg = DefaultPMG;
    DefaultInfo
}

val DecodeShift : bits(2) -> ShiftType

function DecodeShift op = {
    match op {
      0b00 => {
          return(ShiftType_LSL)
      },
      0b01 => {
          return(ShiftType_LSR)
      },
      0b10 => {
          return(ShiftType_ASR)
      },
      0b11 => {
          return(ShiftType_ROR)
      }
    }
}

val DecodeRegExtend : bits(3) -> ExtendType

function DecodeRegExtend op = {
    match op {
      0b000 => {
          return(ExtendType_UXTB)
      },
      0b001 => {
          return(ExtendType_UXTH)
      },
      0b010 => {
          return(ExtendType_UXTW)
      },
      0b011 => {
          return(ExtendType_UXTX)
      },
      0b100 => {
          return(ExtendType_SXTB)
      },
      0b101 => {
          return(ExtendType_SXTH)
      },
      0b110 => {
          return(ExtendType_SXTW)
      },
      0b111 => {
          return(ExtendType_SXTX)
      }
    }
}

let DebugHalt_Watchpoint : vector(6, dec, bit) = 0b101011

let DebugHalt_HaltInstruction : vector(6, dec, bit) = 0b101111

let DebugHalt_Breakpoint : vector(6, dec, bit) = 0b000111

let DebugException_Watchpoint : vector(4, dec, bit) = 0xA

let DebugException_VectorCatch : vector(4, dec, bit) = 0x5

let DebugException_Breakpoint : vector(4, dec, bit) = 0x1

val DataSynchronizationBarrier : (MBReqDomain, MBReqTypes) -> unit

function DataSynchronizationBarrier (domain, types) = {
    return()
}

val DataMemoryBarrier : (MBReqDomain, MBReqTypes) -> unit

function DataMemoryBarrier (domain, types) = {
    return()
}

val system_barriers : (MBReqDomain, MemBarrierOp, MBReqTypes) -> unit

function system_barriers (domain, op, types) = {
    match op {
      MemBarrierOp_DSB => {
          DataSynchronizationBarrier(domain, types)
      },
      MemBarrierOp_DMB => {
          DataMemoryBarrier(domain, types)
      },
      MemBarrierOp_ISB => {
          InstructionSynchronizationBarrier()
      },
      MemBarrierOp_SSBB => {
          SpeculativeSynchronizationBarrierToVA()
      },
      MemBarrierOp_PSSBB => {
          SpeculativeSynchronizationBarrierToPA()
      },
      MemBarrierOp_SB => {
          SpeculationBarrier()
      }
    }
}

val DVP_RCTX : bits(64) -> unit

function DVP_RCTX val_name = {
    return()
}

register DSPSR_EL0 : bits(32)

val set_DSPSR : bits(32) -> unit effect {rreg, wreg}

function set_DSPSR val_name = {
    let r : bits(32) = val_name;
    DSPSR_EL0 = __SetSlice_bits(32, 32, DSPSR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_DSPSR : unit -> bits(32) effect {rreg, undef}

function get_DSPSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DSPSR_EL0, 0, 32));
    r
}

register DLR_EL0 : bits(64)

val set_DLR : bits(32) -> unit effect {rreg, wreg}

function set_DLR val_name = {
    let r : bits(32) = val_name;
    DLR_EL0 = __SetSlice_bits(64, 32, DLR_EL0, 0, slice(r, 0, 32));
    return()
}

register DISR_EL1 : bits(64)

val set_DISR : bits(32) -> unit effect {rreg, wreg}

function set_DISR val_name = {
    DISR_EL1 = __SetSlice_bits(64, 32, DISR_EL1, 0, val_name)
}

register DFSR_S : bits(32)

val DC_CVADP : bits(64) -> unit

function DC_CVADP val_name = {
    return()
}

register DCZID_EL0 : bits(32)

register DBGWVR_EL1 : vector(17, dec, bits(64))

register DBGWVR : vector(17, dec, bits(32))

register DBGWFAR : bits(32)

register DBGWCR_EL1 : vector(17, dec, bits(32))

register DBGWCR : vector(17, dec, bits(32))

register DBGVCR32_EL2 : bits(32)

val set_DBGVCR : bits(32) -> unit effect {rreg, wreg}

function set_DBGVCR val_name = {
    let r : bits(32) = val_name;
    DBGVCR32_EL2 = __SetSlice_bits(32, 32, DBGVCR32_EL2, 0, slice(r, 0, 32));
    return()
}

val get_DBGVCR : unit -> bits(32) effect {rreg, undef}

function get_DBGVCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGVCR32_EL2, 0, 32));
    r
}

register DBGPRCR_EL1 : bits(32)

val set_DBGPRCR : bits(32) -> unit effect {rreg, wreg}

function set_DBGPRCR val_name = {
    let r : bits(32) = val_name;
    DBGPRCR_EL1 = __SetSlice_bits(32, 32, DBGPRCR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGPRCR : unit -> bits(32) effect {rreg, undef}

function get_DBGPRCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGPRCR_EL1, 0, 32));
    r
}

register DBGEN : signal

register DBGDTR_EL0 : bits(64)

register DBGDTRTX_EL0 : bits(32)

register DBGDTRRX_EL0 : bits(32)

register DBGDSCRint : bits(32)

register DBGDIDR : bits(32)

register DBGDEVID2 : bits(32)

register DBGDEVID1 : bits(32)

register DBGCLAIMSET_EL1 : bits(32)

val set_DBGCLAIMSET : bits(32) -> unit effect {rreg, wreg}

function set_DBGCLAIMSET val_name = {
    let r : bits(32) = val_name;
    DBGCLAIMSET_EL1 = __SetSlice_bits(32, 32, DBGCLAIMSET_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGCLAIMSET : unit -> bits(32) effect {rreg, undef}

function get_DBGCLAIMSET () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGCLAIMSET_EL1, 0, 32));
    r
}

register DBGCLAIMCLR_EL1 : bits(32)

val set_DBGCLAIMCLR : bits(32) -> unit effect {rreg, wreg}

function set_DBGCLAIMCLR val_name = {
    let r : bits(32) = val_name;
    DBGCLAIMCLR_EL1 = __SetSlice_bits(32, 32, DBGCLAIMCLR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGCLAIMCLR : unit -> bits(32) effect {rreg, undef}

function get_DBGCLAIMCLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGCLAIMCLR_EL1, 0, 32));
    r
}

register DBGBXVR : vector(17, dec, bits(32))

register DBGBVR_EL1 : vector(17, dec, bits(64))

register DBGBVR : vector(17, dec, bits(32))

register DBGBCR_EL1 : vector(17, dec, bits(32))

register DBGBCR : vector(17, dec, bits(32))

register DBGAUTHSTATUS_EL1 : bits(32)

val set_DBGAUTHSTATUS : bits(32) -> unit effect {rreg, wreg}

function set_DBGAUTHSTATUS val_name = {
    let r : bits(32) = val_name;
    DBGAUTHSTATUS_EL1 = __SetSlice_bits(32, 32, DBGAUTHSTATUS_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGAUTHSTATUS : unit -> bits(32) effect {rreg, undef}

function get_DBGAUTHSTATUS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGAUTHSTATUS_EL1, 0, 32));
    r
}

register DACR_S : bits(32)

register DACR32_EL2 : bits(32)

val get_DACR_NS : unit -> bits(32) effect {rreg, undef}

function get_DACR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DACR32_EL2, 0, 32));
    r
}

val ConsumptionOfSpeculativeDataBarrier : unit -> unit

function ConsumptionOfSpeculativeDataBarrier () = {
    return()
}

val __UNKNOWN_Constraint : unit -> Constraint

function __UNKNOWN_Constraint () = {
    Constraint_NONE
}

val ConstrainUnpredictable : Unpredictable -> Constraint

function ConstrainUnpredictable which = {
    match which {
      Unpredictable_WBOVERLAPLD => {
          return(Constraint_WBSUPPRESS)
      },
      Unpredictable_WBOVERLAPST => {
          return(Constraint_NONE)
      },
      Unpredictable_LDPOVERLAP => {
          return(Constraint_UNDEF)
      },
      Unpredictable_BASEOVERLAP => {
          return(Constraint_NONE)
      },
      Unpredictable_DATAOVERLAP => {
          return(Constraint_NONE)
      },
      Unpredictable_DEVPAGE2 => {
          return(Constraint_FAULT)
      },
      Unpredictable_INSTRDEVICE => {
          return(Constraint_NONE)
      },
      Unpredictable_RESCPACR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESMAIR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESTEXCB => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESDACR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESPRRR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESVTCRS => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESTnSZ => {
          return(Constraint_FORCE)
      },
      Unpredictable_OORTnSZ => {
          return(Constraint_FORCE)
      },
      Unpredictable_LARGEIPA => {
          if __unpred_tsize_aborts then {
              return(Constraint_FAULT)
          } else {
              return(Constraint_FORCE)
          }
      },
      Unpredictable_ESRCONDPASS => {
          return(Constraint_FALSE)
      },
      Unpredictable_ILZEROIT => {
          return(Constraint_FALSE)
      },
      Unpredictable_ILZEROT => {
          return(Constraint_FALSE)
      },
      Unpredictable_BPVECTORCATCHPRI => {
          return(Constraint_TRUE)
      },
      Unpredictable_VCMATCHHALF => {
          return(Constraint_FALSE)
      },
      Unpredictable_VCMATCHDAPA => {
          return(Constraint_FALSE)
      },
      Unpredictable_WPMASKANDBAS => {
          return(Constraint_FALSE)
      },
      Unpredictable_WPBASCONTIGUOUS => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESWPMASK => {
          return(Constraint_DISABLED)
      },
      Unpredictable_WPMASKEDBITS => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESBPWPCTRL => {
          return(Constraint_DISABLED)
      },
      Unpredictable_BPNOTIMPL => {
          return(Constraint_DISABLED)
      },
      Unpredictable_RESBPTYPE => {
          return(Constraint_DISABLED)
      },
      Unpredictable_BPNOTCTXCMP => {
          return(Constraint_DISABLED)
      },
      Unpredictable_BPMATCHHALF => {
          return(Constraint_FALSE)
      },
      Unpredictable_BPMISMATCHHALF => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESTARTALIGNPC => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESTARTZEROUPPERPC => {
          return(Constraint_TRUE)
      },
      Unpredictable_ZEROUPPER => {
          return(Constraint_TRUE)
      },
      Unpredictable_ERETZEROUPPERPC => {
          return(Constraint_TRUE)
      },
      Unpredictable_A32FORCEALIGNPC => {
          return(Constraint_FALSE)
      },
      Unpredictable_SMD => {
          return(Constraint_UNDEF)
      },
      Unpredictable_AFUPDATE => {
          return(Constraint_TRUE)
      },
      Unpredictable_IESBinDebug => {
          return(Constraint_TRUE)
      },
      Unpredictable_ZEROBTYPE => {
          return(Constraint_TRUE)
      },
      Unpredictable_CLEARERRITEZERO => {
          return(Constraint_FALSE)
      }
    }
}

val __UNKNOWN_CompareOp : unit -> CompareOp

function __UNKNOWN_CompareOp () = {
    CompareOp_GT
}

val ClearPendingVirtualSError : unit -> unit effect {rreg, wreg}

function ClearPendingVirtualSError () = {
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 8, 0b0)
}

val ClearPendingPhysicalSError : unit -> unit effect {wreg}

function ClearPendingPhysicalSError () = {
    _PendingPhysicalSE = false
}

val ClearExclusiveLocal : forall ('processorid : Int).
  int('processorid) -> unit effect {undef, wreg}

function ClearExclusiveLocal processorid = {
    __exclusive_block_address = undefined : bits(52);
    return()
}

val ClearEventRegister : unit -> unit effect {wreg}

function ClearEventRegister () = {
    EventRegister = 0b0;
    return()
}

register CTR_EL0 : bits(64)

val set_CTR : bits(32) -> unit effect {rreg, wreg}

function set_CTR val_name = {
    let r : bits(32) = val_name;
    CTR_EL0 = __SetSlice_bits(64, 32, CTR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CTR : unit -> bits(32) effect {rreg, undef}

function get_CTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CTR_EL0, 0, 32));
    r
}

val CTI_SignalEvent : CrossTriggerIn -> unit effect {escape}

function CTI_SignalEvent id = {
    throw(Error_Implementation_Defined("CTI_SignalEvent unimplemented"))
}

register CSSELR_S : bits(32)

register CSSELR_EL1 : bits(32)

val set_CSSELR_NS : bits(32) -> unit effect {rreg, wreg}

function set_CSSELR_NS val_name = {
    let r : bits(32) = val_name;
    CSSELR_EL1 = __SetSlice_bits(32, 32, CSSELR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CSSELR_NS : unit -> bits(32) effect {rreg, undef}

function get_CSSELR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CSSELR_EL1, 0, 32));
    r
}

register CPTR_EL3 : bits(32)

val CPP_RCTX : bits(64) -> unit

function CPP_RCTX val_name = {
    return()
}

register CPACR_EL1 : bits(32)

val set_CPACR : bits(32) -> unit effect {rreg, wreg}

function set_CPACR val_name = {
    let r : bits(32) = val_name;
    CPACR_EL1 = __SetSlice_bits(32, 32, CPACR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CPACR : unit -> bits(32) effect {rreg, undef}

function get_CPACR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CPACR_EL1, 0, 32));
    r
}

register CONTEXTIDR_EL2 : bits(32)

register CONTEXTIDR_EL1 : bits(32)

register CNTV_TVAL_EL0 : bits(32)

register CNTV_CVAL_EL0 : bits(64)

register CNTV_CTL_EL0 : bits(32)

val set_CNTV_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTV_CTL val_name = {
    let r : bits(32) = val_name;
    CNTV_CTL_EL0 = __SetSlice_bits(32, 32, CNTV_CTL_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CNTV_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTV_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTV_CTL_EL0, 0, 32));
    r
}

register CNTVOFF_EL2 : bits(64)

register CNTVCT_EL0 : bits(64)

register CNTSR : bits(32)

register CNTP_TVAL_EL0 : bits(32)

register CNTP_CVAL_EL0 : bits(64)

register CNTP_CTL_S : bits(32)

register CNTP_CTL_EL0 : bits(32)

val set_CNTP_CTL_NS : bits(32) -> unit effect {rreg, wreg}

function set_CNTP_CTL_NS val_name = {
    let r : bits(32) = val_name;
    CNTP_CTL_EL0 = __SetSlice_bits(32, 32, CNTP_CTL_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CNTP_CTL_NS : unit -> bits(32) effect {rreg, undef}

function get_CNTP_CTL_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTP_CTL_EL0, 0, 32));
    r
}

register CNTPS_TVAL_EL1 : bits(32)

register CNTPS_CVAL_EL1 : bits(64)

register CNTPS_CTL_EL1 : bits(32)

register CNTPCT_EL0 : bits(64)

register CNTKCTL_EL1 : bits(32)

val set_CNTKCTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTKCTL val_name = {
    let r : bits(32) = val_name;
    CNTKCTL_EL1 = __SetSlice_bits(32, 32, CNTKCTL_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CNTKCTL : unit -> bits(32) effect {rreg, undef}

function get_CNTKCTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTKCTL_EL1, 0, 32));
    r
}

register CNTHV_TVAL_EL2 : bits(32)

register CNTHV_CVAL_EL2 : bits(64)

register CNTHV_CTL_EL2 : bits(32)

val set_CNTHV_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHV_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHV_CTL_EL2 = __SetSlice_bits(32, 32, CNTHV_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHV_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHV_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHV_CTL_EL2, 0, 32));
    r
}

register CNTHVS_TVAL_EL2 : bits(32)

register CNTHVS_CVAL_EL2 : bits(64)

register CNTHVS_CTL_EL2 : bits(32)

val set_CNTHVS_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHVS_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHVS_CTL_EL2 = __SetSlice_bits(32, 32, CNTHVS_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHVS_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHVS_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHVS_CTL_EL2, 0, 32));
    r
}

register CNTHP_TVAL_EL2 : bits(32)

register CNTHP_CVAL_EL2 : bits(64)

register CNTHP_CTL_EL2 : bits(32)

val set_CNTHP_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHP_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHP_CTL_EL2 = __SetSlice_bits(32, 32, CNTHP_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHP_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHP_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHP_CTL_EL2, 0, 32));
    r
}

register CNTHPS_TVAL_EL2 : bits(32)

register CNTHPS_CVAL_EL2 : bits(64)

register CNTHPS_CTL_EL2 : bits(32)

val set_CNTHPS_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHPS_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHPS_CTL_EL2 = __SetSlice_bits(32, 32, CNTHPS_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHPS_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHPS_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHPS_CTL_EL2, 0, 32));
    r
}

register CNTFRQ_EL0 : bits(32)

register CNTFID0 : bits(32)

register CNTCV : bits(64)

register CNTCR : bits(32)

val __WriteMemoryMappedCounterRegister : forall ('address : Int).
  (int('address), bits(32)) -> unit effect {rreg, wreg}

function __WriteMemoryMappedCounterRegister (address, val_name) = {
    match address {
      0 => {
          CNTCR = val_name
      },
      4 => {
          CNTSR = val_name
      },
      8 => {
          CNTCV = __SetSlice_bits(64, 32, CNTCV, 0, val_name)
      },
      12 => {
          CNTCV = __SetSlice_bits(64, 32, CNTCV, 32, val_name)
      },
      32 => {
          CNTFID0 = val_name
      },
      _ => {
          return()
      }
    }
}

val __ReadMemoryMappedCounterRegister : forall ('address : Int).
  int('address) -> bits(32) effect {rreg, undef}

function __ReadMemoryMappedCounterRegister address = {
    match address {
      0 => {
          return(CNTCR)
      },
      4 => {
          return(CNTSR)
      },
      8 => {
          return(slice(CNTCV, 0, 32))
      },
      12 => {
          return(slice(CNTCV, 32, 32))
      },
      32 => {
          return(CNTFID0)
      },
      _ => {
          return(undefined : bits(32))
      }
    }
}

register CLIDR_EL1 : bits(64)

val set_CLIDR : bits(32) -> unit effect {rreg, wreg}

function set_CLIDR val_name = {
    let r : bits(32) = val_name;
    CLIDR_EL1 = __SetSlice_bits(64, 32, CLIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CLIDR : unit -> bits(32) effect {rreg, undef}

function get_CLIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CLIDR_EL1, 0, 32));
    r
}

val CFP_RCTX : bits(64) -> unit

function CFP_RCTX val_name = {
    return()
}

register configuration CFG_RVBAR : bits(64) = __GetSlice_int(64, 271581184, 0)

register configuration CFG_RMR_AA64 : bits(1) = 0b1

register configuration CFG_ID_AA64PFR0_EL1_MPAM : bits(4) = 0x1

register configuration CFG_ID_AA64PFR0_EL1_EL3 : bits(4) = 0x2

register configuration CFG_ID_AA64PFR0_EL1_EL2 : bits(4) = 0x2

register configuration CFG_ID_AA64PFR0_EL1_EL1 : bits(4) = 0x2

register configuration CFG_ID_AA64PFR0_EL1_EL0 : bits(4) = 0x2

register CCSIDR2_EL1 : bits(32)

val set_CCSIDR2 : bits(32) -> unit effect {rreg, wreg}

function set_CCSIDR2 val_name = {
    let r : bits(32) = val_name;
    CCSIDR2_EL1 = __SetSlice_bits(32, 32, CCSIDR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CCSIDR2 : unit -> bits(32) effect {rreg, undef}

function get_CCSIDR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CCSIDR2_EL1, 0, 32));
    r
}

val __UNKNOWN_BranchType : unit -> BranchType

function __UNKNOWN_BranchType () = {
    BranchType_DIRCALL
}

register BTypeNext : bits(2)

register BTypeCompatible : bool

val AsynchronousErrorType : unit -> AsyncErrorType

function AsynchronousErrorType () = {
    AsyncErrorType_UC
}

val __UNKNOWN_AccType : unit -> AccType

function __UNKNOWN_AccType () = {
    AccType_NORMAL
}

register AbortRgn64Lo2_Hi : bits(32)

register AbortRgn64Lo2 : bits(32)

register AbortRgn64Lo1_Hi : bits(32)

register AbortRgn64Lo1 : bits(32)

register AbortRgn64Hi2_Hi : bits(32)

register AbortRgn64Hi2 : bits(32)

register AbortRgn64Hi1_Hi : bits(32)

register AbortRgn64Hi1 : bits(32)

register APIBKeyLo_EL1 : bits(64)

register APIBKeyHi_EL1 : bits(64)

register APIAKeyLo_EL1 : bits(64)

register APIAKeyHi_EL1 : bits(64)

register APGAKeyLo_EL1 : bits(64)

register APGAKeyHi_EL1 : bits(64)

register APDBKeyLo_EL1 : bits(64)

register APDBKeyHi_EL1 : bits(64)

register APDAKeyLo_EL1 : bits(64)

register APDAKeyHi_EL1 : bits(64)

val set_TargetCPU : bits(32) -> unit effect {wreg}

function set_TargetCPU val_name = {
    let _val : bits(32) = val_name & ~(__GetSlice_int(32, 4294967280, 0)) | __GetSlice_int(32, 0, 0);
    _TargetCPU = _val;
    return()
}

val set_AXIAbortCtl : bits(32) -> unit effect {wreg}

function set_AXIAbortCtl val_name = {
    let _val : bits(32) = val_name & ~(__GetSlice_int(32, 4027580415, 0)) | __GetSlice_int(32, 0, 0);
    _AXIAbortCtl = _val;
    return()
}

val get_TargetCPU : unit -> bits(32) effect {rreg}

function get_TargetCPU () = {
    val_name : bits(32) = _TargetCPU;
    let val_name = val_name & ~(__GetSlice_int(32, 4294967280, 0)) | __GetSlice_int(32, 0, 0);
    val_name
}

val get_AXIAbortCtl : unit -> bits(32) effect {rreg}

function get_AXIAbortCtl () = {
    val_name : bits(32) = _AXIAbortCtl;
    let val_name = val_name & ~(__GetSlice_int(32, 4027580415, 0)) | __GetSlice_int(32, 0, 0);
    val_name
}

val system_register_cpsr : (PSTATEField, bits(4)) -> unit effect {rreg, wreg}

function system_register_cpsr (field, operand) = {
    match field {
      PSTATEField_SP => {
          PSTATE.SP = [operand[0]]
      },
      PSTATEField_DAIFSet => {
          PSTATE.D = PSTATE.D | [operand[3]];
          PSTATE.A = PSTATE.A | [operand[2]];
          PSTATE.I = PSTATE.I | [operand[1]];
          PSTATE.F = PSTATE.F | [operand[0]]
      },
      PSTATEField_DAIFClr => {
          PSTATE.D = PSTATE.D & ~([operand[3]]);
          PSTATE.A = PSTATE.A & ~([operand[2]]);
          PSTATE.I = PSTATE.I & ~([operand[1]]);
          PSTATE.F = PSTATE.F & ~([operand[0]])
      },
      PSTATEField_PAN => {
          PSTATE.PAN = [operand[0]]
      },
      PSTATEField_UAO => {
          PSTATE.UAO = [operand[0]]
      },
      PSTATEField_DIT => {
          PSTATE.DIT = [operand[0]]
      }
    }
}

val integer_flags_xaflag : unit -> unit effect {rreg, wreg}

function integer_flags_xaflag () = {
    let N : vector(1, dec, bit) = ~(PSTATE.C) & ~(PSTATE.Z);
    let Z : vector(1, dec, bit) = PSTATE.Z & PSTATE.C;
    let C : vector(1, dec, bit) = PSTATE.C | PSTATE.Z;
    let V : vector(1, dec, bit) = ~(PSTATE.C) & PSTATE.Z;
    PSTATE.N = N;
    PSTATE.Z = Z;
    PSTATE.C = C;
    PSTATE.V = V
}

val integer_flags_axflag : unit -> unit effect {rreg, wreg}

function integer_flags_axflag () = {
    let N : vector(1, dec, bit) = 0b0;
    let Z : vector(1, dec, bit) = PSTATE.Z | PSTATE.V;
    let C : vector(1, dec, bit) = PSTATE.C & ~(PSTATE.V);
    let V : vector(1, dec, bit) = 0b0;
    PSTATE.N = N;
    PSTATE.Z = Z;
    PSTATE.C = C;
    PSTATE.V = V
}

val SHAmajority : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAmajority (x, y, z) = {
    x & y | (x | y) & z
}

val SHAchoose : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAchoose (x, y, z) = {
    (y ^ z & x) ^ z
}

register AMAIR_EL3 : bits(64)

register AMAIR_EL2 : bits(64)

register AMAIR_EL1 : bits(64)

register AIDR_EL1 : bits(32)

register AFSR1_EL3 : bits(32)

register AFSR1_EL2 : bits(32)

register AFSR1_EL1 : bits(32)

register AFSR0_EL3 : bits(32)

register AFSR0_EL2 : bits(32)

register AFSR0_EL1 : bits(32)

val AESSubBytes : bits(128) -> bits(128) effect {escape}

function AESSubBytes op = {
    throw(Error_Implementation_Defined("AESSubBytes unimplemented"))
}

val AESShiftRows : bits(128) -> bits(128) effect {escape}

function AESShiftRows op = {
    throw(Error_Implementation_Defined("AESShiftRows unimplemented"))
}

val AESMixColumns : bits(128) -> bits(128) effect {escape}

function AESMixColumns op = {
    throw(Error_Implementation_Defined("AESMixColumns unimplemented"))
}

val AESInvSubBytes : bits(128) -> bits(128) effect {escape}

function AESInvSubBytes op = {
    throw(Error_Implementation_Defined("AESInvSubBytes unimplemented"))
}

val AESInvShiftRows : bits(128) -> bits(128) effect {escape}

function AESInvShiftRows op = {
    throw(Error_Implementation_Defined("AESInvShiftRows unimplemented"))
}

val AESInvMixColumns : bits(128) -> bits(128) effect {escape}

function AESInvMixColumns op = {
    throw(Error_Implementation_Defined("AESInvMixColumns unimplemented"))
}

register ACTLR_EL3 : bits(64)

register ACTLR_EL2 : bits(64)

register ACTLR_EL1 : bits(64)

val AArch64_ReportDeferredSError : bits(25) -> bits(64) effect {undef}

function AArch64_ReportDeferredSError syndrome = {
    target : bits(64) = undefined : bits(64);
    target = __SetSlice_bits(64, 1, target, 31, 0b1);
    target = __SetSlice_bits(64, 1, target, 24, [syndrome[24]]);
    let target = __SetSlice_bits(64, 24, target, 0, slice(syndrome, 0, 24));
    target
}

val AArch64_MarkExclusiveVA : forall ('processorid : Int) ('size : Int).
  (bits(64), int('processorid), int('size)) -> unit

function AArch64_MarkExclusiveVA (address, processorid, size) = {
    return()
}

val AArch64_IsExclusiveVA : forall ('processorid : Int) ('size : Int).
  (bits(64), int('processorid), int('size)) -> bool

function AArch64_IsExclusiveVA (address, processorid, size) = {
    true
}

val AArch64_CreateFaultRecord : forall 'level ('write : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (Fault, bits(52), bits(1), int('level), AccType, bool('write), bits(1), bits(2), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_CreateFaultRecord (typ, ipaddress, NS, level, acctype, write, extflag, errortype, secondstage, s2fs1walk) = {
    fault : FaultRecord = undefined : FaultRecord;
    fault.typ = typ;
    fault.domain = undefined : bits(4);
    fault.debugmoe = undefined : bits(4);
    fault.errortype = errortype;
    __tc1 : FullAddress = fault.ipaddress;
    __tc1.NS = NS;
    fault.ipaddress = __tc1;
    __tc2 : FullAddress = fault.ipaddress;
    __tc2.address = ipaddress;
    fault.ipaddress = __tc2;
    fault.level = level;
    fault.acctype = acctype;
    fault.write = write;
    fault.extflag = extflag;
    fault.secondstage = secondstage;
    fault.s2fs1walk = s2fs1walk;
    fault
}

val AArch64_TranslationFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(52), bits(1), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_TranslationFault (ipaddress, NS, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch64_CreateFaultRecord(Fault_Translation, ipaddress, NS, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk)
}

val AArch64_PermissionFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(52), bits(1), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_PermissionFault (ipaddress, NS, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch64_CreateFaultRecord(Fault_Permission, ipaddress, NS, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk)
}

val AArch64_NoFault : unit -> FaultRecord effect {undef}

function AArch64_NoFault () = {
    let ipaddress : vector(52, dec, bit) = undefined : bits(52);
    let level : int = undefined : int;
    let acctype : AccType = AccType_NORMAL;
    let iswrite : bool = undefined : bool;
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    let secondstage : bool(false) = false;
    let s2fs1walk : bool(false) = false;
    AArch64_CreateFaultRecord(Fault_None, ipaddress, undefined : bits(1), level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk)
}

val AArch64_DebugFault : forall ('iswrite : Bool).
  (AccType, bool('iswrite)) -> FaultRecord effect {undef}

function AArch64_DebugFault (acctype, iswrite) = {
    let ipaddress : vector(52, dec, bit) = undefined : bits(52);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    let level : int = undefined : int;
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let secondstage : bool(false) = false;
    let s2fs1walk : bool(false) = false;
    AArch64_CreateFaultRecord(Fault_Debug, ipaddress, undefined : bits(1), level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk)
}

val AArch64_AlignmentFault : forall ('iswrite : Bool) ('secondstage : Bool).
  (AccType, bool('iswrite), bool('secondstage)) -> FaultRecord effect {undef}

function AArch64_AlignmentFault (acctype, iswrite, secondstage) = {
    let ipaddress : vector(52, dec, bit) = undefined : bits(52);
    let level : int = undefined : int;
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    let s2fs1walk : bool = undefined : bool;
    AArch64_CreateFaultRecord(Fault_Alignment, ipaddress, undefined : bits(1), level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk)
}

val AArch64_AddressSizeFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(52), bits(1), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_AddressSizeFault (ipaddress, NS, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch64_CreateFaultRecord(Fault_AddressSize, ipaddress, NS, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk)
}

val AArch64_AccessFlagFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(52), bits(1), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_AccessFlagFault (ipaddress, NS, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch64_CreateFaultRecord(Fault_AccessFlag, ipaddress, NS, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk)
}

val AArch32_PhysicalSErrorSyndrome : unit -> AArch32_SErrorSyndrome effect {undef}

function AArch32_PhysicalSErrorSyndrome () = {
    value_name : AArch32_SErrorSyndrome = undefined : AArch32_SErrorSyndrome;
    match AsynchronousErrorType() {
      AsyncErrorType_UC => {
          value_name.AET = 0b00
      },
      AsyncErrorType_UEU => {
          value_name.AET = 0b01
      },
      AsyncErrorType_UEO => {
          value_name.AET = 0b10
      },
      AsyncErrorType_UER => {
          value_name.AET = 0b11
      },
      AsyncErrorType_CE => {
          value_name.AET = 0b10
      }
    };
    value_name.ExT = 0b0;
    value_name
}

val AArch32_CurrentCond : unit -> bits(4) effect {rreg}

function AArch32_CurrentCond () = {
    __currentCond
}

val set_TUBE : bits(32) -> unit effect {escape}

function set_TUBE val_name = {
    if UInt(val_name) == 4 then {
        prerr("Program exited by writing ^D to TUBE\n");
        exit(())
    } else {
        putchar(UInt(slice(val_name, 0, 8)))
    }
}

val aget_SP : forall ('width : Int). unit -> bits('width) effect {escape, rreg}

function aget_SP () = {
    assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64);
    if PSTATE.SP == 0b0 then {
        return(slice(SP_EL0, 0, 'width))
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              return(slice(SP_EL0, 0, 'width))
          },
          ? if ? == EL1 => {
              return(slice(SP_EL1, 0, 'width))
          },
          ? if ? == EL2 => {
              return(slice(SP_EL2, 0, 'width))
          },
          ? if ? == EL3 => {
              return(slice(SP_EL3, 0, 'width))
          }
        }
    }
}

overload SP = {aget_SP}

val __PreExecute : forall ('pc : Int) ('len : Int).
  (int('pc), int('len), bits(32)) -> bool effect {rreg, wreg}

function __PreExecute (pc, len, instr) = {
    __currentInstrLength = len;
    __currentInstr = instr;
    __PC_changed = false;
    ShouldAdvanceIT = PSTATE.nRW == 0b1 & PSTATE.T == 0b1;
    true
}

val __IMPDEF_integer_map : string -> int effect {escape}

function __IMPDEF_integer_map x = {
    match () {
      () if x == "Maximum Physical Address Size" => {
          return(52)
      },
      () if x == "Reserved Intermediate Physical Address size value" => {
          return(52)
      },
      () if x == "Maximum Virtual Address Size" => {
          return(52)
      },
      _ => {
          throw(Error_Implementation_Defined("Unrecognized integer"))
      }
    }
}

val __IMPDEF_integer : string -> int effect {escape}

function __IMPDEF_integer x = {
    __IMPDEF_integer_map(x)
}

val VAMax : unit -> int effect {escape}

function VAMax () = {
    __IMPDEF_integer("Maximum Virtual Address Size")
}

val PAMax : unit -> int effect {escape}

function PAMax () = {
    __IMPDEF_integer("Maximum Physical Address Size")
}

val __IMPDEF_boolean_map : string -> bool effect {escape}

function __IMPDEF_boolean_map x = {
    match () {
      () if x == "Reserved Control Space Supported" => {
          return(true)
      },
      () if x == "Reserved Control Space Traps Supported" => {
          return(true)
      },
      () if x == "Reserved Control Space EL0 Trapped" => {
          return(true)
      },
      () if x == "Illegal Execution State on return to AArch32" => {
          return(true)
      },
      () if x == "Floating-Point Traps Support" => {
          return(true)
      },
      () if x == "Floating-Point Traps Information" => {
          return(true)
      },
      () if x == "Condition valid for trapped T32" => {
          return(false)
      },
      () if x == "Translation fault on misprogrammed contiguous bit" => {
          return(false)
      },
      () if x == "Virtual SError syndrome valid" => {
          return(false)
      },
      () if x == "Have CRC extension" => {
          return(true)
      },
      () if x == "Report I-cache maintenance fault in IFSR" => {
          return(false)
      },
      () if x == "UNDEF unallocated CP15 access at EL0" => {
          return(true)
      },
      () if x == "Align PC on illegal exception return" => {
          return(true)
      },
      () if x == "EL from SPSR on illegal exception return" => {
          return(false)
      },
      () if x == "Has AES Crypto instructions" => {
          return(__crypto_aes_implemented == 1 | __crypto_aes_implemented == 2)
      },
      () if x == "Has SHA1 Crypto instructions" => {
          return(__crypto_sha1_implemented)
      },
      () if x == "Has SHA256 Crypto instructions" => {
          return(__crypto_sha256_implemented)
      },
      () if x == "Has 128-bit form of PMULL instructions" => {
          return(__crypto_aes_implemented == 2)
      },
      () if x == "vector instructions set TFV to 1" => {
          return(true)
      },
      () if x == "Has accumulate FP16 product into FP32 extension" => {
          return(true)
      },
      () if x == "Has RAS extension" => {
          return(true)
      },
      () if x == "Has Implicit Error Synchronization Barrier" => {
          return(true)
      },
      () if x == "Implicit Error Synchronization Barrier before Exception" => {
          return(true)
      },
      () if x == "Has Dot Product extension" => {
          return(true)
      },
      () if x == "Has SHA512 Crypto instructions" => {
          return(__crypto_sha512_implemented)
      },
      () if x == "Has SHA3 Crypto instructions" => {
          return(__crypto_sha3_implemented)
      },
      () if x == "Has SM3 Crypto instructions" => {
          return(__crypto_sm3_implemented)
      },
      () if x == "Has SM4 Crypto instructions" => {
          return(__crypto_sm4_implemented)
      },
      () if x == "Has MPAM extension" => {
          return(__mpam_implemented)
      },
      () if x == "Has MTE extension" => {
          return(__mte_implemented)
      },
      () if x == "Has Small Page Table extension" => {
          return(true)
      },
      () if x == "Secure-only implementation" => {
          return(true)
      },
      () if x == "OS Double Lock is implemented" => {
          return(false)
      },
      _ => {
          throw(Error_Implementation_Defined("Unrecognized IMPLEMENTATION_DEFINED boolean"))
      }
    }
}

val __IMPDEF_boolean : string -> bool effect {escape}

function __IMPDEF_boolean x = {
    __IMPDEF_boolean_map(x)
}

val HaveSHA256Ext : unit -> bool effect {escape}

function HaveSHA256Ext () = {
    __IMPDEF_boolean("Has SHA256 Crypto instructions")
}

val HaveSHA1Ext : unit -> bool effect {escape}

function HaveSHA1Ext () = {
    __IMPDEF_boolean("Has SHA1 Crypto instructions")
}

val HaveBit128PMULLExt : unit -> bool effect {escape}

function HaveBit128PMULLExt () = {
    __IMPDEF_boolean("Has 128-bit form of PMULL instructions")
}

val HaveAESExt : unit -> bool effect {escape}

function HaveAESExt () = {
    __IMPDEF_boolean("Has AES Crypto instructions")
}

val TLBContextMatch : (TLBContext, TLBContext) -> bool

function TLBContextMatch (a, b) = {
    (((((a.secondstage == b.secondstage & a.twostage == b.twostage) & a.asid == b.asid) & a.vmid == b.vmid) & a.el == b.el) & a.secure == b.secure) & a.t_sz == b.t_sz
}

register TCR_EL2 : bits(64)

val set_HTCR : bits(32) -> unit effect {rreg, wreg}

function set_HTCR val_name = {
    let r : bits(32) = val_name;
    TCR_EL2 = __SetSlice_bits(64, 32, TCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HTCR : unit -> bits(32) effect {rreg, undef}

function get_HTCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TCR_EL2, 0, 32));
    r
}

val RoundTowardsZero : real -> int

function RoundTowardsZero x = {
    if x == 0.0 then 0 else if x >= 0.0 then RoundDown(x) else RoundUp(x)
}

val Restarting : unit -> bool effect {rreg}

function Restarting () = {
    slice(EDSCR, 0, 6) == 0b000001
}

val ReportTagCheckFail : (bits(2), bits(1)) -> unit effect {escape, rreg, wreg}

function ReportTagCheckFail (el, ttbr) = {
    if el == EL3 then {
        assert(ttbr == 0b0);
        TFSR_EL3 = __SetSlice_bits(32, 1, TFSR_EL3, 0, 0b1)
    } else {
        if el == EL2 then {
            if ttbr == 0b0 then {
                TFSR_EL2 = __SetSlice_bits(32, 1, TFSR_EL2, 0, 0b1)
            } else {
                TFSR_EL2 = __SetSlice_bits(32, 1, TFSR_EL2, 1, 0b1)
            }
        } else {
            if el == EL1 then {
                if ttbr == 0b0 then {
                    TFSR_EL1 = __SetSlice_bits(32, 1, TFSR_EL1, 0, 0b1)
                } else {
                    TFSR_EL1 = __SetSlice_bits(32, 1, TFSR_EL1, 1, 0b1)
                }
            } else {
                if el == EL0 then {
                    if ttbr == 0b0 then {
                        TFSRE0_EL1 = __SetSlice_bits(32, 1, TFSRE0_EL1, 0, 0b1)
                    } else {
                        TFSRE0_EL1 = __SetSlice_bits(32, 1, TFSRE0_EL1, 1, 0b1)
                    }
                }
            }
        }
    }
}

val PtrHasUpperAndLowerAddRanges : unit -> bool effect {rreg}

function PtrHasUpperAndLowerAddRanges () = {
    (PSTATE.EL == EL1 | PSTATE.EL == EL0) | PSTATE.EL == EL2 & [HCR_EL2[34]] == 0b1
}

val PARShareabilityDecode : MemoryAttributes -> bits(2) effect {undef}

function PARShareabilityDecode memattrs = {
    result : bits(2) = undefined : bits(2);
    if memattrs.outer.attrs == MemAttr_NC & memattrs.inner.attrs == MemAttr_NC | memattrs.outershareable then {
        result = 0b10
    } else {
        if memattrs.shareable then {
            result = 0b11
        } else {
            result = 0b00
        }
    };
    result
}

val PARAttrsDecode : MemoryAttributes -> bits(8) effect {undef}

function PARAttrsDecode memattrs = {
    result : bits(8) = undefined : bits(8);
    if memattrs.typ == MemType_Device then {
        result = __SetSlice_bits(8, 4, result, 4, 0x0);
        if memattrs.device == DeviceType_nGnRnE then {
            result = __SetSlice_bits(8, 4, result, 0, 0x0)
        } else {
            if memattrs.device == DeviceType_nGnRE then {
                result = __SetSlice_bits(8, 4, result, 0, 0x4)
            } else {
                if memattrs.device == DeviceType_nGRE then {
                    result = __SetSlice_bits(8, 4, result, 0, 0x8)
                } else {
                    result = __SetSlice_bits(8, 4, result, 0, 0xC)
                }
            }
        }
    } else {
        if memattrs.outer.attrs == MemAttr_WT then {
            result = __SetSlice_bits(8, 2, result, 6, if memattrs.outer.transient then 0b00 else 0b10);
            result = __SetSlice_bits(8, 2, result, 4, memattrs.outer.hints)
        } else {
            if memattrs.outer.attrs == MemAttr_WB then {
                result = __SetSlice_bits(8, 2, result, 6, if memattrs.outer.transient then 0b01 else 0b11);
                result = __SetSlice_bits(8, 2, result, 4, memattrs.outer.hints)
            } else {
                result = __SetSlice_bits(8, 4, result, 4, 0x4)
            }
        };
        if memattrs.inner.attrs == MemAttr_WT then {
            result = __SetSlice_bits(8, 2, result, 2, if memattrs.inner.transient then 0b00 else 0b10);
            result = __SetSlice_bits(8, 2, result, 0, memattrs.inner.hints)
        } else {
            if memattrs.inner.attrs == MemAttr_WB then {
                result = __SetSlice_bits(8, 2, result, 2, if memattrs.inner.transient then 0b01 else 0b11);
                result = __SetSlice_bits(8, 2, result, 0, memattrs.inner.hints)
            } else {
                result = __SetSlice_bits(8, 4, result, 0, 0x4)
            }
        }
    };
    result
}

val MemAttrDefaults : MemoryAttributes -> MemoryAttributes effect {undef}

function MemAttrDefaults memattrs__arg = {
    memattrs = memattrs__arg;
    if memattrs.typ == MemType_Device then {
        memattrs.inner = undefined : MemAttrHints;
        memattrs.outer = undefined : MemAttrHints;
        memattrs.shareable = true;
        memattrs.outershareable = true
    } else {
        memattrs.device = undefined : DeviceType;
        if memattrs.inner.attrs == MemAttr_NC & memattrs.outer.attrs == MemAttr_NC then {
            memattrs.shareable = true;
            memattrs.outershareable = true
        }
    };
    memattrs
}

val IsEventRegisterSet : unit -> bool effect {rreg}

function IsEventRegisterSet () = {
    EventRegister == 0b1
}

val HaveAnyAArch32 : unit -> bool

function HaveAnyAArch32 () = {
    ((CFG_ID_AA64PFR0_EL1_EL0 == 0x2 | CFG_ID_AA64PFR0_EL1_EL1 == 0x2) | CFG_ID_AA64PFR0_EL1_EL2 == 0x2) | CFG_ID_AA64PFR0_EL1_EL3 == 0x2
}

val HasArchVersion : ArchVersion -> bool

function HasArchVersion version = {
    ((((version == ARMv8p0 | version == ARMv8p1 & __v81_implemented) | version == ARMv8p2 & __v82_implemented) | version == ARMv8p3 & __v83_implemented) | version == ARMv8p4 & __v84_implemented) | version == ARMv8p5 & __v85_implemented
}

val HaveVirtHostExt : unit -> bool

function HaveVirtHostExt () = {
    HasArchVersion(ARMv8p1)
}

val HaveUAOExt : unit -> bool

function HaveUAOExt () = {
    HasArchVersion(ARMv8p2)
}

val HaveUA16Ext : unit -> bool

function HaveUA16Ext () = {
    HasArchVersion(ARMv8p4)
}

val HaveTrapLoadStoreMultipleDeviceExt : unit -> bool

function HaveTrapLoadStoreMultipleDeviceExt () = {
    HasArchVersion(ARMv8p2)
}

val HaveStatisticalProfiling : unit -> bool

function HaveStatisticalProfiling () = {
    HasArchVersion(ARMv8p2)
}

val HaveStage2MemAttrControl : unit -> bool

function HaveStage2MemAttrControl () = {
    HasArchVersion(ARMv8p4)
}

val HaveSmallPageTblExt : unit -> bool effect {escape}

function HaveSmallPageTblExt () = {
    HasArchVersion(ARMv8p4) & __IMPDEF_boolean("Has Small Page Table extension")
}

val HaveSelfHostedTrace : unit -> bool

function HaveSelfHostedTrace () = {
    HasArchVersion(ARMv8p4)
}

val HaveSecureEL2Ext : unit -> bool

function HaveSecureEL2Ext () = {
    HasArchVersion(ARMv8p4)
}

val HaveRASExt : unit -> bool effect {escape}

function HaveRASExt () = {
    HasArchVersion(ARMv8p2) | __IMPDEF_boolean("Has RAS extension")
}

val HaveIESB : unit -> bool effect {escape}

function HaveIESB () = {
    HaveRASExt() & __IMPDEF_boolean("Has Implicit Error Synchronization Barrier")
}

val InsertIESBBeforeException : bits(2) -> bool effect {escape}

function InsertIESBBeforeException el = {
    HaveIESB() & __IMPDEF_boolean("Implicit Error Synchronization Barrier before Exception")
}

val HaveQRDMLAHExt : unit -> bool

function HaveQRDMLAHExt () = {
    HasArchVersion(ARMv8p1)
}

val HavePrivATExt : unit -> bool

function HavePrivATExt () = {
    HasArchVersion(ARMv8p2)
}

val HavePANExt : unit -> bool

function HavePANExt () = {
    HasArchVersion(ARMv8p1)
}

val HavePACExt : unit -> bool

function HavePACExt () = {
    HasArchVersion(ARMv8p3)
}

val HaveNVExt : unit -> bool

function HaveNVExt () = {
    HasArchVersion(ARMv8p3)
}

val HaveNV2Ext : unit -> bool

function HaveNV2Ext () = {
    HasArchVersion(ARMv8p4)
}

val HaveMPAMExt : unit -> bool effect {escape}

function HaveMPAMExt () = {
    HasArchVersion(ARMv8p2) & __IMPDEF_boolean("Has MPAM extension")
}

val HaveFrintExt : unit -> bool

function HaveFrintExt () = {
    HasArchVersion(ARMv8p5)
}

val HaveFlagManipulateExt : unit -> bool

function HaveFlagManipulateExt () = {
    HasArchVersion(ARMv8p4)
}

val HaveFlagFormatExt : unit -> bool

function HaveFlagFormatExt () = {
    HasArchVersion(ARMv8p5)
}

val HaveFJCVTZSExt : unit -> bool

function HaveFJCVTZSExt () = {
    HasArchVersion(ARMv8p3)
}

val HaveFCADDExt : unit -> bool

function HaveFCADDExt () = {
    HasArchVersion(ARMv8p3)
}

val HaveExtendedExecuteNeverExt : unit -> bool

function HaveExtendedExecuteNeverExt () = {
    HasArchVersion(ARMv8p2)
}

val HaveExtendedCacheSets : unit -> bool

function HaveExtendedCacheSets () = {
    HasArchVersion(ARMv8p3)
}

register CCSIDR_EL1 : bits(64)

val set_CCSIDR : bits(32) -> unit effect {rreg, wreg}

function set_CCSIDR val_name = {
    let r : bits(32) = val_name;
    CCSIDR_EL1 = __SetSlice_bits(64, 32, CCSIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CCSIDR : unit -> bits(32) effect {rreg, undef}

function get_CCSIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CCSIDR_EL1, 0, 32));
    r
}

val HaveE0PDExt : unit -> bool

function HaveE0PDExt () = {
    HasArchVersion(ARMv8p5)
}

val HaveDirtyBitModifierExt : unit -> bool

function HaveDirtyBitModifierExt () = {
    HasArchVersion(ARMv8p1)
}

val HaveDOTPExt : unit -> bool effect {escape}

function HaveDOTPExt () = {
    HasArchVersion(ARMv8p4) | HasArchVersion(ARMv8p2) & __IMPDEF_boolean("Has Dot Product extension")
}

val HaveDITExt : unit -> bool

function HaveDITExt () = {
    HasArchVersion(ARMv8p4)
}

val HaveCommonNotPrivateTransExt : unit -> bool

function HaveCommonNotPrivateTransExt () = {
    HasArchVersion(ARMv8p2)
}

val HaveCRCExt : unit -> bool effect {escape}

function HaveCRCExt () = {
    HasArchVersion(ARMv8p1) | __IMPDEF_boolean("Have CRC extension")
}

val HaveBlockBBM : unit -> bool

function HaveBlockBBM () = {
    HasArchVersion(ARMv8p4)
}

val IsBlockDescriptorNTBitValid : unit -> bool

function IsBlockDescriptorNTBitValid () = {
    HaveBlockBBM() & (__GetSlice_int(4, __block_bbm_implemented, 0) == 0x1 | __GetSlice_int(4, __block_bbm_implemented, 0) == 0x2)
}

val HaveBTIExt : unit -> bool

function HaveBTIExt () = {
    HasArchVersion(ARMv8p5)
}

val HaveAtomicExt : unit -> bool

function HaveAtomicExt () = {
    HasArchVersion(ARMv8p1)
}

val HaveAccessFlagUpdateExt : unit -> bool

function HaveAccessFlagUpdateExt () = {
    HasArchVersion(ARMv8p1)
}

val Have52BitVAExt : unit -> bool

function Have52BitVAExt () = {
    HasArchVersion(ARMv8p2)
}

val AArch64_HaveHPDExt : unit -> bool

function AArch64_HaveHPDExt () = {
    HasArchVersion(ARMv8p1)
}

val AArch32_HaveHPDExt : unit -> bool

function AArch32_HaveHPDExt () = {
    HasArchVersion(ARMv8p2)
}

val GranuleSizeTG0 : bits(2) -> bits(2)

function GranuleSizeTG0 tg1 = {
    if tg1 == 0b10 then {
        return(0b00)
    } else {
        if tg1 == 0b01 then {
            return(0b10)
        } else {
            return(0b01)
        }
    }
}

val ExternalDebugEnabled : unit -> bool effect {rreg}

function ExternalDebugEnabled () = {
    DBGEN == HIGH
}

val EncodeSDFSC : forall ('level : Int).
  (Fault, int('level)) -> bits(5) effect {escape, undef}

function EncodeSDFSC (typ, level) = {
    result : bits(5) = undefined : bits(5);
    match typ {
      Fault_AccessFlag => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b00011 else 0b00110
      },
      Fault_Alignment => {
          result = 0b00001
      },
      Fault_Permission => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b01101 else 0b01111
      },
      Fault_Domain => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b01001 else 0b01011
      },
      Fault_Translation => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b00101 else 0b00111
      },
      Fault_SyncExternal => {
          result = 0b01000
      },
      Fault_SyncExternalOnWalk => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b01100 else 0b01110
      },
      Fault_SyncParity => {
          result = 0b11001
      },
      Fault_SyncParityOnWalk => {
          assert(level == 1 | level == 2);
          result = if level == 1 then 0b11100 else 0b11110
      },
      Fault_AsyncParity => {
          result = 0b11000
      },
      Fault_AsyncExternal => {
          result = 0b10110
      },
      Fault_Debug => {
          result = 0b00010
      },
      Fault_TLBConflict => {
          result = 0b10000
      },
      Fault_Lockdown => {
          result = 0b10100
      },
      Fault_Exclusive => {
          result = 0b10101
      },
      Fault_ICacheMaint => {
          result = 0b00100
      },
      _ => {
          Unreachable()
      }
    };
    result
}

val ConstrainUnpredictableInteger : forall ('low : Int) ('high : Int).
  (int('low), int('high), Unpredictable) -> (Constraint, int) effect {undef}

function ConstrainUnpredictableInteger (low, high, which) = {
    let c : Constraint = ConstrainUnpredictable(which);
    if c == Constraint_UNKNOWN then {
        return((c, low))
    } else {
        return((c, undefined : int))
    }
}

val ConstrainUnpredictableBool : Unpredictable -> bool effect {escape}

function ConstrainUnpredictableBool which = {
    let c : Constraint = ConstrainUnpredictable(which);
    assert(c == Constraint_TRUE | c == Constraint_FALSE);
    c == Constraint_TRUE
}

val CombineS1S2Device : (DeviceType, DeviceType) -> DeviceType effect {undef}

function CombineS1S2Device (s1device, s2device) = {
    result : DeviceType = undefined : DeviceType;
    if s2device == DeviceType_nGnRnE | s1device == DeviceType_nGnRnE then {
        result = DeviceType_nGnRnE
    } else {
        if s2device == DeviceType_nGnRE | s1device == DeviceType_nGnRE then {
            result = DeviceType_nGnRE
        } else {
            if s2device == DeviceType_nGRE | s1device == DeviceType_nGRE then {
                result = DeviceType_nGRE
            } else {
                result = DeviceType_GRE
            }
        }
    };
    result
}

val CombineS1S2AttrHints : (MemAttrHints, MemAttrHints) -> MemAttrHints effect {rreg, undef}

function CombineS1S2AttrHints (s1desc, s2desc) = {
    result : MemAttrHints = undefined : MemAttrHints;
    if HaveStage2MemAttrControl() & [HCR_EL2[46]] == 0b1 then {
        if s2desc.attrs == MemAttr_WB then {
            result.attrs = s1desc.attrs
        } else {
            if s2desc.attrs == MemAttr_WT then {
                result.attrs = MemAttr_WB
            } else {
                result.attrs = MemAttr_NC
            }
        }
    } else {
        if s2desc.attrs == 0b01 | s1desc.attrs == 0b01 then {
            result.attrs = undefined : bits(2)
        } else {
            if s2desc.attrs == MemAttr_NC | s1desc.attrs == MemAttr_NC then {
                result.attrs = MemAttr_NC
            } else {
                if s2desc.attrs == MemAttr_WT | s1desc.attrs == MemAttr_WT then {
                    result.attrs = MemAttr_WT
                } else {
                    result.attrs = MemAttr_WB
                }
            }
        }
    };
    result.hints = s1desc.hints;
    result.transient = s1desc.transient;
    result
}

register CPTR_EL2 : bits(32)

val set_HCPTR : bits(32) -> unit effect {rreg, wreg}

function set_HCPTR val_name = {
    let r : bits(32) = val_name;
    CPTR_EL2 = __SetSlice_bits(32, 32, CPTR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HCPTR : unit -> bits(32) effect {rreg, undef}

function get_HCPTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CPTR_EL2, 0, 32));
    r
}

register CNTHCTL_EL2 : bits(32)

val set_CNTHCTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHCTL val_name = {
    let r : bits(32) = val_name;
    CNTHCTL_EL2 = __SetSlice_bits(32, 32, CNTHCTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHCTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHCTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHCTL_EL2, 0, 32));
    r
}

val AArch64_InstructionDevice : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (AddressDescriptor, bits(64), bits(52), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> AddressDescriptor effect {escape, undef}

function AArch64_InstructionDevice (addrdesc__arg, vaddress, ipaddress, level, acctype, iswrite, secondstage, s2fs1walk) = {
    addrdesc = addrdesc__arg;
    let c : Constraint = ConstrainUnpredictable(Unpredictable_INSTRDEVICE);
    assert(c == Constraint_NONE | c == Constraint_FAULT);
    if c == Constraint_FAULT then {
        addrdesc.fault = AArch64_PermissionFault(ipaddress, undefined : bits(1), level, acctype, iswrite, secondstage, s2fs1walk)
    } else {
        __tc1 : MemoryAttributes = addrdesc.memattrs;
        __tc1.typ = MemType_Normal;
        addrdesc.memattrs = __tc1;
        __tc2 : MemAttrHints = addrdesc.memattrs.inner;
        __tc2.attrs = MemAttr_NC;
        __tc3 : MemoryAttributes = addrdesc.memattrs;
        __tc3.inner = __tc2;
        addrdesc.memattrs = __tc3;
        __tc4 : MemAttrHints = addrdesc.memattrs.inner;
        __tc4.hints = MemHint_No;
        __tc5 : MemoryAttributes = addrdesc.memattrs;
        __tc5.inner = __tc4;
        addrdesc.memattrs = __tc5;
        __tc6 : MemoryAttributes = addrdesc.memattrs;
        __tc6.outer = addrdesc.memattrs.inner;
        addrdesc.memattrs = __tc6;
        __tc7 : MemoryAttributes = addrdesc.memattrs;
        __tc7.tagged = false;
        addrdesc.memattrs = __tc7;
        addrdesc.memattrs = MemAttrDefaults(addrdesc.memattrs)
    };
    addrdesc
}

val AArch64_AccessUsesEL : AccType -> bits(2) effect {rreg}

function AArch64_AccessUsesEL acctype = {
    if acctype == AccType_UNPRIV then {
        return(EL0)
    } else {
        if acctype == AccType_NV2REGISTER then {
            return(EL2)
        } else {
            return(PSTATE.EL)
        }
    }
}

val AArch32_AccessUsesEL : AccType -> bits(2) effect {rreg}

function AArch32_AccessUsesEL acctype = {
    if acctype == AccType_UNPRIV then {
        return(EL0)
    } else {
        return(PSTATE.EL)
    }
}

val aset_Q : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (int('n), bits(128)) -> unit effect {escape, wreg}

function aset_Q (n, value_name) = {
    assert(n >= 0 & n <= 15);
    _V[n] = value_name;
    return()
}

overload Q = {aset_Q}

val AArch32_ResetSIMDFPRegisters : unit -> unit effect {escape, undef, wreg}

function AArch32_ResetSIMDFPRegisters () = {
    foreach (i from 0 to 15 by 1 in inc) {
        Q(i) = undefined : bits(128)
    };
    return()
}

val aget_Vpart : forall 'width 'n 'part,
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}).
  (int('n), int('part)) -> bits('width) effect {escape, rreg}

function aget_Vpart (n, part) = {
    assert(n >= 0 & n <= 31);
    assert(part == 0 | part == 1);
    if part == 0 then {
        assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64);
        return(slice(_V[n], 0, 'width))
    } else {
        assert('width == 32 | 'width == 64);
        return(slice(_V[n], 'width, 'width))
    }
}

overload Vpart = {aget_Vpart}

val aget_V : forall ('width : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  int('n) -> bits('width) effect {escape, rreg}

function aget_V n = {
    assert(n >= 0 & n <= 31);
    assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64 | 'width == 128);
    slice(_V[n], 0, 'width)
}

overload V = {aget_V}

val LookUpRIndex : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (int('n), bits(5)) -> {'m, (0 <= 'm & 'm <= 31). int('m)} effect {escape}

function LookUpRIndex (n, mode) = {
    assert(n >= 0 & n <= 14);
    match n {
      8 => RBankSelect(mode, 8, 24, 8, 8, 8, 8, 8),
      9 => RBankSelect(mode, 9, 25, 9, 9, 9, 9, 9),
      10 => RBankSelect(mode, 10, 26, 10, 10, 10, 10, 10),
      11 => RBankSelect(mode, 11, 27, 11, 11, 11, 11, 11),
      12 => RBankSelect(mode, 12, 28, 12, 12, 12, 12, 12),
      13 => RBankSelect(mode, 13, 29, 17, 19, 21, 23, 15),
      14 => RBankSelect(mode, 14, 30, 16, 18, 20, 22, 14),
      _ => n
    }
}

register _GTE_PPU_SizeEn : vector(6, dec, bits(32))

register _GTE_PPU_Address : vector(6, dec, bits(64))

register _GTE_PPU_Access : vector(6, dec, bits(32))

register _GTE_AS_RecordedData : vector(8, dec, bits(64))

register _GTE_AS_RecordedAddress : vector(8, dec, bits(64))

register _GTE_AS_RecordedAccess : vector(8, dec, bits(32))

register _GTEParam : vector(8, dec, bits(64))

val GTESetCriticalEvent : unit -> unit effect {rreg}

function GTESetCriticalEvent () = {
    let 'list_count = UInt(_GTEParam[0]);
    prerr("TODO: implement GTESetCriticalEvent\n");
    return()
}

val GTERandNum : unit -> unit effect {rreg}

function GTERandNum () = {
    let data : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    prerr("TODO: implement GTERandNum\n");
    return()
}

val GTEEventGenSetup : unit -> unit effect {rreg}

function GTEEventGenSetup () = {
    let handle : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    let event : vector(32, dec, bit) = slice(_GTEParam[1], 0, 32);
    let 'triggers_count = UInt(_GTEParam[2]);
    prerr("TODO: implement GTEEventGenSetup\n");
    return()
}

val GTEEventGenQuery : unit -> unit effect {rreg}

function GTEEventGenQuery () = {
    let handle : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    prerr("TODO: implement GTEEventGenQuery\n");
    return()
}

val GTEEventGenPrime : unit -> unit effect {rreg}

function GTEEventGenPrime () = {
    let handle : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    prerr("TODO: implement GTEEventGenPrime\n");
    return()
}

val GTEEventGenFree : unit -> unit effect {rreg}

function GTEEventGenFree () = {
    let handle : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    prerr("TODO: implement GTEEventGenFree\n");
    return()
}

val GTEEventGenDisable : unit -> unit effect {rreg}

function GTEEventGenDisable () = {
    let handle : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    prerr("TODO: implement GTEEventGenDisable\n");
    return()
}

val GTEEventGenClear : unit -> unit effect {rreg}

function GTEEventGenClear () = {
    let handle : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    prerr("TODO: implement GTEEventGenClear\n");
    return()
}

val GTEDeassert : unit -> unit effect {rreg}

function GTEDeassert () = {
    let cpus : vector(32, dec, bit) = slice(_GTEParam[0], 0, 32);
    prerr("TODO: implement GTEDeassert\n");
    return()
}

val GTEAssert : unit -> unit effect {rreg}

function GTEAssert () = {
    let 'triggers_count = UInt(_GTEParam[0]);
    let cpus : vector(32, dec, bit) = slice(_GTEParam[1], 0, 32);
    prerr("TODO: implement GTEAssert\n");
    return()
}

register _GTEListParam1 : vector(64, dec, bits(64))

register _GTEListParam0 : vector(64, dec, bits(64))

register _GTEExtObsResultIsAddress : vector(4, dec, bool)

register _GTEExtObsResultIndex : vector(4, dec, int)

register _GTEExtObsIndex : vector(4, dec, int)

register _GTEExtObsCount : vector(4, dec, int)

register _GTEExtObsActive : vector(4, dec, bool)

val LowestSetBit : forall ('N : Int), 'N >= 0. bits('N) -> int

function LowestSetBit x = {
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        if [x[i]] == 0b1 then {
            return(i)
        }
    };
    'N
}

val HighestSetBit : forall ('N : Int), 'N >= 0.
  bits('N) -> {'n, (-1 <= 'n & 'n <= 'N - 1). int('n)}

function HighestSetBit x = {
    foreach (i from ('N - 1) to 0 by 1 in dec) {
        if [x[i]] == 0b1 then {
            return(i)
        }
    };
    negate(1)
}

val GTEAllocExtObs : unit -> int effect {rreg, wreg}

function GTEAllocExtObs () = {
    foreach (i from 0 to (NUM_GTE_EXT_OBS_OBSERVERS - 1) by 1 in inc) {
        if _GTEExtObsActive[i] == false then {
            _GTEExtObsActive[i] = true;
            return(i)
        }
    };
    negate(1)
}

val BitReverse : forall ('N : Int), 'N >= 0. bits('N) -> bits('N) effect {undef}

function BitReverse data = {
    result : bits('N) = undefined : bits('N);
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        result = __SetSlice_bits('N, 1, result, 'N - i - 1, [data[i]])
    };
    result
}

register configuration TAG_GRANULE : int = shl_int(1, LOG2_TAG_GRANULE_DEFAULT)

val __PrintConfig : (string, string, string) -> unit

function __PrintConfig (cfg, ty, value_name) = {
    prerr(cfg ++ " (" ++ ty ++ ") default = " ++ value_name ++ " \n")
}

val __ListConfig : unit -> unit

function __ListConfig () = {
    repeat {
        prerr("cpu.has_arm_v8-1=0 (bool) default = '0'\n        : Implement the ARMv8.1 Extension.\n");
        prerr("cpu.has_arm_v8-2=0 (bool) default = '0'\n        : Implement the ARMv8.2 Extension.\n");
        prerr("cpu.has_arm_v8-3=0 (bool) default = '0'\n        : Implement the ARMv8.3 Extension.\n");
        prerr("cpu.has_arm_v8-4=0 (bool) default = '0'\n        : Implement the ARMv8.4 Extension. This feature is incomplete and under development.\n");
        prerr("cpu.num_loregions=0x0 (int) default = '0x0' \n        : Number of Limited Ordering Regions implemented excluding background region (if ARM v8.1 extensions are implemented) : [0x0..0xFF]\n");
        prerr("cpu.num_loregion_descriptors=0x0 (int) default = '0x0'\n        : Number of Limited Ordering Region descriptors implemented (if ARM v8.1 extensions are implemented) : [0x0..0xFF]\n");
        prerr("cpu.PA_SIZE=0x30 (int) default = '0x30'\n        : Physical address range supported.  For ARMv8.0 and ARMv8.1 this is limited to 48 bits. : [0x20..0x34]\n");
        prerr("counter_addr=0x0 (int) default = '0x0'\n        : Address for memory-mapped system counter block.  0 means the counter is not mapped, otherwise the address must be 4KB aligned.\n");
        prerr("cpu.ext_abort_normal_cacheable_read_is_sync=1 (bool) default = '1' \n        : Synchronous reporting of normal write-back cacheable-read external aborts\n");
        prerr("cpu.ext_abort_normal_noncacheable_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of normal noncacheable-read external aborts\n");
        prerr("cpu.ext_abort_device_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of device-nGnRE read external aborts\n");
        prerr("cpu.ext_abort_so_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of device-nGnRnE read external aborts\n");
        prerr("cpu.ext_abort_so_write_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of device-nGnRnE write external aborts\n");
        prerr("cpu.ext_abort_prefetch_is_sync=1 (bool) default = '1'\n        : Behaviour of external aborts generated by normal writeback cacheable instruction fetches.\n        [0, 1], 0: asynchronous abort,  1: synchronous abort.\n");
        prerr("cpu.ext_abort_ttw_cacheable_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of TTW cacheable read external aborts\n");
        prerr("cpu.ext_abort_ttw_noncacheable_read_is_sync=1 (bool) default = '1'\n        : Synchronous reporting of TTW noncacheable read external aborts\n");
        prerr("cpu.ext_abort_normal_cacheable_write_is_sync=0 (bool) default = '0'\n        : Synchronous reporting of normal write-back cacheable write external aborts\n");
        prerr("cpu.ext_abort_normal_noncacheable_write_is_sync=0 (bool) default = '0'\n        : Synchronous reporting of normal noncacheable write external aborts\n");
        prerr("cpu.ext_abort_device_write_is_sync=0 (bool) default = '0'\n        : Synchronous reporting of device-nGnRE write external aborts\n");
        prerr("cpu.unpred_tsize_aborts=0 (bool) default = '0'\n        : Behaviour when TSize is out of range.\n        [0, 1], 0: force into range. 1: translation fault, forces unpred_tsize_pamax_aborts to 1.\n");
        prerr("cpu.cpu0.enable_crc32=0x0 (int) default = '0x0'\n        : CRC32 instructions supported.\n        [0, 1], 0: CRC32 not implemented. 1: CRC32 instructions implemented.\n");
        prerr("cpu.has_pstate_pan=0x1 (int) default = '0x1' \n        : Implement the PSTATE.PAN (Privileged Access Never) control from ARMv8.1.\n        [0, 1], 0: not implemented. 1: Implemented\n");
        prerr("cpu.has_16bit_vmids=0x1 (int) default = '0x1'\n        : Implement support for 16-bit VMIDs from ARMv8.1\n        [0, 1], 0: Not enabled, 1: Implemented\n");
        prerr("cpu.has_dot_product=0x1 (int) default = '0x1' \n        : Implement the dot product (UDOT, SDOT) instructions from ARMv8.4\n        [0, 1], 0: Not implemnetd, 1: Implemnetd\n");
        prerr("cpu.has_fp16=0x1 (int) default = '0x1' \n        : Implement the half-precision floating-point data processing instructions from ARMv8.2.\n        [0, 1] 0: feature is not enabled. 1: feature is implemented\n");
        prerr("cpu.has_aarch32_hpd=0 (bool) default = '0'\n        : If true then hierarchical permission disable is supported in AArch32\n");
        prerr("cpu.has_tlb=0x1 (bool) default = '1'\n        : If true then TLB is enabled\n");
        prerr("cpu.has_trickbox=0x1 (bool) default = '1'\n        : If true then Trickbox and abort region checks are enabled\n");
        prerr("cpu.has_mpam=1 (bool) default = 0\n        : Implement the MPAM extension.\n        [0, 1] 0: FALSE, not implemented. 1: TRUE, implemented.\n");
        prerr("cpu.has_mpamhcr=1 (bool) default = 1\n        : If MPAM is implemented, also implement the MPAM virtualization features.\n        [0, 1] 0: FALSE, not implemented.  1: TRUE, implemented.\n");
        prerr("cpu.mpam_partid_max=127 (int) default = 0\n        : [0 .. 65535] Maximum MPAM PARTID supported by the implementation.");
        prerr("cpu.mpam_pmg_max=3 (int) default = 0\n        : [0 .. 255] Maximum MPAM PMG supported by the implementation.\n");
        prerr("cpu.mpam_vpmr_max=2 (int) default = 0\n        : [0 .. 7] Maximum MPAM virtual PARTID mapping register implemented.\n");
        prerr("cpu.cpu0.crypto_aes=0x2 (int) default = '0x2'\n        : AES and 128 bit PMULL instructions supported.\n        [0, 1, 2], 0: AES instruction not implemented. 1: AES instruction implemented. 2: AES plus 128bit PMULL instruction implemented\n");
        prerr("cpu.cpu0.crypto_sha1=0x1 (int) default = '0x1'\n        : SHA1 instructions supported.\n        [0, 1], 0: SHA1 not implemented. 1: SHA1 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sha256=0x1 (int) default = '0x1'\n        : SHA256 instructions supported.\n        [0, 1], 0: SHA256 not implemented. 1: SHA256 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sha512=0x0 (int) default = '0x0'\n        : SHA512 instructions supported.\n        [0, 1], 0: SHA512 not implemented. 1: SHA512 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sha3=0x0 (int) default = '0x0'\n        : SHA3 instructions supported.\n        [0, 1], 0: SHA3 not implemented. 1: SHA3 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sm3=0x0 (int) default = '0x0'\n        : SM3 instructions supported.\n        [0, 1], 0: SM3 not implemented. 1: SM3 instructions implemented.\n");
        prerr("cpu.cpu0.crypto_sm4=0x0 (int) default = '0x0'\n        : SM4 instructions supported.\n        [0, 1], 0: SM4 not implemented. 1: SM4 instructions implemented.\n")
    } until true;
    repeat {
        __PrintConfig("__trickbox_base_v8", "bits(52)", "__GetSlice_int(52, 318767104, 0)")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoWrite", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnPrefetch", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormNonCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceWrite", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__v81_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v82_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v83_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v84_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v85_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__support_52bit_pa", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__unpred_tsize_aborts", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__aa32_hpd_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crc32_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__pan_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__vmid16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__dot_product_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__fp16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_aes_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha1_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha256_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha512_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm4_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__block_bbm_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__mpam_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__mpam_has_hcr", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__tlb_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__trickbox_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mte_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mpam_partid_max", "bits(16)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_pmg_max", "bits(8)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_vpmr_max", "bits(3)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("LOG2_TAG_GRANULE", "integer", "LOG2_TAG_GRANULE_DEFAULT")
    } until true;
    repeat {
        __PrintConfig("TAG_GRANULE", "integer", "(1 << LOG2_TAG_GRANULE_DEFAULT)")
    } until true;
    repeat {
        __PrintConfig("TAG_STORE_AREA", "bits(56)", "__GetSlice_int(56, 4503599627370496, 0)")
    } until true;
    repeat {
        __PrintConfig("sp_rel_access_pc", "bits(64)", "Ones(64)")
    } until true;
    repeat {
        __PrintConfig("CFG_RVBAR", "bits(64)", "__GetSlice_int(64, 271581184, 0)")
    } until true;
    repeat {
        __PrintConfig("CFG_RMR_AA64", "bits(1)", "'1'")
    } until true;
    repeat {
        __PrintConfig("semihost_clock", "bits(64)", "__GetSlice_int(64, 0, 0)")
    } until true;
    repeat {
        __PrintConfig("__trickbox_base_v8", "bits(52)", "__GetSlice_int(52, 318767104, 0)")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnReadNormNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoRead", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnSoWrite", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnPrefetch", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnTTWNonCache", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnWriteNormNonCache", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__syncAbortOnDeviceWrite", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__v81_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v82_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v83_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v84_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__v85_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__support_52bit_pa", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__unpred_tsize_aborts", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__aa32_hpd_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crc32_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__pan_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__vmid16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__dot_product_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__fp16_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_aes_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha1_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha256_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha512_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sha3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm3_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__crypto_sm4_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__block_bbm_implemented", "integer", "2")
    } until true;
    repeat {
        __PrintConfig("__mpam_implemented", "boolean", "FALSE")
    } until true;
    repeat {
        __PrintConfig("__mpam_has_hcr", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__tlb_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__trickbox_enabled", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mte_implemented", "boolean", "TRUE")
    } until true;
    repeat {
        __PrintConfig("__mpam_partid_max", "bits(16)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_pmg_max", "bits(8)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("__mpam_vpmr_max", "bits(3)", "Zeros()")
    } until true;
    repeat {
        __PrintConfig("LOG2_TAG_GRANULE", "integer", "LOG2_TAG_GRANULE_DEFAULT")
    } until true;
    repeat {
        __PrintConfig("TAG_GRANULE", "integer", "(1 << LOG2_TAG_GRANULE_DEFAULT)")
    } until true;
    repeat {
        __PrintConfig("TAG_STORE_AREA", "bits(56)", "__GetSlice_int(56, 4503599627370496, 0)")
    } until true;
    repeat {
        __PrintConfig("sp_rel_access_pc", "bits(64)", "Ones(64)")
    } until true;
    repeat {
        __PrintConfig("CFG_RVBAR", "bits(64)", "__GetSlice_int(64, 271581184, 0)")
    } until true;
    repeat {
        __PrintConfig("CFG_RMR_AA64", "bits(1)", "'1'")
    } until true;
    repeat {
        __PrintConfig("semihost_clock", "bits(64)", "__GetSlice_int(64, 0, 0)")
    } until true;
    return()
}

val Hint_Prefetch : forall ('target : Int) ('stream : Bool).
  (bits(64), PrefetchHint, int('target), bool('stream)) -> unit effect {undef}

function Hint_Prefetch (address, hint, target, stream) = {
    op : string = undefined : string;
    match hint {
      Prefetch_READ => {
          op = "READ"
      },
      Prefetch_WRITE => {
          op = "WRITE"
      },
      Prefetch_EXEC => {
          op = "EXEC"
      },
      _ => {
          op = "UNKNOWN"
      }
    };
    let op = op;
    let msg : string = "Prefetch" ++ " address=0x" ++ HexStr(UInt(address)) ++ " op=" ++ op ++ " target=" ++ target ++ " stream=" ++ stream;
    __tarmacEvent(msg);
    return()
}

val GTESetPPURegion : unit -> unit effect {rreg, undef, wreg}

function GTESetPPURegion () = {
    prerr("GTESetPPURegion(region=" ++ DecStr(UInt(_GTEParam[0])));
    prerr(", addr=" ++ HexStr(UInt(_GTEParam[1])));
    prerr(", size_en=" ++ HexStr(UInt(slice(_GTEParam[2], 0, 32))));
    prerr(", access=" ++ HexStr(UInt(slice(_GTEParam[3], 0, 32))));
    prerr(")\n");
    let 'region = UInt(_GTEParam[0]);
    GTEStatus : bits(64) = undefined : bits(64);
    if region >= NUM_GTE_REGIONS then {
        GTEStatus = GTE_ST_REQUEST_FAIL;
        prerr("    region out of range\n");
        return()
    };
    _GTE_PPU_Address[region] = _GTEParam[1];
    _GTE_PPU_SizeEn[region] = slice(_GTEParam[2], 0, 32);
    _GTE_PPU_Access[region] = slice(_GTEParam[3], 0, 32);
    _GTEStatus = GTE_ST_REQUEST_GRANTED;
    return()
}

val GTEPPUControl : unit -> unit effect {rreg, wreg}

function GTEPPUControl () = {
    prerr("GTEPPUControl(region=" ++ DecStr(UInt(slice(_GTEParam[0], 0, 32))));
    prerr(", enable=" ++ DecStr(UInt([_GTEParam[1][0]])));
    prerr(")\n");
    let 'region = UInt(slice(_GTEParam[0], 0, 32));
    let enable : vector(1, dec, bit) = [_GTEParam[1][0]];
    if region >= NUM_GTE_REGIONS then {
        foreach (i from 0 to (NUM_GTE_REGIONS - 1) by 1 in inc) {
            __tc1 : bits(32) = _GTE_PPU_SizeEn[region];
            __tc1 = __SetSlice_bits(32, 1, __tc1, 0, enable);
            _GTE_PPU_SizeEn[region] = __tc1
        }
    } else {
        __tc2 : bits(32) = _GTE_PPU_SizeEn[region];
        __tc2 = __SetSlice_bits(32, 1, __tc2, 0, enable);
        _GTE_PPU_SizeEn[region] = __tc2
    };
    return()
}

val GTEGetPPURegion : unit -> unit effect {rreg, undef, wreg}

function GTEGetPPURegion () = {
    prerr("GTEGetPPURegion(region=" ++ DecStr(UInt(slice(_GTEParam[0], 0, 32))));
    prerr(")\n");
    let 'region = UInt(slice(_GTEParam[0], 0, 32));
    GTEStatus : bits(64) = undefined : bits(64);
    if region >= NUM_GTE_REGIONS then {
        prerr("   region out of range\n");
        GTEStatus = GTE_ST_REQUEST_FAIL;
        return()
    };
    _PPURBAR = _GTE_PPU_Address[region];
    _PPURSER = _GTE_PPU_SizeEn[region];
    _PPURACR = _GTE_PPU_Access[region];
    _GTEStatus = GTE_ST_REQUEST_GRANTED;
    return()
}

val __UpdateSystemCounter : unit -> unit effect {rreg, wreg}

function __UpdateSystemCounter () = {
    if [CNTCR[0]] == 0b1 then {
        CNTCV = __GetSlice_int(64, UInt(CNTCV) + 1, 0)
    }
}

val NextInstrAddr : forall ('N : Int), (0 <= 'N & 'N <= 64).
  unit -> bits('N) effect {rreg}

function NextInstrAddr () = slice(_PC + __currentInstrLength, 0, 'N)

val GTEAddListParam : bits(64) -> unit effect {escape, rreg, wreg}

function GTEAddListParam val_name = {
    assert(_GTEListParam < 2);
    prerr("_GTEListParam[" ++ DecStr(_GTEListParam) ++ "][" ++ DecStr(_GTEListParamIndex) ++ "] = " ++ HexStr(UInt(val_name)) ++ "\n");
    if _GTEListParam == 0 then {
        _GTEListParam0[_GTEListParamIndex] = val_name
    } else {
        _GTEListParam1[_GTEListParamIndex] = val_name
    };
    _GTEListParamIndex = _GTEListParamIndex + 1;
    return()
}

val CountLeadingZeroBits : forall ('N : Int), 'N >= 0. bits('N) -> int

function CountLeadingZeroBits x = {
    'N - (HighestSetBit(x) + 1)
}

val CountLeadingSignBits : forall ('N : Int), 'N >= 1. bits('N) -> int

function CountLeadingSignBits x = CountLeadingZeroBits(slice(x, 1, 'N - 1) ^ slice(x, 0, 'N - 1))

val BitCount : forall ('N : Int), 'N >= 0. bits('N) -> int

function BitCount x = {
    result : int = 0;
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        if [x[i]] == 0b1 then {
            result = result + 1
        }
    };
    result
}

val RotCell : forall ('amount : Int).
  (bits(4), int('amount)) -> bits(4) effect {undef}

function RotCell (incell_name, amount) = {
    tmp : bits(8) = undefined : bits(8);
    outcell : bits(4) = undefined : bits(4);
    let tmp = __SetSlice_bits(8, 8, tmp, 0, slice(incell_name, 0, 4) @ slice(incell_name, 0, 4));
    let outcell = slice(tmp, 4 - amount, 4);
    outcell
}

val ProcessorID : unit -> int effect {rreg}

function ProcessorID () = {
    UInt(((slice(MPIDR_EL1, 32, 8) @ slice(MPIDR_EL1, 16, 8)) @ slice(MPIDR_EL1, 8, 8)) @ slice(MPIDR_EL1, 0, 8))
}

val system_monitors : unit -> unit effect {rreg, undef, wreg}

function system_monitors () = {
    ClearExclusiveLocal(ProcessorID())
}

val NextRandomTagBit : unit -> bits(1) effect {rreg, wreg}

function NextRandomTagBit () = {
    let lfsr : vector(16, dec, bit) = slice(RGSR_EL1, 8, 16);
    let top : bits(1) = (([lfsr[5]] ^ [lfsr[3]]) ^ [lfsr[2]]) ^ [lfsr[0]];
    RGSR_EL1 = __SetSlice_bits(32, 16, RGSR_EL1, 8, top @ slice(lfsr, 1, 15));
    top
}

val RandomTag : unit -> bits(4) effect {rreg, undef, wreg}

function RandomTag () = {
    tag : bits(4) = undefined : bits(4);
    foreach (i from 0 to 3 by 1 in inc) {
        tag = __SetSlice_bits(4, 1, tag, i, NextRandomTagBit())
    };
    tag
}

val MakeLSInstructionSyndrome : forall 'size ('sign_extend : Bool) 'Rt ('sixty_four : Bool) ('acq_rel : Bool),
  ('size in {1, 2, 4, 8} & 0 <= 'Rt & 'Rt <= 31).
  (int('size), bool('sign_extend), int('Rt), bool('sixty_four), bool('acq_rel)) -> bits(11) effect {escape, undef}

function MakeLSInstructionSyndrome (size, sign_extend, Rt, sixty_four, acq_rel) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8);
    assert(0 <= Rt & Rt <= 31);
    sz : bits(2) = undefined : bits(2);
    match size {
      1 => {
          sz = 0b00
      },
      2 => {
          sz = 0b01
      },
      4 => {
          sz = 0b10
      },
      8 => {
          sz = 0b11
      }
    };
    let sz = sz;
    let ext : vector(1, dec, bit) = if sign_extend then 0b1 else 0b0;
    let sf : vector(1, dec, bit) = if sixty_four then 0b1 else 0b0;
    let ar : vector(1, dec, bit) = if acq_rel then 0b1 else 0b0;
    ((((0b1 @ sz) @ ext) @ __GetSlice_int(5, Rt, 0)) @ sf) @ ar
}

val AArch64_SetLSInstructionSyndrome : forall 'size 'Rt,
  ('size in {1, 2, 4, 8} & 0 <= 'Rt & 'Rt <= 31).
  (int('size), bool, int('Rt), bool, bool) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SetLSInstructionSyndrome (size, sign_extend, Rt, sixty_four, acq_rel) = {
    if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
        __LSISyndrome = MakeLSInstructionSyndrome(size, sign_extend, Rt, sixty_four, acq_rel)
    }
}

val FPNeg : forall ('N : Int), 'N >= 0. bits('N) -> bits('N) effect {escape}

function FPNeg op = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    ~([op['N - 1]]) @ slice(op, 0, 'N - 1)
}

val FPAbs : forall ('N : Int), 'N >= 0. bits('N) -> bits('N) effect {escape}

function FPAbs op = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    0b0 @ slice(op, 0, 'N - 1)
}

val EncodeLDFSC : forall ('level : Int).
  (Fault, int('level)) -> bits(6) effect {escape, undef}

function EncodeLDFSC (typ, level) = {
    result : bits(6) = undefined : bits(6);
    match typ {
      Fault_AddressSize => {
          result = 0x0 @ __GetSlice_int(2, level, 0);
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_AccessFlag => {
          result = 0x2 @ __GetSlice_int(2, level, 0);
          assert(level == 1 | level == 2 | level == 3)
      },
      Fault_Permission => {
          result = 0x3 @ __GetSlice_int(2, level, 0);
          assert(level == 1 | level == 2 | level == 3)
      },
      Fault_Translation => {
          result = 0x1 @ __GetSlice_int(2, level, 0);
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_SyncExternal => {
          result = 0b010000
      },
      Fault_SyncExternalOnWalk => {
          result = 0x5 @ __GetSlice_int(2, level, 0);
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_SyncParity => {
          result = 0b011000
      },
      Fault_SyncParityOnWalk => {
          result = 0x7 @ __GetSlice_int(2, level, 0);
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_AsyncParity => {
          result = 0b011001
      },
      Fault_AsyncExternal => {
          result = 0b010001
      },
      Fault_Alignment => {
          result = 0b100001
      },
      Fault_Debug => {
          result = 0b100010
      },
      Fault_TLBConflict => {
          result = 0b110000
      },
      Fault_HWUpdateAccessFlag => {
          result = 0b110001
      },
      Fault_Lockdown => {
          result = 0b110100
      },
      Fault_Exclusive => {
          result = 0b110101
      },
      _ => {
          Unreachable()
      }
    };
    result
}

val AArch64_PARFaultStatus : FaultRecord -> bits(6) effect {escape, undef}

function AArch64_PARFaultStatus fault = {
    fst : bits(6) = undefined : bits(6);
    if fault.typ == Fault_Domain then {
        assert(fault.level == 1 | fault.level == 2);
        fst = __SetSlice_bits(6, 2, fst, 0, if fault.level == 1 then 0b01 else 0b10);
        fst = __SetSlice_bits(6, 4, fst, 2, 0xF)
    } else {
        fst = EncodeLDFSC(fault.typ, fault.level)
    };
    fst
}

val BigEndianReverse : forall ('width : Int), 'width >= 0.
  bits('width) -> bits('width) effect {escape}

function BigEndianReverse value_name = {
    assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64 | 'width == 128);
    let 'half : {'n, 'n == div('width, 2). int('n)} = 'width / 2;
    if 'width == 8 then {
        return(value_name)
    };
    BigEndianReverse(slice(value_name, 0, half)) @ BigEndianReverse(slice(value_name, half, 'width - half))
}

val AllocationTagFromAddress : bits(64) -> bits(4)

function AllocationTagFromAddress tagged_address = {
    let logical_tag : bits(4) = slice(tagged_address, 56, 4);
    let tag : bits(4) = logical_tag + (0b000 @ [tagged_address[55]]);
    tag
}

val AddressWithAllocationTag : (bits(64), bits(4)) -> bits(64)

function AddressWithAllocationTag (address, allocation_tag) = {
    result : bits(64) = address;
    let tag : vector(4, dec, bit) = allocation_tag - (0b000 @ [address[55]]);
    let result = __SetSlice_bits(64, 4, result, 56, tag);
    result
}

val aset_Elem__0 : forall 'N 'size 'e,
  ('N >= 0 & 'size >= 0).
  (bits('N), int('e), bits('size)) -> bits('N) effect {escape}

val aset_Elem__1 : forall 'N 'size 'e,
  ('N >= 0 & 'size >= 0).
  (bits('N), int('e), int('size), bits('size)) -> bits('N) effect {escape}

overload aset_Elem = {aset_Elem__0, aset_Elem__1}

overload Elem = {aset_Elem__0, aset_Elem__1}

function aset_Elem__0 (vector_name, e, value_name) = {
    let vector_name = aset_Elem(vector_name, e, 'size, value_name);
    vector_name
}

function aset_Elem__1 (vector_name, e, size, value_name) = {
    assert(e >= 0 & (e + 1) * size <= 'N);
    let vector_name = __SetSlice_bits('N, size, vector_name, e * size, value_name);
    vector_name
}

val aget_Elem__0 : forall 'N 'e 'size,
  ('e >= 0 & 'size >= 0 & ('e + 1) * 'size <= 'N).
  (bits('N), int('e)) -> bits('size)

val aget_Elem__1 : forall 'N 'e 'size,
  ('e >= 0 & 'size >= 0 & ('e + 1) * 'size <= 'N).
  (bits('N), int('e), int('size)) -> bits('size)

overload aget_Elem = {aget_Elem__0, aget_Elem__1}

function aget_Elem__0 (vector_name, e) = aget_Elem(vector_name, e, 'size)

function aget_Elem__1 (vector_name, e, size) = {
    slice(vector_name, e * size, size)
}

val __WriteMemory : forall ('N : Int).
  (int('N), bits(56), bits(8 * 'N)) -> unit effect {rreg, wmem}

function __WriteMemory (N, address, val_name) = {
    __WriteRAM(56, N, __defaultRAM, address, val_name);
    __TraceMemoryWrite(N, address, val_name);
    return()
}

val __ReadMemory : forall ('N : Int).
  (int('N), bits(56)) -> bits(8 * 'N) effect {rmem, rreg}

function __ReadMemory (N, address) = {
    let r : vector(8 * 'N, dec, bit) = __ReadRAM(56, N, __defaultRAM, address);
    __TraceMemoryRead(N, address, r);
    r
}

val UnsignedSatQ : forall ('N : Int) ('i : Int).
  (int('i), int('N)) -> (bits('N), bool) effect {undef}

function UnsignedSatQ (i, N) = {
    result : int = undefined : int;
    saturated : bool = undefined : bool;
    if i > 2 ^ N - 1 then {
        result = 2 ^ N - 1;
        saturated = true
    } else {
        if i < 0 then {
            result = 0;
            saturated = true
        } else {
            result = i;
            saturated = false
        }
    };
    return((__GetSlice_int(N, result, 0), saturated))
}

val SignedSatQ : forall ('N : Int) ('i : Int).
  (int('i), int('N)) -> (bits('N), bool) effect {undef}

function SignedSatQ (i, N) = {
    result : int = undefined : int;
    saturated : bool = undefined : bool;
    if i > 2 ^ (N - 1) - 1 then {
        result = 2 ^ (N - 1) - 1;
        saturated = true
    } else {
        if i < negate(2 ^ (N - 1)) then {
            result = negate(2 ^ (N - 1));
            saturated = true
        } else {
            result = i;
            saturated = false
        }
    };
    return((__GetSlice_int(N, result, 0), saturated))
}

val SatQ : forall ('N : Int) ('i : Int) ('unsigned : Bool).
  (int('i), int('N), bool('unsigned)) -> (bits('N), bool) effect {undef}

function SatQ (i, N, unsigned) = {
    result : bits('N) = undefined : bits('N);
    sat : bool = undefined : bool;
    (result, sat) = if unsigned then UnsignedSatQ(i, N) else SignedSatQ(i, N);
    return((result, sat))
}

val ThisInstrLength : unit -> int effect {rreg}

function ThisInstrLength () = {
    __currentInstrLength * 8
}

val AArch32_ExceptionClass : Exception -> (int, bits(1)) effect {escape, rreg, undef}

function AArch32_ExceptionClass typ = {
    il : bits(1) = undefined : bits(1);
    il = if ThisInstrLength() == 32 then 0b1 else 0b0;
    ec : int = undefined : int;
    match typ {
      Exception_Uncategorized => {
          ec = 0;
          il = 0b1
      },
      Exception_WFxTrap => {
          ec = 1
      },
      Exception_CP15RTTrap => {
          ec = 3
      },
      Exception_CP15RRTTrap => {
          ec = 4
      },
      Exception_CP14RTTrap => {
          ec = 5
      },
      Exception_CP14DTTrap => {
          ec = 6
      },
      Exception_AdvSIMDFPAccessTrap => {
          ec = 7
      },
      Exception_FPIDTrap => {
          ec = 8
      },
      Exception_PACTrap => {
          ec = 9
      },
      Exception_CP14RRTTrap => {
          ec = 12
      },
      Exception_BranchTarget => {
          ec = 13
      },
      Exception_IllegalState => {
          ec = 14;
          il = 0b1
      },
      Exception_SupervisorCall => {
          ec = 17
      },
      Exception_HypervisorCall => {
          ec = 18
      },
      Exception_MonitorCall => {
          ec = 19
      },
      Exception_ERetTrap => {
          ec = 26
      },
      Exception_InstructionAbort => {
          ec = 32;
          il = 0b1
      },
      Exception_PCAlignment => {
          ec = 34;
          il = 0b1
      },
      Exception_DataAbort => {
          ec = 36
      },
      Exception_NV2DataAbort => {
          ec = 37
      },
      Exception_FPTrappedException => {
          ec = 40
      },
      _ => {
          Unreachable()
      }
    };
    if (ec == 32 | ec == 36) & PSTATE.EL == EL2 then {
        ec = ec + 1
    };
    return((ec, il))
}

val AArch32_ReportHypEntry : ExceptionRecord -> unit effect {escape, rreg, undef, wreg}

function AArch32_ReportHypEntry exception = {
    let typ : Exception = exception.typ;
    ec : int = undefined : int;
    il : bits(1) = undefined : bits(1);
    (ec, il) = AArch32_ExceptionClass(typ);
    let iss : bits(25) = exception.syndrome;
    if (ec == 36 | ec == 37) & [iss[24]] == 0b0 then {
        il = 0b1
    };
    set_HSR((__GetSlice_int(6, ec, 0) @ il) @ iss);
    if typ == Exception_InstructionAbort | typ == Exception_PCAlignment then {
        set_HIFAR(slice(exception.vaddress, 0, 32));
        set_HDFAR(undefined : bits(32))
    } else {
        if typ == Exception_DataAbort then {
            set_HIFAR(undefined : bits(32));
            set_HDFAR(slice(exception.vaddress, 0, 32))
        }
    };
    if exception.ipavalid then {
        __tc1 : bits(32) = get_HPFAR();
        __tc1 = __SetSlice_bits(32, 28, __tc1, 4, slice(exception.ipaddress, 12, 28));
        set_HPFAR(__tc1)
    } else {
        __tc2 : bits(32) = get_HPFAR();
        __tc2 = __SetSlice_bits(32, 28, __tc2, 4, undefined : bits(28));
        set_HPFAR(__tc2)
    };
    return()
}

val TLBReset : unit -> unit effect {rreg, wreg}

function TLBReset () = {
    if TLBHits + TLBMisses > 0 then {
        prerr("TLB reset, so far hit rate is ");
        prerr(TLBHits);
        prerr("/");
        prerr(TLBHits + TLBMisses);
        prerr(" == ");
        prerr(100 * TLBHits / (TLBHits + TLBMisses));
        println()
    } else {
        prerr("TLB reset (no requests were made)");
        println()
    };
    TLBHits = 0;
    TLBMisses = 0;
    foreach (i from 0 to (shl_int(1, 10) - 1) by 1 in inc) {
        __tc1 : TLBLine = _TLB[i];
        __tc1.valid_name = false;
        _TLB[i] = __tc1
    }
}

val _TLB_Invalidate : unit -> unit effect {rreg, wreg}

function _TLB_Invalidate () = {
    TLBReset();
    return()
}

val TLBI_VMALLS12E1OS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLS12E1OS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLS12E1IS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLS12E1IS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLS12E1 : unit -> unit effect {rreg, wreg}

function TLBI_VMALLS12E1 () = {
    _TLB_Invalidate()
}

val TLBI_VMALLE1OS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLE1OS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLE1IS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLE1IS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLE1 : unit -> unit effect {rreg, wreg}

function TLBI_VMALLE1 () = {
    _TLB_Invalidate()
}

val TLBI_VALE3OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE3OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE3OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE3OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE3OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE3OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2LE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2LE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2LE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2LE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2LE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2LE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2E1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2E1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2E1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2E1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2E1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2E1 val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2LE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2LE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2LE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2LE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2LE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2LE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2E1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2E1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2E1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2E1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2E1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2E1 val_name = {
    _TLB_Invalidate()
}

val TLBI_ASIDE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_ASIDE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_ASIDE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_ASIDE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_ASIDE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_ASIDE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_ALLE3OS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE3OS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE3IS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE3IS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE3 : unit -> unit effect {rreg, wreg}

function TLBI_ALLE3 () = {
    _TLB_Invalidate()
}

val TLBI_ALLE1OS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE1OS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE1IS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE1IS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE1 : unit -> unit effect {rreg, wreg}

function TLBI_ALLE1 () = {
    _TLB_Invalidate()
}

val Sbox : bits(8) -> bits(8) effect {undef}

function Sbox sboxin = {
    sboxout : bits(8) = undefined : bits(8);
    let sboxstring : vector(2048, dec, bit) = __GetSlice_int(2048, 27086457041271130658097913556973622859223908082898777931279708123265802528354842616141526661043990239966061245146490489245523501543590288385437002023358814947081845591010354165772708439349485551596405955355395097736697731641465653447759785887130139642898454897614116485023073928669016836841447803958846420478804845848435434304342658474410584354851222871590567875520195692946750020179880039080961350182547539832666651577275749378753269779670476274426614755119909370245322827169127262049788036928038538634406508934382584917480550081919950181243327359810644173326097655591141455893541487338091667629050780151417584433480, 0);
    let sboxin = UInt(sboxin);
    let sboxout = slice(sboxstring, (255 - sboxin) * 8, 8 + 8 * sboxin - 8 * sboxin);
    sboxout
}

val Replicate : forall ('M : Int) ('N : Int).
  bits('M) -> bits('N) effect {escape}

function Replicate x = {
    assert('N % 'M == 0, "((N MOD M) == 0)");
    let 'P = 'N / 'M;
    assert(constraint('N == 'P * 'M));
    replicate_bits(x, 'P)
}

val Zeros__0 = {ocaml: "zeros", lem: "zeros", smt: "zeros", interpreter: "zeros", c: "zeros"}: forall ('N : Int).
  int('N) -> bits('N)

val Zeros__1 : forall ('N : Int). unit -> bits('N)

overload Zeros = {Zeros__0, Zeros__1}

function Zeros__1 () = {
    Zeros('N)
}

val set_ClearIRQ : bits(32) -> unit effect {rreg, wreg}

function set_ClearIRQ val_name = {
    _ClearIRQ = __SetSlice_bits(32, 32, _ClearIRQ, 0, val_name);
    if get_ClearIRQ() == Zeros(32) then {
        _IRQPending = false
    };
    return()
}

val set_ClearFIQ : bits(32) -> unit effect {rreg, wreg}

function set_ClearFIQ val_name = {
    _ClearFIQ = __SetSlice_bits(32, 32, _ClearFIQ, 0, val_name);
    if get_ClearFIQ() == Zeros(32) then {
        _FIQPending = false
    };
    return()
}

val mapvpmw : forall ('vpartid : Int).
  int('vpartid) -> bits(16) effect {rreg, undef}

function mapvpmw vpartid = {
    vpmw : bits(64) = undefined : bits(64);
    let 'wd : {'n, 'n == div('vpartid, 4). int('n)} = vpartid / 4;
    match wd {
      0 => {
          vpmw = MPAMVPM0_EL2
      },
      1 => {
          vpmw = MPAMVPM1_EL2
      },
      2 => {
          vpmw = MPAMVPM2_EL2
      },
      3 => {
          vpmw = MPAMVPM3_EL2
      },
      4 => {
          vpmw = MPAMVPM4_EL2
      },
      5 => {
          vpmw = MPAMVPM5_EL2
      },
      6 => {
          vpmw = MPAMVPM6_EL2
      },
      7 => {
          vpmw = MPAMVPM7_EL2
      },
      _ => {
          vpmw = Zeros(64)
      }
    };
    let vpmw = vpmw;
    let 'vpme_lsb = vpartid % 4 * 16;
    slice(vpmw, vpme_lsb, 16)
}

val get_TUBE : unit -> bits(32)

function get_TUBE () = {
    Zeros(32)
}

val get_PPURSER : unit -> bits(32) effect {rreg}

function get_PPURSER () = {
    if _GTEActive then {
        return(_PPURSER)
    } else {
        return(Zeros(32))
    }
}

val get_PPURBAR : unit -> bits(32) effect {rreg}

function get_PPURBAR () = {
    if _GTEActive then {
        return(slice(_PPURBAR, 0, 32))
    } else {
        return(Zeros(32))
    }
}

val get_PPURACR : unit -> bits(32) effect {rreg}

function get_PPURACR () = {
    if _GTEActive then {
        return(_PPURACR)
    } else {
        return(Zeros(32))
    }
}

val get_GTE_API_STATUS_64_HI : unit -> bits(32) effect {rreg}

function get_GTE_API_STATUS_64_HI () = {
    if _GTEActive then {
        return(slice(_GTEStatus, 32, 32))
    } else {
        return(Zeros(32))
    }
}

val get_GTE_API_STATUS_64 : unit -> bits(32) effect {rreg}

function get_GTE_API_STATUS_64 () = {
    if _GTEActive then {
        return(slice(_GTEStatus, 0, 32))
    } else {
        return(Zeros(32))
    }
}

val get_GTE_API_STATUS : unit -> bits(32) effect {rreg}

function get_GTE_API_STATUS () = {
    if _GTEActive then {
        return(slice(_GTEStatus, 0, 32))
    } else {
        return(Zeros(32))
    }
}

val get_GTE_API_PARAM_64_HI : unit -> bits(32) effect {rreg}

function get_GTE_API_PARAM_64_HI () = {
    if _GTEActive then {
        return(slice(_PPURBAR, 32, 32))
    } else {
        return(Zeros(32))
    }
}

val get_GTE_API_PARAM_64 : unit -> bits(32) effect {rreg}

function get_GTE_API_PARAM_64 () = {
    if _GTEActive then {
        return(slice(_PPURBAR, 0, 32))
    } else {
        return(Zeros(32))
    }
}

val get_GTE_API_PARAM : unit -> bits(32)

function get_GTE_API_PARAM () = {
    Zeros(32)
}

register configuration __mpam_vpmr_max : bits(3) = Zeros()

register configuration __mpam_pmg_max : bits(8) = Zeros()

register configuration __mpam_partid_max : bits(16) = Zeros()

val __IMPDEF_bits_map : forall ('N : Int), 'N >= 0.
  (int('N), string) -> bits('N) effect {escape}

function __IMPDEF_bits_map (N, x) = match () {
  () if x == "Virtual Asynchronous Abort ExT bit" => return(Zeros()),
  () if x == "FPEXC.EN value when TGE==1 and RW==0" => return(__GetSlice_int(N, 1, 0)),
  () if x == "MPAM version" => return(__GetSlice_int(N, UInt(CFG_ID_AA64PFR0_EL1_MPAM), 0)),
  () if x == "MPAM maximum PARTID" => return(__GetSlice_int(N, UInt(__mpam_partid_max), 0)),
  () if x == "MPAM maximum PMG" => return(__GetSlice_int(N, UInt(__mpam_pmg_max), 0)),
  () if x == "Has MPAMHCR_EL2" => return(if __mpam_has_hcr then __GetSlice_int(N, 1, 0) else Zeros()),
  () if x == "MPAM maximum VPMR" => return(__GetSlice_int(N, UInt(__mpam_vpmr_max), 0)),
  () if x == "reset vector address" => return(slice(CFG_RVBAR, 0, N)),
  _ => throw(Error_Implementation_Defined("Unrecognized bits(N)"))
}

val __IMPDEF_bits : forall ('N : Int), 'N >= 0.
  (int('N), string) -> bits('N) effect {escape}

function __IMPDEF_bits (N, x) = __IMPDEF_bits_map(N, x)

val ZeroExtend__0 : forall ('M : Int) ('N : Int), 'M >= 0.
  (bits('M), int('N)) -> bits('N) effect {escape}

val ZeroExtend__1 : forall ('M : Int) ('N : Int), 'M >= 0.
  bits('M) -> bits('N) effect {escape}

overload ZeroExtend = {ZeroExtend__0, ZeroExtend__1}

function ZeroExtend__0 (x, N) = {
    assert(N >= 'M);
    Zeros(N - 'M) @ x
}

function ZeroExtend__1 x = {
    ZeroExtend(x, 'N)
}

val get_ScheduleIRQ : unit -> bits(32) effect {escape, rreg}

function get_ScheduleIRQ () = let status : bits(1) = if IRQPending() then 0b1 else 0b0 in ZeroExtend(status)

val get_ScheduleFIQ : unit -> bits(32) effect {rreg, escape}

function get_ScheduleFIQ () = let status : bits(1) = if FIQPending() then 0b1 else 0b0 in ZeroExtend(status)

val _ReadTrickbox : forall 'address ('UNP : Bool) ('UP : Bool) ('PNP : Bool) ('PP : Bool).
  (int('address), bool('UNP), bool('UP), bool('PNP), bool('PP)) -> bits(32) effect {escape, rreg, undef}

function _ReadTrickbox (address, UNP, UP, PNP, PP) = {
    match address {
      0 if ((UNP | PNP) | UP) | PP => {
          return(get_TUBE())
      },
      8 if ((UNP | PNP) | UP) | PP => {
          return(get_ScheduleFIQ())
      },
      12 if ((UNP | PNP) | UP) | PP => {
          return(get_ScheduleIRQ())
      },
      256 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Lo1)
      },
      260 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Lo1_Hi)
      },
      264 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Hi1)
      },
      268 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Hi1_Hi)
      },
      272 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Lo2)
      },
      276 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Lo2_Hi)
      },
      280 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Hi2)
      },
      284 if ((UNP | PNP) | UP) | PP => {
          return(AbortRgn64Hi2_Hi)
      },
      1280 if ((UNP | PNP) | UP) | PP => {
          return(get_AXIAbortCtl())
      },
      2564 if ((UNP | PNP) | UP) | PP => {
          return(get_GTE_API_PARAM())
      },
      2568 if ((UNP | PNP) | UP) | PP => {
          return(get_GTE_API_STATUS())
      },
      2576 if ((UNP | PNP) | UP) | PP => {
          return(get_PPURBAR())
      },
      2580 if ((UNP | PNP) | UP) | PP => {
          return(get_PPURSER())
      },
      2584 if ((UNP | PNP) | UP) | PP => {
          return(get_PPURACR())
      },
      2592 if ((UNP | PNP) | UP) | PP => {
          return(get_GTE_API_STATUS_64())
      },
      2596 if ((UNP | PNP) | UP) | PP => {
          return(get_GTE_API_STATUS_64_HI())
      },
      2600 if ((UNP | PNP) | UP) | PP => {
          return(get_GTE_API_PARAM_64())
      },
      2604 if ((UNP | PNP) | UP) | PP => {
          return(get_GTE_API_PARAM_64_HI())
      },
      _ => {
          prerr("Undefined trickbox read at offset " ++ HexStr(address) ++ "\n");
          return(undefined : bits(32))
      }
    }
}

val aset_Vpart : forall 'width 'n 'part,
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}).
  (int('n), int('part), bits('width)) -> unit effect {escape, rreg, wreg}

function aset_Vpart (n, part, value_name) = {
    assert(n >= 0 & n <= 31);
    assert(part == 0 | part == 1);
    if part == 0 then {
        assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64);
        _V[n] = ZeroExtend(value_name, 128)
    } else {
        assert('width == 64);
        __tc1 : bits(128) = _V[n];
        __tc1 = __SetSlice_bits(128, 'width, __tc1, 'width, slice(value_name, 0, 'width));
        _V[n] = __tc1
    }
}

overload Vpart = {aset_Vpart}

val aset_V : forall ('width : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits('width)) -> unit effect {escape, wreg}

function aset_V (n, value_name) = {
    assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64 | 'width == 128);
    _V[n] = ZeroExtend(value_name, 128)
}

overload V = {aset_V}

val AArch64_ResetSIMDFPRegisters : unit -> unit effect {escape, undef, wreg}

function AArch64_ResetSIMDFPRegisters () = {
    foreach (i from 0 to 31 by 1 in inc) {
        V(i) = undefined : bits(128)
    };
    return()
}

val aset_SP : forall ('width : Int), 'width >= 0.
  bits('width) -> unit effect {escape, rreg, wreg}

function aset_SP value_name = {
    assert('width == 32 | 'width == 64);
    if PSTATE.SP == 0b0 then {
        SP_EL0 = ZeroExtend(value_name)
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              SP_EL0 = ZeroExtend(value_name)
          },
          ? if ? == EL1 => {
              SP_EL1 = ZeroExtend(value_name)
          },
          ? if ? == EL2 => {
              SP_EL2 = ZeroExtend(value_name)
          },
          ? if ? == EL3 => {
              SP_EL3 = ZeroExtend(value_name)
          }
        }
    };
    return()
}

overload SP = {aset_SP}

val TransformTag : bits(64) -> bits(4) effect {escape}

function TransformTag vaddr = let vtag : bits(4) = slice(vaddr, 56, 4) in let tagdelta : bits(4) = ZeroExtend([vaddr[55]]) in let ptag : bits(4) = vtag + tagdelta in ptag

val LSR_C : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> (bits('N), bits(1)) effect {escape}

function LSR_C (x, shift) = {
    assert(shift > 0);
    let (shift as 'S) : {'n, (0 <= 'n & 'n <= 'N). int('n)} = if shift > 'N then 'N else shift;
    let extended_x : bits('S + 'N) = ZeroExtend(x, shift + 'N);
    let result : bits('N) = slice(extended_x, shift, 'N);
    let carry_out : bits(1) = [extended_x[shift - 1]];
    return((result, carry_out))
}

val LSR : forall ('N : Int) ('shift : Int), ('shift >= 0 & 'N >= 0).
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function LSR (x, shift) = {
    assert(shift >= 0);
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if shift == 0 then result = x
    else (result, __anon1) = LSR_C(x, shift);
    result
}

val aset__MemTag : (AddressDescriptor, bits(4)) -> unit effect {escape, rreg, undef, wmem}

function aset__MemTag (desc, value_name) = {
    let offset : bits(64) = ZeroExtend(desc.paddress.address);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let tag_index : bits(64) = LSR(offset, log2_tag_granule);
    let tagaddress : bits(56) = TAG_STORE_AREA + slice(tag_index, 0, 56);
    __WriteMemory(1, ZeroExtend(tagaddress), 0x0 @ value_name)
}

overload _MemTag = {aset__MemTag}

val aget__MemTag : AddressDescriptor -> bits(4) effect {escape, rmem, rreg, undef}

function aget__MemTag desc = {
    let offset : bits(64) = ZeroExtend(desc.paddress.address);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let tag_index : bits(64) = LSR(offset, log2_tag_granule);
    let tagaddress : bits(56) = TAG_STORE_AREA + slice(tag_index, 0, 56);
    let tagbyte : bits(8) = __ReadMemory(1, ZeroExtend(tagaddress));
    slice(tagbyte, 0, 4)
}

overload _MemTag = {aget__MemTag}

val Poly32Mod2 : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> bits(32) effect {escape}

function Poly32Mod2 (data__arg, poly) = {
    data = data__arg;
    assert('N > 32);
    foreach (i from ('N - 1) to 32 by 1 in dec) {
        if [data[i]] == 0b1 then {
            data = __SetSlice_bits('N, i, data, 0, slice(data, 0, i) ^ (poly @ Zeros(i - 32)))
        }
    };
    slice(data, 0, 32)
}

val LSL_C : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> (bits('N), bits(1)) effect {escape}

function LSL_C (x, shift) = {
    assert(shift > 0);
    let (shift as 'S) : {'n, (0 <= 'n & 'n <= 'N). int('n)} = if shift > 'N then 'N else shift;
    let extended_x : bits('N + 'S) = x @ Zeros(shift);
    let result : bits('N) = slice(extended_x, 0, 'N);
    let carry_out : bits(1) = [extended_x['N]];
    return((result, carry_out))
}

val LSL : forall ('N : Int) ('shift : Int), ('shift >= 0 & 'N >= 0).
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function LSL (x, shift) = {
    assert(shift >= 0);
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if shift == 0 then result = x
    else (result, __anon1) = LSL_C(x, shift);
    result
}

val PolynomialMult : forall ('M : Int) ('N : Int), ('M >= 0 & 'N >= 0).
  (bits('M), bits('N)) -> bits('N + 'M) effect {escape, undef}

function PolynomialMult (op1, op2) = {
    result : bits('N + 'M) = undefined : bits('N + 'M);
    result = Zeros('M + 'N);
    let extended_op2 : vector('M + 'N, dec, bit) = ZeroExtend(op2, 'M + 'N);
    foreach (i from 0 to ('M - 1) by 1 in inc) {
        if [op1[i]] == 0b1 then {
            result = result ^ LSL(extended_op2, i)
        }
    };
    result
}

val AArch32_ITAdvance : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_ITAdvance () = {
    if slice(PSTATE.IT, 0, 3) == 0b000 then {
        PSTATE.IT = 0x00
    } else {
        __tc1 : bits(8) = PSTATE.IT;
        __tc1 = __SetSlice_bits(8, 5, __tc1, 0, LSL(slice(PSTATE.IT, 0, 5), 1));
        PSTATE.IT = __tc1
    };
    return()
}

val IsZero : forall ('N : Int), 'N >= 0. bits('N) -> bool

function IsZero x = {
    x == Zeros('N)
}

val IsZeroBit : forall ('N : Int), 'N >= 0. bits('N) -> bits(1)

function IsZeroBit x = {
    if IsZero(x) then 0b1 else 0b0
}

val AddWithCarry : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(1)) -> (bits('N), bits(4))

function AddWithCarry (x, y, carry_in) = {
    let 'unsigned_sum = UInt(x) + UInt(y) + UInt(carry_in);
    let 'signed_sum = SInt(x) + SInt(y) + UInt(carry_in);
    let result : bits('N) = __GetSlice_int('N, unsigned_sum, 0);
    let n : bits(1) = [result['N - 1]];
    let z : bits(1) = if IsZero(result) then 0b1 else 0b0;
    let c : bits(1) = if UInt(result) == unsigned_sum then 0b0 else 0b1;
    let v : bits(1) = if SInt(result) == signed_sum then 0b0 else 0b1;
    return((result, ((n @ z) @ c) @ v))
}

val GetExclusiveBlockAddress : bits(52) -> bits(52)

function GetExclusiveBlockAddress address = {
    let a = UInt(__exclusive_granule_size);
    let a : {'n, (4 <= 'n & 'n <= 11). int('n)} = if a < 4 | a > 11 then 11 else a;
    slice(address, a, negate(a) + 52) @ Zeros(a)
}

val MarkExclusiveLocal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> unit effect {wreg}

function MarkExclusiveLocal (paddress, processorid, size) = {
    __exclusive_block_address = GetExclusiveBlockAddress(paddress.address);
    return()
}

val IsExclusiveLocal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> bool effect {rreg}

function IsExclusiveLocal (paddress, processorid, size) = {
    __exclusive_block_address == GetExclusiveBlockAddress(paddress.address)
}

val ClearExclusiveByAddress : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> unit effect {rreg, undef, wreg}

function ClearExclusiveByAddress (paddress, processorid, size) = {
    if __exclusive_block_address == GetExclusiveBlockAddress(paddress.address) then {
        __exclusive_block_address = undefined : bits(52)
    };
    return()
}

val GTEEnAccessSensitiveBEH : unit -> unit effect {rreg, wreg}

function GTEEnAccessSensitiveBEH () = {
    prerr("GTEEnAccessSensitiveBEH");
    prerr("( address=" ++ HexStr(UInt(_GTEParam[0])));
    prerr(", size=" ++ HexStr(UInt(_GTEParam[1])));
    prerr(", access=" ++ HexStr(UInt(slice(_GTEParam[2], 0, 32))));
    prerr(")\n");
    _GTE_AS_Address = _GTEParam[0];
    _GTE_AS_Size = _GTEParam[1];
    _GTE_AS_Access = slice(_GTEParam[2], 0, 32);
    _GTE_AS_AccessCount = 0;
    _GTEStatus = Zeros();
    return()
}

val FPZero : forall ('N : Int). bits(1) -> bits('N) effect {escape}

function FPZero sign = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    let exp : bits('E) = Zeros(E);
    let frac : bits('N - 1 - 'E) = Zeros(F);
    (sign @ exp) @ frac
}

val FPTwo : forall ('N : Int). bits(1) -> bits('N) effect {escape}

function FPTwo sign = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    let exp : bits('E) = 0b1 @ Zeros(E - 1);
    let frac : bits('N - 1 - 'E) = Zeros(F);
    (sign @ exp) @ frac
}

val FPThree : forall ('N : Int). bits(1) -> bits('N) effect {escape}

function FPThree sign = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    let exp : bits('E) = 0b1 @ Zeros(E - 1);
    let frac : bits('N - 1 - 'E) = 0b1 @ Zeros(F - 1);
    (sign @ exp) @ frac
}

val ExceptionSyndrome : Exception -> ExceptionRecord effect {undef}

function ExceptionSyndrome typ = {
    r : ExceptionRecord = undefined : ExceptionRecord;
    r.typ = typ;
    r.syndrome = Zeros();
    r.vaddress = Zeros();
    r.ipavalid = false;
    r.NS = 0b0;
    r.ipaddress = Zeros();
    r
}

val ConstrainUnpredictableBits : forall ('width : Int).
  Unpredictable -> (Constraint, bits('width)) effect {undef}

function ConstrainUnpredictableBits which = {
    let c : Constraint = ConstrainUnpredictable(which);
    if c == Constraint_UNKNOWN then {
        return((c, Zeros('width)))
    } else {
        return((c, undefined : bits('width)))
    }
}

val ClearLSInstructionSyndrome : unit -> unit effect {wreg}

function ClearLSInstructionSyndrome () = {
    __LSISyndrome = Zeros();
    return()
}

val __EndCycle : unit -> unit effect {configuration, rreg, undef, wreg}

function __EndCycle () = {
    repeat {
        if slice(_ScheduleIRQ, 0, 32) == 0 & ScheduledIRQ then {
            _IRQPending = true;
            ScheduledIRQ = false;
            __WakeupRequest()
        };
        if UInt(slice(_ScheduleIRQ, 0, 32)) > 0 then {
            _ScheduleIRQ = __SetSlice_bits(32, 32, _ScheduleIRQ, 0, slice(_ScheduleIRQ, 0, 32) - 1)
        }
    } until true;
    repeat {
        if slice(_ScheduleFIQ, 0, 32) == 0 & ScheduledFIQ then {
            _FIQPending = true;
            ScheduledFIQ = false;
            __WakeupRequest()
        };
        if UInt(slice(_ScheduleFIQ, 0, 32)) > 0 then {
            _ScheduleFIQ = __SetSlice_bits(32, 32, _ScheduleFIQ, 0, slice(_ScheduleFIQ, 0, 32) - 1)
        }
    } until true;
    repeat {
        ClearLSInstructionSyndrome()
    } until true;
    repeat {
        semihost_clock = semihost_clock + 1
    } until true;
    return()
}

val __CycleEnd : unit -> unit effect {configuration, rreg, undef, wreg}

function __CycleEnd () = {
    __EndCycle()
}

val AArch64_PhysicalSErrorSyndrome : forall ('implicit_esb : Bool).
  bool('implicit_esb) -> bits(25)

function AArch64_PhysicalSErrorSyndrome implicit_esb = {
    syndrome : bits(25) = Zeros();
    syndrome = __SetSlice_bits(25, 1, syndrome, 24, 0b0);
    syndrome = __SetSlice_bits(25, 1, syndrome, 13, if implicit_esb then 0b1 else 0b0);
    match AsynchronousErrorType() {
      AsyncErrorType_UC => {
          syndrome = __SetSlice_bits(25, 3, syndrome, 10, 0b000)
      },
      AsyncErrorType_UEU => {
          syndrome = __SetSlice_bits(25, 3, syndrome, 10, 0b001)
      },
      AsyncErrorType_UEO => {
          syndrome = __SetSlice_bits(25, 3, syndrome, 10, 0b010)
      },
      AsyncErrorType_UER => {
          syndrome = __SetSlice_bits(25, 3, syndrome, 10, 0b011)
      },
      AsyncErrorType_CE => {
          syndrome = __SetSlice_bits(25, 3, syndrome, 10, 0b110)
      }
    };
    let syndrome = __SetSlice_bits(25, 6, syndrome, 0, 0b010001);
    syndrome
}

val VFPExpandImm : forall ('N : Int). bits(8) -> bits('N) effect {escape}

function VFPExpandImm imm8 = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - 'E - 1. int('n)} = 'N - E - 1;
    let sign : bits(1) = [imm8[7]];
    let exp : bits('E) = (~([imm8[6]]) @ replicate_bits([imm8[6]], E - 3)) @ slice(imm8, 4, 2);
    let frac : bits('N - 1 - 'E) = slice(imm8, 0, 4) @ Zeros(F - 4);
    (sign @ exp) @ frac
}

val SignExtend__0 : forall ('M : Int) ('N : Int), 'M >= 0.
  (bits('M), int('N)) -> bits('N) effect {escape}

val SignExtend__1 : forall ('M : Int) ('N : Int), 'M >= 0.
  bits('M) -> bits('N) effect {escape}

overload SignExtend = {SignExtend__0, SignExtend__1}

function SignExtend__0 (x, N) = {
    assert(N >= 'M);
    replicate_bits([x['M - 1]], N - 'M) @ x
}

function SignExtend__1 x = {
    SignExtend(x, 'N)
}

val Extend__0 : forall ('M : Int) ('N : Int), 'M >= 0.
  (bits('M), int('N), bool) -> bits('N) effect {escape}

val Extend__1 : forall ('M : Int) ('N : Int), 'M >= 0.
  (bits('M), bool) -> bits('N) effect {escape}

overload Extend = {Extend__0, Extend__1}

function Extend__0 (x, N, unsigned) = {
    if unsigned then ZeroExtend(x, N) else SignExtend(x, N)
}

function Extend__1 (x, unsigned) = {
    Extend(x, 'N, unsigned)
}

val ASR_C : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> (bits('N), bits(1)) effect {escape}

function ASR_C (x, shift) = {
    assert(shift > 0);
    let (shift as 'S) : {'n, (0 <= 'n & 'n <= 'N). int('n)} = if shift > 'N then 'N else shift;
    let extended_x : bits('S + 'N) = SignExtend(x, shift + 'N);
    let result : bits('N) = slice(extended_x, shift, 'N);
    let carry_out : bits(1) = [extended_x[shift - 1]];
    return((result, carry_out))
}

val ASR : forall ('N : Int) ('shift : Int), ('shift >= 0 & 'N >= 0).
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function ASR (x, shift) = {
    assert(shift >= 0);
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if shift == 0 then result = x
    else (result, __anon1) = ASR_C(x, shift);
    result
}

val Ones__0 : forall ('N : Int). int('N) -> bits('N)

val Ones__1 : forall ('N : Int). unit -> bits('N)

overload Ones = {Ones__0, Ones__1}

function Ones__0 N = {
    replicate_bits(0b1, N)
}

function Ones__1 () = {
    Ones('N)
}

register configuration sp_rel_access_pc : bits(64) = Ones(64)

val _ChooseRandomNonExcludedTag : bits(16) -> bits(4) effect {rreg}

function _ChooseRandomNonExcludedTag exclude = {
    let exclude = exclude | slice(GCR_EL1, 0, 16);
    if exclude == Ones(16) then {
        return(0x0)
    };
    tag : bits(4) = 0x0;
    while [exclude[UInt(tag)]] == 0b1 do {
        tag = tag + 0x1
    };
    tag
}

val IsOnes : forall ('N : Int), 'N >= 0. bits('N) -> bool

function IsOnes x = {
    x == Ones('N)
}

val FPOnePointFive : forall ('N : Int). bits(1) -> bits('N) effect {escape}

function FPOnePointFive sign = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    let exp : bits('E) = 0b0 @ Ones(E - 1);
    let frac : bits('N - 1 - 'E) = 0b1 @ Zeros(F - 1);
    (sign @ exp) @ frac
}

val FPMaxNormal : forall ('N : Int). bits(1) -> bits('N) effect {escape}

function FPMaxNormal sign = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    let exp : bits('E) = Ones(E - 1) @ 0b0;
    let frac : bits('N - 1 - 'E) = Ones(F);
    (sign @ exp) @ frac
}

val FPInfinity : forall ('N : Int). bits(1) -> bits('N) effect {escape}

function FPInfinity sign = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    let exp : bits('E) = Ones(E);
    let frac : bits('N - 1 - 'E) = Zeros(F);
    (sign @ exp) @ frac
}

val FPDefaultNaN : forall ('N : Int). unit -> bits('N) effect {escape}

function FPDefaultNaN () = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'E : {'n, 'n in {5, 8, 11}. int('n)} = if 'N == 16 then 5 else if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    let sign : vector(1, dec, bit) = 0b0;
    let exp : bits('E) = Ones(E);
    let frac : bits('N - 1 - 'E) = 0b1 @ Zeros(F - 1);
    (sign @ exp) @ frac
}

val FPConvertNaN : forall ('N : Int) ('M : Int), 'N >= 0.
  bits('N) -> bits('M) effect {escape, undef}

function FPConvertNaN op = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert('M == 16 | 'M == 32 | 'M == 64);
    result : bits('M) = undefined : bits('M);
    frac : bits(51) = undefined : bits(51);
    let sign : bits(1) = [op['N - 1]];
    match 'N {
      64 => {
          frac = slice(op, 0, 51)
      },
      32 => {
          frac = slice(op, 0, 22) @ Zeros(29)
      },
      16 => {
          frac = slice(op, 0, 9) @ Zeros(42)
      }
    };
    let frac = frac;
    match 'M {
      64 => {
          result = (sign @ Ones('M - 52)) @ frac
      },
      32 => {
          result = (sign @ Ones('M - 23)) @ slice(frac, 29, 22)
      },
      16 => {
          result = (sign @ Ones('M - 10)) @ slice(frac, 42, 9)
      }
    };
    let result = result;
    result
}

val RecipSqrtEstimate : forall ('a : Int). int('a) -> int effect {escape}

function RecipSqrtEstimate a__arg = {
    a : int = a__arg;
    assert(128 <= a & a < 512);
    if a < 256 then {
        a = a * 2 + 1
    } else {
        a = shl_int(shr_int(a, 1), 1);
        a = (a + 1) * 2
    };
    b : int = 512;
    while a * (b + 1) * (b + 1) < 2 ^ 28 do {
        b = b + 1
    };
    let r : int = (b + 1) / 2;
    assert(256 <= r & r < 512);
    r
}

val UnsignedRSqrtEstimate : forall ('N : Int), 'N >= 0.
  bits('N) -> bits('N) effect {escape, undef}

function UnsignedRSqrtEstimate operand = {
    assert('N == 16 | 'N == 32);
    estimate : int = undefined : int;
    result : bits('N) = undefined : bits('N);
    if slice(operand, 'N - 2, 2) == 0b00 then {
        result = Ones('N)
    } else {
        match 'N {
          16 => {
              estimate = RecipSqrtEstimate(UInt(slice(operand, 7, 9)))
          },
          32 => {
              estimate = RecipSqrtEstimate(UInt(slice(operand, 23, 9)))
          }
        };
        result = __GetSlice_int(9, estimate, 0) @ Zeros('N - 9)
    };
    result
}

val RecipEstimate : forall ('a : Int). int('a) -> int effect {escape}

function RecipEstimate a = {
    assert(256 <= a & a < 512);
    let a = a * 2 + 1;
    let 'b = 2 ^ 19 / a;
    let r : int = (b + 1) / 2;
    assert(256 <= r & r < 512);
    r
}

val UnsignedRecipEstimate : forall ('N : Int), 'N >= 0.
  bits('N) -> bits('N) effect {escape, undef}

function UnsignedRecipEstimate operand = {
    assert('N == 16 | 'N == 32);
    estimate : int = undefined : int;
    result : bits('N) = undefined : bits('N);
    if [operand['N - 1]] == 0b0 then {
        result = Ones('N)
    } else {
        match 'N {
          16 => {
              estimate = RecipEstimate(UInt(slice(operand, 7, 9)))
          },
          32 => {
              estimate = RecipEstimate(UInt(slice(operand, 23, 9)))
          }
        };
        result = __GetSlice_int(9, estimate, 0) @ Zeros('N - 9)
    };
    result
}

val PACSub : bits(64) -> bits(64) effect {undef}

function PACSub Tinput = {
    Toutput : bits(64) = undefined : bits(64);
    foreach (i from 0 to 15 by 1 in inc) {
        match slice(Tinput, 4 * i, 4) {
          0x0 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xB)
          },
          0x1 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x6)
          },
          0x2 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x8)
          },
          0x3 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xF)
          },
          0x4 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xC)
          },
          0x5 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x0)
          },
          0x6 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x9)
          },
          0x7 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xE)
          },
          0x8 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x3)
          },
          0x9 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x7)
          },
          0xA => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x4)
          },
          0xB => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x5)
          },
          0xC => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xD)
          },
          0xD => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x2)
          },
          0xE => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x1)
          },
          0xF => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xA)
          }
        }
    };
    Toutput
}

val PACMult : bits(64) -> bits(64) effect {undef}

function PACMult Sinput = {
    t0 : bits(4) = undefined : bits(4);
    t1 : bits(4) = undefined : bits(4);
    t2 : bits(4) = undefined : bits(4);
    t3 : bits(4) = undefined : bits(4);
    Soutput : bits(64) = undefined : bits(64);
    foreach (i from 0 to 3 by 1 in inc) {
        t0 = __SetSlice_bits(4, 4, t0, 0, RotCell(slice(Sinput, 4 * (i + 8), 4), 1) ^ RotCell(slice(Sinput, 4 * (i + 4), 4), 2));
        t0 = __SetSlice_bits(4, 4, t0, 0, slice(t0, 0, 4) ^ RotCell(slice(Sinput, 4 * i, 4), 1));
        t1 = __SetSlice_bits(4, 4, t1, 0, RotCell(slice(Sinput, 4 * (i + 12), 4), 1) ^ RotCell(slice(Sinput, 4 * (i + 4), 4), 1));
        t1 = __SetSlice_bits(4, 4, t1, 0, slice(t1, 0, 4) ^ RotCell(slice(Sinput, 4 * i, 4), 2));
        t2 = __SetSlice_bits(4, 4, t2, 0, RotCell(slice(Sinput, 4 * (i + 12), 4), 2) ^ RotCell(slice(Sinput, 4 * (i + 8), 4), 1));
        t2 = __SetSlice_bits(4, 4, t2, 0, slice(t2, 0, 4) ^ RotCell(slice(Sinput, 4 * i, 4), 1));
        t3 = __SetSlice_bits(4, 4, t3, 0, RotCell(slice(Sinput, 4 * (i + 12), 4), 1) ^ RotCell(slice(Sinput, 4 * (i + 8), 4), 2));
        t3 = __SetSlice_bits(4, 4, t3, 0, slice(t3, 0, 4) ^ RotCell(slice(Sinput, 4 * (i + 4), 4), 1));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * i, slice(t3, 0, 4));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * (i + 4), slice(t2, 0, 4));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * (i + 8), slice(t1, 0, 4));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * (i + 12), slice(t0, 0, 4))
    };
    Soutput
}

val PACInvSub : bits(64) -> bits(64) effect {undef}

function PACInvSub Tinput = {
    Toutput : bits(64) = undefined : bits(64);
    foreach (i from 0 to 15 by 1 in inc) {
        match slice(Tinput, 4 * i, 4) {
          0x0 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x5)
          },
          0x1 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xE)
          },
          0x2 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xD)
          },
          0x3 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x8)
          },
          0x4 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xA)
          },
          0x5 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xB)
          },
          0x6 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x1)
          },
          0x7 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x9)
          },
          0x8 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x2)
          },
          0x9 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x6)
          },
          0xA => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xF)
          },
          0xB => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x0)
          },
          0xC => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x4)
          },
          0xD => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xC)
          },
          0xE => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x7)
          },
          0xF => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x3)
          }
        }
    };
    Toutput
}

val ComputePAC : (bits(64), bits(64), bits(64), bits(64)) -> bits(64) effect {rreg, undef, wreg}

function ComputePAC (data, modifier, key0, key1) = {
    workingval : bits(64) = undefined : bits(64);
    runningmod : bits(64) = undefined : bits(64);
    roundkey : bits(64) = undefined : bits(64);
    modk0 : bits(64) = undefined : bits(64);
    let 'Alpha : bits(64) = __GetSlice_int(64, 13883517620612518109, 0);
    RC[0] = __GetSlice_int(64, 0, 0);
    RC[1] = __GetSlice_int(64, 1376283091369227076, 0);
    RC[2] = __GetSlice_int(64, 11820040416388919760, 0);
    RC[3] = __GetSlice_int(64, 589684135938649225, 0);
    RC[4] = __GetSlice_int(64, 4983270260364809079, 0);
    let modk0 = ([key0[0]] @ slice(key0, 2, 62)) @ ([key0[63]] ^ [key0[1]]);
    runningmod = modifier;
    workingval = data ^ key0;
    foreach (i from 0 to 4 by 1 in inc) {
        roundkey = key1 ^ runningmod;
        workingval = workingval ^ roundkey;
        workingval = workingval ^ RC[i];
        if i > 0 then {
            workingval = PACCellShuffle(workingval);
            workingval = PACMult(workingval)
        };
        workingval = PACSub(workingval);
        runningmod = TweakShuffle(slice(runningmod, 0, 64))
    };
    roundkey = modk0 ^ runningmod;
    workingval = workingval ^ roundkey;
    workingval = PACCellShuffle(workingval);
    workingval = PACMult(workingval);
    workingval = PACSub(workingval);
    workingval = PACCellShuffle(workingval);
    workingval = PACMult(workingval);
    workingval = key1 ^ workingval;
    workingval = PACCellInvShuffle(workingval);
    workingval = PACInvSub(workingval);
    workingval = PACMult(workingval);
    workingval = PACCellInvShuffle(workingval);
    workingval = workingval ^ key0;
    workingval = workingval ^ runningmod;
    foreach (i from 0 to 4 by 1 in inc) {
        workingval = PACInvSub(workingval);
        if i < 4 then {
            workingval = PACMult(workingval);
            workingval = PACCellInvShuffle(workingval)
        };
        runningmod = TweakInvShuffle(slice(runningmod, 0, 64));
        roundkey = key1 ^ runningmod;
        workingval = workingval ^ RC[4 - i];
        workingval = workingval ^ roundkey;
        workingval = workingval ^ Alpha
    };
    let workingval = workingval ^ modk0;
    workingval
}

let NUM_GTE_EXT_OBS_OBSERVATIONS : int(4 * 64) = NUM_GTE_EXT_OBS_OBSERVERS * NUM_GTE_EXT_OBS_OBSERVATIONS_PER_OBSERVER

register _GTEExtObsResult : vector(256, dec, bits(64))

register _GTEExtObsData : vector(256, dec, bits(64))

register _GTEExtObsAddress : vector(256, dec, bits(64))

register _GTEExtObsAccess : vector(256, dec, bits(16))

val __Reset : bool -> unit effect {escape, rreg, wreg}

function __Reset cold = {
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 8, val_name, 0, Zeros(8));
        set_TUBE(get_TUBE() & ~(__GetSlice_int(32, 255, 0)) | val_name)
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 1, val_name, 3, __GetSlice_int(1, 1, 0));
        val_name = __SetSlice_bits(32, 1, val_name, 2, __GetSlice_int(1, 1, 0));
        val_name = __SetSlice_bits(32, 1, val_name, 1, __GetSlice_int(1, 1, 0));
        val_name = __SetSlice_bits(32, 1, val_name, 0, __GetSlice_int(1, 1, 0));
        set_TargetCPU(get_TargetCPU() & ~(__GetSlice_int(32, 15, 0)) | val_name)
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1073741824, 0));
        AbortRgn64Lo1 = AbortRgn64Lo1 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Lo1_Hi = AbortRgn64Lo1_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1342177280, 0));
        AbortRgn64Hi1 = AbortRgn64Hi1 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Hi1_Hi = AbortRgn64Hi1_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1056964608, 0));
        AbortRgn64Lo2 = AbortRgn64Lo2 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Lo2_Hi = AbortRgn64Lo2_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1057423360, 0));
        AbortRgn64Hi2 = AbortRgn64Hi2 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Hi2_Hi = AbortRgn64Hi2_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 2, val_name, 26, Zeros(2));
        val_name = __SetSlice_bits(32, 1, val_name, 25, Zeros(1));
        val_name = __SetSlice_bits(32, 1, val_name, 24, Zeros(1));
        val_name = __SetSlice_bits(32, 2, val_name, 22, Zeros(2));
        val_name = __SetSlice_bits(32, 1, val_name, 21, Zeros(1));
        val_name = __SetSlice_bits(32, 1, val_name, 20, Zeros(1));
        set_AXIAbortCtl(get_AXIAbortCtl() & ~(__GetSlice_int(32, 267386880, 0)) | val_name)
    } until true;
    repeat {
        _ScheduleIRQ = Zeros();
        _ClearIRQ = Zeros();
        ScheduledIRQ = false;
        _IRQPending = false
    } until true;
    repeat {
        _ScheduleFIQ = Zeros();
        _ClearIRQ = Zeros();
        ScheduledFIQ = false;
        _FIQPending = false
    } until true;
    repeat {
        _GTEActive = false;
        _GTEStatus = Zeros();
        _GTEParamLo = Zeros();
        _PPURBAR = Zeros();
        _PPURSER = Zeros();
        _PPURACR = Zeros();
        foreach (i from 0 to (NUM_GTE_REGIONS - 1) by 1 in inc) {
            _GTE_PPU_SizeEn[i] = Zeros(32);
            _GTE_PPU_Address[i] = Zeros(64);
            _GTE_PPU_Access[i] = Zeros(32)
        }
    } until true;
    repeat {
        foreach (i from 0 to (NUM_GTE_EXT_OBS_OBSERVERS - 1) by 1 in inc) {
            _GTEExtObsActive[i] = if i == 0 then true else false;
            _GTEExtObsIndex[i] = 0;
            _GTEExtObsCount[i] = 0;
            _GTEExtObsResultIndex[i] = 0;
            _GTEExtObsResultIsAddress[i] = true
        };
        foreach (i from 0 to (NUM_GTE_EXT_OBS_OBSERVATIONS - 1) by 1 in inc) {
            _GTEExtObsAccess[i] = Zeros(16);
            _GTEExtObsAddress[i] = Zeros(64);
            _GTEExtObsData[i] = Zeros(64);
            _GTEExtObsResult[i] = Zeros(64)
        }
    } until true;
    repeat {
        _GTE_AS_Address = Zeros();
        _GTE_AS_Size = Zeros();
        _GTE_AS_Access = Zeros();
        _GTE_AS_AccessCount = 0
    } until true;
    return()
}

val GTEPerformExtObsCommon : forall ('observer : Int).
  int('observer) -> unit effect {rmem, rreg, undef, wmem, wreg}

function GTEPerformExtObsCommon observer = {
    let currentNS : vector(1, dec, bit) = 0b1;
    let 'procid = UInt(MPIDR_EL1);
    ok : bool = undefined : bool;
    foreach (i
    from _GTEExtObsIndex[observer]
    to (_GTEExtObsIndex[observer] + _GTEExtObsCount[observer] - 1)
    by 1
    in inc) {
        NS : bits(1) = undefined : bits(1);
        match slice(_GTEExtObsAccess[i], 5, 3) {
          ? if ? == GTE_EXT_OBS_OUTER_NS => {
              NS = 0b1
          },
          ? if ? == GTE_EXT_OBS_INNER_NS => {
              NS = 0b1
          },
          ? if ? == GTE_EXT_OBS_OUTER_S => {
              NS = 0b0
          },
          ? if ? == GTE_EXT_OBS_INNER_S => {
              NS = 0b0
          },
          _ => {
              prerr("TODO: GTE External observer requires 'current' security state\n");
              NS = currentNS
          }
        };
        let NS = NS;
        match slice(_GTEExtObsAccess[i], 0, 3) {
          ? if ? == GTE_EXT_OBS_ACC_READ => {
              data : bits(64) = Zeros(64);
              ok = true;
              match slice(_GTEExtObsAccess[i], 8, 3) {
                ? if ? == GTE_EXT_OBS_ACC_SIZE64 => {
                    data = __SetSlice_bits(64, 64, data, 0, __ReadMemory(8, slice(_GTEExtObsAddress[i], 0, 56)))
                },
                ? if ? == GTE_EXT_OBS_ACC_SIZE32 => {
                    data = __SetSlice_bits(64, 32, data, 0, __ReadMemory(4, slice(_GTEExtObsAddress[i], 0, 56)))
                },
                ? if ? == GTE_EXT_OBS_ACC_SIZE16 => {
                    data = __SetSlice_bits(64, 16, data, 0, __ReadMemory(2, slice(_GTEExtObsAddress[i], 0, 56)))
                },
                ? if ? == GTE_EXT_OBS_ACC_SIZE8 => {
                    data = __SetSlice_bits(64, 8, data, 0, __ReadMemory(1, slice(_GTEExtObsAddress[i], 0, 56)))
                },
                _ => {
                    ok = false
                }
              };
              if ok then {
                  _GTEExtObsResult[i] = data
              } else {
                  _GTEExtObsResult[i] = GTE_ST_REQUEST_FAIL
              }
          },
          ? if ? == GTE_EXT_OBS_ACC_WRITE => {
              ok = true;
              match slice(_GTEExtObsAccess[i], 8, 3) {
                ? if ? == GTE_EXT_OBS_ACC_SIZE64 => {
                    __WriteMemory(8, slice(_GTEExtObsAddress[i], 0, 56), slice(_GTEExtObsData[i], 0, 64))
                },
                ? if ? == GTE_EXT_OBS_ACC_SIZE32 => {
                    __WriteMemory(4, slice(_GTEExtObsAddress[i], 0, 56), slice(_GTEExtObsData[i], 0, 32))
                },
                ? if ? == GTE_EXT_OBS_ACC_SIZE16 => {
                    __WriteMemory(2, slice(_GTEExtObsAddress[i], 0, 56), slice(_GTEExtObsData[i], 0, 16))
                },
                ? if ? == GTE_EXT_OBS_ACC_SIZE8 => {
                    __WriteMemory(1, slice(_GTEExtObsAddress[i], 0, 56), slice(_GTEExtObsData[i], 0, 8))
                },
                _ => {
                    ok = false
                }
              };
              if ok then {
                  _GTEExtObsResult[i] = GTE_ST_REQUEST_GRANTED
              } else {
                  _GTEExtObsResult[i] = GTE_ST_REQUEST_FAIL
              }
          },
          _ => {
              _GTEExtObsResult[i] = GTE_ST_REQUEST_FAIL
          }
        }
    };
    return()
}

val MAP_vPARTID : bits(16) -> (bits(16), bool) effect {rreg, undef}

function MAP_vPARTID vpartid = {
    ret : bits(16) = undefined : bits(16);
    err : bool = undefined : bool;
    virt : int = UInt(vpartid);
    let 'vmprmax = UInt(slice(MPAMIDR_EL1, 18, 3));
    let 'vpartid_max : {'n, 'n == 4 * 'vmprmax + 3. int('n)} = 4 * vmprmax + 3;
    if virt > vpartid_max then {
        virt = virt % (vpartid_max + 1)
    };
    if [MPAMVPMV_EL2[virt]] == 0b1 then {
        ret = mapvpmw(virt);
        err = false
    } else {
        if [MPAMVPMV_EL2[0]] == 0b1 then {
            ret = slice(MPAMVPM0_EL2, 0, 16);
            err = false
        } else {
            ret = DefaultPARTID;
            err = true
        }
    };
    let 'partid_max = UInt(slice(MPAMIDR_EL1, 0, 16));
    if UInt(ret) > partid_max then {
        ret = DefaultPARTID;
        err = true
    };
    return((ret, err))
}

val ImpDefTagArrayStartAndCount : bits(64) -> (bits(64), int) effect {escape, rreg}

function ImpDefTagArrayStartAndCount address__arg = {
    address = address__arg;
    let block_bitspan : int = UInt(slice(DCZID_EL0, 0, 4)) + 2;
    let block_bitspan = if block_bitspan < LOG2_TAG_GRANULE then LOG2_TAG_GRANULE else block_bitspan;
    if block_bitspan < 8 then {
        address = __SetSlice_bits(64, block_bitspan, address, 0, Zeros(block_bitspan));
        let first_block : bits(4) = ZeroExtend(slice(address, block_bitspan, negate(block_bitspan) + 8), 4);
        let 'first_tag : int = UInt(first_block) * 4;
        return((address, 4))
    } else {
        address = __SetSlice_bits(64, 8, address, 0, Zeros(8));
        return((address, 16))
    }
}

val GTESetupExtObs64 : unit -> unit effect {rreg, wreg}

function GTESetupExtObs64 () = {
    let 'access_count = UInt(_GTEParam[0]);
    let 'address_data_count = UInt(_GTEParam[1]);
    prerr("GTESetupExtObs64(accesses=(");
    foreach (i from 0 to (access_count - 1) by 1 in inc) {
        prerr(HexStr(UInt(_GTEListParam0[i])) ++ " ")
    };
    prerr("), address_data=(");
    foreach (i from 0 to (address_data_count - 1) by 1 in inc) {
        prerr(HexStr(UInt(_GTEListParam1[i])) ++ " ")
    };
    prerr("))\n");
    if access_count == 0 then {
        prerr("  access list empty\n");
        _GTEStatus = Ones(64);
        return()
    };
    let 'num_addresses = UInt(slice(_GTEListParam0[0], 0, 8));
    if address_data_count < num_addresses * 2 then {
        prerr("address/data list too short\n");
        _GTEStatus = Ones(64);
        return()
    };
    if access_count * 4 - 1 < num_addresses then {
        prerr("  access list too short\n");
        _GTEStatus = Ones(64);
        return()
    };
    let 'observer = GTEAllocExtObs();
    if observer == negate(1) then {
        _GTEStatus = Ones(64);
        return()
    };
    let 'ibase : {'n, 'n == 64 * 'observer. int('n)} = NUM_GTE_EXT_OBS_OBSERVATIONS_PER_OBSERVER * observer;
    ai : int = 8;
    foreach (i from 0 to (num_addresses - 1) by 1 in inc) {
        let access_lo : bits(8) = slice(_GTEListParam0[shr_int(ai, 6)], ai % 64, 8);
        ai = ai + 8;
        let access_hi : bits(8) = slice(_GTEListParam0[shr_int(ai, 6)], ai % 64, 8);
        ai = ai + 8;
        _GTEExtObsAccess[ibase + i] = access_hi @ access_lo;
        _GTEExtObsAddress[ibase + i] = _GTEListParam1[i * 2];
        _GTEExtObsData[ibase + i] = _GTEListParam1[i * 2 + 1]
    };
    _GTEExtObsCount[observer] = num_addresses;
    _GTEExtObsIndex[observer] = ibase;
    _GTEExtObsResultIndex[observer] = ibase;
    _GTEExtObsResultIsAddress[observer] = true;
    _GTEStatus = __GetSlice_int(64, 1, 0);
    return()
}

val GTESetupExtObs : unit -> unit effect {rreg, wreg}

function GTESetupExtObs () = {
    let 'address_data_count = UInt(_GTEParam[0]);
    let 'access_count = UInt(_GTEParam[1]);
    prerr("GTESetupExtObs(address_data=(");
    foreach (i from 0 to (address_data_count - 1) by 1 in inc) {
        prerr(HexStr(UInt(slice(_GTEListParam0[i], 0, 32))) ++ " ")
    };
    prerr("), accesses=(");
    foreach (i from 0 to (access_count - 1) by 1 in inc) {
        prerr(HexStr(UInt(slice(_GTEListParam1[i], 0, 32))) ++ " ")
    };
    prerr("))\n");
    if access_count == 0 then {
        prerr("   ERROR: zero accesses provided\n");
        _GTEStatus = Ones(64);
        return()
    };
    let 'num_addresses = UInt(slice(_GTEListParam1[0], 0, 8));
    if address_data_count < num_addresses * 2 then {
        prerr("    ERROR: address/data count mismatch\n");
        _GTEStatus = Ones(64);
        return()
    };
    if access_count * 4 - 1 < num_addresses then {
        prerr("    ERROR: address/count mismatch\n");
        _GTEStatus = Ones(64);
        return()
    };
    let 'observer = GTEAllocExtObs();
    if observer == negate(1) then {
        prerr("    no more observers\n");
        _GTEStatus = Ones(64);
        return()
    };
    let 'ibase : {'n, 'n == 64 * 'observer. int('n)} = NUM_GTE_EXT_OBS_OBSERVATIONS_PER_OBSERVER * observer;
    ai : int = 8;
    foreach (i from 0 to (num_addresses - 1) by 1 in inc) {
        let access : bits(8) = slice(_GTEListParam1[shr_int(ai, 5)], ai % 32, 8);
        ai = ai + 8;
        _GTEExtObsAccess[ibase + i] = Zeros(8) @ access;
        _GTEExtObsAddress[ibase + i] = _GTEListParam0[i * 2];
        _GTEExtObsData[ibase + i] = _GTEListParam0[i * 2 + 1]
    };
    _GTEExtObsCount[observer] = num_addresses;
    _GTEExtObsIndex[observer] = ibase;
    _GTEExtObsResultIndex[observer] = ibase;
    _GTEExtObsResultIsAddress[observer] = true;
    _GTEStatus = Zeros(64);
    return()
}

val Align__0 : forall ('x : Int) ('y : Int). (int('x), int('y)) -> int

val Align__1 : forall ('N : Int) ('y : Int). (bits('N), int('y)) -> bits('N)

overload Align = {Align__0, Align__1}

function Align__0 (x, y) = y * (x / y)

function Align__1 (x, y) = let x = UInt(x) in __GetSlice_int('N, Align(x, y), 0)

val aset_X : forall ('width : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits('width)) -> unit effect {escape, wreg}

function aset_X (n, value_name) = {
    assert('width == 32 | 'width == 64);
    if n != 31 then _R[n] = ZeroExtend(value_name, 64)
    else ();
    return()
}

overload X = {aset_X}

val semihost_ret : bits(64) -> unit effect {escape, wreg}

function semihost_ret value_name = {
    X(0) = value_name
}

val integer_arithmetic_address_pcrel : forall ('d : Int), (0 <= 'd & 'd <= 31).
  (int('d), bits(64), bool) -> unit effect {escape, rreg, wreg}

function integer_arithmetic_address_pcrel (d, imm, page) = {
    base : bits(64) = aget_PC();
    if page then base = __SetSlice_bits(64, 12, base, 0, Zeros(12))
    else ();
    X(d) = base + imm
}

val AArch64_ResetGeneralRegisters : unit -> unit effect {escape, undef, wreg}

function AArch64_ResetGeneralRegisters () = {
    foreach (i from 0 to 30 by 1 in inc) {
        X(i) = undefined : bits(64)
    };
    return()
}

val aset_ELR__0 : (bits(2), bits(64)) -> unit effect {escape, wreg}

val aset_ELR__1 : bits(64) -> unit effect {escape, rreg, wreg}

overload aset_ELR = {aset_ELR__0, aset_ELR__1}

overload ELR = {aset_ELR__0, aset_ELR__1}

function aset_ELR__0 (el, value_name) = let r : bits(64) = value_name in {
    match el {
      ? if ? == EL1 => ELR_EL1 = r,
      ? if ? == EL2 => ELR_EL2 = r,
      ? if ? == EL3 => ELR_EL3 = r,
      _ => Unreachable()
    };
    return()
}

function aset_ELR__1 value_name = {
    assert(PSTATE.EL != EL0);
    aset_ELR(PSTATE.EL, value_name);
    return()
}

val aget_X : forall 'width 'n,
  ('n >= 0 & 'n <= 31 & 'width in {8, 16, 32, 64}).
  int('n) -> bits('width) effect {rreg}

function aget_X n = if n != 31 then slice(_R[n], 0, 'width) else Zeros('width)

overload X = {aget_X}

val semihost_arg : forall ('n : Int), ('n >= 0 & 'n <= 31).
  int('n) -> bits(64) effect {rreg}

function semihost_arg n = {
    X(n)
}

val integer_tags_mcinserttagmask : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, wreg}

function integer_tags_mcinserttagmask (d, m, n) = {
    let address : bits(64) = if n == 31 then SP() else X(n);
    mask : bits(64) = X(m);
    let tag : bits(4) = AllocationTagFromAddress(address);
    let mask = __SetSlice_bits(64, 1, mask, UInt(tag), 0b1);
    X(d) = mask
}

val integer_insext_insert_movewide : forall 'd 'datasize 'pos,
  ('d >= 0 & 'd <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('d), int('datasize), bits(16), MoveWideOp, int('pos)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_insert_movewide (d, datasize, imm, opcode, pos) = {
    result : bits('datasize) = undefined : bits('datasize);
    if opcode == MoveWideOp_K then {
        result = X(d)
    } else {
        result = Zeros()
    };
    result = __SetSlice_bits(datasize, 16, result, pos, imm);
    if opcode == MoveWideOp_N then {
        result = ~(result)
    };
    X(d) = result
}

val integer_insext_extract_immediate : forall 'd 'datasize 'lsb 'm 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('lsb), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_extract_immediate (d, datasize, lsb, m, n) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let concat : bits(2 * 'datasize) = operand1 @ operand2;
    let result = slice(concat, lsb, datasize);
    X(d) = result
}

val integer_flags_setf : forall 'msb 'n,
  ('n >= 0 & 'n <= 31) & 'msb + 1 >= 0.
  (int('msb), int('n)) -> unit effect {rreg, wreg}

function integer_flags_setf (msb, n) = {
    let tmpreg : bits(32) = X(n);
    PSTATE.N = [tmpreg[msb]];
    PSTATE.Z = if slice(tmpreg, 0, msb + 1) == Zeros(msb + 1) then 0b1 else 0b0;
    PSTATE.V = [tmpreg[msb + 1]] ^ [tmpreg[msb]]
}

val integer_flags_rmif : forall ('lsb : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  (int('lsb), bits(4), int('n)) -> unit effect {rreg, undef, wreg}

function integer_flags_rmif (lsb, mask, n) = {
    tmp : bits(4) = undefined : bits(4);
    let tmpreg : bits(64) = X(n);
    let tmp = slice(tmpreg @ tmpreg, lsb, 4);
    if [mask[3]] == 0b1 then {
        PSTATE.N = [tmp[3]]
    };
    if [mask[2]] == 0b1 then {
        PSTATE.Z = [tmp[2]]
    };
    if [mask[1]] == 0b1 then {
        PSTATE.C = [tmp[1]]
    };
    if [mask[0]] == 0b1 then {
        PSTATE.V = [tmp[0]]
    }
}

val integer_crc : forall ('crc32c : Bool) 'd 'm 'n 'size,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31 & 'size in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (bool('crc32c), int('d), int('m), int('n), int('size)) -> unit effect {escape, rreg, undef, wreg}

function integer_crc (crc32c, d, m, n, size) = {
    let acc : bits(32) = X(n);
    let val_name : bits('size) = X(m);
    let poly : vector(32, dec, bit) = __GetSlice_int(32, if crc32c then 517762881 else 79764919, 0);
    let tempacc : bits('size + 32) = BitReverse(acc) @ Zeros(size);
    let tempval : bits('size + 32) = BitReverse(val_name) @ Zeros(32);
    X(d) = BitReverse(Poly32Mod2(tempacc ^ tempval, poly))
}

val integer_arithmetic_rev : forall 'container_size 'd 'datasize 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('container_size), int('d), int('datasize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rev (container_size, d, datasize, n) = {
    let operand : bits('datasize) = X(n);
    result : bits('datasize) = undefined : bits('datasize);
    let 'containers : {'n, 'n == div('datasize, 'container_size). int('n)} = datasize / container_size;
    let 'elements_per_container : {'n, 'n == div('container_size, 8). int('n)} = container_size / 8;
    index : int = 0;
    rev_index : int = undefined : int;
    foreach (c from 0 to (containers - 1) by 1 in inc) {
        rev_index = index + (elements_per_container - 1) * 8;
        foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
            result = __SetSlice_bits(datasize, 8, result, rev_index, slice(operand, index, 8));
            index = index + 8;
            rev_index = rev_index - 8
        }
    };
    X(d) = result
}

val integer_arithmetic_rbit : forall 'd 'datasize 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rbit (d, datasize, n) = {
    let operand : bits('datasize) = X(n);
    result : bits('datasize) = undefined : bits('datasize);
    foreach (i from 0 to (datasize - 1) by 1 in inc) {
        result = __SetSlice_bits(datasize, 1, result, datasize - 1 - i, [operand[i]])
    };
    X(d) = result
}

val integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags : forall 'd 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31 | not(not('m == 31))) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags (d, m, n, setflags) = {
    operand1 : bits(64) = if n == 31 then SP() else X(n);
    operand2 : bits(64) = if m == 31 then SP() else X(m);
    let operand1 = SignExtend(slice(operand1, 0, 56), 64);
    operand2 = SignExtend(slice(operand2, 0, 56), 64);
    result : bits(64) = undefined : bits(64);
    nzcv : bits(4) = undefined : bits(4);
    let operand2 = ~(operand2);
    (result, nzcv) = AddWithCarry(operand1, operand2, 0b1);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val integer_arithmetic_pointer_mcsubtracttaggedaddress : forall 'd 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31 | not(not('m == 31))) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddress (d, m, n, setflags) = {
    operand1 : bits(64) = if n == 31 then SP() else X(n);
    operand2 : bits(64) = if m == 31 then SP() else X(m);
    let operand1 = SignExtend(slice(operand1, 0, 56), 64);
    operand2 = SignExtend(slice(operand2, 0, 56), 64);
    result : bits(64) = undefined : bits(64);
    nzcv : bits(4) = undefined : bits(4);
    let operand2 = ~(operand2);
    (result, nzcv) = AddWithCarry(operand1, operand2, 0b1);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val integer_arithmetic_mul_widening_64128hi : forall 'd 'datasize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, wreg}

function integer_arithmetic_mul_widening_64128hi (d, datasize, m, n, unsigned) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let result : int = asl_Int(operand1, unsigned) * asl_Int(operand2, unsigned);
    X(d) = __GetSlice_int(64, result, 64)
}

val integer_arithmetic_mul_widening_3264 : forall 'a 'd 'datasize 'destsize 'm 'n ('sub_op : Bool) ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('a >= 0 & 'a <= 31 & 'destsize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_widening_3264 (a, d, datasize, destsize, m, n, sub_op, unsigned) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let operand3 : bits('destsize) = X(a);
    result : int = undefined : int;
    if sub_op then {
        result = asl_Int(operand3, unsigned) - asl_Int(operand1, unsigned) * asl_Int(operand2, unsigned)
    } else {
        result = asl_Int(operand3, unsigned) + asl_Int(operand1, unsigned) * asl_Int(operand2, unsigned)
    };
    X(d) = __GetSlice_int(64, result, 0)
}

val integer_arithmetic_mul_uniform_addsub : forall 'a 'd 'datasize 'destsize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('a >= 0 & 'a <= 31 & 'destsize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_uniform_addsub (a, d, datasize, destsize, m, n, sub_op) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let operand3 : bits('destsize) = X(a);
    result : int = undefined : int;
    if sub_op then {
        result = UInt(operand3) - UInt(operand1) * UInt(operand2)
    } else {
        result = UInt(operand3) + UInt(operand1) * UInt(operand2)
    };
    X(d) = __GetSlice_int(destsize, result, 0)
}

val integer_arithmetic_div : forall 'd 'datasize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_div (d, datasize, m, n, unsigned) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    result : int = undefined : int;
    if IsZero(operand2) then {
        result = 0
    } else {
        result = RoundTowardsZero(Real(asl_Int(operand1, unsigned)) / Real(asl_Int(operand2, unsigned)))
    };
    X(d) = __GetSlice_int(datasize, result, 0)
}

val integer_arithmetic_cnt : forall 'd 'datasize 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('n), CountOp) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_cnt (d, datasize, n, opcode) = {
    result : int = undefined : int;
    let operand1 : bits('datasize) = X(n);
    if opcode == CountOp_CLZ then {
        result = CountLeadingZeroBits(operand1)
    } else {
        result = CountLeadingSignBits(operand1)
    };
    X(d) = __GetSlice_int(datasize, result, 0)
}

val integer_arithmetic_addsub_carry : forall 'd 'datasize 'm 'n ('setflags : Bool) ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_carry (d, datasize, m, n, setflags, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = X(m);
    nzcv : bits(4) = undefined : bits(4);
    if sub_op then {
        operand2 = ~(operand2)
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val ExtendReg : forall 'N 'reg 'shift,
  ('shift >= 0 & 'shift <= 4 & 'reg >= 0 & 'reg <= 31 & 'N in {8, 16, 32, 64}).
  (int('reg), ExtendType, int('shift)) -> bits('N) effect {escape, rreg, undef}

function ExtendReg (reg, typ, shift) = {
    assert(shift >= 0 & shift <= 4);
    let val_name : bits('N) = aget_X(reg);
    unsigned : bool = undefined : bool;
    len : int = undefined : int;
    match typ {
      ExtendType_SXTB => {
          unsigned = false;
          len = 8
      },
      ExtendType_SXTH => {
          unsigned = false;
          len = 16
      },
      ExtendType_SXTW => {
          unsigned = false;
          len = 32
      },
      ExtendType_SXTX => {
          unsigned = false;
          len = 64
      },
      ExtendType_UXTB => {
          unsigned = true;
          len = 8
      },
      ExtendType_UXTH => {
          unsigned = true;
          len = 16
      },
      ExtendType_UXTW => {
          unsigned = true;
          len = 32
      },
      ExtendType_UXTX => {
          unsigned = true;
          len = 64
      }
    };
    let 'len = min(len, 'N - shift);
    assert(constraint(('len in {8, 16, 32, 64} | 'len == 'N - 'shift)));
    Extend(slice(val_name, 0, len) @ Zeros(shift), 'N, unsigned)
}

val aget_ELR__0 : bits(2) -> bits(64) effect {escape, rreg, undef}

val aget_ELR__1 : unit -> bits(64) effect {escape, rreg, undef}

overload aget_ELR = {aget_ELR__0, aget_ELR__1}

overload ELR = {aget_ELR__0, aget_ELR__1}

function aget_ELR__0 el = {
    r : bits(64) = undefined : bits(64);
    match el {
      ? if ? == EL1 => {
          r = ELR_EL1
      },
      ? if ? == EL2 => {
          r = ELR_EL2
      },
      ? if ? == EL3 => {
          r = ELR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    r
}

function aget_ELR__1 () = {
    assert(PSTATE.EL != EL0);
    ELR(PSTATE.EL)
}

val __SetConfig : (string, int) -> unit effect {configuration, rreg, wreg}

function __SetConfig (arg, value_name) = {
    match () {
      () if arg == "trickbox_base" => {
          __trickbox_base_v8 = __GetSlice_int(52, value_name, 0)
      },
      () if arg == "cpu.has_arm_v8-1" => {
          __ConfigureV81Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-2" => {
          __ConfigureV82Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-3" => {
          __ConfigureV83Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-4" => {
          __ConfigureV84Features(value_name == 1)
      },
      () if arg == "cpu.has_arm_v8-5" => {
          __ConfigureV85Features(value_name == 1)
      },
      () if arg == "cpu.num_loregions" => {
          LORID_EL1 = __SetSlice_bits(32, 8, LORID_EL1, 0, __GetSlice_int(8, value_name, 0))
      },
      () if arg == "cpu.num_loregion_descriptors" => {
          LORID_EL1 = __SetSlice_bits(32, 8, LORID_EL1, 16, __GetSlice_int(8, value_name, 0))
      },
      () if arg == "cpu.has_pstate_pan" => {
          __pan_implemented = value_name != 0
      },
      () if arg == "cpu.has_16bit_vmids" => {
          __vmid16_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.enable_crc32" => {
          __crc32_implemented = value_name == 1
      },
      () if arg == "cpu.has_dot_product" => {
          __dot_product_implemented = value_name != 0
      },
      () if arg == "cpu.has_fp16" => {
          __fp16_implemented = value_name != 0
      },
      () if arg == "cpu.has_aarch32_hpd" => {
          __aa32_hpd_implemented = value_name == 1
      },
      () if arg == "cpu.cpu0.crypto_aes" => {
          __crypto_aes_implemented = value_name
      },
      () if arg == "cpu.cpu0.crypto_sha1" => {
          __crypto_sha1_implemented = value_name == 1
      },
      () if arg == "cpu.cpu0.crypto_sha256" => {
          __crypto_sha256_implemented = value_name == 1
      },
      () if arg == "cpu.cpu0.crypto_sha512" => {
          __crypto_sha512_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.crypto_sha3" => {
          __crypto_sha3_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.crypto_sm3" => {
          __crypto_sm3_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.crypto_sm4" => {
          __crypto_sm4_implemented = value_name != 0
      },
      () if arg == "cpu.cpu0.BBM" => {
          __block_bbm_implemented = value_name
      },
      () if arg == "cpu.PA_SIZE" => {
          __support_52bit_pa = value_name == 52
      },
      () if arg == "counter_addr" => {
          __CNTControlBase = __GetSlice_int(52, value_name, 0)
      },
      () if arg == "cpu.ext_abort_normal_cacheable_read_is_sync" => {
          __syncAbortOnReadNormCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_normal_noncacheable_read_is_sync" => {
          __syncAbortOnReadNormNonCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_device_read_is_sync" => {
          __syncAbortOnDeviceRead = value_name == 1
      },
      () if arg == "cpu.ext_abort_so_read_is_sync" => {
          __syncAbortOnSoRead = value_name == 1
      },
      () if arg == "cpu.ext_abort_so_write_is_sync" => {
          __syncAbortOnSoWrite = value_name == 1
      },
      () if arg == "cpu.ext_abort_prefetch_is_sync" => {
          __syncAbortOnPrefetch = value_name == 1
      },
      () if arg == "cpu.ext_abort_ttw_cacheable_read_is_sync" => {
          __syncAbortOnTTWCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_ttw_noncacheable_read_is_sync" => {
          __syncAbortOnTTWNonCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_normal_cacheable_write_is_sync" => {
          __syncAbortOnWriteNormCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_normal_noncacheable_write_is_sync" => {
          __syncAbortOnWriteNormNonCache = value_name == 1
      },
      () if arg == "cpu.ext_abort_device_write_is_sync" => {
          __syncAbortOnDeviceWrite = value_name == 1
      },
      () if arg == "cpu.has_mpam" => {
          __mpam_implemented = value_name == 1
      },
      () if arg == "cpu.has_mpamhcr" => {
          __mpam_has_hcr = value_name == 1
      },
      () if arg == "cpu.mpam_partid_max" => {
          __mpam_partid_max = __GetSlice_int(16, value_name, 0)
      },
      () if arg == "cpu.mpam_pmg_max" => {
          __mpam_pmg_max = __GetSlice_int(8, value_name, 0)
      },
      () if arg == "cpu.mpam_vpmr_max" => {
          __mpam_vpmr_max = __GetSlice_int(3, value_name, 0)
      },
      () if arg == "cpu.unpred_tsize_aborts" => {
          __unpred_tsize_aborts = value_name == 1
      },
      () if arg == "cpu.cpu0.CONFIG64" => {
          CFG_RMR_AA64 = __GetSlice_int(1, value_name, 0)
      },
      () if arg == "cpu.cpu0.RVBAR" => {
          CFG_RVBAR = __GetSlice_int(64, value_name, 0)
      },
      () if arg == "cpu.has_tlb" => {
          __tlb_enabled = value_name == 1
      },
      () if arg == "cpu.has_trickbox" => {
          __trickbox_enabled = value_name == 1
      },
      () if arg == "__trickbox_base_v8" => {
          __trickbox_base_v8 = __raw_GetSlice_int(52, value_name, 0)
      },
      () if arg == "__syncAbortOnReadNormCache" => {
          __syncAbortOnReadNormCache = value_name != 0
      },
      () if arg == "__syncAbortOnReadNormNonCache" => {
          __syncAbortOnReadNormNonCache = value_name != 0
      },
      () if arg == "__syncAbortOnDeviceRead" => {
          __syncAbortOnDeviceRead = value_name != 0
      },
      () if arg == "__syncAbortOnSoRead" => {
          __syncAbortOnSoRead = value_name != 0
      },
      () if arg == "__syncAbortOnSoWrite" => {
          __syncAbortOnSoWrite = value_name != 0
      },
      () if arg == "__syncAbortOnPrefetch" => {
          __syncAbortOnPrefetch = value_name != 0
      },
      () if arg == "__syncAbortOnTTWCache" => {
          __syncAbortOnTTWCache = value_name != 0
      },
      () if arg == "__syncAbortOnTTWNonCache" => {
          __syncAbortOnTTWNonCache = value_name != 0
      },
      () if arg == "__syncAbortOnWriteNormCache" => {
          __syncAbortOnWriteNormCache = value_name != 0
      },
      () if arg == "__syncAbortOnWriteNormNonCache" => {
          __syncAbortOnWriteNormNonCache = value_name != 0
      },
      () if arg == "__syncAbortOnDeviceWrite" => {
          __syncAbortOnDeviceWrite = value_name != 0
      },
      () if arg == "__v81_implemented" => {
          __v81_implemented = value_name != 0
      },
      () if arg == "__v82_implemented" => {
          __v82_implemented = value_name != 0
      },
      () if arg == "__v83_implemented" => {
          __v83_implemented = value_name != 0
      },
      () if arg == "__v84_implemented" => {
          __v84_implemented = value_name != 0
      },
      () if arg == "__v85_implemented" => {
          __v85_implemented = value_name != 0
      },
      () if arg == "__support_52bit_pa" => {
          __support_52bit_pa = value_name != 0
      },
      () if arg == "__unpred_tsize_aborts" => {
          __unpred_tsize_aborts = value_name != 0
      },
      () if arg == "__aa32_hpd_implemented" => {
          __aa32_hpd_implemented = value_name != 0
      },
      () if arg == "__crc32_implemented" => {
          __crc32_implemented = value_name != 0
      },
      () if arg == "__pan_implemented" => {
          __pan_implemented = value_name != 0
      },
      () if arg == "__vmid16_implemented" => {
          __vmid16_implemented = value_name != 0
      },
      () if arg == "__dot_product_implemented" => {
          __dot_product_implemented = value_name != 0
      },
      () if arg == "__fp16_implemented" => {
          __fp16_implemented = value_name != 0
      },
      () if arg == "__crypto_aes_implemented" => {
          __crypto_aes_implemented = value_name
      },
      () if arg == "__crypto_sha1_implemented" => {
          __crypto_sha1_implemented = value_name != 0
      },
      () if arg == "__crypto_sha256_implemented" => {
          __crypto_sha256_implemented = value_name != 0
      },
      () if arg == "__crypto_sha512_implemented" => {
          __crypto_sha512_implemented = value_name != 0
      },
      () if arg == "__crypto_sha3_implemented" => {
          __crypto_sha3_implemented = value_name != 0
      },
      () if arg == "__crypto_sm3_implemented" => {
          __crypto_sm3_implemented = value_name != 0
      },
      () if arg == "__crypto_sm4_implemented" => {
          __crypto_sm4_implemented = value_name != 0
      },
      () if arg == "__block_bbm_implemented" => {
          __block_bbm_implemented = value_name
      },
      () if arg == "__mpam_implemented" => {
          __mpam_implemented = value_name != 0
      },
      () if arg == "__mpam_has_hcr" => {
          __mpam_has_hcr = value_name != 0
      },
      () if arg == "__tlb_enabled" => {
          __tlb_enabled = value_name != 0
      },
      () if arg == "__trickbox_enabled" => {
          __trickbox_enabled = value_name != 0
      },
      () if arg == "__mte_implemented" => {
          __mte_implemented = value_name != 0
      },
      () if arg == "__mpam_partid_max" => {
          __mpam_partid_max = __raw_GetSlice_int(16, value_name, 0)
      },
      () if arg == "__mpam_pmg_max" => {
          __mpam_pmg_max = __raw_GetSlice_int(8, value_name, 0)
      },
      () if arg == "__mpam_vpmr_max" => {
          __mpam_vpmr_max = __raw_GetSlice_int(3, value_name, 0)
      },
      () if arg == "LOG2_TAG_GRANULE" => {
          LOG2_TAG_GRANULE = value_name
      },
      () if arg == "TAG_GRANULE" => {
          TAG_GRANULE = value_name
      },
      () if arg == "TAG_STORE_AREA" => {
          TAG_STORE_AREA = __raw_GetSlice_int(56, value_name, 0)
      },
      () if arg == "sp_rel_access_pc" => {
          sp_rel_access_pc = __raw_GetSlice_int(64, value_name, 0)
      },
      () if arg == "CFG_RVBAR" => {
          CFG_RVBAR = __raw_GetSlice_int(64, value_name, 0)
      },
      () if arg == "CFG_RMR_AA64" => {
          CFG_RMR_AA64 = __raw_GetSlice_int(1, value_name, 0)
      },
      () if arg == "semihost_clock" => {
          semihost_clock = __raw_GetSlice_int(64, value_name, 0)
      },
      _ => {
          prerr("Unrecognized Config '" ++ arg ++ "' = '" ++ DecStr(value_name) ++ "'.\n")
      }
    }
}

val ROR_C : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> (bits('N), bits(1)) effect {escape, undef}

function ROR_C (x, shift) = {
    let m : int = shift % 'N;
    assert('N - m >= 0 & m >= 0);
    let result : bits('N) = LSR(x, m) | LSL(x, 'N - m);
    let carry_out : bits(1) = [result['N - 1]];
    return((result, carry_out))
}

val ROR : forall ('N : Int) ('shift : Int), ('N >= 0 & 'shift >= 0).
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function ROR (x, shift) = {
    assert(shift >= 0);
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if shift == 0 then {
        result = x
    } else {
        (result, __anon1) = ROR_C(x, shift)
    };
    result
}

val integer_bitfield : forall 'R 'S 'd 'datasize 'n,
  ('R >= 0 & 'datasize >= 0 & 'datasize >= 0 & 'd >= 0 & 'd <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31).
  (int('R), int('S), int('d), int('datasize), bool, bool, int('n), bits('datasize), bits('datasize)) -> unit effect {escape, rreg, undef, wreg}

function integer_bitfield (R, S, d, datasize, extend, inzero, n, tmask, wmask) = {
    let dst : bits('datasize) = if inzero then Zeros() else X(d);
    let src : bits('datasize) = X(n);
    let bot : bits('datasize) = dst & ~(wmask) | ROR(src, R) & wmask;
    let top : bits('datasize) = if extend then Replicate([src[S]]) else dst;
    X(d) = top & ~(tmask) | bot & tmask
}

val ShiftReg : forall 'N 'reg 'amount,
  ('reg >= 0 & 'reg <= 31 & 'N in {8, 16, 32, 64}) & 'amount >= 0.
  (int('reg), ShiftType, int('amount)) -> bits('N) effect {escape, rreg, undef}

function ShiftReg (reg, typ, amount) = {
    result : bits('N) = X(reg);
    match typ {
      ShiftType_LSL => {
          result = LSL(result, amount)
      },
      ShiftType_LSR => {
          result = LSR(result, amount)
      },
      ShiftType_ASR => {
          result = ASR(result, amount)
      },
      ShiftType_ROR => {
          result = ROR(result, amount)
      }
    };
    result
}

val integer_shift_variable : forall 'd 'datasize 'm 'n,
  ('m >= 0 & 'm <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), ShiftType) -> unit effect {escape, rreg, undef, wreg}

function integer_shift_variable (d, datasize, m, n, shift_type) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand2 : bits('datasize) = aget_X(m);
    let amount = UInt(operand2) % datasize;
    let result : bits('datasize) = ShiftReg(n, shift_type, amount);
    aset_X(d, result)
}

val integer_logical_shiftedreg : forall 'd 'datasize ('invert : Bool) 'm 'n ('setflags : Bool) 'shift_amount,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & 'shift_amount >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), bool('invert), int('m), int('n), LogicalOp, bool('setflags), int('shift_amount), ShiftType) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_shiftedreg (d, datasize, invert, m, n, op, setflags, shift_amount, shift_type) = {
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = ShiftReg(m, shift_type, shift_amount);
    if invert then {
        operand2 = ~(operand2)
    };
    result : bits('datasize) = undefined : bits('datasize);
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = operand1 ^ operand2
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    };
    X(d) = result
}

val integer_arithmetic_addsub_shiftedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift_amount ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & 'shift_amount >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), int('shift_amount), ShiftType, bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_shiftedreg (d, datasize, m, n, setflags, shift_amount, shift_type, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = ShiftReg(m, shift_type, shift_amount);
    nzcv : bits(4) = undefined : bits(4);
    carry_in : bits(1) = undefined : bits(1);
    if sub_op then {
        operand2 = ~(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val SHAhashSIGMA1 : bits(32) -> bits(32) effect {escape, undef}

function SHAhashSIGMA1 x = {
    (ROR(x, 6) ^ ROR(x, 11)) ^ ROR(x, 25)
}

val SHAhashSIGMA0 : bits(32) -> bits(32) effect {escape, undef}

function SHAhashSIGMA0 x = {
    (ROR(x, 2) ^ ROR(x, 13)) ^ ROR(x, 22)
}

val ROL : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function ROL (x, shift) = {
    assert(shift >= 0 & shift <= 'N);
    if shift == 0 then {
        return(x)
    };
    ROR(x, 'N - shift)
}

val SHA256hash : forall ('part1 : Bool).
  (bits(128), bits(128), bits(128), bool('part1)) -> bits(128) effect {escape, undef}

function SHA256hash (X__arg, Y__arg, W, part1) = {
    X = X__arg;
    Y = Y__arg;
    chs : bits(32) = undefined : bits(32);
    maj : bits(32) = undefined : bits(32);
    t : bits(32) = undefined : bits(32);
    foreach (e from 0 to 3 by 1 in inc) {
        chs = SHAchoose(slice(Y, 0, 32), slice(Y, 32, 32), slice(Y, 64, 32));
        maj = SHAmajority(slice(X, 0, 32), slice(X, 32, 32), slice(X, 64, 32));
        t = slice(Y, 96, 32) + SHAhashSIGMA1(slice(Y, 0, 32)) + chs + aget_Elem(W, e, 32);
        X = __SetSlice_bits(128, 32, X, 96, t + slice(X, 96, 32));
        Y = __SetSlice_bits(128, 32, Y, 96, t + SHAhashSIGMA0(slice(X, 0, 32)) + maj);
        let __tc1 : vector(128 + 128, dec, bit) = ROL(Y @ X, 32);
        Y = slice(__tc1, 128, 128);
        X = slice(__tc1, 0, 128)
    };
    if part1 then X else Y
}

val Prefetch : (bits(64), bits(5)) -> unit effect {undef}

function Prefetch (address, prfop) = {
    hint : PrefetchHint = undefined : PrefetchHint;
    target : int = undefined : int;
    stream : bool = undefined : bool;
    match slice(prfop, 3, 2) {
      0b00 => {
          hint = Prefetch_READ
      },
      0b01 => {
          hint = Prefetch_EXEC
      },
      0b10 => {
          hint = Prefetch_WRITE
      },
      0b11 => {
          return()
      }
    };
    let target = UInt(slice(prfop, 1, 2));
    let stream = [prfop[0]] != 0b0;
    Hint_Prefetch(address, hint, target, stream);
    return()
}

val IsSecondStage : FaultRecord -> bool effect {escape}

function IsSecondStage fault = {
    assert(fault.typ != Fault_None);
    fault.secondstage
}

val IsSErrorInterrupt__0 : Fault -> bool effect {escape}

val IsSErrorInterrupt__1 : FaultRecord -> bool effect {escape}

overload IsSErrorInterrupt = {IsSErrorInterrupt__0, IsSErrorInterrupt__1}

function IsSErrorInterrupt__0 typ = {
    assert(typ != Fault_None);
    typ == Fault_AsyncExternal | typ == Fault_AsyncParity
}

function IsSErrorInterrupt__1 fault = {
    IsSErrorInterrupt(fault.typ)
}

val IsFault : AddressDescriptor -> bool

function IsFault addrdesc = {
    addrdesc.fault.typ != Fault_None
}

val CombineS1S2Desc : (AddressDescriptor, AddressDescriptor) -> AddressDescriptor effect {rreg, undef}

function CombineS1S2Desc (s1desc, s2desc) = {
    result : AddressDescriptor = undefined : AddressDescriptor;
    result.paddress = s2desc.paddress;
    if IsFault(s1desc) | IsFault(s2desc) then {
        result = if IsFault(s1desc) then s1desc else s2desc
    } else {
        if s2desc.memattrs.typ == MemType_Device | s1desc.memattrs.typ == MemType_Device then {
            __tc1 : MemoryAttributes = result.memattrs;
            __tc1.typ = MemType_Device;
            result.memattrs = __tc1;
            if s1desc.memattrs.typ == MemType_Normal then {
                __tc2 : MemoryAttributes = result.memattrs;
                __tc2.device = s2desc.memattrs.device;
                result.memattrs = __tc2
            } else {
                if s2desc.memattrs.typ == MemType_Normal then {
                    __tc3 : MemoryAttributes = result.memattrs;
                    __tc3.device = s1desc.memattrs.device;
                    result.memattrs = __tc3
                } else {
                    __tc4 : MemoryAttributes = result.memattrs;
                    __tc4.device = CombineS1S2Device(s1desc.memattrs.device, s2desc.memattrs.device);
                    result.memattrs = __tc4
                }
            };
            __tc5 : MemoryAttributes = result.memattrs;
            __tc5.tagged = false;
            result.memattrs = __tc5
        } else {
            __tc6 : MemoryAttributes = result.memattrs;
            __tc6.typ = MemType_Normal;
            result.memattrs = __tc6;
            __tc7 : MemoryAttributes = result.memattrs;
            __tc7.device = undefined : DeviceType;
            result.memattrs = __tc7;
            __tc8 : MemoryAttributes = result.memattrs;
            __tc8.inner = CombineS1S2AttrHints(s1desc.memattrs.inner, s2desc.memattrs.inner);
            result.memattrs = __tc8;
            __tc9 : MemoryAttributes = result.memattrs;
            __tc9.outer = CombineS1S2AttrHints(s1desc.memattrs.outer, s2desc.memattrs.outer);
            result.memattrs = __tc9;
            __tc10 : MemoryAttributes = result.memattrs;
            __tc10.shareable = s1desc.memattrs.shareable | s2desc.memattrs.shareable;
            result.memattrs = __tc10;
            __tc11 : MemoryAttributes = result.memattrs;
            __tc11.outershareable = s1desc.memattrs.outershareable | s2desc.memattrs.outershareable;
            result.memattrs = __tc11;
            __tc12 : MemoryAttributes = result.memattrs;
            __tc12.tagged = (((s1desc.memattrs.tagged & result.memattrs.inner.attrs == MemAttr_WB) & result.memattrs.inner.hints == MemHint_RWA) & result.memattrs.outer.attrs == MemAttr_WB) & result.memattrs.outer.hints == MemHint_RWA;
            result.memattrs = __tc12
        }
    };
    result.memattrs = MemAttrDefaults(result.memattrs);
    result
}

val IsExternalSyncAbort__0 : Fault -> bool effect {escape}

val IsExternalSyncAbort__1 : FaultRecord -> bool effect {escape}

overload IsExternalSyncAbort = {IsExternalSyncAbort__0, IsExternalSyncAbort__1}

function IsExternalSyncAbort__0 typ = {
    assert(typ != Fault_None);
    typ == Fault_SyncExternal | typ == Fault_SyncParity | typ == Fault_SyncExternalOnWalk | typ == Fault_SyncParityOnWalk
}

function IsExternalSyncAbort__1 fault = {
    IsExternalSyncAbort(fault.typ)
}

val IsExternalAbort__0 : Fault -> bool effect {escape}

val IsExternalAbort__1 : FaultRecord -> bool effect {escape}

overload IsExternalAbort = {IsExternalAbort__0, IsExternalAbort__1}

function IsExternalAbort__0 typ = {
    assert(typ != Fault_None);
    typ == Fault_SyncExternal | typ == Fault_SyncParity | typ == Fault_SyncExternalOnWalk | typ == Fault_SyncParityOnWalk | typ == Fault_AsyncExternal | typ == Fault_AsyncParity
}

function IsExternalAbort__1 fault = {
    IsExternalAbort(fault.typ)
}

val IsDebugException : FaultRecord -> bool effect {escape}

function IsDebugException fault = {
    assert(fault.typ != Fault_None);
    fault.typ == Fault_Debug
}

val IsAsyncAbort__0 : Fault -> bool effect {escape}

val IsAsyncAbort__1 : FaultRecord -> bool effect {escape}

overload IsAsyncAbort = {IsAsyncAbort__0, IsAsyncAbort__1}

function IsAsyncAbort__0 typ = {
    assert(typ != Fault_None);
    typ == Fault_AsyncExternal | typ == Fault_AsyncParity
}

function IsAsyncAbort__1 fault = {
    IsAsyncAbort(fault.typ)
}

val IPAValid : FaultRecord -> bool effect {escape}

function IPAValid fault = {
    assert(fault.typ != Fault_None);
    if fault.s2fs1walk then {
        return(fault.typ == Fault_AccessFlag | fault.typ == Fault_Permission | fault.typ == Fault_Translation | fault.typ == Fault_AddressSize)
    } else {
        if fault.secondstage then {
            return(fault.typ == Fault_AccessFlag | fault.typ == Fault_Translation | fault.typ == Fault_AddressSize)
        } else {
            return(false)
        }
    }
}

val HaveEL : bits(2) -> bool effect {escape}

function HaveEL el = {
    if el == EL1 | el == EL0 then {
        return(true)
    } else {
        if el == EL2 then {
            return(CFG_ID_AA64PFR0_EL1_EL2 != 0x0)
        } else {
            if el == EL3 then {
                return(CFG_ID_AA64PFR0_EL1_EL3 != 0x0)
            } else {
                assert(false);
                false
            }
        }
    }
}

val aget_SCR_GEN : unit -> bits(32) effect {escape, rreg, undef}

function aget_SCR_GEN () = {
    assert(HaveEL(EL3));
    r : bits(32) = undefined : bits(32);
    if HighestELUsingAArch32() then {
        r = get_SCR()
    } else {
        r = SCR_EL3
    };
    r
}

overload SCR_GEN = {aget_SCR_GEN}

val HighestEL : unit -> bits(2) effect {escape}

function HighestEL () = {
    if HaveEL(EL3) then {
        return(EL3)
    } else {
        if HaveEL(EL2) then {
            return(EL2)
        } else {
            return(EL1)
        }
    }
}

val SetResetVector : bits(64) -> unit effect {escape, rreg, wreg}

function SetResetVector value_name = {
    if HighestELUsingAArch32() then {
        if HaveEL(EL3) then {
            MVBAR = slice(value_name, 0, 32)
        } else {
            RVBAR = slice(value_name, 0, 32)
        }
    } else {
        if HighestEL() == EL3 then {
            RVBAR_EL3 = value_name
        } else {
            if HighestEL() == EL2 then {
                RVBAR_EL2 = value_name
            } else {
                RVBAR_EL1 = value_name
            }
        }
    };
    return()
}

val MPAMisEnabled : unit -> bool effect {escape, rreg}

function MPAMisEnabled () = {
    let el : vector(2, dec, bit) = HighestEL();
    match el {
      ? if ? == EL3 => {
          return([MPAM3_EL3[63]] == 0b1)
      },
      ? if ? == EL2 => {
          return([MPAM2_EL2[63]] == 0b1)
      },
      ? if ? == EL1 => {
          return([MPAM1_EL1[63]] == 0b1)
      }
    }
}

val IsHighestEL : bits(2) -> bool effect {escape}

function IsHighestEL el = {
    HighestEL() == el
}

val AArch64_AutoGen_SysRegAlloc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> bool effect {escape, rreg, undef}

function AArch64_AutoGen_SysRegAlloc (el, op0, op1, CRn, op2, CRm, read) = {
    let __HCR_EL2_NV1 : bits(1) = [HCR_EL2[43]];
    let __HCR_EL2_FMO : bits(1) = [HCR_EL2[3]];
    let __HCR_EL2_NV2 : bits(1) = [HCR_EL2[45]];
    let __HCR_EL2_E2H : bits(1) = [HCR_EL2[34]];
    let __HCR_EL2_TGE : bits(1) = [HCR_EL2[27]];
    let __SCTLR_EL1_EE0E : bits(1) = [SCTLR_EL1[34]];
    let __SPSel_SP : bits(1) = [get_SPSel()[0]];
    let __SCTLR_EL2_EE0E : bits(1) = [SCTLR_EL2[34]];
    let __IsHighestEL_EL1_ : bool = IsHighestEL(EL1);
    let __SCR_EL3_EEL2 : bits(1) = [SCR_EL3[18]];
    let __SCR_EL3_NS : bits(1) = [SCR_EL3[0]];
    let __HCR_EL2_IMO : bits(1) = [HCR_EL2[4]];
    let __IsHighestEL_EL2_ : bool = IsHighestEL(EL2);
    let __IsHighestEL_EL3_ : bool = IsHighestEL(EL3);
    let __HCR_EL2_NV : bits(1) = [HCR_EL2[42]];
    __cond0 : bool = undefined : bool;
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    } else {
                        if op2 == 0b111 then {
                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        } else {
                            if op2 == 0b100 then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if op2 == 0b110 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    }
                }
            }
        }
    };
    __cond1 : bool = undefined : bool;
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0 | __cond1)
                    }
                }
            }
        }
    };
    __cond2 : bool = undefined : bool;
    __cond3 : bool = undefined : bool;
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    } else {
                        if CRm == 0x9 then {
                            __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            __cond0 = (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                            __cond1 = ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1;
                            __cond2 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1;
                            __cond3 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(((__cond0 | __cond1) | __cond2) | __cond3)
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op1 == 0b000 then {
            if CRn == 0x0 then {
                if CRm == 0x1 then {
                    if op2 == 0b010 then {
                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                        return(__cond0)
                    } else {
                        if op2 == 0b011 then {
                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if op2 == 0b000 then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if op2 == 0b101 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b111 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b001 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b100 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x2 then {
                        if op2 == 0b010 then {
                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if op2 == 0b011 then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if op2 == 0b000 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b101 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b111 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b000 then {
                            if CRm == 0x0 then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRm == 0x7 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x3 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if op2 == 0b101 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b110 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if op2 == 0b101 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0 | __cond1)
                        } else {
                            if CRn == 0x1 then {
                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0 | __cond1)
                            } else {
                                if CRn == 0x6 then {
                                    __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRn == 0x2 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xC then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRn == 0xE then {
                                    __cond0 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL3 | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = ((((el == EL3 | el == EL1) & __SPSel_SP == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __SPSel_SP == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __SPSel_SP == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0x5 then {
                                    __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0xA then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0x8 then {
                                            __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0xC then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x7 then {
                                            if CRm == 0x4 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x6 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0 | __cond1)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                } else {
                                                    if CRn == 0x2 then {
                                                        if CRm == 0x3 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0xC then {
                        if CRm == 0xC then {
                            if op2 == 0b010 then {
                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0 | __cond1)
                            } else {
                                if op2 == 0b011 then {
                                    __cond0 = (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                                    __cond1 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1;
                                    __cond2 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return((__cond0 | __cond1) | __cond2)
                                } else {
                                    if op2 == 0b101 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __SCR_EL3_EEL2 == 1;
                                        __cond1 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0 | __cond1)
                                    } else {
                                        if op2 == 0b111 then {
                                            __cond0 = (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                                            __cond1 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1;
                                            __cond2 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return((__cond0 | __cond1) | __cond2)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                                                    __cond1 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1;
                                                    __cond2 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return((__cond0 | __cond1) | __cond2)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0 | __cond1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0xB then {
                                if op2 == 0b101 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b011 then {
                                        __cond0 = read == 0b1 & ((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        __cond1 = read == 0b1 & (((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0 | __cond1)
                                    } else {
                                        if op2 == 0b111 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b0 & ((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & (((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x8 then {
                                    if op2 == 0b010 then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if op2 == 0b010 then {
                                            __cond0 = el == EL1 & __IsHighestEL_EL1_;
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b1 & el == EL1 & __IsHighestEL_EL1_;
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b001 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0xD then {
                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x5 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x4 then {
                                                __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if CRn == 0x9 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x2 then {
                                                    if CRn == 0x1 then {
                                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0 | __cond1)
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0x6 then {
                                                            __cond0 = true;
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x0 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0x1 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0x1 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x2 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if CRm == 0xE then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x4 then {
                                                    if CRn == 0xA then {
                                                        __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xD then {
                                        if op2 == 0b111 then {
                                            __cond0 = (((((((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if op2 == 0b100 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if op2 == 0b101 then {
                                                __cond0 = true;
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = true;
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0x2 then {
                                            if CRn == 0x4 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x2 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x4 then {
                                                if op2 == 0b111 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b100 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x2 then {
                                                    if op2 == 0b100 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x9 then {
                                                    if CRm == 0xE then {
                                                        if op2 == 0b110 then {
                                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op1 == 0b100 then {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        } else {
                            if CRn == 0x4 then {
                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRn == 0x3 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x6 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x0 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRn == 0x1 then {
                                    __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xA then {
                                if CRm == 0x2 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xE then {
                                    if CRm == 0x2 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x4 then {
                                                __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if CRm == 0x2 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if CRm == 0x2 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x6 then {
                                                    __cond0 = ((((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | ((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1;
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        __cond0 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                } else {
                                                    if CRn == 0x4 then {
                                                        if CRm == 0x3 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                __cond0 = read == 0b1 & (((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRn == 0x5 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x1 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0xD then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if CRm == 0x2 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1;
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        __cond0 = ((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x2 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if CRn == 0xA then {
                                                __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = ((((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | ((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1;
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRn == 0xC then {
                                    if CRm == 0xB then {
                                        __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0xE then {
                                            __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x9 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0x0 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b111 then {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0xD then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x1 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0xA then {
                                                            __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x6 then {
                                                if op2 == 0b100 then {
                                                    __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0x6 then {
                                                    if op2 == 0b100 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if op1 == 0b011 then {
                        if CRn == 0xF then {
                            if CRm == 0x0 then {
                                __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x2 then {
                                    __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x1 then {
                                                __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x4 then {
                                if CRm == 0x2 then {
                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x9 then {
                                    if CRm == 0xD then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0xE then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0xC then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0x0 then {
                                                __cond0 = read == 0b0 & (((((el == EL1 & __IsHighestEL_EL1_ | ((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & ((((((el == EL0 | el == EL1) & __IsHighestEL_EL1_ | ((((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL3 | el == EL0) | el == EL1) & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = ((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | ((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0x2 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0xC then {
                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x6 then {
                                            __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x1 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        __cond0 = ((((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1 | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xA then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0xE then {
                                            __cond0 = (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x5 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if CRn == 0x6 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0xA then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    __cond0 = ((((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1 | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRn == 0xA then {
                                                        __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b110 then {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x6 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x4 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRn == 0x2 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x4 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x1 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x2 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0x0 then {
                                        if op1 == 0b010 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op1 == 0b001 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0x9 then {
                            if CRm == 0xC then {
                                if op2 == 0b010 then {
                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b011 then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b110 then {
                                                            __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xD then {
                                    if op2 == 0b010 then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b001 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0xE then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRn == 0xF then {
                                            __cond0 = (((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if op2 == 0b011 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x0 then {
                                            if op2 == 0b111 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b001 then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0x4 then {
                                        if op2 == 0b101 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = true;
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_E2H == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0xE then {
                                                __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRn == 0xF then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b001 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = ((((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0x4 then {
                                            if CRm == 0x5 then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x4 then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = (((((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if op2 == 0b010 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = (((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if CRm == 0xF then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if op1 == 0b110 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xC then {
                                        __cond0 = ((el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x2 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0xC then {
                                            __cond0 = read == 0b1 & (((el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x1 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRn == 0xD then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b101 then {
                                    if op2 == 0b001 then {
                                        if CRn == 0x2 then {
                                            __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0xD then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0x1 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b001 then {
                                        if CRn == 0x0 then {
                                            if op2 == 0b010 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b111 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if op1 == 0b101 then {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            __cond0 = read == 0b1 & (((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((el == EL2 & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((((el == EL2 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((el == EL2 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b0 & (((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRn == 0x1 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x2 then {
                                            if CRn == 0xE then {
                                                if op1 == 0b111 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if op1 == 0b101 then {
                                                __cond0 = ((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op1 == 0b111 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if op1 == 0b101 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if op1 == 0b110 then {
                                                if CRn == 0x1 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op1 == 0b110 then {
                                            if CRm == 0xC then {
                                                if op2 == 0b101 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b111 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b100 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b01 then {
            if CRn == 0x8 then {
                if op1 == 0b100 then {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        } else {
                            if CRm == 0x1 then {
                                __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x2 then {
                                    __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x7 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b101 then {
                            if CRm == 0x0 then {
                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x1 then {
                                    __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x2 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x4 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x6 then {
                                                    __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x7 then {
                                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x4 then {
                                if op2 == 0b010 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b000 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if CRm == 0x0 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x1 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            if CRm == 0x1 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x7 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b010 then {
                                                if CRm == 0x0 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x1 then {
                            if op2 == 0b010 then {
                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if op2 == 0b101 then {
                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b000 then {
                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x3 then {
                                if op2 == 0b010 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b000 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b011 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b111 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x7 then {
                                    if op2 == 0b010 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b000 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b011 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b111 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if op2 == 0b101 then {
                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b011 then {
                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b111 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if op2 == 0b101 then {
                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b011 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b111 then {
                                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if op2 == 0b101 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b011 then {
                                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b111 then {
                                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        } else {
                                                            if op2 == 0b001 then {
                                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                                return(__cond0)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b110 then {
                            if op2 == 0b001 then {
                                if CRm == 0x1 then {
                                    __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x2 then {
                                        __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x7 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRm == 0x1 then {
                                        __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x2 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x5 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x6 then {
                                                    __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x7 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x1 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0x7 then {
                    if op1 == 0b011 then {
                        if op2 == 0b001 then {
                            if CRm == 0xE then {
                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0xA then {
                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0xD then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xB then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x4 then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0xC then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRm == 0xD then {
                                    __cond0 = true;
                                    return(__cond0)
                                } else {
                                    if CRm == 0xA then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xE then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRm == 0xD then {
                                        __cond0 = true;
                                        return(__cond0)
                                    } else {
                                        if CRm == 0xA then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xE then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0xC then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b100 then {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b000 then {
                            if CRm == 0x6 then {
                                if op2 == 0b010 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b101 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if CRm == 0x8 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x1 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x9 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b010 then {
                                        if CRm == 0x8 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xA then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xE then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0xE then {
                                            if op2 == 0b100 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRm == 0xA then {
                                                if op2 == 0b100 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x8 then {
                                                    if op2 == 0b011 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if CRm == 0x9 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x8 then {
                                if op1 == 0b100 then {
                                    if op2 == 0b000 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b100 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b110 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        if op2 == 0b000 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op0 == 0b10 then {
                if op1 == 0b000 then {
                    if CRn == 0x1 then {
                        if op2 == 0b100 then {
                            if CRm == 0x0 then {
                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRm == 0x1 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x3 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b000 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                }
                            }
                        }
                    } else {
                        if CRn == 0x0 then {
                            if op2 == 0b010 then {
                                if CRm == 0x2 then {
                                    __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x0 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if op2 == 0b000 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if op2 == 0b110 then {
                                    if CRm == 0x8 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0xE then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x9 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b000 then {
                        if CRn == 0x0 then {
                            if op1 == 0b011 then {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    __cond1 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRm == 0x1 then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b100 then {
                                    if CRm == 0x7 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0x4 then {
                    if op0 == 0b00 then {
                        if op1 == 0b011 then {
                            if op2 == 0b010 then {
                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if op2 == 0b111 then {
                                    __cond0 = read == 0b0 & ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_E2H == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b001 then {
                                        __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b100 then {
                                            __cond0 = read == 0b0 & true;
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b110 then {
                                                __cond0 = read == 0b0 & ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_E2H == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b000 then {
                                if op2 == 0b101 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b011 then {
                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b100 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    false
}

val Have16bitVMID : unit -> bool effect {escape}

function Have16bitVMID () = {
    HaveEL(EL2) & __IMPDEF_boolean("")
}

val AArch32_ResetSpecialRegisters : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_ResetSpecialRegisters () = {
    SPSR_fiq = undefined : bits(32);
    SPSR_irq = undefined : bits(32);
    set_SPSR_svc(undefined : bits(32));
    SPSR_abt = undefined : bits(32);
    SPSR_und = undefined : bits(32);
    if HaveEL(EL2) then {
        set_SPSR_hyp(undefined : bits(32));
        set_ELR_hyp(undefined : bits(32))
    };
    if HaveEL(EL3) then {
        set_SPSR_mon(undefined : bits(32))
    };
    set_DLR(undefined : bits(32));
    set_DSPSR(undefined : bits(32));
    return()
}

val GTEOnesTerminatedListParam : unit -> unit effect {rreg, wreg}

function GTEOnesTerminatedListParam () = {
    if _GTEParamType != GTEParam_LIST then {
        _GTEParamType = GTEParam_LIST;
        _GTEListParamIndex = 0;
        _GTEListParamTerminator = Ones(64);
        _GTEListParamTerminators = 1;
        _GTEListParamTerminatorCount = 0
    }
}

val GTEListParam : unit -> unit effect {rreg, wreg}

function GTEListParam () = {
    if _GTEParamType != GTEParam_LIST then {
        _GTEParamType = GTEParam_LIST;
        _GTEListParamIndex = 0;
        _GTEListParamTerminator = Zeros(64);
        _GTEListParamTerminators = 1;
        _GTEListParamTerminatorCount = 0
    }
}

val GTEExtObsAddrDataListParam : unit -> unit effect {rreg, wreg}

function GTEExtObsAddrDataListParam () = {
    if _GTEParamType != GTEParam_LIST then {
        _GTEParamType = GTEParam_LIST;
        _GTEListParamIndex = 0;
        _GTEListParamTerminator = Zeros(64);
        _GTEListParamTerminators = 1;
        _GTEListParamTerminatorCount = 0
    }
}

val GTEExtObsAccessListParam : unit -> unit effect {rreg, wreg}

function GTEExtObsAccessListParam () = {
    if _GTEParamType != GTEParam_EOACCESS then {
        prerr("** starting EOACCESS list\n");
        _GTEParamType = GTEParam_EOACCESS;
        _GTEListParamIndex = 0;
        _GTEListParamTerminator = Zeros(64)
    }
}

val GTEChkAccessSensitiveBEH : unit -> unit effect {rreg, wreg}

function GTEChkAccessSensitiveBEH () = {
    let 'list_count = UInt(_GTEParam[0]);
    let 'address_count : {'n, 'n == div('list_count, 3). int('n)} = list_count / 3;
    prerr("GTEChkAccessSensitiveBEH(");
    foreach (i from 0 to (address_count - 1) by 1 in inc) {
        prerr("( address=" ++ HexStr(UInt(_GTEListParam0[i * 3])));
        prerr(", access=" ++ HexStr(UInt(_GTEListParam0[i * 3 + 1])));
        prerr(", data=" ++ HexStr(UInt(_GTEListParam0[i * 3 + 2])));
        prerr("), ")
    };
    prerr(")\n");
    foreach (i from 0 to (address_count - 1) by 1 in inc) {
        if ((i >= _GTE_AS_AccessCount | _GTE_AS_RecordedAddress[i] != _GTEListParam0[i * 3]) | _GTE_AS_RecordedAccess[i] != slice(_GTEListParam0[i * 3 + 1], 0, 32)) | _GTE_AS_RecordedData[i] != _GTEListParam0[i * 3 + 2] then {
            _GTEStatus = __SetSlice_bits(64, 1, _GTEStatus, i, 0b1)
        }
    };
    _GTE_AS_AccessCount = 0;
    _GTEStatus = __SetSlice_bits(64, negate(address_count) + 64, _GTEStatus, address_count, Zeros());
    return()
}

val EffectiveTCF : bits(2) -> bits(2) effect {rreg, undef}

function EffectiveTCF el = {
    tcf : bits(2) = undefined : bits(2);
    if el == EL3 then {
        tcf = slice(SCTLR_EL3, 40, 2)
    } else {
        if el == EL2 then {
            tcf = slice(SCTLR_EL2, 40, 2)
        } else {
            if el == EL1 then {
                tcf = slice(SCTLR_EL1, 40, 2)
            } else {
                if el == EL0 & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) == 0b11 then {
                    tcf = slice(SCTLR_EL2, 38, 2)
                } else {
                    if el == EL0 & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) != 0b11 then {
                        tcf = slice(SCTLR_EL1, 38, 2)
                    }
                }
            }
        }
    };
    tcf
}

val DecodeBitMasks : forall ('M : Int), 'M >= 0.
  (bits(1), bits(6), bits(6), bool) -> (bits('M), bits('M)) effect {escape, undef}

function DecodeBitMasks (immN, imms, immr, immediate) = {
    tmask : bits(64) = undefined : bits(64);
    wmask : bits(64) = undefined : bits(64);
    tmask_and : bits(6) = undefined : bits(6);
    wmask_and : bits(6) = undefined : bits(6);
    tmask_or : bits(6) = undefined : bits(6);
    wmask_or : bits(6) = undefined : bits(6);
    levels : bits(6) = undefined : bits(6);
    let len : int = HighestSetBit(immN @ ~(imms));
    if len < 1 then {
        throw(Error_Undefined())
    };
    assert(len >= 1);
    assert('M >= shl_int(1, len));
    let levels = ZeroExtend(Ones(len), 6);
    if immediate & (imms & levels) == levels then {
        throw(Error_Undefined())
    };
    let S : int = UInt(imms & levels);
    let R : int = UInt(immr & levels);
    let diff : int = S - R;
    let tmask_and = __GetSlice_int(6, diff, 0) | ~(levels);
    let tmask_or = __GetSlice_int(6, diff, 0) & levels;
    tmask = Ones(64);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[0]], 1) @ Ones(1), 32) | replicate_bits(Zeros(1) @ replicate_bits([tmask_or[0]], 1), 32);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[1]], 2) @ Ones(2), 16) | replicate_bits(Zeros(2) @ replicate_bits([tmask_or[1]], 2), 16);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[2]], 4) @ Ones(4), 8) | replicate_bits(Zeros(4) @ replicate_bits([tmask_or[2]], 4), 8);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[3]], 8) @ Ones(8), 4) | replicate_bits(Zeros(8) @ replicate_bits([tmask_or[3]], 8), 4);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[4]], 16) @ Ones(16), 2) | replicate_bits(Zeros(16) @ replicate_bits([tmask_or[4]], 16), 2);
    let tmask = tmask & replicate_bits(replicate_bits([tmask_and[5]], 32) @ Ones(32), 1) | replicate_bits(Zeros(32) @ replicate_bits([tmask_or[5]], 32), 1);
    let wmask_and = immr | ~(levels);
    let wmask_or = immr & levels;
    wmask = Zeros(64);
    wmask = wmask & replicate_bits(Ones(1) @ replicate_bits([wmask_and[0]], 1), 32) | replicate_bits(replicate_bits([wmask_or[0]], 1) @ Zeros(1), 32);
    wmask = wmask & replicate_bits(Ones(2) @ replicate_bits([wmask_and[1]], 2), 16) | replicate_bits(replicate_bits([wmask_or[1]], 2) @ Zeros(2), 16);
    wmask = wmask & replicate_bits(Ones(4) @ replicate_bits([wmask_and[2]], 4), 8) | replicate_bits(replicate_bits([wmask_or[2]], 4) @ Zeros(4), 8);
    wmask = wmask & replicate_bits(Ones(8) @ replicate_bits([wmask_and[3]], 8), 4) | replicate_bits(replicate_bits([wmask_or[3]], 8) @ Zeros(8), 4);
    wmask = wmask & replicate_bits(Ones(16) @ replicate_bits([wmask_and[4]], 16), 2) | replicate_bits(replicate_bits([wmask_or[4]], 16) @ Zeros(16), 2);
    wmask = wmask & replicate_bits(Ones(32) @ replicate_bits([wmask_and[5]], 32), 1) | replicate_bits(replicate_bits([wmask_or[5]], 32) @ Zeros(32), 1);
    if __GetSlice_int(1, diff, 6) != 0b0 then {
        wmask = wmask & tmask
    } else {
        wmask = wmask | tmask
    };
    return((slice(wmask, 0, 'M), slice(tmask, 0, 'M)))
}

val ChooseNonExcludedTag : (bits(4), bits(4), bits(16)) -> bits(4)

function ChooseNonExcludedTag (tag__arg, offset__arg, exclude) = {
    offset = offset__arg;
    tag = tag__arg;
    if exclude == Ones(16) then {
        return(tag)
    };
    while offset != 0x0 do {
        offset = offset - 0x1;
        tag = tag + 0x1;
        while [exclude[UInt(tag)]] == 0b1 do {
            tag = tag + 0x1
        }
    };
    tag
}

val BTypeCompatible_BTI : bits(2) -> bool effect {rreg}

function BTypeCompatible_BTI hintcode = {
    match hintcode {
      0b00 => {
          return(false)
      },
      0b01 => {
          return(PSTATE.BTYPE != 0b11)
      },
      0b10 => {
          return(PSTATE.BTYPE != 0b10)
      },
      0b11 => {
          return(true)
      }
    }
}

val AllocationTagAccessIsEnabled : unit -> bool effect {rreg}

function AllocationTagAccessIsEnabled () = {
    if [SCR_EL3[26]] == 0b0 & (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) then {
        return(false)
    } else {
        if ([HCR_EL2[56]] == 0b0 & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) != 0b11) & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
            return(false)
        } else {
            if [SCTLR_EL3[43]] == 0b0 & PSTATE.EL == EL3 then {
                return(false)
            } else {
                if [SCTLR_EL2[43]] == 0b0 & PSTATE.EL == EL2 then {
                    return(false)
                } else {
                    if [SCTLR_EL1[43]] == 0b0 & PSTATE.EL == EL1 then {
                        return(false)
                    } else {
                        if ([SCTLR_EL2[42]] == 0b0 & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) == 0b11) & PSTATE.EL == EL0 then {
                            return(false)
                        } else {
                            if ([SCTLR_EL1[42]] == 0b0 & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) != 0b11) & PSTATE.EL == EL0 then {
                                return(false)
                            } else {
                                return(true)
                            }
                        }
                    }
                }
            }
        }
    }
}

val integer_tags_mcsubtag : forall ('ADD : Bool) 'd 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('d >= 0 & 'd <= 31 | not(not('d == 31))).
  (bool('ADD), int('d), int('n), bits(64), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcsubtag (ADD, d, n, offset, tag_offset) = {
    let operand1 : bits(64) = if n == 31 then SP() else X(n);
    let start_tag : bits(4) = AllocationTagFromAddress(operand1);
    let exclude : vector(16, dec, bit) = slice(GCR_EL1, 0, 16);
    result : bits(64) = undefined : bits(64);
    rtag : bits(4) = undefined : bits(4);
    if AllocationTagAccessIsEnabled() then {
        rtag = ChooseNonExcludedTag(start_tag, tag_offset, exclude)
    } else {
        rtag = 0x0
    };
    __anon1 : bits(4) = undefined : bits(4);
    __anon2 : bits(4) = undefined : bits(4);
    if ADD then {
        (result, __anon1) = AddWithCarry(operand1, offset, 0b0)
    } else {
        (result, __anon2) = AddWithCarry(operand1, ~(offset), 0b1)
    };
    let result = AddressWithAllocationTag(result, rtag);
    if d == 31 then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_tags_mcinsertrandomtag : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31 | not(not('d == 31))).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcinsertrandomtag (d, m, n) = {
    let operand : bits(64) = if n == 31 then SP() else X(n);
    let xm : bits(64) = X(m);
    let exclude : bits(16) = slice(xm, 0, 16) | slice(GCR_EL1, 0, 16);
    rtag : bits(4) = undefined : bits(4);
    if AllocationTagAccessIsEnabled() then {
        if [GCR_EL1[16]] == 0b1 then {
            RGSR_EL1 = undefined : bits(32);
            rtag = _ChooseRandomNonExcludedTag(exclude)
        } else {
            let start : vector(4, dec, bit) = slice(RGSR_EL1, 0, 4);
            let offset : vector(4, dec, bit) = RandomTag();
            rtag = ChooseNonExcludedTag(start, offset, exclude);
            RGSR_EL1 = __SetSlice_bits(32, 4, RGSR_EL1, 0, rtag)
        }
    } else {
        rtag = 0x0
    };
    let result : bits(64) = AddressWithAllocationTag(operand, rtag);
    if d == 31 then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_tags_mcaddtag : forall ('ADD : Bool) 'd 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('d >= 0 & 'd <= 31 | not(not('d == 31))).
  (bool('ADD), int('d), int('n), bits(64), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcaddtag (ADD, d, n, offset, tag_offset) = {
    let operand1 : bits(64) = if n == 31 then SP() else X(n);
    let start_tag : bits(4) = AllocationTagFromAddress(operand1);
    let exclude : vector(16, dec, bit) = slice(GCR_EL1, 0, 16);
    result : bits(64) = undefined : bits(64);
    rtag : bits(4) = undefined : bits(4);
    if AllocationTagAccessIsEnabled() then {
        rtag = ChooseNonExcludedTag(start_tag, tag_offset, exclude)
    } else {
        rtag = 0x0
    };
    __anon1 : bits(4) = undefined : bits(4);
    __anon2 : bits(4) = undefined : bits(4);
    if ADD then {
        (result, __anon1) = AddWithCarry(operand1, offset, 0b0)
    } else {
        (result, __anon2) = AddWithCarry(operand1, ~(offset), 0b1)
    };
    let result = AddressWithAllocationTag(result, rtag);
    if d == 31 then {
        SP() = result
    } else {
        X(d) = result
    }
}

val AArch32_FaultStatusSD : forall ('d_side : Bool).
  (bool('d_side), FaultRecord) -> bits(32) effect {escape, undef}

function AArch32_FaultStatusSD (d_side, fault) = {
    assert(fault.typ != Fault_None);
    fsr : bits(32) = Zeros();
    if HaveRASExt() & IsAsyncAbort(fault) then {
        fsr = __SetSlice_bits(32, 2, fsr, 14, fault.errortype)
    };
    if d_side then {
        if fault.acctype == AccType_DC | fault.acctype == AccType_IC | fault.acctype == AccType_AT then {
            fsr = __SetSlice_bits(32, 1, fsr, 13, 0b1);
            fsr = __SetSlice_bits(32, 1, fsr, 11, 0b1)
        } else {
            fsr = __SetSlice_bits(32, 1, fsr, 11, if fault.write then 0b1 else 0b0)
        }
    };
    if IsExternalAbort(fault) then {
        fsr = __SetSlice_bits(32, 1, fsr, 12, fault.extflag)
    };
    fsr = __SetSlice_bits(32, 1, fsr, 9, 0b0);
    (fsr[10 .. 10] @ fsr[3 .. 0]) = EncodeSDFSC(fault.typ, fault.level);
    if d_side then {
        fsr = __SetSlice_bits(32, 4, fsr, 4, fault.domain)
    };
    fsr
}

val AArch32_FaultStatusLD : forall ('d_side : Bool).
  (bool('d_side), FaultRecord) -> bits(32) effect {escape, undef}

function AArch32_FaultStatusLD (d_side, fault) = {
    assert(fault.typ != Fault_None);
    fsr : bits(32) = Zeros();
    if HaveRASExt() & IsAsyncAbort(fault) then {
        fsr = __SetSlice_bits(32, 2, fsr, 14, fault.errortype)
    };
    if d_side then {
        if fault.acctype == AccType_DC | fault.acctype == AccType_IC | fault.acctype == AccType_AT then {
            fsr = __SetSlice_bits(32, 1, fsr, 13, 0b1);
            fsr = __SetSlice_bits(32, 1, fsr, 11, 0b1)
        } else {
            fsr = __SetSlice_bits(32, 1, fsr, 11, if fault.write then 0b1 else 0b0)
        }
    };
    if IsExternalAbort(fault) then {
        fsr = __SetSlice_bits(32, 1, fsr, 12, fault.extflag)
    };
    fsr = __SetSlice_bits(32, 1, fsr, 9, 0b1);
    let fsr = __SetSlice_bits(32, 6, fsr, 0, EncodeLDFSC(fault.typ, fault.level));
    fsr
}

val AArch32_DomainValid : forall ('level : Int).
  (Fault, int('level)) -> bool effect {escape}

function AArch32_DomainValid (typ, level) = {
    assert(typ != Fault_None);
    match typ {
      Fault_Domain => {
          return(true)
      },
      Fault_Translation => {
          return(level == 2)
      },
      Fault_AccessFlag => {
          return(level == 2)
      },
      Fault_SyncExternalOnWalk => {
          return(level == 2)
      },
      Fault_SyncParityOnWalk => {
          return(level == 2)
      },
      _ => {
          return(false)
      }
    }
}

val AArch32_AccessIsPrivileged : AccType -> bool effect {rreg, undef}

function AArch32_AccessIsPrivileged acctype = {
    let el : bits(2) = AArch32_AccessUsesEL(acctype);
    ispriv : bool = undefined : bool;
    if el == EL0 then {
        ispriv = false
    } else {
        if el != EL1 then {
            ispriv = true
        } else {
            ispriv = acctype != AccType_UNPRIV
        }
    };
    ispriv
}

val integer_logical_immediate : forall 'd 'datasize 'n ('setflags : Bool),
  'datasize >= 0 & ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31 | not(not(('d == 31 & not('setflags))))).
  (int('d), int('datasize), bits('datasize), int('n), LogicalOp, bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_immediate (d, datasize, imm, n, op, setflags) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    let operand2 : vector('datasize, dec, bit) = imm;
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = operand1 ^ operand2
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    };
    if d == 31 & ~(setflags) then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_arithmetic_addsub_immediate : forall 'd 'datasize 'n ('setflags : Bool) ('sub_op : Bool),
  'datasize >= 0 & ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64} | not(not('n == 31))) & ('d >= 0 & 'd <= 31 | not(not(('d == 31 & not('setflags))))).
  (int('d), int('datasize), bits('datasize), int('n), bool('setflags), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_immediate (d, datasize, imm, n, setflags, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = if n == 31 then SP() else X(n);
    operand2 : bits('datasize) = imm;
    nzcv : bits(4) = undefined : bits(4);
    carry_in : bits(1) = undefined : bits(1);
    if sub_op then {
        operand2 = ~(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    if d == 31 & ~(setflags) then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_arithmetic_addsub_extendedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64} | not(not('n == 31))) & ('shift >= 0 & 'shift <= 4 & 'm >= 0 & 'm <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31 | not(not(('d == 31 & not('setflags))))).
  (int('d), int('datasize), ExtendType, int('m), int('n), bool('setflags), int('shift), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_extendedreg (d, datasize, extend_type, m, n, setflags, shift, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = if n == 31 then SP() else X(n);
    operand2 : bits('datasize) = ExtendReg(m, extend_type, shift);
    nzcv : bits(4) = undefined : bits(4);
    carry_in : bits(1) = undefined : bits(1);
    if sub_op then {
        operand2 = ~(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    if d == 31 & ~(setflags) then {
        SP() = result
    } else {
        X(d) = result
    }
}

val __PreFetch : forall ('pc : Int).
  int('pc) -> bool effect {escape, rreg, undef, wreg}

function __PreFetch pc = {
    interrupt_req : InterruptReq = undefined : InterruptReq;
    interrupt_req.take_SE = true;
    interrupt_req.take_vSE = true;
    interrupt_req.take_IRQ = true;
    interrupt_req.take_vIRQ = true;
    interrupt_req.take_FIQ = true;
    interrupt_req.take_vFIQ = true;
    let interrupt_taken : bool = TakePendingInterrupts(interrupt_req);
    let fetch : bool = ~(interrupt_taken);
    BTypeCompatible = false;
    fetch
}

val UsingAArch32 : unit -> bool effect {escape, rreg}

function UsingAArch32 () = {
    let aarch32 : bool = PSTATE.nRW == 0b1;
    if ~(HaveAnyAArch32()) then {
        assert(~(aarch32))
    };
    if HighestELUsingAArch32() then {
        assert(aarch32)
    };
    aarch32
}

val aset_SPSR : bits(32) -> unit effect {escape, rreg, wreg}

function aset_SPSR value_name = {
    if UsingAArch32() then {
        match PSTATE.M {
          ? if ? == M32_FIQ => {
              SPSR_fiq = value_name
          },
          ? if ? == M32_IRQ => {
              SPSR_irq = value_name
          },
          ? if ? == M32_Svc => {
              set_SPSR_svc(value_name)
          },
          ? if ? == M32_Monitor => {
              set_SPSR_mon(value_name)
          },
          ? if ? == M32_Abort => {
              SPSR_abt = value_name
          },
          ? if ? == M32_Hyp => {
              set_SPSR_hyp(value_name)
          },
          ? if ? == M32_Undef => {
              SPSR_und = value_name
          },
          _ => {
              Unreachable()
          }
        }
    } else {
        match PSTATE.EL {
          ? if ? == EL1 => {
              SPSR_EL1 = value_name
          },
          ? if ? == EL2 => {
              SPSR_EL2 = value_name
          },
          ? if ? == EL3 => {
              SPSR_EL3 = value_name
          },
          _ => {
              Unreachable()
          }
        }
    };
    return()
}

overload SPSR = {aset_SPSR}

val aget_SPSR : unit -> bits(32) effect {escape, rreg, undef}

function aget_SPSR () = {
    result : bits(32) = undefined : bits(32);
    if UsingAArch32() then {
        match PSTATE.M {
          ? if ? == M32_FIQ => {
              result = SPSR_fiq
          },
          ? if ? == M32_IRQ => {
              result = SPSR_irq
          },
          ? if ? == M32_Svc => {
              result = get_SPSR_svc()
          },
          ? if ? == M32_Monitor => {
              result = get_SPSR_mon()
          },
          ? if ? == M32_Abort => {
              result = SPSR_abt
          },
          ? if ? == M32_Hyp => {
              result = get_SPSR_hyp()
          },
          ? if ? == M32_Undef => {
              result = SPSR_und
          },
          _ => {
              Unreachable()
          }
        }
    } else {
        match PSTATE.EL {
          ? if ? == EL1 => {
              result = SPSR_EL1
          },
          ? if ? == EL2 => {
              result = SPSR_EL2
          },
          ? if ? == EL3 => {
              result = SPSR_EL3
          },
          _ => {
              Unreachable()
          }
        }
    };
    result
}

overload SPSR = {aget_SPSR}

val ThisInstrAddr : forall ('N : Int). unit -> bits('N) effect {escape, rreg}

function ThisInstrAddr () = {
    assert('N == 64 | 'N == 32 & UsingAArch32());
    slice(_PC, 0, 'N)
}

val SetNotTagCheckedInstruction : forall ('unchecked : Bool).
  bool('unchecked) -> unit effect {configuration, escape, rreg}

function SetNotTagCheckedInstruction unchecked = {
    if unchecked then {
        sp_rel_access_pc = ThisInstrAddr()
    }
}

val IsNonTagCheckedInstruction : unit -> bool effect {escape, rreg}

function IsNonTagCheckedInstruction () = {
    let here : bits(64) = ThisInstrAddr();
    sp_rel_access_pc == here
}

val FPProcessException : (FPExc, bits(32)) -> unit effect {escape, rreg, undef, wreg}

function FPProcessException (exception, fpcr) = {
    cumul : int = undefined : int;
    match exception {
      FPExc_InvalidOp => {
          cumul = 0
      },
      FPExc_DivideByZero => {
          cumul = 1
      },
      FPExc_Overflow => {
          cumul = 2
      },
      FPExc_Underflow => {
          cumul = 3
      },
      FPExc_Inexact => {
          cumul = 4
      },
      FPExc_InputDenorm => {
          cumul = 7
      }
    };
    let cumul = cumul;
    let enable : int = cumul + 8;
    if [fpcr[enable]] == 0b1 then {
        throw(Error_Implementation_Defined("floating-point trap handling"))
    } else {
        if UsingAArch32() then {
            FPSCR = __SetSlice_bits(32, 1, FPSCR, cumul, 0b1)
        } else {
            FPSR = __SetSlice_bits(32, 1, FPSR, cumul, 0b1)
        }
    };
    return()
}

val FPRoundBase : forall ('N : Int).
  (real, bits(32), FPRounding) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRoundBase (op, fpcr, rounding) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(op != 0.0);
    assert(rounding != FPRounding_TIEAWAY);
    result : bits('N) = undefined : bits('N);
    E : int = undefined : int;
    F : int = undefined : int;
    minimum_exp : int = undefined : int;
    if 'N == 16 then {
        minimum_exp = negate(14);
        E = 5;
        F = 10
    } else {
        if 'N == 32 then {
            minimum_exp = negate(126);
            E = 8;
            F = 23
        } else {
            minimum_exp = negate(1022);
            E = 11;
            F = 52
        }
    };
    let 'F = F;
    let 'E = E;
    assert(constraint(('F in {10, 23, 52} & 'E in {5, 8, 11})));
    mantissa : real = undefined : real;
    sign : bits(1) = undefined : bits(1);
    if op < 0.0 then {
        sign = 0b1;
        mantissa = negate(op)
    } else {
        sign = 0b0;
        mantissa = op
    };
    exponent : int = undefined : int;
    exponent = 0;
    while mantissa < 1.0 do {
        mantissa = mantissa * 2.0;
        exponent = exponent - 1
    };
    while mantissa >= 2.0 do {
        mantissa = mantissa / 2.0;
        exponent = exponent + 1
    };
    if ([fpcr[24]] == 0b1 & 'N != 16 | [fpcr[19]] == 0b1 & 'N == 16) & exponent < minimum_exp then {
        if UsingAArch32() then {
            FPSCR = __SetSlice_bits(32, 1, FPSCR, 3, 0b1)
        } else {
            FPSR = __SetSlice_bits(32, 1, FPSR, 3, 0b1)
        };
        return(FPZero(sign))
    };
    biased_exp : int = undefined : int;
    biased_exp = max(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then {
        mantissa = mantissa / 2.0 ^ (minimum_exp - exponent)
    };
    int_mant : int = undefined : int;
    int_mant = RoundDown(mantissa * 2.0 ^ F);
    error : real = undefined : real;
    error = mantissa * 2.0 ^ F - Real(int_mant);
    if biased_exp == 0 & (error != 0.0 | [fpcr[11]] == 0b1) then {
        FPProcessException(FPExc_Underflow, fpcr)
    };
    overflow_to_inf : bool = undefined : bool;
    round_up : bool = undefined : bool;
    match rounding {
      FPRounding_TIEEVEN => {
          round_up = error > 0.5 | error == 0.5 & __GetSlice_int(1, int_mant, 0) == 0b1;
          overflow_to_inf = true
      },
      FPRounding_POSINF => {
          round_up = error != 0.0 & sign == 0b0;
          overflow_to_inf = sign == 0b0
      },
      FPRounding_NEGINF => {
          round_up = error != 0.0 & sign == 0b1;
          overflow_to_inf = sign == 0b1
      },
      FPRounding_ZERO => {
          round_up = false;
          overflow_to_inf = false
      },
      FPRounding_ODD => {
          round_up = false;
          overflow_to_inf = false
      }
    };
    if round_up then {
        int_mant = int_mant + 1;
        if int_mant == pow2(F) then {
            biased_exp = 1
        };
        if int_mant == pow2(F + 1) then {
            biased_exp = biased_exp + 1;
            int_mant = int_mant / 2
        }
    };
    if error != 0.0 & rounding == FPRounding_ODD then {
        int_mant = __SetSlice_int(1, int_mant, 0, 0b1)
    };
    if 'N != 16 | [fpcr[26]] == 0b0 then {
        if biased_exp >= pow2(E) - 1 then {
            result = if overflow_to_inf then FPInfinity(sign) else FPMaxNormal(sign);
            FPProcessException(FPExc_Overflow, fpcr);
            error = 1.0
        } else {
            result = (sign @ __GetSlice_int('N - F - 1, biased_exp, 0)) @ __GetSlice_int(F, int_mant, 0)
        }
    } else {
        if biased_exp >= pow2(E) then {
            result = sign @ Ones('N - 1);
            FPProcessException(FPExc_InvalidOp, fpcr);
            error = 0.0
        } else {
            result = (sign @ __GetSlice_int('N - F - 1, biased_exp, 0)) @ __GetSlice_int(F, int_mant, 0)
        }
    };
    if error != 0.0 then {
        FPProcessException(FPExc_Inexact, fpcr)
    };
    result
}

val FPRoundCV : forall ('N : Int).
  (real, bits(32), FPRounding) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRoundCV (op, fpcr, rounding) = {
    let fpcr = __SetSlice_bits(32, 1, fpcr, 19, 0b0);
    FPRoundBase(op, fpcr, rounding)
}

val FPRound__0 : forall ('N : Int).
  (real, bits(32), FPRounding) -> bits('N) effect {escape, rreg, undef, wreg}

val FPRound__1 : forall ('N : Int).
  (real, bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

overload FPRound = {FPRound__0, FPRound__1}

function FPRound__0 (op, fpcr, rounding) = {
    let fpcr = __SetSlice_bits(32, 1, fpcr, 26, 0b0);
    FPRoundBase(op, fpcr, rounding)
}

function FPRound__1 (op, fpcr) = {
    FPRound(op, fpcr, FPRoundingMode(fpcr))
}

val FixedToFP : forall ('M : Int) ('N : Int) ('fbits : Int), 'M >= 0.
  (bits('M), int('fbits), bool, bits(32), FPRounding) -> bits('N) effect {escape, undef, wreg, rreg}

function FixedToFP (op, fbits, unsigned, fpcr, rounding) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert('M == 16 | 'M == 32 | 'M == 64);
    result : bits('N) = undefined : bits('N);
    assert(fbits >= 0);
    assert(rounding != FPRounding_ODD);
    let int_operand : int = asl_Int(op, unsigned);
    let real_operand : real = Real(int_operand) / 2.0 ^ fbits;
    if real_operand == 0.0 then {
        result = FPZero(0b0)
    } else {
        result = FPRound(real_operand, fpcr, rounding)
    };
    result
}

val FPProcessNaN : forall ('N : Int), 'N >= 0.
  (FPType, bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPProcessNaN (typ, op, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(typ == FPType_QNaN | typ == FPType_SNaN);
    topfrac : int = undefined : int;
    match 'N {
      16 => {
          topfrac = 9
      },
      32 => {
          topfrac = 22
      },
      64 => {
          topfrac = 51
      }
    };
    let topfrac = topfrac;
    result : bits('N) = undefined : bits('N);
    result = op;
    if typ == FPType_SNaN then {
        result = __SetSlice_bits('N, 1, result, topfrac, 0b1);
        FPProcessException(FPExc_InvalidOp, fpcr)
    };
    if [fpcr[25]] == 0b1 then {
        result = FPDefaultNaN()
    };
    result
}

val FPProcessNaNs3H : forall ('N : Int), 'N >= 0.
  (FPType, FPType, FPType, bits('N), bits(div('N, 2)), bits(div('N, 2)), bits(32)) -> (bool, bits('N)) effect {escape, rreg, undef, wreg}

function FPProcessNaNs3H (type1, type2, type3, op1, op2, op3, fpcr) = {
    assert('N == 32 | 'N == 64);
    result : bits('N) = undefined : bits('N);
    done : bool = undefined : bool;
    if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type1, op1, fpcr)
    } else {
        if type2 == FPType_SNaN then {
            done = true;
            result = FPConvertNaN(FPProcessNaN(type2, op2, fpcr))
        } else {
            if type3 == FPType_SNaN then {
                done = true;
                result = FPConvertNaN(FPProcessNaN(type3, op3, fpcr))
            } else {
                if type1 == FPType_QNaN then {
                    done = true;
                    result = FPProcessNaN(type1, op1, fpcr)
                } else {
                    if type2 == FPType_QNaN then {
                        done = true;
                        result = FPConvertNaN(FPProcessNaN(type2, op2, fpcr))
                    } else {
                        if type3 == FPType_QNaN then {
                            done = true;
                            result = FPConvertNaN(FPProcessNaN(type3, op3, fpcr))
                        } else {
                            done = false;
                            result = Zeros()
                        }
                    }
                }
            }
        }
    };
    return((done, result))
}

val FPProcessNaNs3 : forall ('N : Int), ('N >= 0 & 'N >= 0 & 'N >= 0).
  (FPType, FPType, FPType, bits('N), bits('N), bits('N), bits(32)) -> (bool, bits('N)) effect {escape, rreg, undef, wreg}

function FPProcessNaNs3 (type1, type2, type3, op1, op2, op3, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type1, op1, fpcr)
    } else {
        if type2 == FPType_SNaN then {
            done = true;
            result = FPProcessNaN(type2, op2, fpcr)
        } else {
            if type3 == FPType_SNaN then {
                done = true;
                result = FPProcessNaN(type3, op3, fpcr)
            } else {
                if type1 == FPType_QNaN then {
                    done = true;
                    result = FPProcessNaN(type1, op1, fpcr)
                } else {
                    if type2 == FPType_QNaN then {
                        done = true;
                        result = FPProcessNaN(type2, op2, fpcr)
                    } else {
                        if type3 == FPType_QNaN then {
                            done = true;
                            result = FPProcessNaN(type3, op3, fpcr)
                        } else {
                            done = false;
                            result = Zeros()
                        }
                    }
                }
            }
        }
    };
    return((done, result))
}

val FPProcessNaNs : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (FPType, FPType, bits('N), bits('N), bits(32)) -> (bool, bits('N)) effect {escape, rreg, undef, wreg}

function FPProcessNaNs (type1, type2, op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type1, op1, fpcr)
    } else {
        if type2 == FPType_SNaN then {
            done = true;
            result = FPProcessNaN(type2, op2, fpcr)
        } else {
            if type1 == FPType_QNaN then {
                done = true;
                result = FPProcessNaN(type1, op1, fpcr)
            } else {
                if type2 == FPType_QNaN then {
                    done = true;
                    result = FPProcessNaN(type2, op2, fpcr)
                } else {
                    done = false;
                    result = Zeros()
                }
            }
        }
    };
    return((done, result))
}

val CurrentInstrSet : unit -> InstrSet effect {escape, rreg, undef}

function CurrentInstrSet () = {
    result : InstrSet = undefined : InstrSet;
    if UsingAArch32() then {
        result = if PSTATE.T == 0b0 then InstrSet_A32 else InstrSet_T32
    } else {
        result = InstrSet_A64
    };
    result
}

val AArch32_ExecutingLSMInstr : unit -> bool effect {escape, rreg, undef}

function AArch32_ExecutingLSMInstr () = {
    let instr : vector(32, dec, bit) = ThisInstr();
    let instr_set : InstrSet = CurrentInstrSet();
    assert(instr_set == InstrSet_A32 | instr_set == InstrSet_T32);
    if instr_set == InstrSet_A32 then {
        return(slice(instr, 28, 4) != 0xF & slice(instr, 25, 3) == 0b100)
    } else {
        if ThisInstrLength() == 16 then {
            return(slice(instr, 12, 4) == 0xC)
        } else {
            return(slice(instr, 25, 7) == 0b1110100 & [instr[22]] == 0b0)
        }
    }
}

val AArch32_ExecutingCP10or11Instr : unit -> bool effect {escape, rreg, undef}

function AArch32_ExecutingCP10or11Instr () = {
    let instr : vector(32, dec, bit) = ThisInstr();
    let instr_set : InstrSet = CurrentInstrSet();
    assert(instr_set == InstrSet_A32 | instr_set == InstrSet_T32);
    if instr_set == InstrSet_A32 then {
        return((slice(instr, 24, 4) == 0xE | slice(instr, 25, 3) == 0b110) & (slice(instr, 8, 4) & 0xE) == 0xA)
    } else {
        return(((slice(instr, 28, 4) & 0xE) == 0xE & (slice(instr, 24, 4) == 0xE | slice(instr, 25, 3) == 0b110)) & (slice(instr, 8, 4) & 0xE) == 0xA)
    }
}

val AdvSIMDExpandImm : (bits(1), bits(4), bits(8)) -> bits(64) effect {escape, rreg, undef}

function AdvSIMDExpandImm (op, cmode, imm8) = {
    imm32 : bits(32) = undefined : bits(32);
    imm64 : bits(64) = undefined : bits(64);
    imm8a : bits(8) = undefined : bits(8);
    imm8b : bits(8) = undefined : bits(8);
    imm8c : bits(8) = undefined : bits(8);
    imm8d : bits(8) = undefined : bits(8);
    imm8e : bits(8) = undefined : bits(8);
    imm8f : bits(8) = undefined : bits(8);
    imm8g : bits(8) = undefined : bits(8);
    imm8h : bits(8) = undefined : bits(8);
    match slice(cmode, 1, 3) {
      0b000 => {
          imm64 = replicate_bits(Zeros(24) @ imm8, 2)
      },
      0b001 => {
          imm64 = replicate_bits((Zeros(16) @ imm8) @ Zeros(8), 2)
      },
      0b010 => {
          imm64 = replicate_bits((Zeros(8) @ imm8) @ Zeros(16), 2)
      },
      0b011 => {
          imm64 = replicate_bits(imm8 @ Zeros(24), 2)
      },
      0b100 => {
          imm64 = replicate_bits(Zeros(8) @ imm8, 4)
      },
      0b101 => {
          imm64 = replicate_bits(imm8 @ Zeros(8), 4)
      },
      0b110 => {
          if [cmode[0]] == 0b0 then {
              imm64 = replicate_bits((Zeros(16) @ imm8) @ Ones(8), 2)
          } else {
              imm64 = replicate_bits((Zeros(8) @ imm8) @ Ones(16), 2)
          }
      },
      0b111 => {
          if [cmode[0]] == 0b0 & op == 0b0 then {
              imm64 = replicate_bits(imm8, 8)
          };
          if [cmode[0]] == 0b0 & op == 0b1 then {
              imm8a = replicate_bits([imm8[7]], 8);
              imm8b = replicate_bits([imm8[6]], 8);
              imm8c = replicate_bits([imm8[5]], 8);
              imm8d = replicate_bits([imm8[4]], 8);
              imm8e = replicate_bits([imm8[3]], 8);
              imm8f = replicate_bits([imm8[2]], 8);
              imm8g = replicate_bits([imm8[1]], 8);
              imm8h = replicate_bits([imm8[0]], 8);
              imm64 = ((((((imm8a @ imm8b) @ imm8c) @ imm8d) @ imm8e) @ imm8f) @ imm8g) @ imm8h
          };
          if [cmode[0]] == 0b1 & op == 0b0 then {
              imm32 = ((([imm8[7]] @ ~([imm8[6]])) @ replicate_bits([imm8[6]], 5)) @ slice(imm8, 0, 6)) @ Zeros(19);
              imm64 = replicate_bits(imm32, 2)
          };
          if [cmode[0]] == 0b1 & op == 0b1 then {
              if UsingAArch32() then {
                  throw(Error_ReservedEncoding())
              };
              imm64 = ((([imm8[7]] @ ~([imm8[6]])) @ replicate_bits([imm8[6]], 8)) @ slice(imm8, 0, 6)) @ Zeros(48)
          }
      }
    };
    imm64
}

val IsSecureBelowEL3 : unit -> bool effect {escape, rreg, undef}

function IsSecureBelowEL3 () = {
    if HaveEL(EL3) then {
        return([SCR_GEN()[0]] == 0b0)
    } else {
        if HaveEL(EL2) & (~(HaveSecureEL2Ext()) | HighestELUsingAArch32()) then {
            return(false)
        } else {
            return(__IMPDEF_boolean("Secure-only implementation"))
        }
    }
}

val IsSecure : unit -> bool effect {escape, rreg, undef}

function IsSecure () = {
    if (HaveEL(EL3) & ~(UsingAArch32())) & PSTATE.EL == EL3 then {
        return(true)
    } else {
        if (HaveEL(EL3) & UsingAArch32()) & PSTATE.M == M32_Monitor then {
            return(true)
        }
    };
    IsSecureBelowEL3()
}

val IsGTEPPUMatch : (FullAddress, bits(1)) -> bool effect {escape, rreg}

function IsGTEPPUMatch (fullAddress, read) = {
    if ~(_GTEActive) then {
        return(false)
    };
    let address : bits(64) = ZeroExtend(fullAddress.address);
    let ns : bits(1) = fullAddress.NS;
    let priv : bits(1) = 0b1;
    generate_abort : bool = false;
    let 'ns_access_bit : {|1, 0|} = if ns == 0b1 then 1 else 0;
    let 'prot_access_bit : int = 4 + (if ns == 0b1 then 4 else 0) + (if priv == 0b1 then 2 else 0) + (if read == 0b1 then 1 else 0);
    let 'log_or_abort_bit : {'n, 'n == 31. int('n)} = 31;
    foreach (i from 0 to (NUM_GTE_REGIONS - 1) by 1 in inc) {
        let 'size : int = UInt(slice(_GTE_PPU_SizeEn[i], 1, 7)) + 1;
        assert(constraint(- 'size + 64 >= 0));
        if [_GTE_PPU_SizeEn[i][0]] == 0b1 & slice(address, size, negate(size) + 64) == slice(_GTE_PPU_Address[i], size, negate(size) + 64) then {
            prerr("GTE_PPU[" ++ DecStr(i) ++ "] matched address " ++ HexStr(UInt(address)));
            if ns == 0b1 then {
                prerr("_ns")
            } else {
                prerr("_s")
            };
            prerr("\n");
            if [_GTE_PPU_Access[i][ns_access_bit]] == 0b1 then {
                generate_abort = true
            };
            if [_GTE_PPU_Access[i][prot_access_bit]] != [_GTE_PPU_Access[i][prot_access_bit - 4]] then {
                prerr("TODO: GTE_PPU match needs privilege information\n")
            };
            if [_GTE_PPU_Access[i][prot_access_bit]] == 0b1 then {
                generate_abort = true
            };
            if [_GTE_PPU_Access[i][log_or_abort_bit]] == 0b1 then {
                prerr("GTE_PPU logged a matched address access violation");
                generate_abort = false
            }
        }
    };
    generate_abort
}

val HaveSM4Ext : unit -> bool effect {escape}

function HaveSM4Ext () = {
    if ~(HasArchVersion(ARMv8p2)) then {
        return(false)
    };
    __IMPDEF_boolean("Has SM4 Crypto instructions")
}

val HaveSM3Ext : unit -> bool effect {escape}

function HaveSM3Ext () = {
    if ~(HasArchVersion(ARMv8p2)) then {
        return(false)
    };
    __IMPDEF_boolean("Has SM3 Crypto instructions")
}

val HaveSHA512Ext : unit -> bool effect {escape}

function HaveSHA512Ext () = {
    if ~(HasArchVersion(ARMv8p2)) | ~(HaveSHA1Ext() & HaveSHA256Ext()) then {
        return(false)
    };
    __IMPDEF_boolean("Has SHA512 Crypto instructions")
}

val HaveSHA3Ext : unit -> bool effect {escape}

function HaveSHA3Ext () = {
    if ~(HasArchVersion(ARMv8p2)) | ~(HaveSHA1Ext() & HaveSHA256Ext()) then {
        return(false)
    };
    __IMPDEF_boolean("Has SHA3 Crypto instructions")
}

val HaveMTEExt : unit -> bool effect {escape}

function HaveMTEExt () = {
    if ~(HasArchVersion(ARMv8p5)) then {
        return(false)
    };
    __IMPDEF_boolean("Has MTE extension")
}

val GetPSRFromPSTATE : unit -> bits(32) effect {escape, rreg}

function GetPSRFromPSTATE () = {
    spsr : bits(32) = Zeros();
    spsr = __SetSlice_bits(32, 4, spsr, 28, PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V)));
    if HaveDITExt() then {
        spsr = __SetSlice_bits(32, 1, spsr, 24, PSTATE.DIT)
    };
    if HavePANExt() then {
        spsr = __SetSlice_bits(32, 1, spsr, 22, PSTATE.PAN)
    };
    spsr = __SetSlice_bits(32, 1, spsr, 21, PSTATE.SS);
    spsr = __SetSlice_bits(32, 1, spsr, 20, PSTATE.IL);
    if PSTATE.nRW == 0b1 then {
        spsr = __SetSlice_bits(32, 1, spsr, 27, PSTATE.Q);
        spsr = __SetSlice_bits(32, 2, spsr, 25, slice(PSTATE.IT, 0, 2));
        spsr = __SetSlice_bits(32, 4, spsr, 16, PSTATE.GE);
        spsr = __SetSlice_bits(32, 6, spsr, 10, slice(PSTATE.IT, 2, 6));
        spsr = __SetSlice_bits(32, 1, spsr, 9, PSTATE.E);
        spsr = __SetSlice_bits(32, 3, spsr, 6, PSTATE.A @ (PSTATE.I @ PSTATE.F));
        spsr = __SetSlice_bits(32, 1, spsr, 5, PSTATE.T);
        assert([PSTATE.M[4]] == PSTATE.nRW);
        spsr = __SetSlice_bits(32, 5, spsr, 0, PSTATE.M)
    } else {
        if HaveUAOExt() then {
            spsr = __SetSlice_bits(32, 1, spsr, 23, PSTATE.UAO)
        };
        if HaveMTEExt() then {
            spsr = __SetSlice_bits(32, 1, spsr, 25, PSTATE.TCO)
        };
        if HaveBTIExt() then {
            spsr = __SetSlice_bits(32, 2, spsr, 10, PSTATE.BTYPE)
        };
        spsr = __SetSlice_bits(32, 4, spsr, 6, PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F)));
        spsr = __SetSlice_bits(32, 1, spsr, 4, PSTATE.nRW);
        spsr = __SetSlice_bits(32, 2, spsr, 2, PSTATE.EL);
        spsr = __SetSlice_bits(32, 1, spsr, 0, PSTATE.SP)
    };
    spsr
}

val HaveFP16MulNoRoundingToFP32Ext : unit -> bool effect {escape}

function HaveFP16MulNoRoundingToFP32Ext () = {
    if ~(HaveFP16Ext()) then {
        return(false)
    };
    if HasArchVersion(ARMv8p4) then {
        return(true)
    };
    HasArchVersion(ARMv8p2) & __IMPDEF_boolean("Has accumulate FP16 product into FP32 extension")
}

val HaveDoubleLock : unit -> bool effect {escape}

function HaveDoubleLock () = {
    ~(HasArchVersion(ARMv8p4)) | __IMPDEF_boolean("OS Double Lock is implemented")
}

val HaveAnyAArch64 : unit -> bool effect {rreg}

function HaveAnyAArch64 () = {
    ~(HighestELUsingAArch32())
}

val HaveAArch32EL : bits(2) -> bool effect {escape, rreg}

function HaveAArch32EL el = {
    if ~(HaveEL(el)) then {
        return(false)
    } else {
        if ~(HaveAnyAArch32()) then {
            return(false)
        } else {
            if HighestELUsingAArch32() then {
                return(true)
            } else {
                if el == HighestEL() then {
                    return(false)
                } else {
                    if el == EL0 then {
                        return(true)
                    } else {
                        match el {
                          ? if ? == EL0 => {
                              return(CFG_ID_AA64PFR0_EL1_EL0 == 0x2)
                          },
                          ? if ? == EL1 => {
                              return(CFG_ID_AA64PFR0_EL1_EL1 == 0x2)
                          },
                          ? if ? == EL2 => {
                              return(CFG_ID_AA64PFR0_EL1_EL2 == 0x2)
                          },
                          ? if ? == EL3 => {
                              return(CFG_ID_AA64PFR0_EL1_EL3 == 0x2)
                          }
                        }
                    }
                }
            }
        }
    }
}

val AArch64_ResetSpecialRegisters : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_ResetSpecialRegisters () = {
    SP_EL0 = undefined : bits(64);
    SP_EL1 = undefined : bits(64);
    SPSR_EL1 = undefined : bits(32);
    ELR_EL1 = undefined : bits(64);
    if HaveEL(EL2) then {
        SP_EL2 = undefined : bits(64);
        SPSR_EL2 = undefined : bits(32);
        ELR_EL2 = undefined : bits(64)
    };
    if HaveEL(EL3) then {
        SP_EL3 = undefined : bits(64);
        SPSR_EL3 = undefined : bits(32);
        ELR_EL3 = undefined : bits(64)
    };
    if HaveAArch32EL(EL1) then {
        SPSR_fiq = undefined : bits(32);
        SPSR_irq = undefined : bits(32);
        SPSR_abt = undefined : bits(32);
        SPSR_und = undefined : bits(32)
    };
    DLR_EL0 = undefined : bits(64);
    DSPSR_EL0 = undefined : bits(32);
    return()
}

val Halted : unit -> bool effect {rreg}

function Halted () = {
    ~(slice(EDSCR, 0, 6) == 0b000001 | slice(EDSCR, 0, 6) == 0b000010)
}

val GTEIsExtObsActive : forall ('observer : Int).
  int('observer) -> bool effect {rreg}

function GTEIsExtObsActive observer = {
    if observer >= NUM_GTE_EXT_OBS_OBSERVERS then {
        prerr("    ERROR handle out of range\n");
        return(false)
    };
    if ~(_GTEExtObsActive[observer]) then {
        prerr("    ERROR observer not active\n");
        return(false)
    };
    true
}

val GTEReturnObsData : unit -> unit effect {rreg, wreg}

function GTEReturnObsData () = {
    prerr("GTEReturnObsData(" ++ DecStr(UInt(slice(_GTEParam[0], 0, 32))) ++ ")\n");
    let 'observer = UInt(slice(_GTEParam[0], 0, 32));
    if ~(GTEIsExtObsActive(observer)) then {
        _GTEStatus = GTE_ST_REQUEST_FAIL;
        return()
    };
    if _GTEExtObsResultIndex[observer] == _GTEExtObsIndex[observer] + _GTEExtObsCount[observer] then {
        _GTEStatus = Ones(64);
        return()
    };
    let 'index = _GTEExtObsResultIndex[observer];
    if _GTEExtObsResultIsAddress[observer] then {
        _GTEStatus = _GTEExtObsAddress[_GTEExtObsResultIndex[observer]]
    } else {
        _GTEStatus = _GTEExtObsResult[_GTEExtObsResultIndex[observer]];
        _GTEExtObsResultIndex[observer] = _GTEExtObsResultIndex[observer] + 1
    };
    _GTEExtObsResultIsAddress[observer] = ~(_GTEExtObsResultIsAddress[observer]);
    return()
}

val GTEReleaseExtObs : unit -> unit effect {rreg, wreg}

function GTEReleaseExtObs () = {
    prerr("GTEReleaseExtObs(" ++ DecStr(UInt(slice(_GTEParam[0], 0, 32))) ++ ")\n");
    let 'observer = UInt(slice(_GTEParam[0], 0, 32));
    if ~(GTEIsExtObsActive(observer)) then {
        _GTEStatus = GTE_ST_REQUEST_FAIL;
        return()
    };
    _GTEExtObsActive[observer] = false;
    _GTEStatus = GTE_ST_REQUEST_GRANTED;
    return()
}

val GTEPerformExtObs64 : unit -> unit effect {rmem, rreg, undef, wmem, wreg}

function GTEPerformExtObs64 () = {
    prerr("GTEPerformExtObs64(" ++ DecStr(UInt(slice(_GTEParam[0], 0, 32))) ++ ")\n");
    let 'observer = UInt(slice(_GTEParam[0], 0, 32));
    if ~(GTEIsExtObsActive(observer)) then {
        _GTEStatus = GTE_ST_REQUEST_FAIL;
        return()
    };
    GTEPerformExtObsCommon(observer);
    _GTEStatus = GTE_ST_REQUEST_GRANTED;
    return()
}

val GTEPerformExtObs : unit -> unit effect {rmem, rreg, undef, wmem, wreg}

function GTEPerformExtObs () = {
    prerr("GTEPerformExtObs(" ++ DecStr(UInt(slice(_GTEParam[0], 0, 32))) ++ ")\n");
    let 'observer = UInt(slice(_GTEParam[0], 0, 32));
    if ~(GTEIsExtObsActive(observer)) then {
        _GTEStatus = GTE_ST_REQUEST_FAIL;
        return()
    };
    GTEPerformExtObsCommon(observer);
    _GTEStatus = GTE_EXT_OBS_RESULTS_ADDRESS;
    return()
}

val GTEEnableExtObs : unit -> unit effect {rreg, wreg}

function GTEEnableExtObs () = {
    prerr("GTEEnableExtObs(" ++ DecStr(UInt(slice(_GTEParam[0], 0, 32))) ++ ")\n");
    let 'observer = UInt(slice(_GTEParam[0], 0, 32));
    if ~(GTEIsExtObsActive(observer)) then {
        _GTEStatus = GTE_ST_REQUEST_FAIL;
        return()
    };
    _GTEExtObsResultIndex[observer] = _GTEExtObsIndex[observer];
    _GTEExtObsResultIsAddress[observer] = true;
    _GTEStatus = GTE_ST_REQUEST_GRANTED;
    return()
}

val GTEProcessParam : unit -> unit effect {rmem, rreg, undef, wmem, wreg}

function GTEProcessParam () = {
    match _GTECurrentAPI {
      ? if ? == VAL_EVENTGEN_SETUP => {
          if _GTEParamCount == 2 then {
              GTEListParam()
          } else {
              if _GTEParamCount == 3 then {
                  _GTEParamsComplete = true;
                  GTEEventGenSetup()
              }
          }
      },
      ? if ? == VAL_EVENTGEN_PRIME => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEEventGenPrime()
          }
      },
      ? if ? == VAL_EVENTGEN_CLEAR => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEEventGenClear()
          }
      },
      ? if ? == VAL_EVENTGEN_QUERY => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEEventGenQuery()
          }
      },
      ? if ? == VAL_EVENTGEN_DISABLE => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEEventGenDisable()
          }
      },
      ? if ? == VAL_EVENTGEN_FREE => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEEventGenFree()
          }
      },
      ? if ? == VAL_ASSERT => {
          if _GTEParamCount == 0 then {
              GTEListParam()
          } else {
              if _GTEParamCount == 2 then {
                  _GTEParamsComplete = true;
                  GTEAssert()
              }
          }
      },
      ? if ? == VAL_DEASSERT => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEDeassert()
          }
      },
      ? if ? == VAL_GET_PPU_ID => {
          _GTEParamsComplete = true;
          GTEGetPPUID()
      },
      ? if ? == VAL_SET_PPU_REGION => {
          if _GTEParamCount == 4 then {
              _GTEParamsComplete = true;
              GTESetPPURegion()
          }
      },
      ? if ? == VAL_GET_PPU_REGION => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEGetPPURegion()
          }
      },
      ? if ? == VAL_PPU_CONTROL => {
          if _GTEParamCount == 2 then {
              _GTEParamsComplete = true;
              GTEPPUControl()
          }
      },
      ? if ? == VAL_SETUP_EXT_OBS => {
          if _GTEParamCount == 0 then {
              GTEExtObsAddrDataListParam()
          } else {
              if _GTEParamCount == 1 then {
                  GTEListParam()
              } else {
                  if _GTEParamCount == 2 then {
                      _GTEParamsComplete = true;
                      GTESetupExtObs()
                  }
              }
          }
      },
      ? if ? == VAL_ENABLE_EXT_OBS => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEEnableExtObs()
          }
      },
      ? if ? == VAL_PERFORM_EXT_OBS => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEPerformExtObs()
          }
      },
      ? if ? == VAL_RELEASE_EXT_OBS => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEReleaseExtObs()
          }
      },
      ? if ? == VAL_SET_CRITICAL_EVENT => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTESetCriticalEvent()
          }
      },
      ? if ? == VAL_CRITICAL_SECTION_START => {
          if _GTEParamCount == 0 then {
              _GTEParamsComplete = true;
              GTECriticalSectionStart()
          }
      },
      ? if ? == VAL_CRITICAL_SECTION_END => {
          if _GTEParamCount == 0 then {
              _GTEParamsComplete = true;
              GTECriticalSectionEnd()
          }
      },
      ? if ? == VAL_RANDNUM => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTERandNum()
          }
      },
      ? if ? == VAL_DEFINE_NO_ABORTING_REGIONS => {
          prerr("Unhandled Trickbox GTE function VAL_DEFINE_NO_ABORTING_REGIONS\n")
      },
      ? if ? == VAL_OBSERVER_PIN_VALUE => {
          prerr("Unhandled Trickbox GTE function VAL_OBSERVER_PIN_VALUE\n")
      },
      ? if ? == VAL_EN_ACCESS_SENSITIVE_BEH => {
          if _GTEParamCount == 3 then {
              GTEEnAccessSensitiveBEH()
          }
      },
      ? if ? == VAL_CHK_ACCESS_SENSITIVE_BEH => {
          if _GTEParamCount == 0 then {
              GTEOnesTerminatedListParam()
          } else {
              if _GTEParamCount == 1 then {
                  GTEChkAccessSensitiveBEH()
              }
          }
      },
      ? if ? == VAL_SETUP_EXT_OBS_64 => {
          if _GTEParamCount == 0 then {
              GTEExtObsAccessListParam()
          } else {
              if _GTEParamCount == 1 then {
                  GTEOnesTerminatedListParam()
              } else {
                  if _GTEParamCount == 2 then {
                      _GTEParamsComplete = true;
                      GTESetupExtObs64()
                  }
              }
          }
      },
      ? if ? == VAL_ENABLE_EXT_OBS_64 => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEEnableExtObs()
          }
      },
      ? if ? == VAL_PERFORM_EXT_OBS_64 => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEPerformExtObs64()
          }
      },
      ? if ? == VAL_RETURN_OBS_DATA_64 => {
          if _GTEParamCount == 1 then {
              _GTEParamsComplete = true;
              GTEReturnObsData()
          }
      },
      _ => {
          prerr("Unknown Trickbox GTE function" ++ HexStr(UInt(_GTECurrentAPI)) ++ "\n")
      }
    };
    return()
}

val set_GTE_API : bits(32) -> unit effect {rmem, rreg, undef, wmem, wreg}

function set_GTE_API val_name = {
    _GTEActive = true;
    _GTEParamCount = 0;
    _GTEParamType = GTEParam_WORD;
    _GTEListParam = 0;
    _GTEParamsComplete = false;
    _GTEHaveParamLo = false;
    _GTECurrentAPI = val_name;
    GTEProcessParam();
    return()
}

val GTENextParam : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function GTENextParam val_name__arg = {
    val_name = val_name__arg;
    if _GTEParamType == GTEParam_LIST then {
        if val_name == _GTEListParamTerminator then {
            _GTEListParamTerminatorCount = _GTEListParamTerminatorCount + 1
        } else {
            _GTEListParamTerminatorCount = 0
        };
        if _GTEListParamTerminatorCount == _GTEListParamTerminators then {
            _GTEParamType = GTEParam_WORD;
            _GTEListParam = _GTEListParam + 1;
            val_name = __GetSlice_int(64, _GTEListParamIndex, 0);
            _GTEListParamIndex = 0
        } else {
            GTEAddListParam(val_name);
            return()
        }
    };
    if _GTEParamType == GTEParam_EOACCESS then {
        if _GTEListParamIndex == 0 then {
            let 'num_access = UInt(slice(val_name, 0, 8));
            _GTEListParamTerminatorCount = 1 + shr_int(num_access, 2)
        };
        if val_name == _GTEListParamTerminator & _GTEListParamIndex >= _GTEListParamTerminatorCount then {
            _GTEParamType = GTEParam_WORD;
            _GTEListParam = _GTEListParam + 1;
            val_name = __GetSlice_int(64, _GTEListParamIndex, 0);
            _GTEListParamIndex = 0
        } else {
            GTEAddListParam(val_name);
            return()
        }
    };
    _GTEParam[_GTEParamCount] = val_name;
    _GTEParamCount = _GTEParamCount + 1;
    GTEProcessParam();
    return()
}

val set_GTE_API_PARAM_64_HI : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function set_GTE_API_PARAM_64_HI val_name = {
    let val64_name : bits(64) = slice(val_name, 0, 32) @ _GTEParamLo;
    GTENextParam(val64_name)
}

val set_GTE_API_PARAM : bits(32) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function set_GTE_API_PARAM val_name = {
    GTENextParam(Zeros(32) @ val_name)
}

val _WriteTrickbox : forall 'address ('UNP : Bool) ('UP : Bool) ('PNP : Bool) ('PP : Bool).
  (int('address), bool('UNP), bool('UP), bool('PNP), bool('PP), bits(32)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function _WriteTrickbox (address, UNP, UP, PNP, PP, val_name) = {
    match address {
      0 if ((UNP | PNP) | UP) | PP => {
          set_TUBE(val_name)
      },
      8 if ((UNP | PNP) | UP) | PP => {
          set_ScheduleFIQ(val_name)
      },
      12 if ((UNP | PNP) | UP) | PP => {
          set_ScheduleIRQ(val_name)
      },
      16 if ((UNP | PNP) | UP) | PP => {
          set_ClearFIQ(val_name)
      },
      20 if ((UNP | PNP) | UP) | PP => {
          set_ClearIRQ(val_name)
      },
      252 if ((UNP | PNP) | UP) | PP => {
          set_TargetCPU(val_name)
      },
      256 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Lo1 = val_name
      },
      260 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Lo1_Hi = val_name
      },
      264 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Hi1 = val_name
      },
      268 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Hi1_Hi = val_name
      },
      272 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Lo2 = val_name
      },
      276 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Lo2_Hi = val_name
      },
      280 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Hi2 = val_name
      },
      284 if ((UNP | PNP) | UP) | PP => {
          AbortRgn64Hi2_Hi = val_name
      },
      1280 if ((UNP | PNP) | UP) | PP => {
          set_AXIAbortCtl(val_name)
      },
      2560 if ((UNP | PNP) | UP) | PP => {
          let GTE_API : vector(32, dec, bit) = undefined : bits(32);
          set_GTE_API(val_name)
      },
      2564 if ((UNP | PNP) | UP) | PP => {
          set_GTE_API_PARAM(val_name)
      },
      2600 if ((UNP | PNP) | UP) | PP => {
          set_GTE_API_PARAM_64(val_name)
      },
      2604 if ((UNP | PNP) | UP) | PP => {
          set_GTE_API_PARAM_64_HI(val_name)
      },
      _ => {
          prerr("Undefined trickbox write at offset " ++ HexStr(address) ++ " with value " ++ HexStr(UInt(val_name)) ++ "\n");
          return()
      }
    }
}

val GTECheckAccessSensitiveAccess : forall ('size : Int), 'size >= 0.
  (bits(52), int('size), bits(8 * 'size), bool) -> unit effect {escape, rreg, wreg}

function GTECheckAccessSensitiveAccess (address, size, data, isRead) = {
    if (~(_GTEActive) | _GTE_AS_Size == 0) | _GTE_AS_Access == 0 then {
        return()
    };
    if (_GTE_AS_AccessCount < NUM_GTE_AS_ACCESSES & UInt(address) >= UInt(_GTE_AS_Address)) & UInt(address) < UInt(_GTE_AS_Address + _GTE_AS_Size) then {
        let access_dir : bits(2) = if isRead then 0b01 else 0b10;
        let access : bits(32) = (Zeros(26) @ __GetSlice_int(4, size, 0)) @ access_dir;
        prerr("Access sensitive " ++ (if isRead then "read" else "write") ++ " at " ++ HexStr(UInt(address)) ++ " size " ++ DecStr(size));
        if (_GTE_AS_Access & access) == access then {
            prerr(" access match\n");
            let return_size : bits(2) = match size {
              1 => 0b01,
              2 => 0b10,
              4 => 0b00,
              8 => 0b11
            };
            _GTE_AS_RecordedAddress[_GTE_AS_AccessCount] = ZeroExtend(address);
            _GTE_AS_RecordedData[_GTE_AS_AccessCount] = ZeroExtend(data);
            __tc1 : bits(32) = _GTE_AS_RecordedAccess[_GTE_AS_AccessCount];
            __tc1 = __SetSlice_bits(32, 2, __tc1, 2, return_size);
            _GTE_AS_RecordedAccess[_GTE_AS_AccessCount] = __tc1;
            __tc2 : bits(32) = _GTE_AS_RecordedAccess[_GTE_AS_AccessCount];
            __tc2 = __SetSlice_bits(32, 2, __tc2, 0, access_dir);
            _GTE_AS_RecordedAccess[_GTE_AS_AccessCount] = __tc2;
            _GTE_AS_AccessCount = _GTE_AS_AccessCount + 1
        } else {
            prerr(" no access match\n")
        }
    };
    return()
}

val FPUnpackBase : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> (FPType, bits(1), real) effect {escape, rreg, undef, wreg}

function FPUnpackBase (fpval, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    exp16 : bits(5) = undefined : bits(5);
    exp32 : bits(8) = undefined : bits(8);
    exp64 : bits(11) = undefined : bits(11);
    frac16 : bits(10) = undefined : bits(10);
    frac32 : bits(23) = undefined : bits(23);
    frac64 : bits(52) = undefined : bits(52);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    if 'N == 16 then {
        sign = [fpval[15]];
        exp16 = slice(fpval, 10, 5);
        frac16 = slice(fpval, 0, 10);
        if IsZero(exp16) then {
            if IsZero(frac16) | [fpcr[19]] == 0b1 then {
                typ = FPType_Zero;
                value_name = 0.0
            } else {
                typ = FPType_Nonzero;
                value_name = 2.0 ^ negate(14) * (Real(UInt(frac16)) * 2.0 ^ negate(10))
            }
        } else {
            if IsOnes(exp16) & [fpcr[26]] == 0b0 then {
                if IsZero(frac16) then {
                    typ = FPType_Infinity;
                    value_name = 2.0 ^ 1000000
                } else {
                    typ = if [frac16[9]] == 0b1 then FPType_QNaN else FPType_SNaN;
                    value_name = 0.0
                }
            } else {
                typ = FPType_Nonzero;
                value_name = 2.0 ^ (UInt(exp16) - 15) * (1.0 + Real(UInt(frac16)) * 2.0 ^ negate(10))
            }
        }
    } else {
        if 'N == 32 then {
            sign = [fpval[31]];
            exp32 = slice(fpval, 23, 8);
            frac32 = slice(fpval, 0, 23);
            if IsZero(exp32) then {
                if IsZero(frac32) | [fpcr[24]] == 0b1 then {
                    typ = FPType_Zero;
                    value_name = 0.0;
                    if ~(IsZero(frac32)) then {
                        FPProcessException(FPExc_InputDenorm, fpcr)
                    }
                } else {
                    typ = FPType_Nonzero;
                    value_name = 2.0 ^ negate(126) * (Real(UInt(frac32)) * 2.0 ^ negate(23))
                }
            } else {
                if IsOnes(exp32) then {
                    if IsZero(frac32) then {
                        typ = FPType_Infinity;
                        value_name = 2.0 ^ 1000000
                    } else {
                        typ = if [frac32[22]] == 0b1 then FPType_QNaN else FPType_SNaN;
                        value_name = 0.0
                    }
                } else {
                    typ = FPType_Nonzero;
                    value_name = 2.0 ^ (UInt(exp32) - 127) * (1.0 + Real(UInt(frac32)) * 2.0 ^ negate(23))
                }
            }
        } else {
            sign = [fpval[63]];
            exp64 = slice(fpval, 52, 11);
            frac64 = slice(fpval, 0, 52);
            if IsZero(exp64) then {
                if IsZero(frac64) | [fpcr[24]] == 0b1 then {
                    typ = FPType_Zero;
                    value_name = 0.0;
                    if ~(IsZero(frac64)) then {
                        FPProcessException(FPExc_InputDenorm, fpcr)
                    }
                } else {
                    typ = FPType_Nonzero;
                    value_name = 2.0 ^ negate(1022) * (Real(UInt(frac64)) * 2.0 ^ negate(52))
                }
            } else {
                if IsOnes(exp64) then {
                    if IsZero(frac64) then {
                        typ = FPType_Infinity;
                        value_name = 2.0 ^ 1000000
                    } else {
                        typ = if [frac64[51]] == 0b1 then FPType_QNaN else FPType_SNaN;
                        value_name = 0.0
                    }
                } else {
                    typ = FPType_Nonzero;
                    value_name = 2.0 ^ (UInt(exp64) - 1023) * (1.0 + Real(UInt(frac64)) * 2.0 ^ negate(52))
                }
            }
        }
    };
    if sign == 0b1 then {
        value_name = negate(value_name)
    };
    return((typ, sign, value_name))
}

val FPUnpackCV : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> (FPType, bits(1), real) effect {escape, rreg, undef, wreg}

function FPUnpackCV (fpval, fpcr) = {
    let fpcr = __SetSlice_bits(32, 1, fpcr, 19, 0b0);
    fp_type : FPType = undefined : FPType;
    sign : bits(1) = undefined : bits(1);
    value_name : real = undefined : real;
    (fp_type, sign, value_name) = FPUnpackBase(fpval, fpcr);
    return((fp_type, sign, value_name))
}

val FPConvert__0 : forall ('N : Int) ('M : Int), 'N >= 0.
  (bits('N), bits(32), FPRounding) -> bits('M) effect {escape, rreg, undef, wreg}

val FPConvert__1 : forall ('N : Int) ('M : Int), 'N >= 0.
  (bits('N), bits(32)) -> bits('M) effect {escape, rreg, undef, wreg}

overload FPConvert = {FPConvert__0, FPConvert__1}

function FPConvert__0 (op, fpcr, rounding) = {
    assert('M == 16 | 'M == 32 | 'M == 64);
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('M) = undefined : bits('M);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpackCV(op, fpcr);
    let alt_hp : bool = 'M == 16 & [fpcr[26]] == 0b1;
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        if alt_hp then {
            result = FPZero(sign)
        } else {
            if [fpcr[25]] == 0b1 then {
                result = FPDefaultNaN()
            } else {
                result = FPConvertNaN(op)
            }
        };
        if typ == FPType_SNaN | alt_hp then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        }
    } else {
        if typ == FPType_Infinity then {
            if alt_hp then {
                result = sign @ Ones('M - 1);
                FPProcessException(FPExc_InvalidOp, fpcr)
            } else {
                result = FPInfinity(sign)
            }
        } else {
            if typ == FPType_Zero then {
                result = FPZero(sign)
            } else {
                result = FPRoundCV(value_name, fpcr, rounding)
            }
        }
    };
    result
}

function FPConvert__1 (op, fpcr) = {
    FPConvert(op, fpcr, FPRoundingMode(fpcr))
}

val FPUnpack : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> (FPType, bits(1), real) effect {escape, rreg, undef, wreg}

function FPUnpack (fpval, fpcr) = {
    let fpcr = __SetSlice_bits(32, 1, fpcr, 26, 0b0);
    fp_type : FPType = undefined : FPType;
    sign : bits(1) = undefined : bits(1);
    value_name : real = undefined : real;
    (fp_type, sign, value_name) = FPUnpackBase(fpval, fpcr);
    return((fp_type, sign, value_name))
}

val FPToFixedJS : forall ('M : Int) ('N : Int) ('Is64 : Bool), 'M >= 0.
  (bits('M), bits(32), bool('Is64)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPToFixedJS (op, fpcr, Is64) = {
    assert('M == 64 & 'N == 32);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(op, fpcr);
    Z : bits(1) = undefined : bits(1);
    Z = 0b1;
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        Z = 0b0
    };
    int_result : int = undefined : int;
    int_result = RoundDown(value_name);
    let error : real = value_name - Real(int_result);
    let round_it_up : bool = error != 0.0 & int_result < 0;
    if round_it_up then {
        int_result = int_result + 1
    };
    result : int = undefined : int;
    if int_result < 0 then {
        result = int_result - 2 ^ 32 * RoundUp(Real(int_result) / Real(2 ^ 32))
    } else {
        result = int_result - 2 ^ 32 * RoundDown(Real(int_result) / Real(2 ^ 32))
    };
    if int_result < negate(2 ^ 31) | int_result > 2 ^ 31 - 1 then {
        FPProcessException(FPExc_InvalidOp, fpcr);
        Z = 0b0
    } else {
        if error != 0.0 then {
            FPProcessException(FPExc_Inexact, fpcr);
            Z = 0b0
        }
    };
    if sign == 0b1 & value_name == 0.0 then {
        Z = 0b0
    };
    if typ == FPType_Infinity then {
        result = 0
    };
    if Is64 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = (0b0 @ Z) @ 0b00
    } else {
        FPSCR = __SetSlice_bits(32, 4, FPSCR, 28, (0b0 @ Z) @ 0b00)
    };
    __GetSlice_int('N, result, 0)
}

val FPToFixed : forall 'N 'M 'fbits ('unsigned : Bool),
  ('N >= 0 & 'fbits >= 0).
  (bits('N), int('fbits), bool('unsigned), bits(32), FPRounding) -> bits('M) effect {escape, rreg, undef, wreg}

function FPToFixed (op, fbits, unsigned, fpcr, rounding) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert('M == 16 | 'M == 32 | 'M == 64);
    assert(fbits >= 0);
    assert(rounding != FPRounding_ODD);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(op, fpcr);
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        FPProcessException(FPExc_InvalidOp, fpcr)
    };
    let value_name = value_name * 2.0 ^ fbits;
    int_result : int = undefined : int;
    int_result = RoundDown(value_name);
    let error : real = value_name - Real(int_result);
    round_up : bool = undefined : bool;
    match rounding {
      FPRounding_TIEEVEN => {
          round_up = error > 0.5 | error == 0.5 & __GetSlice_int(1, int_result, 0) == 0b1
      },
      FPRounding_POSINF => {
          round_up = error != 0.0
      },
      FPRounding_NEGINF => {
          round_up = false
      },
      FPRounding_ZERO => {
          round_up = error != 0.0 & int_result < 0
      },
      FPRounding_TIEAWAY => {
          round_up = error > 0.5 | error == 0.5 & int_result >= 0
      }
    };
    let round_up = round_up;
    if round_up then {
        int_result = int_result + 1
    };
    overflow : bool = undefined : bool;
    result : bits('M) = undefined : bits('M);
    (result, overflow) = SatQ(int_result, 'M, unsigned);
    if overflow then {
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        if error != 0.0 then {
            FPProcessException(FPExc_Inexact, fpcr)
        }
    };
    result
}

val FPSqrt : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPSqrt (op, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(op, fpcr);
    result : bits('N) = undefined : bits('N);
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        result = FPProcessNaN(typ, op, fpcr)
    } else {
        if typ == FPType_Zero then {
            result = FPZero(sign)
        } else {
            if typ == FPType_Infinity & sign == 0b0 then {
                result = FPInfinity(sign)
            } else {
                if sign == 0b1 then {
                    result = FPDefaultNaN();
                    FPProcessException(FPExc_InvalidOp, fpcr)
                } else {
                    result = FPRound(Sqrt(value_name), fpcr)
                }
            }
        }
    };
    result
}

val FPRoundIntN : forall 'N 'intsize,
  ('N >= 0 & 'intsize in {32, 64}).
  (bits('N), bits(32), FPRounding, int('intsize)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRoundIntN (op, fpcr, rounding, intsize) = {
    assert(rounding != FPRounding_ODD);
    assert('N == 32 | 'N == 64);
    assert(intsize == 32 | intsize == 64);
    exp : int = undefined : int;
    let 'E : {'n, 'n in {8, 11}. int('n)} = if 'N == 32 then 8 else 11;
    let 'F : {'n, 'n == 'N - ('E + 1). int('n)} = 'N - (E + 1);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(op, fpcr);
    error : real = undefined : real;
    int_result : int = undefined : int;
    real_result : real = undefined : real;
    result : bits('N) = undefined : bits('N);
    round_up : bool = undefined : bool;
    if typ == FPType_SNaN | typ == FPType_QNaN | typ == FPType_Infinity then {
        if 'N == 32 then {
            exp = 126 + intsize;
            result = (0b1 @ __GetSlice_int(E, exp, 0)) @ Zeros(F)
        } else {
            exp = 1022 + intsize;
            result = (0b1 @ __GetSlice_int(E, exp, 0)) @ Zeros(F)
        };
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        if typ == FPType_Zero then {
            result = FPZero(sign)
        } else {
            int_result = RoundDown(value_name);
            error = value_name - Real(int_result);
            match rounding {
              FPRounding_TIEEVEN => {
                  round_up = error > 0.5 | error == 0.5 & __GetSlice_int(1, int_result, 0) == 0b1
              },
              FPRounding_POSINF => {
                  round_up = error != 0.0
              },
              FPRounding_NEGINF => {
                  round_up = false
              },
              FPRounding_ZERO => {
                  round_up = error != 0.0 & int_result < 0
              },
              FPRounding_TIEAWAY => {
                  round_up = error > 0.5 | error == 0.5 & int_result >= 0
              }
            };
            if round_up then {
                int_result = int_result + 1
            };
            if int_result > 2 ^ (intsize - 1) - 1 | int_result < negate(1) * 2 ^ (intsize - 1) then {
                if 'N == 32 then {
                    exp = 126 + intsize;
                    result = (0b1 @ __GetSlice_int(E, exp, 0)) @ Zeros(F)
                } else {
                    exp = 1022 + intsize;
                    result = (0b1 @ __GetSlice_int(E, exp, 0)) @ Zeros(F)
                };
                FPProcessException(FPExc_InvalidOp, fpcr);
                error = 0.0
            } else {
                real_result = Real(int_result);
                if real_result == 0.0 then {
                    result = FPZero(sign)
                } else {
                    result = FPRound(real_result, fpcr, FPRounding_ZERO)
                }
            };
            if error != 0.0 then {
                FPProcessException(FPExc_Inexact, fpcr)
            }
        }
    };
    result
}

val FPRoundInt : forall ('N : Int) ('exact : Bool), 'N >= 0.
  (bits('N), bits(32), FPRounding, bool('exact)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRoundInt (op, fpcr, rounding, exact) = {
    assert(rounding != FPRounding_ODD);
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(op, fpcr);
    error : real = undefined : real;
    int_result : int = undefined : int;
    real_result : real = undefined : real;
    result : bits('N) = undefined : bits('N);
    round_up : bool = undefined : bool;
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        result = FPProcessNaN(typ, op, fpcr)
    } else {
        if typ == FPType_Infinity then {
            result = FPInfinity(sign)
        } else {
            if typ == FPType_Zero then {
                result = FPZero(sign)
            } else {
                int_result = RoundDown(value_name);
                error = value_name - Real(int_result);
                match rounding {
                  FPRounding_TIEEVEN => {
                      round_up = error > 0.5 | error == 0.5 & __GetSlice_int(1, int_result, 0) == 0b1
                  },
                  FPRounding_POSINF => {
                      round_up = error != 0.0
                  },
                  FPRounding_NEGINF => {
                      round_up = false
                  },
                  FPRounding_ZERO => {
                      round_up = error != 0.0 & int_result < 0
                  },
                  FPRounding_TIEAWAY => {
                      round_up = error > 0.5 | error == 0.5 & int_result >= 0
                  }
                };
                if round_up then {
                    int_result = int_result + 1
                };
                real_result = Real(int_result);
                if real_result == 0.0 then {
                    result = FPZero(sign)
                } else {
                    result = FPRound(real_result, fpcr, FPRounding_ZERO)
                };
                if error != 0.0 & exact then {
                    FPProcessException(FPExc_Inexact, fpcr)
                }
            }
        }
    };
    result
}

val FPRecpX : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRecpX (op, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let 'esize : {|5, 8, 11|} = match 'N {
      16 => 5,
      32 => 8,
      64 => 11
    };
    result : bits('N) = undefined : bits('N);
    exp : bits('esize) = undefined : bits('esize);
    max_exp : bits('esize) = undefined : bits('esize);
    let frac : bits('N - 'esize - 1) = Zeros();
    match 'N {
      16 => {
          exp = slice(op, 10, esize)
      },
      32 => {
          exp = slice(op, 23, esize)
      },
      64 => {
          exp = slice(op, 52, esize)
      }
    };
    let max_exp = Ones(esize) - 1;
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(op, fpcr);
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        result = FPProcessNaN(typ, op, fpcr)
    } else {
        if IsZero(exp) then {
            result = (sign @ max_exp) @ frac
        } else {
            result = (sign @ ~(exp)) @ frac
        }
    };
    result
}

val FPRecipEstimate : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRecipEstimate (operand, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(operand, fpcr);
    estimate : int = undefined : int;
    exp : int = undefined : int;
    fraction : bits(52) = undefined : bits(52);
    overflow_to_inf : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    result_exp : int = undefined : int;
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        result = FPProcessNaN(typ, operand, fpcr)
    } else {
        if typ == FPType_Infinity then {
            result = FPZero(sign)
        } else {
            if typ == FPType_Zero then {
                result = FPInfinity(sign);
                FPProcessException(FPExc_DivideByZero, fpcr)
            } else {
                if ('N == 16 & abs(value_name) < 2.0 ^ negate(16) | 'N == 32 & abs(value_name) < 2.0 ^ negate(128)) | 'N == 64 & abs(value_name) < 2.0 ^ negate(1024) then {
                    match FPRoundingMode(fpcr) {
                      FPRounding_TIEEVEN => {
                          overflow_to_inf = true
                      },
                      FPRounding_POSINF => {
                          overflow_to_inf = sign == 0b0
                      },
                      FPRounding_NEGINF => {
                          overflow_to_inf = sign == 0b1
                      },
                      FPRounding_ZERO => {
                          overflow_to_inf = false
                      }
                    };
                    result = if overflow_to_inf then FPInfinity(sign) else FPMaxNormal(sign);
                    FPProcessException(FPExc_Overflow, fpcr);
                    FPProcessException(FPExc_Inexact, fpcr)
                } else {
                    if ([fpcr[24]] == 0b1 & 'N != 16 | [fpcr[19]] == 0b1 & 'N == 16) & (('N == 16 & abs(value_name) >= 2.0 ^ 14 | 'N == 32 & abs(value_name) >= 2.0 ^ 126) | 'N == 64 & abs(value_name) >= 2.0 ^ 1022) then {
                        result = FPZero(sign);
                        if UsingAArch32() then {
                            FPSCR = __SetSlice_bits(32, 1, FPSCR, 3, 0b1)
                        } else {
                            FPSR = __SetSlice_bits(32, 1, FPSR, 3, 0b1)
                        }
                    } else {
                        match 'N {
                          16 => {
                              fraction = slice(operand, 0, 10) @ Zeros(42);
                              exp = UInt(slice(operand, 10, 5))
                          },
                          32 => {
                              fraction = slice(operand, 0, 23) @ Zeros(29);
                              exp = UInt(slice(operand, 23, 8))
                          },
                          64 => {
                              fraction = slice(operand, 0, 52);
                              exp = UInt(slice(operand, 52, 11))
                          }
                        };
                        if exp == 0 then {
                            if [fraction[51]] == 0 then {
                                exp = negate(1);
                                fraction = slice(fraction, 0, 50) @ 0b00
                            } else {
                                fraction = slice(fraction, 0, 51) @ 0b0
                            }
                        };
                        let 'scaled = UInt(0b1 @ slice(fraction, 44, 8));
                        match 'N {
                          16 => {
                              result_exp = 29 - exp
                          },
                          32 => {
                              result_exp = 253 - exp
                          },
                          64 => {
                              result_exp = 2045 - exp
                          }
                        };
                        estimate = RecipEstimate(scaled);
                        fraction = __GetSlice_int(8, estimate, 0) @ Zeros(44);
                        if result_exp == 0 then {
                            fraction = 0b1 @ slice(fraction, 1, 51)
                        } else {
                            if result_exp == negate(1) then {
                                fraction = 0b01 @ slice(fraction, 2, 50);
                                result_exp = 0
                            }
                        };
                        match 'N {
                          16 => {
                              result = (sign @ __GetSlice_int('N - 11, result_exp, 0)) @ slice(fraction, 42, 10)
                          },
                          32 => {
                              result = (sign @ __GetSlice_int('N - 24, result_exp, 0)) @ slice(fraction, 29, 23)
                          },
                          64 => {
                              result = (sign @ __GetSlice_int('N - 53, result_exp, 0)) @ slice(fraction, 0, 52)
                          }
                        }
                    }
                }
            }
        }
    };
    result
}

val FPRSqrtEstimate : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRSqrtEstimate (operand, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    (typ, sign, value_name) = FPUnpack(operand, fpcr);
    estimate : int = undefined : int;
    exp : int = undefined : int;
    fraction : bits(52) = undefined : bits(52);
    result : bits('N) = undefined : bits('N);
    result_exp : int = undefined : int;
    scaled : int = undefined : int;
    if typ == FPType_SNaN | typ == FPType_QNaN then {
        result = FPProcessNaN(typ, operand, fpcr)
    } else {
        if typ == FPType_Zero then {
            result = FPInfinity(sign);
            FPProcessException(FPExc_DivideByZero, fpcr)
        } else {
            if sign == 0b1 then {
                result = FPDefaultNaN();
                FPProcessException(FPExc_InvalidOp, fpcr)
            } else {
                if typ == FPType_Infinity then {
                    result = FPZero(0b0)
                } else {
                    match 'N {
                      16 => {
                          fraction = slice(operand, 0, 10) @ Zeros(42);
                          exp = UInt(slice(operand, 10, 5))
                      },
                      32 => {
                          fraction = slice(operand, 0, 23) @ Zeros(29);
                          exp = UInt(slice(operand, 23, 8))
                      },
                      64 => {
                          fraction = slice(operand, 0, 52);
                          exp = UInt(slice(operand, 52, 11))
                      }
                    };
                    if exp == 0 then {
                        while [fraction[51]] == 0 do {
                            fraction = slice(fraction, 0, 51) @ 0b0;
                            exp = exp - 1
                        };
                        fraction = slice(fraction, 0, 51) @ 0b0
                    };
                    if __GetSlice_int(1, exp, 0) == 0b0 then {
                        scaled = UInt(0b1 @ slice(fraction, 44, 8))
                    } else {
                        scaled = UInt(0b01 @ slice(fraction, 45, 7))
                    };
                    match 'N {
                      16 => {
                          result_exp = (44 - exp) / 2
                      },
                      32 => {
                          result_exp = (380 - exp) / 2
                      },
                      64 => {
                          result_exp = (3068 - exp) / 2
                      }
                    };
                    estimate = RecipSqrtEstimate(scaled);
                    match 'N {
                      16 => {
                          result = ((0b0 @ __GetSlice_int('N - 11, result_exp, 0)) @ __GetSlice_int(8, estimate, 0)) @ Zeros(2)
                      },
                      32 => {
                          result = ((0b0 @ __GetSlice_int('N - 24, result_exp, 0)) @ __GetSlice_int(8, estimate, 0)) @ Zeros(15)
                      },
                      64 => {
                          result = ((0b0 @ __GetSlice_int('N - 53, result_exp, 0)) @ __GetSlice_int(8, estimate, 0)) @ Zeros(44)
                      }
                    }
                }
            }
        }
    };
    result
}

val FPCompareGT : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bool effect {escape, rreg, undef, wreg}

function FPCompareGT (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bool = undefined : bool;
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = false;
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = value1_name > value2_name
    };
    result
}

val FPCompareGE : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bool effect {escape, rreg, undef, wreg}

function FPCompareGE (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bool = undefined : bool;
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = false;
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = value1_name >= value2_name
    };
    result
}

val FPCompareEQ : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bool effect {escape, rreg, undef, wreg}

function FPCompareEQ (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bool = undefined : bool;
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = false;
        if type1 == FPType_SNaN | type2 == FPType_SNaN then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        }
    } else {
        result = value1_name == value2_name
    };
    result
}

val FPCompare : forall 'N ('signal_nans : Bool),
  ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bool('signal_nans), bits(32)) -> bits(4) effect {escape, rreg, undef, wreg}

function FPCompare (op1, op2, signal_nans, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    result : bits(4) = undefined : bits(4);
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = 0x3;
        if (type1 == FPType_SNaN | type2 == FPType_SNaN) | signal_nans then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        }
    } else {
        if value1_name == value2_name then {
            result = 0x6
        } else {
            if value1_name < value2_name then {
                result = 0x8
            } else {
                result = 0x2
            }
        }
    };
    result
}

val FPSub : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPSub (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    result_sign : bits(1) = undefined : bits(1);
    result_value : real = undefined : real;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == sign2 then {
            result = FPDefaultNaN();
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b1 then {
                result = FPInfinity(0b0)
            } else {
                if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b0 then {
                    result = FPInfinity(0b1)
                } else {
                    if (zero1 & zero2) & sign1 == ~(sign2) then {
                        result = FPZero(sign1)
                    } else {
                        result_value = value1_name - value2_name;
                        if result_value == 0.0 then {
                            result_sign = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                            result = FPZero(result_sign)
                        } else {
                            result = FPRound(result_value, fpcr, rounding)
                        }
                    }
                }
            }
        }
    };
    result
}

val FPRecipStepFused : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRecipStepFused (op1, op2) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined : bits('N);
    let op1 = FPNeg(op1);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, FPCR);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, FPCR);
    done : bool = undefined : bool;
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, FPCR);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    result_value : real = undefined : real;
    sign : bits(1) = undefined : bits(1);
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPTwo(0b0)
        } else {
            if inf1 | inf2 then {
                result = FPInfinity(sign1 ^ sign2)
            } else {
                result_value = 2.0 + value1_name * value2_name;
                if result_value == 0.0 then {
                    sign = if FPRoundingMode(FPCR) == FPRounding_NEGINF then 0b1 else 0b0;
                    result = FPZero(sign)
                } else {
                    result = FPRound(result_value, FPCR)
                }
            }
        }
    };
    result
}

val FPRSqrtStepFused : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRSqrtStepFused (op1, op2) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined : bits('N);
    let op1 = FPNeg(op1);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, FPCR);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, FPCR);
    done : bool = undefined : bool;
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, FPCR);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    result_value : real = undefined : real;
    sign : bits(1) = undefined : bits(1);
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPOnePointFive(0b0)
        } else {
            if inf1 | inf2 then {
                result = FPInfinity(sign1 ^ sign2)
            } else {
                result_value = (3.0 + value1_name * value2_name) / 2.0;
                if result_value == 0.0 then {
                    sign = if FPRoundingMode(FPCR) == FPRounding_NEGINF then 0b1 else 0b0;
                    result = FPZero(sign)
                } else {
                    result = FPRound(result_value, FPCR)
                }
            }
        }
    };
    result
}

val FPMulX : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMulX (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined : bits('N);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPTwo(sign1 ^ sign2)
        } else {
            if inf1 | inf2 then {
                result = FPInfinity(sign1 ^ sign2)
            } else {
                if zero1 | zero2 then {
                    result = FPZero(sign1 ^ sign2)
                } else {
                    result = FPRound(value1_name * value2_name, fpcr)
                }
            }
        }
    };
    result
}

val FPMulAddH : forall ('N : Int), 'N >= 0.
  (bits('N), bits(div('N, 2)), bits(div('N, 2)), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMulAddH (addend, op1, op2, fpcr) = {
    assert('N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    signA : bits(1) = undefined : bits(1);
    typeA : FPType = undefined : FPType;
    valueA_name : real = undefined : real;
    (typeA, signA, valueA_name) = FPUnpack(addend, fpcr);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    let inf1 : bool = type1 == FPType_Infinity;
    let zero1 : bool = type1 == FPType_Zero;
    let inf2 : bool = type2 == FPType_Infinity;
    let zero2 : bool = type2 == FPType_Zero;
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs3H(typeA, type1, type2, addend, op1, op2, fpcr);
    if typeA == FPType_QNaN & (inf1 & zero2 | zero1 & inf2) then {
        result = FPDefaultNaN();
        FPProcessException(FPExc_InvalidOp, fpcr)
    };
    infA : bool = undefined : bool;
    infP : bool = undefined : bool;
    result_sign : bits(1) = undefined : bits(1);
    result_value : real = undefined : real;
    signP : bits(1) = undefined : bits(1);
    zeroA : bool = undefined : bool;
    zeroP : bool = undefined : bool;
    if ~(done) then {
        infA = typeA == FPType_Infinity;
        zeroA = typeA == FPType_Zero;
        signP = sign1 ^ sign2;
        infP = inf1 | inf2;
        zeroP = zero1 | zero2;
        if (inf1 & zero2 | zero1 & inf2) | (infA & infP) & signA != signP then {
            result = FPDefaultNaN();
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            if infA & signA == 0b0 | infP & signP == 0b0 then {
                result = FPInfinity(0b0)
            } else {
                if infA & signA == 0b1 | infP & signP == 0b1 then {
                    result = FPInfinity(0b1)
                } else {
                    if (zeroA & zeroP) & signA == signP then {
                        result = FPZero(signA)
                    } else {
                        result_value = valueA_name + value1_name * value2_name;
                        if result_value == 0.0 then {
                            result_sign = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                            result = FPZero(result_sign)
                        } else {
                            result = FPRound(result_value, fpcr)
                        }
                    }
                }
            }
        }
    };
    result
}

val FPMulAdd : forall ('N : Int), ('N >= 0 & 'N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMulAdd (addend, op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    signA : bits(1) = undefined : bits(1);
    typeA : FPType = undefined : FPType;
    valueA_name : real = undefined : real;
    (typeA, signA, valueA_name) = FPUnpack(addend, fpcr);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    let inf1 : bool = type1 == FPType_Infinity;
    let zero1 : bool = type1 == FPType_Zero;
    let inf2 : bool = type2 == FPType_Infinity;
    let zero2 : bool = type2 == FPType_Zero;
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs3(typeA, type1, type2, addend, op1, op2, fpcr);
    if typeA == FPType_QNaN & (inf1 & zero2 | zero1 & inf2) then {
        result = FPDefaultNaN();
        FPProcessException(FPExc_InvalidOp, fpcr)
    };
    infA : bool = undefined : bool;
    infP : bool = undefined : bool;
    result_sign : bits(1) = undefined : bits(1);
    result_value : real = undefined : real;
    signP : bits(1) = undefined : bits(1);
    zeroA : bool = undefined : bool;
    zeroP : bool = undefined : bool;
    if ~(done) then {
        infA = typeA == FPType_Infinity;
        zeroA = typeA == FPType_Zero;
        signP = sign1 ^ sign2;
        infP = inf1 | inf2;
        zeroP = zero1 | zero2;
        if (inf1 & zero2 | zero1 & inf2) | (infA & infP) & signA != signP then {
            result = FPDefaultNaN();
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            if infA & signA == 0b0 | infP & signP == 0b0 then {
                result = FPInfinity(0b0)
            } else {
                if infA & signA == 0b1 | infP & signP == 0b1 then {
                    result = FPInfinity(0b1)
                } else {
                    if (zeroA & zeroP) & signA == signP then {
                        result = FPZero(signA)
                    } else {
                        result_value = valueA_name + value1_name * value2_name;
                        if result_value == 0.0 then {
                            result_sign = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                            result = FPZero(result_sign)
                        } else {
                            result = FPRound(result_value, fpcr)
                        }
                    }
                }
            }
        }
    };
    result
}

val FPMul : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMul (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPDefaultNaN();
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            if inf1 | inf2 then {
                result = FPInfinity(sign1 ^ sign2)
            } else {
                if zero1 | zero2 then {
                    result = FPZero(sign1 ^ sign2)
                } else {
                    result = FPRound(value1_name * value2_name, fpcr)
                }
            }
        }
    };
    result
}

val FPMin : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMin (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    if ~(done) then {
        if value1_name < value2_name then {
            (typ, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (typ, sign, value_name) = (type2, sign2, value2_name)
        };
        if typ == FPType_Infinity then {
            result = FPInfinity(sign)
        } else {
            if typ == FPType_Zero then {
                sign = sign1 | sign2;
                result = FPZero(sign)
            } else {
                result = FPRound(value_name, fpcr)
            }
        }
    };
    result
}

val FPMinNum : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMinNum (op1__arg, op2__arg, fpcr) = {
    op1 = op1__arg;
    op2 = op2__arg;
    assert('N == 16 | 'N == 32 | 'N == 64);
    __anon1 : bits(1) = undefined : bits(1);
    __anon2 : real = undefined : real;
    type1 : FPType = undefined : FPType;
    (type1, __anon1, __anon2) = FPUnpack(op1, fpcr);
    __anon3 : bits(1) = undefined : bits(1);
    __anon4 : real = undefined : real;
    type2 : FPType = undefined : FPType;
    (type2, __anon3, __anon4) = FPUnpack(op2, fpcr);
    if type1 == FPType_QNaN & type2 != FPType_QNaN then {
        op1 = FPInfinity(0b0)
    } else {
        if type1 != FPType_QNaN & type2 == FPType_QNaN then {
            op2 = FPInfinity(0b0)
        }
    };
    FPMin(op1, op2, fpcr)
}

val FPMax : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMax (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    sign : bits(1) = undefined : bits(1);
    typ : FPType = undefined : FPType;
    value_name : real = undefined : real;
    if ~(done) then {
        if value1_name > value2_name then {
            (typ, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (typ, sign, value_name) = (type2, sign2, value2_name)
        };
        if typ == FPType_Infinity then {
            result = FPInfinity(sign)
        } else {
            if typ == FPType_Zero then {
                sign = sign1 & sign2;
                result = FPZero(sign)
            } else {
                result = FPRound(value_name, fpcr)
            }
        }
    };
    result
}

val FPMaxNum : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMaxNum (op1__arg, op2__arg, fpcr) = {
    op1 = op1__arg;
    op2 = op2__arg;
    assert('N == 16 | 'N == 32 | 'N == 64);
    __anon1 : bits(1) = undefined : bits(1);
    __anon2 : real = undefined : real;
    type1 : FPType = undefined : FPType;
    (type1, __anon1, __anon2) = FPUnpack(op1, fpcr);
    __anon3 : bits(1) = undefined : bits(1);
    __anon4 : real = undefined : real;
    type2 : FPType = undefined : FPType;
    (type2, __anon3, __anon4) = FPUnpack(op2, fpcr);
    if type1 == FPType_QNaN & type2 != FPType_QNaN then {
        op1 = FPInfinity(0b1)
    } else {
        if type1 != FPType_QNaN & type2 == FPType_QNaN then {
            op2 = FPInfinity(0b1)
        }
    };
    FPMax(op1, op2, fpcr)
}

val FPDiv : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPDiv (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if inf1 & inf2 | zero1 & zero2 then {
            result = FPDefaultNaN();
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            if inf1 | zero2 then {
                result = FPInfinity(sign1 ^ sign2);
                if ~(inf1) then {
                    FPProcessException(FPExc_DivideByZero, fpcr)
                }
            } else {
                if zero1 | inf2 then {
                    result = FPZero(sign1 ^ sign2)
                } else {
                    result = FPRound(value1_name / value2_name, fpcr)
                }
            }
        }
    };
    result
}

val FPAdd : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPAdd (op1, op2, fpcr) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    sign1 : bits(1) = undefined : bits(1);
    type1 : FPType = undefined : FPType;
    value1_name : real = undefined : real;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    sign2 : bits(1) = undefined : bits(1);
    type2 : FPType = undefined : FPType;
    value2_name : real = undefined : real;
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    done : bool = undefined : bool;
    result : bits('N) = undefined : bits('N);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    inf1 : bool = undefined : bool;
    inf2 : bool = undefined : bool;
    result_sign : bits(1) = undefined : bits(1);
    result_value : real = undefined : real;
    zero1 : bool = undefined : bool;
    zero2 : bool = undefined : bool;
    if ~(done) then {
        inf1 = type1 == FPType_Infinity;
        inf2 = type2 == FPType_Infinity;
        zero1 = type1 == FPType_Zero;
        zero2 = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == ~(sign2) then {
            result = FPDefaultNaN();
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b0 then {
                result = FPInfinity(0b0)
            } else {
                if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b1 then {
                    result = FPInfinity(0b1)
                } else {
                    if (zero1 & zero2) & sign1 == sign2 then {
                        result = FPZero(sign1)
                    } else {
                        result_value = value1_name + value2_name;
                        if result_value == 0.0 then {
                            result_sign = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                            result = FPZero(result_sign)
                        } else {
                            result = FPRound(result_value, fpcr, rounding)
                        }
                    }
                }
            }
        }
    };
    result
}

val Reduce : forall 'N 'esize,
  'N >= 0 & ('esize >= 0 & 'esize >= 0).
  (ReduceOp, bits('N), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce (op, input, esize) = {
    half : int = undefined : int;
    hi : bits('esize) = undefined : bits('esize);
    lo : bits('esize) = undefined : bits('esize);
    result : bits('esize) = undefined : bits('esize);
    if 'N == esize then {
        return(slice(input, 0, esize))
    };
    let half = 'N / 2;
    let hi = Reduce(op, slice(input, half, negate(half) + 'N), esize);
    let lo = Reduce(op, slice(input, 0, half), esize);
    match op {
      ReduceOp_FMINNUM => {
          result = FPMinNum(lo, hi, FPCR)
      },
      ReduceOp_FMAXNUM => {
          result = FPMaxNum(lo, hi, FPCR)
      },
      ReduceOp_FMIN => {
          result = FPMin(lo, hi, FPCR)
      },
      ReduceOp_FMAX => {
          result = FPMax(lo, hi, FPCR)
      },
      ReduceOp_FADD => {
          result = FPAdd(lo, hi, FPCR)
      },
      ReduceOp_ADD => {
          result = lo + hi
      }
    };
    let result = result;
    result
}

val ExternalSecureDebugEnabled : unit -> bool effect {escape, rreg, undef}

function ExternalSecureDebugEnabled () = {
    if ~(HaveEL(EL3)) & ~(IsSecure()) then {
        return(false)
    };
    ExternalDebugEnabled() & SPIDEN == HIGH
}

val ExternalDebugInterruptsDisabled : bits(2) -> bool effect {escape, rreg, undef}

function ExternalDebugInterruptsDisabled target = {
    int_dis : bool = undefined : bool;
    match target {
      ? if ? == EL3 => {
          int_dis = slice(EDSCR, 22, 2) == 0b11 & ExternalSecureDebugEnabled()
      },
      ? if ? == EL2 => {
          int_dis = (slice(EDSCR, 22, 2) & 0b10) == 0b10 & ExternalDebugEnabled()
      },
      ? if ? == EL1 => {
          if IsSecure() then {
              int_dis = (slice(EDSCR, 22, 2) & 0b10) == 0b10 & ExternalSecureDebugEnabled()
          } else {
              int_dis = slice(EDSCR, 22, 2) != 0b00 & ExternalDebugEnabled()
          }
      }
    };
    int_dis
}

val ELStateUsingAArch32K : forall ('secure : Bool).
  (bits(2), bool('secure)) -> (bool, bool) effect {escape, rreg, undef}

function ELStateUsingAArch32K (el, secure) = {
    aarch32 : bool = undefined : bool;
    known : bool = undefined : bool;
    known = true;
    aarch32_at_el1 : bool = undefined : bool;
    aarch32_below_el3 : bool = undefined : bool;
    if ~(HaveAArch32EL(el)) then {
        aarch32 = false
    } else {
        if HighestELUsingAArch32() then {
            aarch32 = true
        } else {
            aarch32_below_el3 = HaveEL(EL3) & [SCR_EL3[10]] == 0b0;
            aarch32_at_el1 = aarch32_below_el3 | ((HaveEL(EL2) & (HaveSecureEL2Ext() & [SCR_EL3[18]] == 0b1 | ~(secure))) & [HCR_EL2[31]] == 0b0) & ~(([HCR_EL2[34]] == 0b1 & [HCR_EL2[27]] == 0b1) & HaveVirtHostExt());
            if el == EL0 & ~(aarch32_at_el1) then {
                if PSTATE.EL == EL0 then {
                    aarch32 = PSTATE.nRW == 0b1
                } else {
                    known = false
                }
            } else {
                aarch32 = aarch32_below_el3 & el != EL3 | aarch32_at_el1 & (el == EL1 | el == EL0)
            }
        }
    };
    if ~(known) then {
        aarch32 = undefined : bool
    };
    return((known, aarch32))
}

val ELUsingAArch32K : bits(2) -> (bool, bool) effect {escape, rreg, undef}

function ELUsingAArch32K el = {
    ELStateUsingAArch32K(el, IsSecureBelowEL3())
}

val ELStateUsingAArch32 : forall ('secure : Bool).
  (bits(2), bool('secure)) -> bool effect {escape, rreg, undef}

function ELStateUsingAArch32 (el, secure) = {
    aarch32 : bool = undefined : bool;
    known : bool = undefined : bool;
    (known, aarch32) = ELStateUsingAArch32K(el, secure);
    assert(known);
    aarch32
}

val ELUsingAArch32 : bits(2) -> bool effect {escape, rreg, undef}

function ELUsingAArch32 el = {
    ELStateUsingAArch32(el, IsSecureBelowEL3())
}

val set_VBAR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_VBAR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        VBAR_S = r
    } else {
        set_VBAR_NS(r)
    };
    return()
}

val set_TTBR1 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function set_TTBR1 val_name = {
    let r : bits(64) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBR1_S = r
    } else {
        set_TTBR1_NS(r)
    };
    return()
}

val set_TTBR0 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function set_TTBR0 val_name = {
    let r : bits(64) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBR0_S = r
    } else {
        set_TTBR0_NS(r)
    };
    return()
}

val set_TTBCR2 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_TTBCR2 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBCR2_S = r
    } else {
        set_TTBCR2_NS(r)
    };
    return()
}

val set_TTBCR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_TTBCR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBCR_S = r
    } else {
        set_TTBCR_NS(r)
    };
    return()
}

val set_SCTLR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_SCTLR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        SCTLR_S = r
    } else {
        set_SCTLR_NS(r)
    };
    return()
}

val set_PRRR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_PRRR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        PRRR_S = r
    } else {
        set_PRRR_NS(r)
    };
    return()
}

val set_PAR : bits(64) -> unit effect {escape, rreg, undef, wreg}

function set_PAR val_name = {
    let r : bits(64) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        PAR_S = r
    } else {
        set_PAR_NS(r)
    };
    return()
}

val set_NMRR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_NMRR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        NMRR_S = r
    } else {
        set_NMRR_NS(r)
    };
    return()
}

val set_IFSR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_IFSR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        IFSR_S = r
    } else {
        set_IFSR_NS(r)
    };
    return()
}

val set_IFAR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_IFAR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_IFAR_S(r)
    } else {
        set_IFAR_NS(r)
    };
    return()
}

val set_ICC_SRE_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_SRE_EL1_S = r
    } else {
        ICC_SRE_EL1_NS = r
    };
    return()
}

val set_ICC_IGRPEN1_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_IGRPEN1_EL1_S = r
    } else {
        ICC_IGRPEN1_EL1_NS = r
    };
    return()
}

val set_ICC_CTLR_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_CTLR_EL1_S = r
    } else {
        ICC_CTLR_EL1_NS = r
    };
    return()
}

val set_ICC_BPR1_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_BPR1_EL1_S = r
    } else {
        ICC_BPR1_EL1_NS = r
    };
    return()
}

val set_DFSR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_DFSR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        DFSR_S = r
    } else {
        set_DFSR_NS(r)
    };
    return()
}

val set_DFAR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_DFAR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_DFAR_S(r)
    } else {
        set_DFAR_NS(r)
    };
    return()
}

val set_CSSELR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_CSSELR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        CSSELR_S = r
    } else {
        set_CSSELR_NS(r)
    };
    return()
}

val set_CNTP_CTL : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_CNTP_CTL val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        CNTP_CTL_S = r
    } else {
        set_CNTP_CTL_NS(r)
    };
    return()
}

val get_VBAR : unit -> bits(32) effect {escape, rreg, undef}

function get_VBAR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = VBAR_S
    } else {
        r = get_VBAR_NS()
    };
    r
}

val get_TTBR1 : unit -> bits(64) effect {escape, rreg, undef}

function get_TTBR1 () = {
    r : bits(64) = undefined : bits(64);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = TTBR1_S
    } else {
        r = get_TTBR1_NS()
    };
    r
}

val get_TTBR0 : unit -> bits(64) effect {escape, rreg, undef}

function get_TTBR0 () = {
    r : bits(64) = undefined : bits(64);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = TTBR0_S
    } else {
        r = get_TTBR0_NS()
    };
    r
}

val get_TTBCR2 : unit -> bits(32) effect {escape, rreg, undef}

function get_TTBCR2 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = TTBCR2_S
    } else {
        r = get_TTBCR2_NS()
    };
    r
}

val get_TTBCR : unit -> bits(32) effect {escape, rreg, undef}

function get_TTBCR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = TTBCR_S
    } else {
        r = get_TTBCR_NS()
    };
    r
}

val get_CONTEXTIDR_NS : unit -> bits(32) effect {rreg, undef}

function get_CONTEXTIDR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CONTEXTIDR_EL1, 0, 32));
    r
}

register CONTEXTIDR_S : bits(32)

val AArch32_ReportDeferredSError : (bits(2), bits(1)) -> bits(32) effect {escape, rreg, undef}

function AArch32_ReportDeferredSError (AET, ExT) = {
    target : bits(32) = undefined : bits(32);
    target = __SetSlice_bits(32, 1, target, 31, 0b1);
    syndrome : bits(16) = undefined : bits(16);
    syndrome = Zeros(16);
    if PSTATE.EL == EL2 then {
        syndrome = __SetSlice_bits(16, 2, syndrome, 10, AET);
        syndrome = __SetSlice_bits(16, 1, syndrome, 9, ExT);
        syndrome = __SetSlice_bits(16, 6, syndrome, 0, 0b010001)
    } else {
        syndrome = __SetSlice_bits(16, 2, syndrome, 14, AET);
        syndrome = __SetSlice_bits(16, 1, syndrome, 12, ExT);
        syndrome = __SetSlice_bits(16, 1, syndrome, 9, [get_TTBCR()[31]]);
        if [get_TTBCR()[31]] == 0b1 then {
            syndrome = __SetSlice_bits(16, 6, syndrome, 0, 0b010001)
        } else {
            (syndrome[10 .. 10] @ syndrome[3 .. 0]) = 0b10110
        }
    };
    if HaveAnyAArch64() then {
        target = __SetSlice_bits(32, 25, target, 0, ZeroExtend(syndrome))
    } else {
        target = __SetSlice_bits(32, 16, target, 0, syndrome)
    };
    target
}

val get_SCTLR : unit -> bits(32) effect {escape, rreg, undef}

function get_SCTLR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = SCTLR_S
    } else {
        r = get_SCTLR_NS()
    };
    r
}

val RestoredITBits : bits(32) -> bits(8) effect {escape, rreg, undef}

function RestoredITBits spsr = {
    let it : bits(8) = spsr[10 .. 5] @ spsr[25 .. 24];
    if PSTATE.IL == 0b1 then {
        if ConstrainUnpredictableBool(Unpredictable_ILZEROIT) then {
            return(0x00)
        } else {
            return(it)
        }
    };
    if ~(IsZero(slice(it, 4, 4))) & IsZero(slice(it, 0, 4)) then {
        return(0x00)
    };
    let itd : vector(1, dec, bit) = if PSTATE.EL == EL2 then [get_HSCTLR()[7]] else [get_SCTLR()[7]];
    if [spsr[5]] == 0b0 & ~(IsZero(it)) | itd == 0b1 & ~(IsZero(slice(it, 0, 3))) then {
        return(0x00)
    } else {
        return(it)
    }
}

val ExcVectorBase : unit -> bits(32) effect {escape, rreg, undef}

function ExcVectorBase () = {
    if [get_SCTLR()[13]] == 0b1 then {
        return(Ones(16) @ Zeros(16))
    } else {
        return(slice(get_VBAR(), 5, 27) @ Zeros(5))
    }
}

val get_PRRR : unit -> bits(32) effect {escape, rreg, undef}

function get_PRRR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = PRRR_S
    } else {
        r = get_PRRR_NS()
    };
    r
}

val get_PAR : unit -> bits(64) effect {escape, rreg, undef}

function get_PAR () = {
    r : bits(64) = undefined : bits(64);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = PAR_S
    } else {
        r = get_PAR_NS()
    };
    r
}

val get_NMRR : unit -> bits(32) effect {escape, rreg, undef}

function get_NMRR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = NMRR_S
    } else {
        r = get_NMRR_NS()
    };
    r
}

val AArch32_IMPDEFResets : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_IMPDEFResets () = {
    set_PMCEID0(0x7FFF0F3F);
    __tc1 : bits(32) = get_PMCR();
    let __tc1 = __SetSlice_bits(32, 8, __tc1, 24, 0x41);
    set_PMCR(__tc1);
    __tc2 : bits(32) = get_PMCR();
    let __tc2 = __SetSlice_bits(32, 8, __tc2, 16, 0x01);
    set_PMCR(__tc2);
    __tc3 : bits(32) = get_PMCR();
    let __tc3 = __SetSlice_bits(32, 5, __tc3, 11, 0b00110);
    set_PMCR(__tc3);
    __tc4 : bits(32) = get_PMCR();
    let __tc4 = __SetSlice_bits(32, 1, __tc4, 2, 0b0);
    set_PMCR(__tc4);
    __tc5 : bits(32) = get_PMCR();
    let __tc5 = __SetSlice_bits(32, 1, __tc5, 1, 0b0);
    set_PMCR(__tc5);
    __tc6 : bits(32) = get_CCSIDR();
    let __tc6 = __SetSlice_bits(32, 15, __tc6, 13, 0b000000011111111);
    set_CCSIDR(__tc6);
    __tc7 : bits(32) = get_CCSIDR();
    let __tc7 = __SetSlice_bits(32, 21, __tc7, 3, ZeroExtend(0b1));
    set_CCSIDR(__tc7);
    __tc8 : bits(32) = get_CCSIDR();
    let __tc8 = __SetSlice_bits(32, 3, __tc8, 0, 0b010);
    set_CCSIDR(__tc8);
    __tc9 : bits(32) = get_CCSIDR();
    let __tc9 = __SetSlice_bits(32, 21, __tc9, 3, 0b111111110000000001010);
    set_CCSIDR(__tc9);
    __tc10 : bits(32) = get_CCSIDR();
    let __tc10 = __SetSlice_bits(32, 3, __tc10, 0, 0b010);
    set_CCSIDR(__tc10);
    __tc11 : bits(32) = get_CLIDR();
    let __tc11 = __SetSlice_bits(32, 2, __tc11, 30, 0b00);
    set_CLIDR(__tc11);
    __tc12 : bits(32) = get_CLIDR();
    let __tc12 = __SetSlice_bits(32, 3, __tc12, 27, 0b001);
    set_CLIDR(__tc12);
    __tc13 : bits(32) = get_CLIDR();
    let __tc13 = __SetSlice_bits(32, 3, __tc13, 24, 0b010);
    set_CLIDR(__tc13);
    __tc14 : bits(32) = get_CLIDR();
    let __tc14 = __SetSlice_bits(32, 3, __tc14, 21, 0b001);
    set_CLIDR(__tc14);
    __tc15 : bits(32) = get_CLIDR();
    let __tc15 = __SetSlice_bits(32, 21, __tc15, 0, 0b000000000000000100011);
    set_CLIDR(__tc15);
    __tc16 : bits(32) = get_CTR();
    let __tc16 = __SetSlice_bits(32, 1, __tc16, 29, 0b0);
    set_CTR(__tc16);
    __tc17 : bits(32) = get_CTR();
    let __tc17 = __SetSlice_bits(32, 1, __tc17, 28, 0b0);
    set_CTR(__tc17);
    __tc18 : bits(32) = get_CTR();
    let __tc18 = __SetSlice_bits(32, 4, __tc18, 24, 0x4);
    set_CTR(__tc18);
    __tc19 : bits(32) = get_CTR();
    let __tc19 = __SetSlice_bits(32, 4, __tc19, 20, 0x4);
    set_CTR(__tc19);
    __tc20 : bits(32) = get_CTR();
    let __tc20 = __SetSlice_bits(32, 4, __tc20, 16, 0x4);
    set_CTR(__tc20);
    __tc21 : bits(32) = get_CTR();
    let __tc21 = __SetSlice_bits(32, 2, __tc21, 14, 0b11);
    set_CTR(__tc21);
    __tc22 : bits(32) = get_CTR();
    let __tc22 = __SetSlice_bits(32, 4, __tc22, 0, 0x4);
    set_CTR(__tc22);
    FPSID = __SetSlice_bits(32, 8, FPSID, 24, 0x41);
    FPSID = __SetSlice_bits(32, 1, FPSID, 23, 0b0);
    FPSID = __SetSlice_bits(32, 7, FPSID, 16, 0b0000100);
    FPSID = __SetSlice_bits(32, 8, FPSID, 8, 0x30);
    FPSID = __SetSlice_bits(32, 4, FPSID, 4, 0x7);
    FPSID = __SetSlice_bits(32, 4, FPSID, 0, 0x0);
    __tc23 : bits(32) = get_ID_DFR0();
    let __tc23 = __SetSlice_bits(32, 4, __tc23, 24, 0x3);
    set_ID_DFR0(__tc23);
    __tc24 : bits(32) = get_ID_DFR0();
    let __tc24 = __SetSlice_bits(32, 4, __tc24, 20, 0x0);
    set_ID_DFR0(__tc24);
    __tc25 : bits(32) = get_ID_DFR0();
    let __tc25 = __SetSlice_bits(32, 4, __tc25, 16, 0x1);
    set_ID_DFR0(__tc25);
    __tc26 : bits(32) = get_ID_DFR0();
    let __tc26 = __SetSlice_bits(32, 4, __tc26, 12, 0x0);
    set_ID_DFR0(__tc26);
    __tc27 : bits(32) = get_ID_DFR0();
    let __tc27 = __SetSlice_bits(32, 4, __tc27, 8, 0x0);
    set_ID_DFR0(__tc27);
    __tc28 : bits(32) = get_ID_DFR0();
    let __tc28 = __SetSlice_bits(32, 4, __tc28, 4, 0x6);
    set_ID_DFR0(__tc28);
    __tc29 : bits(32) = get_ID_DFR0();
    let __tc29 = __SetSlice_bits(32, 4, __tc29, 0, 0x6);
    set_ID_DFR0(__tc29);
    __tc30 : bits(32) = get_ID_ISAR0();
    let __tc30 = __SetSlice_bits(32, 4, __tc30, 24, 0x2);
    set_ID_ISAR0(__tc30);
    __tc31 : bits(32) = get_ID_ISAR0();
    let __tc31 = __SetSlice_bits(32, 4, __tc31, 20, 0x1);
    set_ID_ISAR0(__tc31);
    __tc32 : bits(32) = get_ID_ISAR0();
    let __tc32 = __SetSlice_bits(32, 4, __tc32, 16, 0x0);
    set_ID_ISAR0(__tc32);
    __tc33 : bits(32) = get_ID_ISAR0();
    let __tc33 = __SetSlice_bits(32, 4, __tc33, 12, 0x1);
    set_ID_ISAR0(__tc33);
    __tc34 : bits(32) = get_ID_ISAR0();
    let __tc34 = __SetSlice_bits(32, 4, __tc34, 8, 0x1);
    set_ID_ISAR0(__tc34);
    __tc35 : bits(32) = get_ID_ISAR0();
    let __tc35 = __SetSlice_bits(32, 4, __tc35, 4, 0x1);
    set_ID_ISAR0(__tc35);
    __tc36 : bits(32) = get_ID_ISAR0();
    let __tc36 = __SetSlice_bits(32, 4, __tc36, 0, 0x0);
    set_ID_ISAR0(__tc36);
    __tc37 : bits(32) = get_ID_ISAR1();
    let __tc37 = __SetSlice_bits(32, 4, __tc37, 28, 0x1);
    set_ID_ISAR1(__tc37);
    __tc38 : bits(32) = get_ID_ISAR1();
    let __tc38 = __SetSlice_bits(32, 4, __tc38, 24, 0x3);
    set_ID_ISAR1(__tc38);
    __tc39 : bits(32) = get_ID_ISAR1();
    let __tc39 = __SetSlice_bits(32, 4, __tc39, 20, 0x1);
    set_ID_ISAR1(__tc39);
    __tc40 : bits(32) = get_ID_ISAR1();
    let __tc40 = __SetSlice_bits(32, 4, __tc40, 16, 0x1);
    set_ID_ISAR1(__tc40);
    __tc41 : bits(32) = get_ID_ISAR1();
    let __tc41 = __SetSlice_bits(32, 4, __tc41, 12, 0x2);
    set_ID_ISAR1(__tc41);
    __tc42 : bits(32) = get_ID_ISAR1();
    let __tc42 = __SetSlice_bits(32, 4, __tc42, 8, 0x1);
    set_ID_ISAR1(__tc42);
    __tc43 : bits(32) = get_ID_ISAR1();
    let __tc43 = __SetSlice_bits(32, 4, __tc43, 4, 0x1);
    set_ID_ISAR1(__tc43);
    __tc44 : bits(32) = get_ID_ISAR1();
    let __tc44 = __SetSlice_bits(32, 4, __tc44, 0, 0x1);
    set_ID_ISAR1(__tc44);
    __tc45 : bits(32) = get_ID_ISAR2();
    let __tc45 = __SetSlice_bits(32, 4, __tc45, 28, 0x2);
    set_ID_ISAR2(__tc45);
    __tc46 : bits(32) = get_ID_ISAR2();
    let __tc46 = __SetSlice_bits(32, 4, __tc46, 24, 0x1);
    set_ID_ISAR2(__tc46);
    __tc47 : bits(32) = get_ID_ISAR2();
    let __tc47 = __SetSlice_bits(32, 4, __tc47, 20, 0x2);
    set_ID_ISAR2(__tc47);
    __tc48 : bits(32) = get_ID_ISAR2();
    let __tc48 = __SetSlice_bits(32, 4, __tc48, 16, 0x3);
    set_ID_ISAR2(__tc48);
    __tc49 : bits(32) = get_ID_ISAR2();
    let __tc49 = __SetSlice_bits(32, 4, __tc49, 12, 0x2);
    set_ID_ISAR2(__tc49);
    __tc50 : bits(32) = get_ID_ISAR2();
    let __tc50 = __SetSlice_bits(32, 4, __tc50, 8, 0x0);
    set_ID_ISAR2(__tc50);
    __tc51 : bits(32) = get_ID_ISAR2();
    let __tc51 = __SetSlice_bits(32, 4, __tc51, 4, 0x4);
    set_ID_ISAR2(__tc51);
    __tc52 : bits(32) = get_ID_ISAR2();
    let __tc52 = __SetSlice_bits(32, 4, __tc52, 0, 0x2);
    set_ID_ISAR2(__tc52);
    __tc53 : bits(32) = get_ID_ISAR3();
    let __tc53 = __SetSlice_bits(32, 4, __tc53, 28, 0x0);
    set_ID_ISAR3(__tc53);
    __tc54 : bits(32) = get_ID_ISAR3();
    let __tc54 = __SetSlice_bits(32, 4, __tc54, 24, 0x1);
    set_ID_ISAR3(__tc54);
    __tc55 : bits(32) = get_ID_ISAR3();
    let __tc55 = __SetSlice_bits(32, 4, __tc55, 20, 0x1);
    set_ID_ISAR3(__tc55);
    __tc56 : bits(32) = get_ID_ISAR3();
    let __tc56 = __SetSlice_bits(32, 4, __tc56, 16, 0x1);
    set_ID_ISAR3(__tc56);
    __tc57 : bits(32) = get_ID_ISAR3();
    let __tc57 = __SetSlice_bits(32, 4, __tc57, 12, 0x2);
    set_ID_ISAR3(__tc57);
    __tc58 : bits(32) = get_ID_ISAR3();
    let __tc58 = __SetSlice_bits(32, 4, __tc58, 8, 0x1);
    set_ID_ISAR3(__tc58);
    __tc59 : bits(32) = get_ID_ISAR3();
    let __tc59 = __SetSlice_bits(32, 4, __tc59, 4, 0x3);
    set_ID_ISAR3(__tc59);
    __tc60 : bits(32) = get_ID_ISAR3();
    let __tc60 = __SetSlice_bits(32, 4, __tc60, 0, 0x1);
    set_ID_ISAR3(__tc60);
    __tc61 : bits(32) = get_ID_ISAR4();
    let __tc61 = __SetSlice_bits(32, 4, __tc61, 28, 0x0);
    set_ID_ISAR4(__tc61);
    __tc62 : bits(32) = get_ID_ISAR4();
    let __tc62 = __SetSlice_bits(32, 4, __tc62, 24, 0x0);
    set_ID_ISAR4(__tc62);
    __tc63 : bits(32) = get_ID_ISAR4();
    let __tc63 = __SetSlice_bits(32, 4, __tc63, 20, 0x0);
    set_ID_ISAR4(__tc63);
    __tc64 : bits(32) = get_ID_ISAR4();
    let __tc64 = __SetSlice_bits(32, 4, __tc64, 16, 0x1);
    set_ID_ISAR4(__tc64);
    __tc65 : bits(32) = get_ID_ISAR4();
    let __tc65 = __SetSlice_bits(32, 4, __tc65, 12, 0x1);
    set_ID_ISAR4(__tc65);
    __tc66 : bits(32) = get_ID_ISAR4();
    let __tc66 = __SetSlice_bits(32, 4, __tc66, 8, 0x1);
    set_ID_ISAR4(__tc66);
    __tc67 : bits(32) = get_ID_ISAR4();
    let __tc67 = __SetSlice_bits(32, 4, __tc67, 4, 0x4);
    set_ID_ISAR4(__tc67);
    __tc68 : bits(32) = get_ID_ISAR4();
    let __tc68 = __SetSlice_bits(32, 4, __tc68, 0, 0x2);
    set_ID_ISAR4(__tc68);
    __tc69 : bits(32) = get_ID_ISAR5();
    let __tc69 = __SetSlice_bits(32, 4, __tc69, 28, 0x1);
    set_ID_ISAR5(__tc69);
    __tc70 : bits(32) = get_ID_ISAR5();
    let __tc70 = __SetSlice_bits(32, 4, __tc70, 24, 0x1);
    set_ID_ISAR5(__tc70);
    __tc71 : bits(32) = get_ID_ISAR5();
    let __tc71 = __SetSlice_bits(32, 4, __tc71, 16, 0x0);
    set_ID_ISAR5(__tc71);
    __tc72 : bits(32) = get_ID_ISAR5();
    let __tc72 = __SetSlice_bits(32, 4, __tc72, 12, 0x1);
    set_ID_ISAR5(__tc72);
    __tc73 : bits(32) = get_ID_ISAR5();
    let __tc73 = __SetSlice_bits(32, 4, __tc73, 8, 0x1);
    set_ID_ISAR5(__tc73);
    __tc74 : bits(32) = get_ID_ISAR5();
    let __tc74 = __SetSlice_bits(32, 4, __tc74, 4, 0x2);
    set_ID_ISAR5(__tc74);
    __tc75 : bits(32) = get_ID_ISAR5();
    let __tc75 = __SetSlice_bits(32, 4, __tc75, 0, 0x1);
    set_ID_ISAR5(__tc75);
    __tc76 : bits(32) = get_ID_ISAR6();
    let __tc76 = __SetSlice_bits(32, 4, __tc76, 4, 0x1);
    set_ID_ISAR6(__tc76);
    if __fp16_implemented then {
        __tc77 : bits(32) = get_MVFR1();
        __tc77 = __SetSlice_bits(32, 4, __tc77, 24, 0x3);
        set_MVFR1(__tc77);
        __tc78 : bits(32) = get_MVFR1();
        __tc78 = __SetSlice_bits(32, 4, __tc78, 20, 0x2);
        set_MVFR1(__tc78)
    } else {
        __tc79 : bits(32) = get_MVFR1();
        __tc79 = __SetSlice_bits(32, 4, __tc79, 24, 0x2);
        set_MVFR1(__tc79);
        __tc80 : bits(32) = get_MVFR1();
        __tc80 = __SetSlice_bits(32, 4, __tc80, 20, 0x1);
        set_MVFR1(__tc80)
    };
    if HasArchVersion(ARMv8p3) then {
        __tc81 : bits(32) = get_ID_MMFR4();
        __tc81 = __SetSlice_bits(32, 4, __tc81, 24, 0x1);
        set_ID_MMFR4(__tc81);
        __tc82 : bits(32) = get_ID_ISAR6();
        __tc82 = __SetSlice_bits(32, 4, __tc82, 0, 0x1);
        set_ID_ISAR6(__tc82)
    };
    if HasArchVersion(ARMv8p4) then {
        EDPFR = __SetSlice_bits(64, 4, EDPFR, 36, 0x1);
        __tc83 : bits(32) = get_ID_ISAR6();
        __tc83 = __SetSlice_bits(32, 4, __tc83, 8, 0x1);
        set_ID_ISAR6(__tc83)
    };
    __tc84 : bits(32) = get_ID_MMFR0();
    let __tc84 = __SetSlice_bits(32, 4, __tc84, 28, 0x1);
    set_ID_MMFR0(__tc84);
    __tc85 : bits(32) = get_ID_MMFR0();
    let __tc85 = __SetSlice_bits(32, 4, __tc85, 24, 0x0);
    set_ID_MMFR0(__tc85);
    __tc86 : bits(32) = get_ID_MMFR0();
    let __tc86 = __SetSlice_bits(32, 4, __tc86, 20, 0x1);
    set_ID_MMFR0(__tc86);
    __tc87 : bits(32) = get_ID_MMFR0();
    let __tc87 = __SetSlice_bits(32, 4, __tc87, 16, 0x0);
    set_ID_MMFR0(__tc87);
    __tc88 : bits(32) = get_ID_MMFR0();
    let __tc88 = __SetSlice_bits(32, 4, __tc88, 12, 0x1);
    set_ID_MMFR0(__tc88);
    __tc89 : bits(32) = get_ID_MMFR0();
    let __tc89 = __SetSlice_bits(32, 4, __tc89, 8, 0x1);
    set_ID_MMFR0(__tc89);
    __tc90 : bits(32) = get_ID_MMFR0();
    let __tc90 = __SetSlice_bits(32, 4, __tc90, 4, 0x0);
    set_ID_MMFR0(__tc90);
    __tc91 : bits(32) = get_ID_MMFR0();
    let __tc91 = __SetSlice_bits(32, 4, __tc91, 0, 0x5);
    set_ID_MMFR0(__tc91);
    __tc92 : bits(32) = get_ID_MMFR1();
    let __tc92 = __SetSlice_bits(32, 4, __tc92, 28, 0x4);
    set_ID_MMFR1(__tc92);
    __tc93 : bits(32) = get_ID_MMFR1();
    let __tc93 = __SetSlice_bits(32, 4, __tc93, 24, 0x0);
    set_ID_MMFR1(__tc93);
    __tc94 : bits(32) = get_ID_MMFR1();
    let __tc94 = __SetSlice_bits(32, 4, __tc94, 20, 0x0);
    set_ID_MMFR1(__tc94);
    __tc95 : bits(32) = get_ID_MMFR1();
    let __tc95 = __SetSlice_bits(32, 4, __tc95, 16, 0x0);
    set_ID_MMFR1(__tc95);
    __tc96 : bits(32) = get_ID_MMFR1();
    let __tc96 = __SetSlice_bits(32, 4, __tc96, 12, 0x0);
    set_ID_MMFR1(__tc96);
    __tc97 : bits(32) = get_ID_MMFR1();
    let __tc97 = __SetSlice_bits(32, 4, __tc97, 8, 0x0);
    set_ID_MMFR1(__tc97);
    __tc98 : bits(32) = get_ID_MMFR1();
    let __tc98 = __SetSlice_bits(32, 4, __tc98, 4, 0x0);
    set_ID_MMFR1(__tc98);
    __tc99 : bits(32) = get_ID_MMFR1();
    let __tc99 = __SetSlice_bits(32, 4, __tc99, 0, 0x0);
    set_ID_MMFR1(__tc99);
    __tc100 : bits(32) = get_ID_MMFR2();
    let __tc100 = __SetSlice_bits(32, 4, __tc100, 28, 0x0);
    set_ID_MMFR2(__tc100);
    __tc101 : bits(32) = get_ID_MMFR2();
    let __tc101 = __SetSlice_bits(32, 4, __tc101, 24, 0x1);
    set_ID_MMFR2(__tc101);
    __tc102 : bits(32) = get_ID_MMFR2();
    let __tc102 = __SetSlice_bits(32, 4, __tc102, 20, 0x2);
    set_ID_MMFR2(__tc102);
    __tc103 : bits(32) = get_ID_MMFR2();
    let __tc103 = __SetSlice_bits(32, 4, __tc103, 16, 0x6);
    set_ID_MMFR2(__tc103);
    __tc104 : bits(32) = get_ID_MMFR2();
    let __tc104 = __SetSlice_bits(32, 4, __tc104, 12, 0x0);
    set_ID_MMFR2(__tc104);
    __tc105 : bits(32) = get_ID_MMFR2();
    let __tc105 = __SetSlice_bits(32, 4, __tc105, 8, 0x0);
    set_ID_MMFR2(__tc105);
    __tc106 : bits(32) = get_ID_MMFR2();
    let __tc106 = __SetSlice_bits(32, 4, __tc106, 4, 0x0);
    set_ID_MMFR2(__tc106);
    __tc107 : bits(32) = get_ID_MMFR2();
    let __tc107 = __SetSlice_bits(32, 4, __tc107, 0, 0x0);
    set_ID_MMFR2(__tc107);
    __tc108 : bits(32) = get_ID_MMFR3();
    let __tc108 = __SetSlice_bits(32, 4, __tc108, 28, 0x0);
    set_ID_MMFR3(__tc108);
    __tc109 : bits(32) = get_ID_MMFR3();
    let __tc109 = __SetSlice_bits(32, 4, __tc109, 24, 0x2);
    set_ID_MMFR3(__tc109);
    __tc110 : bits(32) = get_ID_MMFR3();
    let __tc110 = __SetSlice_bits(32, 4, __tc110, 20, 0x1);
    set_ID_MMFR3(__tc110);
    __tc111 : bits(32) = get_ID_MMFR3();
    let __tc111 = __SetSlice_bits(32, 4, __tc111, 16, 0x1);
    set_ID_MMFR3(__tc111);
    __tc112 : bits(32) = get_ID_MMFR3();
    let __tc112 = __SetSlice_bits(32, 4, __tc112, 12, 0x2);
    set_ID_MMFR3(__tc112);
    __tc113 : bits(32) = get_ID_MMFR3();
    let __tc113 = __SetSlice_bits(32, 4, __tc113, 8, 0x2);
    set_ID_MMFR3(__tc113);
    __tc114 : bits(32) = get_ID_MMFR3();
    let __tc114 = __SetSlice_bits(32, 4, __tc114, 4, 0x1);
    set_ID_MMFR3(__tc114);
    __tc115 : bits(32) = get_ID_MMFR3();
    let __tc115 = __SetSlice_bits(32, 4, __tc115, 0, 0x1);
    set_ID_MMFR3(__tc115);
    __tc116 : bits(32) = get_ID_PFR0();
    let __tc116 = __SetSlice_bits(32, 4, __tc116, 28, 0x0);
    set_ID_PFR0(__tc116);
    __tc117 : bits(32) = get_ID_PFR0();
    let __tc117 = __SetSlice_bits(32, 4, __tc117, 12, 0x0);
    set_ID_PFR0(__tc117);
    __tc118 : bits(32) = get_ID_PFR0();
    let __tc118 = __SetSlice_bits(32, 4, __tc118, 8, 0x1);
    set_ID_PFR0(__tc118);
    __tc119 : bits(32) = get_ID_PFR0();
    let __tc119 = __SetSlice_bits(32, 4, __tc119, 4, 0x3);
    set_ID_PFR0(__tc119);
    __tc120 : bits(32) = get_ID_PFR0();
    let __tc120 = __SetSlice_bits(32, 4, __tc120, 0, 0x1);
    set_ID_PFR0(__tc120);
    __tc121 : bits(32) = get_ID_PFR1();
    let __tc121 = __SetSlice_bits(32, 4, __tc121, 28, 0x0);
    set_ID_PFR1(__tc121);
    __tc122 : bits(32) = get_ID_PFR1();
    let __tc122 = __SetSlice_bits(32, 4, __tc122, 24, 0x0);
    set_ID_PFR1(__tc122);
    __tc123 : bits(32) = get_ID_PFR1();
    let __tc123 = __SetSlice_bits(32, 4, __tc123, 20, 0x0);
    set_ID_PFR1(__tc123);
    __tc124 : bits(32) = get_ID_PFR1();
    let __tc124 = __SetSlice_bits(32, 4, __tc124, 16, 0x1);
    set_ID_PFR1(__tc124);
    __tc125 : bits(32) = get_ID_PFR1();
    let __tc125 = __SetSlice_bits(32, 4, __tc125, 12, 0x1);
    set_ID_PFR1(__tc125);
    __tc126 : bits(32) = get_ID_PFR1();
    let __tc126 = __SetSlice_bits(32, 4, __tc126, 8, 0x0);
    set_ID_PFR1(__tc126);
    __tc127 : bits(32) = get_ID_PFR1();
    let __tc127 = __SetSlice_bits(32, 4, __tc127, 4, 0x1);
    set_ID_PFR1(__tc127);
    __tc128 : bits(32) = get_ID_PFR1();
    let __tc128 = __SetSlice_bits(32, 4, __tc128, 0, 0x1);
    set_ID_PFR1(__tc128);
    __tc129 : bits(32) = get_MIDR();
    let __tc129 = __SetSlice_bits(32, 8, __tc129, 24, 0x41);
    set_MIDR(__tc129);
    __tc130 : bits(32) = get_MIDR();
    let __tc130 = __SetSlice_bits(32, 4, __tc130, 20, 0x0);
    set_MIDR(__tc130);
    __tc131 : bits(32) = get_MIDR();
    let __tc131 = __SetSlice_bits(32, 4, __tc131, 16, 0xF);
    set_MIDR(__tc131);
    __tc132 : bits(32) = get_MIDR();
    let __tc132 = __SetSlice_bits(32, 12, __tc132, 4, 0xD0F);
    set_MIDR(__tc132);
    __tc133 : bits(32) = get_MIDR();
    let __tc133 = __SetSlice_bits(32, 4, __tc133, 0, 0x0);
    set_MIDR(__tc133);
    __tc134 : bits(32) = get_MPIDR();
    let __tc134 = __SetSlice_bits(32, 1, __tc134, 31, 0b1);
    set_MPIDR(__tc134);
    __tc135 : bits(32) = get_MPIDR();
    let __tc135 = __SetSlice_bits(32, 1, __tc135, 30, 0b0);
    set_MPIDR(__tc135);
    __tc136 : bits(32) = get_MPIDR();
    let __tc136 = __SetSlice_bits(32, 1, __tc136, 24, 0b0);
    set_MPIDR(__tc136);
    __tc137 : bits(32) = get_MPIDR();
    let __tc137 = __SetSlice_bits(32, 8, __tc137, 16, 0x00);
    set_MPIDR(__tc137);
    __tc138 : bits(32) = get_MPIDR();
    let __tc138 = __SetSlice_bits(32, 8, __tc138, 8, 0x00);
    set_MPIDR(__tc138);
    __tc139 : bits(32) = get_MPIDR();
    let __tc139 = __SetSlice_bits(32, 8, __tc139, 0, 0x00);
    set_MPIDR(__tc139);
    __tc140 : bits(32) = get_MVFR0();
    let __tc140 = __SetSlice_bits(32, 4, __tc140, 28, 0x1);
    set_MVFR0(__tc140);
    __tc141 : bits(32) = get_MVFR0();
    let __tc141 = __SetSlice_bits(32, 4, __tc141, 24, 0x0);
    set_MVFR0(__tc141);
    __tc142 : bits(32) = get_MVFR0();
    let __tc142 = __SetSlice_bits(32, 4, __tc142, 20, 0x1);
    set_MVFR0(__tc142);
    __tc143 : bits(32) = get_MVFR0();
    let __tc143 = __SetSlice_bits(32, 4, __tc143, 16, 0x1);
    set_MVFR0(__tc143);
    __tc144 : bits(32) = get_MVFR0();
    let __tc144 = __SetSlice_bits(32, 4, __tc144, 12, 0x1);
    set_MVFR0(__tc144);
    __tc145 : bits(32) = get_MVFR0();
    let __tc145 = __SetSlice_bits(32, 4, __tc145, 8, 0x2);
    set_MVFR0(__tc145);
    __tc146 : bits(32) = get_MVFR0();
    let __tc146 = __SetSlice_bits(32, 4, __tc146, 4, 0x2);
    set_MVFR0(__tc146);
    __tc147 : bits(32) = get_MVFR0();
    let __tc147 = __SetSlice_bits(32, 4, __tc147, 0, 0x2);
    set_MVFR0(__tc147);
    __tc148 : bits(32) = get_MVFR1();
    let __tc148 = __SetSlice_bits(32, 4, __tc148, 28, 0x1);
    set_MVFR1(__tc148);
    __tc149 : bits(32) = get_MVFR1();
    let __tc149 = __SetSlice_bits(32, 4, __tc149, 16, 0x1);
    set_MVFR1(__tc149);
    __tc150 : bits(32) = get_MVFR1();
    let __tc150 = __SetSlice_bits(32, 4, __tc150, 12, 0x1);
    set_MVFR1(__tc150);
    __tc151 : bits(32) = get_MVFR1();
    let __tc151 = __SetSlice_bits(32, 4, __tc151, 8, 0x1);
    set_MVFR1(__tc151);
    __tc152 : bits(32) = get_MVFR1();
    let __tc152 = __SetSlice_bits(32, 4, __tc152, 4, 0x1);
    set_MVFR1(__tc152);
    __tc153 : bits(32) = get_MVFR1();
    let __tc153 = __SetSlice_bits(32, 4, __tc153, 0, 0x1);
    set_MVFR1(__tc153);
    __tc154 : bits(32) = get_MVFR2();
    let __tc154 = __SetSlice_bits(32, 4, __tc154, 4, 0x4);
    set_MVFR2(__tc154);
    __tc155 : bits(32) = get_MVFR2();
    let __tc155 = __SetSlice_bits(32, 4, __tc155, 0, 0x3);
    set_MVFR2(__tc155);
    TLBTR = __SetSlice_bits(32, 1, TLBTR, 0, 0b0);
    __tc156 : bits(32) = get_HSCTLR();
    let __tc156 = __SetSlice_bits(32, 1, __tc156, 25, 0b0);
    set_HSCTLR(__tc156);
    __tc157 : bits(32) = get_SCTLR();
    let __tc157 = __SetSlice_bits(32, 1, __tc157, 30, 0b0);
    set_SCTLR(__tc157);
    __tc158 : bits(32) = get_SCTLR();
    let __tc158 = __SetSlice_bits(32, 1, __tc158, 25, 0b0);
    set_SCTLR(__tc158);
    __tc159 : bits(32) = get_SCTLR();
    let __tc159 = __SetSlice_bits(32, 1, __tc159, 23, 0b0);
    set_SCTLR(__tc159);
    __tc160 : bits(32) = get_SCTLR();
    let __tc160 = __SetSlice_bits(32, 1, __tc160, 13, 0b0);
    set_SCTLR(__tc160);
    __tc161 : bits(32) = get_SCTLR();
    let __tc161 = __SetSlice_bits(32, 1, __tc161, 6, 0b0);
    set_SCTLR(__tc161);
    __tc162 : bits(32) = get_FPEXC();
    let __tc162 = __SetSlice_bits(32, 1, __tc162, 31, 0b0);
    set_FPEXC(__tc162);
    __tc163 : bits(32) = get_FPEXC();
    let __tc163 = __SetSlice_bits(32, 1, __tc163, 28, 0b0);
    set_FPEXC(__tc163);
    __tc164 : bits(32) = get_FPEXC();
    let __tc164 = __SetSlice_bits(32, 1, __tc164, 27, 0b0);
    set_FPEXC(__tc164);
    __tc165 : bits(32) = get_FPEXC();
    let __tc165 = __SetSlice_bits(32, 1, __tc165, 26, 0b0);
    set_FPEXC(__tc165);
    __tc166 : bits(32) = get_FPEXC();
    let __tc166 = __SetSlice_bits(32, 3, __tc166, 8, 0b111);
    set_FPEXC(__tc166);
    __tc167 : bits(32) = get_HTCR();
    let __tc167 = __SetSlice_bits(32, 1, __tc167, 28, 0b0);
    set_HTCR(__tc167);
    __tc168 : bits(32) = get_HTCR();
    let __tc168 = __SetSlice_bits(32, 1, __tc168, 27, 0b0);
    set_HTCR(__tc168);
    __tc169 : bits(32) = get_HTCR();
    let __tc169 = __SetSlice_bits(32, 1, __tc169, 26, 0b0);
    set_HTCR(__tc169);
    __tc170 : bits(32) = get_HTCR();
    let __tc170 = __SetSlice_bits(32, 1, __tc170, 25, 0b0);
    set_HTCR(__tc170);
    __tc171 : bits(32) = get_HTCR();
    let __tc171 = __SetSlice_bits(32, 1, __tc171, 24, 0b0);
    set_HTCR(__tc171);
    __tc172 : bits(32) = get_HTCR();
    let __tc172 = __SetSlice_bits(32, 2, __tc172, 12, 0b00);
    set_HTCR(__tc172);
    __tc173 : bits(32) = get_HTCR();
    let __tc173 = __SetSlice_bits(32, 2, __tc173, 10, 0b00);
    set_HTCR(__tc173);
    __tc174 : bits(32) = get_HTCR();
    let __tc174 = __SetSlice_bits(32, 2, __tc174, 8, 0b00);
    set_HTCR(__tc174);
    __tc175 : bits(32) = get_HTCR();
    let __tc175 = __SetSlice_bits(32, 3, __tc175, 0, 0b000);
    set_HTCR(__tc175);
    __tc176 : bits(32) = get_NMRR();
    let __tc176 = __SetSlice_bits(32, 16, __tc176, 16, 0x44E0);
    set_NMRR(__tc176);
    __tc177 : bits(32) = get_NMRR();
    let __tc177 = __SetSlice_bits(32, 16, __tc177, 0, 0x48E0);
    set_NMRR(__tc177);
    NSACR = __SetSlice_bits(32, 1, NSACR, 11, 0b0);
    NSACR = __SetSlice_bits(32, 1, NSACR, 10, 0b0);
    __tc178 : bits(32) = get_PRRR();
    let __tc178 = __SetSlice_bits(32, 8, __tc178, 24, Zeros());
    set_PRRR(__tc178);
    __tc179 : bits(32) = get_PRRR();
    let __tc179 = __SetSlice_bits(32, 1, __tc179, 19, 0b1);
    set_PRRR(__tc179);
    __tc180 : bits(32) = get_PRRR();
    let __tc180 = __SetSlice_bits(32, 1, __tc180, 18, 0b0);
    set_PRRR(__tc180);
    __tc181 : bits(32) = get_PRRR();
    let __tc181 = __SetSlice_bits(32, 1, __tc181, 17, 0b0);
    set_PRRR(__tc181);
    __tc182 : bits(32) = get_PRRR();
    let __tc182 = __SetSlice_bits(32, 1, __tc182, 16, 0b1);
    set_PRRR(__tc182);
    __tc183 : bits(32) = get_PRRR();
    let __tc183 = __SetSlice_bits(32, 16, __tc183, 0, 0x8AA4);
    set_PRRR(__tc183);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 28, 0x1);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 24, 0x1);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 20, 0x1);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 16, 0x6);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 14, 0b0);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 12, 0b1);
    __tc184 : bits(32) = get_ICC_MSRE();
    let __tc184 = __SetSlice_bits(32, 1, __tc184, 0, 0b1);
    set_ICC_MSRE(__tc184);
    __tc185 : bits(32) = get_ICC_HSRE();
    let __tc185 = __SetSlice_bits(32, 1, __tc185, 0, 0b1);
    set_ICC_HSRE(__tc185);
    return()
}

val get_MAIR1 : unit -> bits(32) effect {escape, rreg, undef}

function get_MAIR1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = MAIR1_S
    } else {
        r = get_MAIR1_NS()
    };
    r
}

val get_MAIR0 : unit -> bits(32) effect {escape, rreg, undef}

function get_MAIR0 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = MAIR0_S
    } else {
        r = get_MAIR0_NS()
    };
    r
}

val get_IFSR : unit -> bits(32) effect {escape, rreg, undef}

function get_IFSR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = IFSR_S
    } else {
        r = get_IFSR_NS()
    };
    r
}

val get_ICC_SRE_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_SRE_EL1_S
    } else {
        r = ICC_SRE_EL1_NS
    };
    r
}

val set_ICC_SRE_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_SRE_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_SRE_EL1(__tc1);
    return()
}

val set_ICC_SRE_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_SRE_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_SRE_EL1(__tc1);
    return()
}

val set_ICC_SRE : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_SRE_S(r)
    } else {
        set_ICC_SRE_NS(r)
    };
    return()
}

val get_ICC_SRE_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_SRE_EL1(), 0, 32));
    r
}

val get_ICC_SRE_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_SRE_EL1(), 0, 32));
    r
}

val get_ICC_SRE : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_SRE_S()
    } else {
        r = get_ICC_SRE_NS()
    };
    r
}

val get_ICC_IGRPEN1_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_IGRPEN1_EL1_S
    } else {
        r = ICC_IGRPEN1_EL1_NS
    };
    r
}

val set_ICC_IGRPEN1_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_IGRPEN1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_IGRPEN1_EL1(__tc1);
    return()
}

val set_ICC_IGRPEN1_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_IGRPEN1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_IGRPEN1_EL1(__tc1);
    return()
}

val set_ICC_IGRPEN1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_IGRPEN1_S(r)
    } else {
        set_ICC_IGRPEN1_NS(r)
    };
    return()
}

val get_ICC_IGRPEN1_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_IGRPEN1_EL1(), 0, 32));
    r
}

val get_ICC_IGRPEN1_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_IGRPEN1_EL1(), 0, 32));
    r
}

val get_ICC_IGRPEN1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_IGRPEN1_S()
    } else {
        r = get_ICC_IGRPEN1_NS()
    };
    r
}

val get_ICC_CTLR_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_CTLR_EL1_S
    } else {
        r = ICC_CTLR_EL1_NS
    };
    r
}

val set_ICC_CTLR_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_CTLR_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_CTLR_EL1(__tc1);
    return()
}

val set_ICC_CTLR_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_CTLR_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_CTLR_EL1(__tc1);
    return()
}

val set_ICC_CTLR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_CTLR_S(r)
    } else {
        set_ICC_CTLR_NS(r)
    };
    return()
}

val get_ICC_CTLR_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_CTLR_EL1(), 0, 32));
    r
}

val get_ICC_CTLR_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_CTLR_EL1(), 0, 32));
    r
}

val AArch64_AutoGen_ArchitectureReset : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_ArchitectureReset cold = {
    HCR_EL2 = __SetSlice_bits(64, 6, HCR_EL2, 58, 0b000000);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 37, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 36, 0b0);
    ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 44, 0x0);
    PAR_EL1 = __SetSlice_bits(64, 4, PAR_EL1, 52, 0x0);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 11, 0b1);
    PAR_EL1 = __SetSlice_bits(64, 6, PAR_EL1, 1, 0b000000);
    PAR_EL1 = __SetSlice_bits(64, 36, PAR_EL1, 12, 0x000000000);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 11, 0b1);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 10, 0b0);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 7, 0b0);
    CCSIDR_EL1 = __SetSlice_bits(64, 32, CCSIDR_EL1, 32, 0x00000000);
    CCSIDR_EL1 = __SetSlice_bits(64, 4, CCSIDR_EL1, 28, 0x0);
    CCSIDR_EL1 = __SetSlice_bits(64, 8, CCSIDR_EL1, 56, 0x00);
    CCSIDR_EL1 = __SetSlice_bits(64, 8, CCSIDR_EL1, 24, 0x00);
    CLIDR_EL1 = __SetSlice_bits(64, 17, CLIDR_EL1, 47, 0b00000000000000000);
    CPACR_EL1 = __SetSlice_bits(32, 6, CPACR_EL1, 22, 0b000000);
    CPACR_EL1 = __SetSlice_bits(32, 2, CPACR_EL1, 18, 0b00);
    CPACR_EL1 = __SetSlice_bits(32, 16, CPACR_EL1, 0, 0x0000);
    CPTR_EL2 = __SetSlice_bits(32, 9, CPTR_EL2, 21, 0b000000000);
    CPTR_EL2 = __SetSlice_bits(32, 6, CPTR_EL2, 14, 0b000000);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 12, 0b01);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 11, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 9, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 8, CPTR_EL2, 0, 0x01);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 29, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 6, CPTR_EL2, 22, 0b000000);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 18, 0b00);
    CPTR_EL2 = __SetSlice_bits(32, 16, CPTR_EL2, 0, 0x0000);
    CPTR_EL3 = __SetSlice_bits(32, 9, CPTR_EL3, 21, 0b000000000);
    CPTR_EL3 = __SetSlice_bits(32, 9, CPTR_EL3, 11, 0b000000000);
    CPTR_EL3 = __SetSlice_bits(32, 1, CPTR_EL3, 9, 0b0);
    CPTR_EL3 = __SetSlice_bits(32, 8, CPTR_EL3, 0, 0x00);
    CTR_EL0 = __SetSlice_bits(64, 26, CTR_EL0, 38, 0b00000000000000000000000000);
    CTR_EL0 = __SetSlice_bits(64, 1, CTR_EL0, 31, 0b1);
    CTR_EL0 = __SetSlice_bits(64, 1, CTR_EL0, 30, 0b0);
    CTR_EL0 = __SetSlice_bits(64, 10, CTR_EL0, 4, 0b0000000000);
    DBGCLAIMCLR_EL1 = __SetSlice_bits(32, 24, DBGCLAIMCLR_EL1, 8, 0x000000);
    if cold then {
        DBGCLAIMCLR_EL1 = __SetSlice_bits(32, 8, DBGCLAIMCLR_EL1, 0, 0x00)
    };
    DBGCLAIMSET_EL1 = __SetSlice_bits(32, 24, DBGCLAIMSET_EL1, 8, 0x000000);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 29, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 17, DBGVCR32_EL2, 8, 0b00000000000000000);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 5, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 0, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 5, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 0, 0b0);
    DSPSR_EL0 = __SetSlice_bits(32, 2, DSPSR_EL0, 26, 0b00);
    DSPSR_EL0 = __SetSlice_bits(32, 7, DSPSR_EL0, 13, 0b0000000);
    DSPSR_EL0 = __SetSlice_bits(32, 1, DSPSR_EL0, 5, 0b0);
    FPCR = __SetSlice_bits(32, 2, FPCR, 13, 0b00);
    FPCR = __SetSlice_bits(32, 8, FPCR, 0, 0x00);
    FPEXC32_EL2 = __SetSlice_bits(32, 15, FPEXC32_EL2, 11, 0b000000000000000);
    FPEXC32_EL2 = __SetSlice_bits(32, 2, FPEXC32_EL2, 5, 0b00);
    FPSR = __SetSlice_bits(32, 19, FPSR, 8, 0b0000000000000000000);
    FPSR = __SetSlice_bits(32, 2, FPSR, 5, 0b00);
    HPFAR_EL2 = __SetSlice_bits(64, 19, HPFAR_EL2, 44, 0b0000000000000000000);
    HPFAR_EL2 = __SetSlice_bits(64, 4, HPFAR_EL2, 0, 0x0);
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 8, ICC_ASGI1R_EL1, 56, 0x00);
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 3, ICC_ASGI1R_EL1, 41, 0b000);
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 4, ICC_ASGI1R_EL1, 28, 0x0);
    __tc1 : bits(32) = get_ICC_CTLR_EL1();
    let __tc1 = __SetSlice_bits(32, 2, __tc1, 16, 0b00);
    set_ICC_CTLR_EL1(__tc1);
    __tc2 : bits(32) = get_ICC_CTLR_EL1();
    let __tc2 = __SetSlice_bits(32, 1, __tc2, 7, 0b0);
    set_ICC_CTLR_EL1(__tc2);
    __tc3 : bits(32) = get_ICC_CTLR_EL1();
    let __tc3 = __SetSlice_bits(32, 4, __tc3, 2, 0x0);
    set_ICC_CTLR_EL1(__tc3);
    ICC_CTLR_EL3 = __SetSlice_bits(32, 1, ICC_CTLR_EL3, 16, 0b0);
    ICC_CTLR_EL3 = __SetSlice_bits(32, 1, ICC_CTLR_EL3, 7, 0b0);
    ICC_CTLR_EL3 = __SetSlice_bits(32, 1, ICC_CTLR_EL3, 6, 0b0);
    ICC_IGRPEN0_EL1 = __SetSlice_bits(32, 1, ICC_IGRPEN0_EL1, 0, 0b0);
    __tc4 : bits(32) = get_ICC_IGRPEN1_EL1();
    let __tc4 = __SetSlice_bits(32, 1, __tc4, 0, 0b0);
    set_ICC_IGRPEN1_EL1(__tc4);
    ICC_IGRPEN1_EL3 = __SetSlice_bits(32, 1, ICC_IGRPEN1_EL3, 1, 0b0);
    ICC_IGRPEN1_EL3 = __SetSlice_bits(32, 1, ICC_IGRPEN1_EL3, 0, 0b0);
    ICC_PMR_EL1 = __SetSlice_bits(32, 8, ICC_PMR_EL1, 0, 0x00);
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 8, ICC_SGI0R_EL1, 56, 0x00);
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 3, ICC_SGI0R_EL1, 41, 0b000);
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 4, ICC_SGI0R_EL1, 28, 0x0);
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 8, ICC_SGI1R_EL1, 56, 0x00);
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 3, ICC_SGI1R_EL1, 41, 0b000);
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 4, ICC_SGI1R_EL1, 28, 0x0);
    __tc5 : bits(32) = get_ICC_SRE_EL1();
    let __tc5 = __SetSlice_bits(32, 1, __tc5, 2, 0b0);
    set_ICC_SRE_EL1(__tc5);
    __tc6 : bits(32) = get_ICC_SRE_EL1();
    let __tc6 = __SetSlice_bits(32, 1, __tc6, 1, 0b0);
    set_ICC_SRE_EL1(__tc6);
    __tc7 : bits(32) = get_ICC_SRE_EL1();
    let __tc7 = __SetSlice_bits(32, 1, __tc7, 0, 0b0);
    set_ICC_SRE_EL1(__tc7);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 2, 0b0);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 1, 0b0);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 0, 0b0);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 2, 0b0);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 1, 0b0);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 0, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 5, ICH_HCR_EL2, 27, 0b00000);
    ICH_HCR_EL2 = __SetSlice_bits(32, 12, ICH_HCR_EL2, 15, 0x000);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 14, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 13, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 12, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 11, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 10, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 2, ICH_HCR_EL2, 8, 0b00);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 7, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 6, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 5, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 4, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 3, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 2, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 1, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 0, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 7, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 6, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 5, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 4, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 3, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 2, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 1, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 0, 0b0);
    ICH_VMCR_EL2 = __SetSlice_bits(32, 8, ICH_VMCR_EL2, 10, 0x00);
    ICH_VMCR_EL2 = __SetSlice_bits(32, 4, ICH_VMCR_EL2, 5, 0x0);
    ICH_VTR_EL2 = __SetSlice_bits(32, 14, ICH_VTR_EL2, 5, 0b00000000000000);
    ICV_CTLR_EL1 = __SetSlice_bits(32, 2, ICV_CTLR_EL1, 16, 0b00);
    ICV_CTLR_EL1 = __SetSlice_bits(32, 6, ICV_CTLR_EL1, 2, 0b000000);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 16, ID_AA64DFR0_EL1, 48, 0x0000);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 44, 0x0);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 24, 0x0);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 16, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 0, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 20, ID_AA64ISAR1_EL1, 44, 0x00000);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 8, ID_AA64MMFR0_EL1, 56, 0x00);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 52, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 48, 0x0);
    ID_AA64PFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64PFR1_EL1, 12, 0x0);
    ID_ISAR5_EL1 = __SetSlice_bits(32, 4, ID_ISAR5_EL1, 20, 0x0);
    ID_PFR2_EL1 = __SetSlice_bits(32, 4, ID_PFR2_EL1, 8, 0x0);
    IFSR32_EL2 = __SetSlice_bits(32, 3, IFSR32_EL2, 13, 0b000);
    IFSR32_EL2 = __SetSlice_bits(32, 1, IFSR32_EL2, 11, 0b0);
    IFSR32_EL2 = __SetSlice_bits(32, 5, IFSR32_EL2, 4, 0b00000);
    IFSR32_EL2 = __SetSlice_bits(32, 3, IFSR32_EL2, 13, 0b000);
    IFSR32_EL2 = __SetSlice_bits(32, 2, IFSR32_EL2, 10, 0b00);
    IFSR32_EL2 = __SetSlice_bits(32, 3, IFSR32_EL2, 6, 0b000);
    ISR_EL1 = __SetSlice_bits(32, 6, ISR_EL1, 0, 0b000000);
    LORC_EL1 = __SetSlice_bits(32, 1, LORC_EL1, 1, 0b0);
    LORC_EL1 = __SetSlice_bits(32, 1, LORC_EL1, 0, 0b0);
    LOREA_EL1 = __SetSlice_bits(64, 12, LOREA_EL1, 52, 0x000);
    LOREA_EL1 = __SetSlice_bits(64, 16, LOREA_EL1, 0, 0x0000);
    LORID_EL1 = __SetSlice_bits(32, 8, LORID_EL1, 8, 0x00);
    LORSA_EL1 = __SetSlice_bits(64, 12, LORSA_EL1, 52, 0x000);
    LORSA_EL1 = __SetSlice_bits(64, 15, LORSA_EL1, 1, 0b000000000000000);
    LORSA_EL1 = __SetSlice_bits(64, 1, LORSA_EL1, 0, 0b0);
    MDCCINT_EL1 = __SetSlice_bits(32, 1, MDCCINT_EL1, 30, 0b0);
    MDCCINT_EL1 = __SetSlice_bits(32, 1, MDCCINT_EL1, 29, 0b0);
    MDCCINT_EL1 = __SetSlice_bits(32, 29, MDCCINT_EL1, 0, 0b00000000000000000000000000000);
    MDCCSR_EL0 = __SetSlice_bits(32, 10, MDCCSR_EL0, 19, 0b0000000000);
    MDCCSR_EL0 = __SetSlice_bits(32, 4, MDCCSR_EL0, 15, 0x0);
    MDCCSR_EL0 = __SetSlice_bits(32, 2, MDCCSR_EL0, 13, 0b00);
    MDCCSR_EL0 = __SetSlice_bits(32, 1, MDCCSR_EL0, 12, 0b0);
    MDCCSR_EL0 = __SetSlice_bits(32, 6, MDCCSR_EL0, 6, 0b000000);
    MDCCSR_EL0 = __SetSlice_bits(32, 4, MDCCSR_EL0, 2, 0x0);
    MDCCSR_EL0 = __SetSlice_bits(32, 2, MDCCSR_EL0, 0, 0b00);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 26, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 2, MDCR_EL2, 24, 0b00);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 23, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 3, MDCR_EL2, 20, 0b000);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 18, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 17, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 2, MDCR_EL2, 15, 0b00);
    MDCR_EL3 = __SetSlice_bits(32, 2, MDCR_EL3, 24, 0b00);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 23, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 22, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 21, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 20, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 18, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 17, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 11, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 2, MDCR_EL3, 7, 0b00);
    MDCR_EL3 = __SetSlice_bits(32, 6, MDCR_EL3, 0, 0b000000);
    MDRAR_EL1 = __SetSlice_bits(64, 12, MDRAR_EL1, 52, 0x000);
    MDRAR_EL1 = __SetSlice_bits(64, 10, MDRAR_EL1, 2, 0b0000000000);
    MDSCR_EL1 = __SetSlice_bits(32, 1, MDSCR_EL1, 28, 0b0);
    MDSCR_EL1 = __SetSlice_bits(32, 2, MDSCR_EL1, 24, 0b00);
    MDSCR_EL1 = __SetSlice_bits(32, 1, MDSCR_EL1, 20, 0b0);
    MDSCR_EL1 = __SetSlice_bits(32, 5, MDSCR_EL1, 7, 0b00000);
    MDSCR_EL1 = __SetSlice_bits(32, 5, MDSCR_EL1, 1, 0b00000);
    MPIDR_EL1 = __SetSlice_bits(64, 24, MPIDR_EL1, 40, 0x000000);
    MPIDR_EL1 = __SetSlice_bits(64, 1, MPIDR_EL1, 31, 0b1);
    MPIDR_EL1 = __SetSlice_bits(64, 5, MPIDR_EL1, 25, 0b00000);
    OSDLR_EL1 = __SetSlice_bits(32, 1, OSDLR_EL1, 0, 0b0);
    if cold then {
        OSLSR_EL1 = __SetSlice_bits(32, 1, OSLSR_EL1, 1, 0b1)
    };
    PMCCFILTR_EL0 = __SetSlice_bits(32, 1, PMCCFILTR_EL0, 25, 0b0);
    PMCCFILTR_EL0 = __SetSlice_bits(32, 24, PMCCFILTR_EL0, 0, 0x000000);
    PMCR_EL0 = __SetSlice_bits(32, 3, PMCR_EL0, 8, 0b000);
    PMCR_EL0 = __SetSlice_bits(32, 1, PMCR_EL0, 7, 0b0);
    PMCR_EL0 = __SetSlice_bits(32, 1, PMCR_EL0, 0, 0b0);
    RMR_EL1 = __SetSlice_bits(32, 1, RMR_EL1, 1, 0b0);
    RMR_EL2 = __SetSlice_bits(32, 1, RMR_EL2, 1, 0b0);
    RMR_EL3 = __SetSlice_bits(32, 1, RMR_EL3, 1, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 20, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 19, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 15, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 6, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 2, SCR_EL3, 4, 0b01);
    SCTLR_EL1 = __SetSlice_bits(64, 18, SCTLR_EL1, 46, 0b000000000000000000);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 17, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 12, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 2, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 0, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 19, SCTLR_EL2, 45, 0b0000000000000000000);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 42, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 38, 0b00);
    SCTLR_EL2 = __SetSlice_bits(64, 4, SCTLR_EL2, 32, 0x0);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 28, 0b01);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 26, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 24, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 23, 0b1);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 20, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 18, 0b1);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 17, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 16, 0b1);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 14, 0b00);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 12, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 4, SCTLR_EL2, 7, 0x0);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 4, 0b01);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 2, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 0, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 18, SCTLR_EL2, 46, 0b000000000000000000);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 17, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 12, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 9, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 2, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 0, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 19, SCTLR_EL3, 45, 0b0000000000000000000);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 42, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 38, 0b00);
    SCTLR_EL3 = __SetSlice_bits(64, 4, SCTLR_EL3, 32, 0x0);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 28, 0b01);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 26, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 24, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 23, 0b1);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 20, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 18, 0b1);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 17, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 16, 0b1);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 14, 0b00);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 12, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 4, SCTLR_EL3, 7, 0x0);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 4, 0b01);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 2, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 0, 0b0);
    SPSR_abt = __SetSlice_bits(32, 1, SPSR_abt, 23, 0b0);
    SPSR_EL0 = __SetSlice_bits(32, 4, SPSR_EL0, 24, 0x0);
    SPSR_EL0 = __SetSlice_bits(32, 10, SPSR_EL0, 10, 0b0000000000);
    SPSR_EL0 = __SetSlice_bits(32, 12, SPSR_EL0, 6, 0x000);
    SPSR_EL0 = __SetSlice_bits(32, 1, SPSR_EL0, 0, 0b0);
    SPSR_EL1 = __SetSlice_bits(32, 2, SPSR_EL1, 26, 0b00);
    SPSR_EL1 = __SetSlice_bits(32, 7, SPSR_EL1, 13, 0b0000000);
    SPSR_EL1 = __SetSlice_bits(32, 12, SPSR_EL1, 6, 0x000);
    SPSR_EL1 = __SetSlice_bits(32, 1, SPSR_EL1, 0, 0b0);
    SPSR_EL2 = __SetSlice_bits(32, 2, SPSR_EL2, 26, 0b00);
    SPSR_EL2 = __SetSlice_bits(32, 7, SPSR_EL2, 13, 0b0000000);
    SPSR_EL2 = __SetSlice_bits(32, 12, SPSR_EL2, 6, 0x000);
    SPSR_EL2 = __SetSlice_bits(32, 1, SPSR_EL2, 0, 0b0);
    SPSR_EL3 = __SetSlice_bits(32, 2, SPSR_EL3, 26, 0b00);
    SPSR_EL3 = __SetSlice_bits(32, 7, SPSR_EL3, 13, 0b0000000);
    SPSR_EL3 = __SetSlice_bits(32, 12, SPSR_EL3, 6, 0x000);
    SPSR_EL3 = __SetSlice_bits(32, 1, SPSR_EL3, 0, 0b0);
    SPSR_fiq = __SetSlice_bits(32, 1, SPSR_fiq, 23, 0b0);
    SPSR_irq = __SetSlice_bits(32, 1, SPSR_irq, 23, 0b0);
    SPSR_und = __SetSlice_bits(32, 1, SPSR_und, 23, 0b0);
    TCR_EL1 = __SetSlice_bits(64, 5, TCR_EL1, 59, 0b00000);
    TCR_EL1 = __SetSlice_bits(64, 1, TCR_EL1, 35, 0b0);
    TCR_EL1 = __SetSlice_bits(64, 1, TCR_EL1, 6, 0b0);
    TCR_EL2 = __SetSlice_bits(64, 32, TCR_EL2, 32, 0x00000000);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 31, 0b1);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 23, 0b1);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 19, 0b0);
    TCR_EL2 = __SetSlice_bits(64, 2, TCR_EL2, 6, 0b00);
    TCR_EL2 = __SetSlice_bits(64, 5, TCR_EL2, 59, 0b00000);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 35, 0b0);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 6, 0b0);
    TCR_EL3 = __SetSlice_bits(32, 1, TCR_EL3, 31, 0b1);
    TCR_EL3 = __SetSlice_bits(32, 1, TCR_EL3, 23, 0b1);
    TCR_EL3 = __SetSlice_bits(32, 1, TCR_EL3, 19, 0b0);
    TCR_EL3 = __SetSlice_bits(32, 2, TCR_EL3, 6, 0b00);
    TRFCR_EL1 = __SetSlice_bits(32, 3, TRFCR_EL1, 2, 0b000);
    TRFCR_EL1 = __SetSlice_bits(32, 1, TRFCR_EL1, 1, 0b0);
    TRFCR_EL1 = __SetSlice_bits(32, 1, TRFCR_EL1, 0, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 2, TRFCR_EL2, 5, 0b00);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 4, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 3, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 2, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 1, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 0, 0b0);
    TTBR0_EL3 = __SetSlice_bits(64, 16, TTBR0_EL3, 48, 0x0000);
    VBAR_EL0 = __SetSlice_bits(64, 11, VBAR_EL0, 0, 0b00000000000);
    VBAR_EL1 = __SetSlice_bits(64, 11, VBAR_EL1, 0, 0b00000000000);
    VBAR_EL2 = __SetSlice_bits(64, 11, VBAR_EL2, 0, 0b00000000000);
    VBAR_EL3 = __SetSlice_bits(64, 11, VBAR_EL3, 0, 0b00000000000);
    VMPIDR_EL2 = __SetSlice_bits(64, 24, VMPIDR_EL2, 40, 0x000000);
    VMPIDR_EL2 = __SetSlice_bits(64, 1, VMPIDR_EL2, 31, 0b1);
    VMPIDR_EL2 = __SetSlice_bits(64, 5, VMPIDR_EL2, 25, 0b00000);
    VNCR_EL2 = __SetSlice_bits(64, 12, VNCR_EL2, 0, 0x000);
    VSTCR_EL2 = __SetSlice_bits(32, 1, VSTCR_EL2, 31, 0b1);
    VSTCR_EL2 = __SetSlice_bits(32, 13, VSTCR_EL2, 16, 0b0000000000000);
    VSTCR_EL2 = __SetSlice_bits(32, 6, VSTCR_EL2, 8, 0b000000);
    VSTTBR_EL2 = __SetSlice_bits(64, 16, VSTTBR_EL2, 48, 0x0000);
    VTCR_EL2 = __SetSlice_bits(32, 1, VTCR_EL2, 31, 0b1);
    VTCR_EL2 = __SetSlice_bits(32, 2, VTCR_EL2, 23, 0b00);
    VTCR_EL2 = __SetSlice_bits(32, 1, VTCR_EL2, 20, 0b0);
    MPAM0_EL1 = __SetSlice_bits(64, 16, MPAM0_EL1, 48, 0x0000);
    if cold then {
        MPAM1_EL1 = __SetSlice_bits(64, 1, MPAM1_EL1, 63, 0b0)
    };
    MPAM1_EL1 = __SetSlice_bits(64, 15, MPAM1_EL1, 48, 0b000000000000000);
    MPAM2_EL2 = __SetSlice_bits(64, 13, MPAM2_EL2, 50, 0b0000000000000);
    if cold then {
        MPAM2_EL2 = __SetSlice_bits(64, 1, MPAM2_EL2, 63, 0b0)
    };
    if cold then {
        MPAM3_EL3 = __SetSlice_bits(64, 1, MPAM3_EL3, 63, 0b0)
    };
    if cold then {
        MPAM3_EL3 = __SetSlice_bits(64, 1, MPAM3_EL3, 62, 0b1)
    };
    MPAM3_EL3 = __SetSlice_bits(64, 14, MPAM3_EL3, 48, 0b00000000000000);
    MPAMHCR_EL2 = __SetSlice_bits(32, 22, MPAMHCR_EL2, 9, 0b0000000000000000000000);
    MPAMHCR_EL2 = __SetSlice_bits(32, 6, MPAMHCR_EL2, 2, 0b000000);
    MPAMIDR_EL1 = __SetSlice_bits(64, 24, MPAMIDR_EL1, 40, 0x000000);
    MPAMIDR_EL1 = __SetSlice_bits(64, 11, MPAMIDR_EL1, 21, 0b00000000000);
    MPAMIDR_EL1 = __SetSlice_bits(64, 1, MPAMIDR_EL1, 16, 0b0);
    RGSR_EL1 = __SetSlice_bits(32, 4, RGSR_EL1, 4, 0x0)
}

val get_ICC_CTLR : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_CTLR_S()
    } else {
        r = get_ICC_CTLR_NS()
    };
    r
}

val get_ICC_BPR1_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_BPR1_EL1_S
    } else {
        r = ICC_BPR1_EL1_NS
    };
    r
}

val set_ICC_BPR1_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_BPR1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_BPR1_EL1(__tc1);
    return()
}

val set_ICC_BPR1_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_BPR1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_BPR1_EL1(__tc1);
    return()
}

val set_ICC_BPR1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_BPR1_S(r)
    } else {
        set_ICC_BPR1_NS(r)
    };
    return()
}

val get_ICC_BPR1_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_BPR1_EL1(), 0, 32));
    r
}

val get_ICC_BPR1_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_BPR1_EL1(), 0, 32));
    r
}

val get_ICC_BPR1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_BPR1_S()
    } else {
        r = get_ICC_BPR1_NS()
    };
    r
}

val get_DFSR : unit -> bits(32) effect {escape, rreg, undef}

function get_DFSR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = DFSR_S
    } else {
        r = get_DFSR_NS()
    };
    r
}

val get_DACR : unit -> bits(32) effect {escape, rreg, undef}

function get_DACR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = DACR_S
    } else {
        r = get_DACR_NS()
    };
    r
}

val get_CSSELR : unit -> bits(32) effect {escape, rreg, undef}

function get_CSSELR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = CSSELR_S
    } else {
        r = get_CSSELR_NS()
    };
    r
}

val get_CONTEXTIDR : unit -> bits(32) effect {escape, rreg, undef}

function get_CONTEXTIDR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = CONTEXTIDR_S
    } else {
        r = get_CONTEXTIDR_NS()
    };
    r
}

val get_CNTP_CTL : unit -> bits(32) effect {escape, rreg, undef}

function get_CNTP_CTL () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = CNTP_CTL_S
    } else {
        r = get_CNTP_CTL_NS()
    };
    r
}

val AArch32_AutoGen_ArchitectureReset : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function AArch32_AutoGen_ArchitectureReset cold = {
    __tc1 : bits(32) = get_TTBCR();
    let __tc1 = __SetSlice_bits(32, 1, __tc1, 31, 0b0);
    set_TTBCR(__tc1);
    __tc2 : bits(32) = get_TTBCR();
    let __tc2 = __SetSlice_bits(32, 25, __tc2, 6, 0b0000000000000000000000000);
    set_TTBCR(__tc2);
    __tc3 : bits(32) = get_TTBCR();
    let __tc3 = __SetSlice_bits(32, 1, __tc3, 5, 0b0);
    set_TTBCR(__tc3);
    __tc4 : bits(32) = get_TTBCR();
    let __tc4 = __SetSlice_bits(32, 1, __tc4, 4, 0b0);
    set_TTBCR(__tc4);
    __tc5 : bits(32) = get_TTBCR();
    let __tc5 = __SetSlice_bits(32, 1, __tc5, 3, 0b0);
    set_TTBCR(__tc5);
    __tc6 : bits(32) = get_TTBCR();
    let __tc6 = __SetSlice_bits(32, 3, __tc6, 0, 0b000);
    set_TTBCR(__tc6);
    __tc7 : bits(32) = get_TTBCR();
    let __tc7 = __SetSlice_bits(32, 1, __tc7, 31, 0b0);
    set_TTBCR(__tc7);
    __tc8 : bits(32) = get_TTBCR();
    let __tc8 = __SetSlice_bits(32, 1, __tc8, 30, 0b0);
    set_TTBCR(__tc8);
    __tc9 : bits(32) = get_TTBCR();
    let __tc9 = __SetSlice_bits(32, 2, __tc9, 28, 0b00);
    set_TTBCR(__tc9);
    __tc10 : bits(32) = get_TTBCR();
    let __tc10 = __SetSlice_bits(32, 2, __tc10, 26, 0b00);
    set_TTBCR(__tc10);
    __tc11 : bits(32) = get_TTBCR();
    let __tc11 = __SetSlice_bits(32, 2, __tc11, 24, 0b00);
    set_TTBCR(__tc11);
    __tc12 : bits(32) = get_TTBCR();
    let __tc12 = __SetSlice_bits(32, 1, __tc12, 23, 0b0);
    set_TTBCR(__tc12);
    __tc13 : bits(32) = get_TTBCR();
    let __tc13 = __SetSlice_bits(32, 1, __tc13, 22, 0b0);
    set_TTBCR(__tc13);
    __tc14 : bits(32) = get_TTBCR();
    let __tc14 = __SetSlice_bits(32, 3, __tc14, 19, 0b000);
    set_TTBCR(__tc14);
    __tc15 : bits(32) = get_TTBCR();
    let __tc15 = __SetSlice_bits(32, 3, __tc15, 16, 0b000);
    set_TTBCR(__tc15);
    __tc16 : bits(32) = get_TTBCR();
    let __tc16 = __SetSlice_bits(32, 2, __tc16, 14, 0b00);
    set_TTBCR(__tc16);
    __tc17 : bits(32) = get_TTBCR();
    let __tc17 = __SetSlice_bits(32, 2, __tc17, 12, 0b00);
    set_TTBCR(__tc17);
    __tc18 : bits(32) = get_TTBCR();
    let __tc18 = __SetSlice_bits(32, 2, __tc18, 10, 0b00);
    set_TTBCR(__tc18);
    __tc19 : bits(32) = get_TTBCR();
    let __tc19 = __SetSlice_bits(32, 2, __tc19, 8, 0b00);
    set_TTBCR(__tc19);
    __tc20 : bits(32) = get_TTBCR();
    let __tc20 = __SetSlice_bits(32, 1, __tc20, 7, 0b0);
    set_TTBCR(__tc20);
    __tc21 : bits(32) = get_TTBCR();
    let __tc21 = __SetSlice_bits(32, 3, __tc21, 3, 0b000);
    set_TTBCR(__tc21);
    __tc22 : bits(32) = get_TTBCR();
    let __tc22 = __SetSlice_bits(32, 3, __tc22, 0, 0b000);
    set_TTBCR(__tc22);
    __tc23 : bits(32) = get_CCSIDR();
    let __tc23 = __SetSlice_bits(32, 4, __tc23, 28, 0x0);
    set_CCSIDR(__tc23);
    __tc24 : bits(32) = get_CCSIDR();
    let __tc24 = __SetSlice_bits(32, 8, __tc24, 24, 0x00);
    set_CCSIDR(__tc24);
    __tc25 : bits(32) = get_CCSIDR2();
    let __tc25 = __SetSlice_bits(32, 8, __tc25, 24, 0x00);
    set_CCSIDR2(__tc25);
    __tc26 : bits(32) = get_CNTHCTL();
    let __tc26 = __SetSlice_bits(32, 24, __tc26, 8, 0x000000);
    set_CNTHCTL(__tc26);
    __tc27 : bits(32) = get_CNTHP_CTL();
    let __tc27 = __SetSlice_bits(32, 29, __tc27, 3, 0b00000000000000000000000000000);
    set_CNTHP_CTL(__tc27);
    __tc28 : bits(32) = get_CNTHP_CTL();
    let __tc28 = __SetSlice_bits(32, 1, __tc28, 0, 0b0);
    set_CNTHP_CTL(__tc28);
    __tc29 : bits(32) = get_CNTHPS_CTL();
    let __tc29 = __SetSlice_bits(32, 29, __tc29, 3, 0b00000000000000000000000000000);
    set_CNTHPS_CTL(__tc29);
    __tc30 : bits(32) = get_CNTHV_CTL();
    let __tc30 = __SetSlice_bits(32, 29, __tc30, 3, 0b00000000000000000000000000000);
    set_CNTHV_CTL(__tc30);
    __tc31 : bits(32) = get_CNTHVS_CTL();
    let __tc31 = __SetSlice_bits(32, 29, __tc31, 3, 0b00000000000000000000000000000);
    set_CNTHVS_CTL(__tc31);
    __tc32 : bits(32) = get_CNTKCTL();
    let __tc32 = __SetSlice_bits(32, 22, __tc32, 10, 0b0000000000000000000000);
    set_CNTKCTL(__tc32);
    __tc33 : bits(32) = get_CNTP_CTL();
    let __tc33 = __SetSlice_bits(32, 29, __tc33, 3, 0b00000000000000000000000000000);
    set_CNTP_CTL(__tc33);
    __tc34 : bits(32) = get_CNTP_CTL();
    let __tc34 = __SetSlice_bits(32, 1, __tc34, 0, 0b0);
    set_CNTP_CTL(__tc34);
    __tc35 : bits(32) = get_CNTV_CTL();
    let __tc35 = __SetSlice_bits(32, 29, __tc35, 3, 0b00000000000000000000000000000);
    set_CNTV_CTL(__tc35);
    __tc36 : bits(32) = get_CNTV_CTL();
    let __tc36 = __SetSlice_bits(32, 1, __tc36, 0, 0b0);
    set_CNTV_CTL(__tc36);
    __tc37 : bits(32) = get_CPACR();
    let __tc37 = __SetSlice_bits(32, 1, __tc37, 31, 0b0);
    set_CPACR(__tc37);
    __tc38 : bits(32) = get_CPACR();
    let __tc38 = __SetSlice_bits(32, 2, __tc38, 29, 0b00);
    set_CPACR(__tc38);
    __tc39 : bits(32) = get_CPACR();
    let __tc39 = __SetSlice_bits(32, 4, __tc39, 24, 0x0);
    set_CPACR(__tc39);
    __tc40 : bits(32) = get_CPACR();
    let __tc40 = __SetSlice_bits(32, 2, __tc40, 22, 0b00);
    set_CPACR(__tc40);
    __tc41 : bits(32) = get_CPACR();
    let __tc41 = __SetSlice_bits(32, 2, __tc41, 20, 0b00);
    set_CPACR(__tc41);
    __tc42 : bits(32) = get_CPACR();
    let __tc42 = __SetSlice_bits(32, 20, __tc42, 0, 0x00000);
    set_CPACR(__tc42);
    __tc43 : bits(32) = get_CSSELR();
    let __tc43 = __SetSlice_bits(32, 28, __tc43, 4, 0x0000000);
    set_CSSELR(__tc43);
    __tc44 : bits(32) = get_CTR();
    let __tc44 = __SetSlice_bits(32, 1, __tc44, 31, 0b1);
    set_CTR(__tc44);
    __tc45 : bits(32) = get_CTR();
    let __tc45 = __SetSlice_bits(32, 1, __tc45, 30, 0b0);
    set_CTR(__tc45);
    __tc46 : bits(32) = get_CTR();
    let __tc46 = __SetSlice_bits(32, 10, __tc46, 4, 0b0000000000);
    set_CTR(__tc46);
    __tc47 : bits(32) = get_DBGAUTHSTATUS();
    let __tc47 = __SetSlice_bits(32, 24, __tc47, 8, 0x000000);
    set_DBGAUTHSTATUS(__tc47);
    __tc48 : bits(32) = get_DBGCLAIMCLR();
    let __tc48 = __SetSlice_bits(32, 24, __tc48, 8, 0x000000);
    set_DBGCLAIMCLR(__tc48);
    if cold then {
        __tc49 : bits(32) = get_DBGCLAIMCLR();
        __tc49 = __SetSlice_bits(32, 8, __tc49, 0, 0x00);
        set_DBGCLAIMCLR(__tc49)
    };
    __tc50 : bits(32) = get_DBGCLAIMSET();
    let __tc50 = __SetSlice_bits(32, 24, __tc50, 8, 0x000000);
    set_DBGCLAIMSET(__tc50);
    if cold then {
        __tc51 : bits(32) = get_DBGCLAIMSET();
        __tc51 = __SetSlice_bits(32, 8, __tc51, 0, 0x00);
        set_DBGCLAIMSET(__tc51)
    };
    __tc52 : bits(32) = get_DBGDCCINT();
    let __tc52 = __SetSlice_bits(32, 1, __tc52, 31, 0b0);
    set_DBGDCCINT(__tc52);
    __tc53 : bits(32) = get_DBGDCCINT();
    let __tc53 = __SetSlice_bits(32, 1, __tc53, 30, 0b0);
    set_DBGDCCINT(__tc53);
    __tc54 : bits(32) = get_DBGDCCINT();
    let __tc54 = __SetSlice_bits(32, 1, __tc54, 29, 0b0);
    set_DBGDCCINT(__tc54);
    __tc55 : bits(32) = get_DBGDCCINT();
    let __tc55 = __SetSlice_bits(32, 29, __tc55, 0, 0b00000000000000000000000000000);
    set_DBGDCCINT(__tc55);
    DBGDEVID1 = __SetSlice_bits(32, 28, DBGDEVID1, 4, 0x0000000);
    DBGDEVID2 = __SetSlice_bits(32, 32, DBGDEVID2, 0, 0x00000000);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 15, 0b1);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 13, 0b0);
    DBGDIDR = __SetSlice_bits(32, 12, DBGDIDR, 0, 0x000);
    __tc56 : bits(64) = get_DBGDRAR();
    let __tc56 = __SetSlice_bits(64, 10, __tc56, 2, 0b0000000000);
    set_DBGDRAR(__tc56);
    __tc57 : bits(64) = get_DBGDRAR();
    let __tc57 = __SetSlice_bits(64, 16, __tc57, 48, 0x0000);
    set_DBGDRAR(__tc57);
    __tc58 : bits(64) = get_DBGDRAR();
    let __tc58 = __SetSlice_bits(64, 10, __tc58, 2, 0b0000000000);
    set_DBGDRAR(__tc58);
    __tc59 : bits(32) = get_DBGDSCRext();
    let __tc59 = __SetSlice_bits(32, 1, __tc59, 28, 0b0);
    set_DBGDSCRext(__tc59);
    __tc60 : bits(32) = get_DBGDSCRext();
    let __tc60 = __SetSlice_bits(32, 2, __tc60, 24, 0b00);
    set_DBGDSCRext(__tc60);
    __tc61 : bits(32) = get_DBGDSCRext();
    let __tc61 = __SetSlice_bits(32, 1, __tc61, 20, 0b0);
    set_DBGDSCRext(__tc61);
    __tc62 : bits(32) = get_DBGDSCRext();
    let __tc62 = __SetSlice_bits(32, 1, __tc62, 15, 0b0);
    set_DBGDSCRext(__tc62);
    __tc63 : bits(32) = get_DBGDSCRext();
    let __tc63 = __SetSlice_bits(32, 1, __tc63, 13, 0b0);
    set_DBGDSCRext(__tc63);
    __tc64 : bits(32) = get_DBGDSCRext();
    let __tc64 = __SetSlice_bits(32, 1, __tc64, 12, 0b0);
    set_DBGDSCRext(__tc64);
    __tc65 : bits(32) = get_DBGDSCRext();
    let __tc65 = __SetSlice_bits(32, 5, __tc65, 7, 0b00000);
    set_DBGDSCRext(__tc65);
    __tc66 : bits(32) = get_DBGDSCRext();
    let __tc66 = __SetSlice_bits(32, 2, __tc66, 0, 0b00);
    set_DBGDSCRext(__tc66);
    DBGDSCRint = __SetSlice_bits(32, 1, DBGDSCRint, 31, 0b0);
    DBGDSCRint = __SetSlice_bits(32, 10, DBGDSCRint, 19, 0b0000000000);
    DBGDSCRint = __SetSlice_bits(32, 2, DBGDSCRint, 13, 0b00);
    DBGDSCRint = __SetSlice_bits(32, 6, DBGDSCRint, 6, 0b000000);
    DBGDSCRint = __SetSlice_bits(32, 2, DBGDSCRint, 0, 0b00);
    __tc67 : bits(32) = get_DBGOSDLR();
    let __tc67 = __SetSlice_bits(32, 31, __tc67, 1, 0b0000000000000000000000000000000);
    set_DBGOSDLR(__tc67);
    __tc68 : bits(32) = get_DBGOSDLR();
    let __tc68 = __SetSlice_bits(32, 1, __tc68, 0, 0b0);
    set_DBGOSDLR(__tc68);
    __tc69 : bits(32) = get_DBGOSLSR();
    let __tc69 = __SetSlice_bits(32, 28, __tc69, 4, 0x0000000);
    set_DBGOSLSR(__tc69);
    if cold then {
        __tc70 : bits(32) = get_DBGOSLSR();
        __tc70 = __SetSlice_bits(32, 1, __tc70, 1, 0b1);
        set_DBGOSLSR(__tc70)
    };
    __tc71 : bits(32) = get_DBGPRCR();
    let __tc71 = __SetSlice_bits(32, 31, __tc71, 1, 0b0000000000000000000000000000000);
    set_DBGPRCR(__tc71);
    __tc72 : bits(32) = get_DBGVCR();
    let __tc72 = __SetSlice_bits(32, 1, __tc72, 29, 0b0);
    set_DBGVCR(__tc72);
    __tc73 : bits(32) = get_DBGVCR();
    let __tc73 = __SetSlice_bits(32, 9, __tc73, 16, 0b000000000);
    set_DBGVCR(__tc73);
    __tc74 : bits(32) = get_DBGVCR();
    let __tc74 = __SetSlice_bits(32, 1, __tc74, 13, 0b0);
    set_DBGVCR(__tc74);
    __tc75 : bits(32) = get_DBGVCR();
    let __tc75 = __SetSlice_bits(32, 2, __tc75, 8, 0b00);
    set_DBGVCR(__tc75);
    __tc76 : bits(32) = get_DBGVCR();
    let __tc76 = __SetSlice_bits(32, 1, __tc76, 5, 0b0);
    set_DBGVCR(__tc76);
    __tc77 : bits(32) = get_DBGVCR();
    let __tc77 = __SetSlice_bits(32, 1, __tc77, 0, 0b0);
    set_DBGVCR(__tc77);
    __tc78 : bits(32) = get_DBGVCR();
    let __tc78 = __SetSlice_bits(32, 1, __tc78, 29, 0b0);
    set_DBGVCR(__tc78);
    __tc79 : bits(32) = get_DBGVCR();
    let __tc79 = __SetSlice_bits(32, 17, __tc79, 8, 0b00000000000000000);
    set_DBGVCR(__tc79);
    __tc80 : bits(32) = get_DBGVCR();
    let __tc80 = __SetSlice_bits(32, 1, __tc80, 5, 0b0);
    set_DBGVCR(__tc80);
    __tc81 : bits(32) = get_DBGVCR();
    let __tc81 = __SetSlice_bits(32, 1, __tc81, 0, 0b0);
    set_DBGVCR(__tc81);
    __tc82 : bits(32) = get_DBGVCR();
    let __tc82 = __SetSlice_bits(32, 24, __tc82, 8, 0x000000);
    set_DBGVCR(__tc82);
    __tc83 : bits(32) = get_DBGVCR();
    let __tc83 = __SetSlice_bits(32, 1, __tc83, 5, 0b0);
    set_DBGVCR(__tc83);
    __tc84 : bits(32) = get_DBGVCR();
    let __tc84 = __SetSlice_bits(32, 1, __tc84, 0, 0b0);
    set_DBGVCR(__tc84);
    DBGWFAR = __SetSlice_bits(32, 32, DBGWFAR, 0, 0x00000000);
    __tc85 : bits(32) = get_DFSR();
    let __tc85 = __SetSlice_bits(32, 15, __tc85, 17, 0b000000000000000);
    set_DFSR(__tc85);
    __tc86 : bits(32) = get_DFSR();
    let __tc86 = __SetSlice_bits(32, 1, __tc86, 8, 0b0);
    set_DFSR(__tc86);
    __tc87 : bits(32) = get_DFSR();
    let __tc87 = __SetSlice_bits(32, 15, __tc87, 17, 0b000000000000000);
    set_DFSR(__tc87);
    __tc88 : bits(32) = get_DFSR();
    let __tc88 = __SetSlice_bits(32, 1, __tc88, 10, 0b0);
    set_DFSR(__tc88);
    __tc89 : bits(32) = get_DFSR();
    let __tc89 = __SetSlice_bits(32, 3, __tc89, 6, 0b000);
    set_DFSR(__tc89);
    __tc90 : bits(32) = get_DSPSR();
    let __tc90 = __SetSlice_bits(32, 1, __tc90, 23, 0b0);
    set_DSPSR(__tc90);
    FCSEIDR = __SetSlice_bits(32, 32, FCSEIDR, 0, 0x00000000);
    __tc91 : bits(32) = get_FPEXC();
    let __tc91 = __SetSlice_bits(32, 1, __tc91, 30, 0b0);
    set_FPEXC(__tc91);
    __tc92 : bits(32) = get_FPEXC();
    let __tc92 = __SetSlice_bits(32, 15, __tc92, 11, 0b000000000000000);
    set_FPEXC(__tc92);
    __tc93 : bits(32) = get_FPEXC();
    let __tc93 = __SetSlice_bits(32, 2, __tc93, 5, 0b00);
    set_FPEXC(__tc93);
    FPSCR = __SetSlice_bits(32, 2, FPSCR, 13, 0b00);
    FPSCR = __SetSlice_bits(32, 2, FPSCR, 5, 0b00);
    __tc94 : bits(32) = get_HCPTR();
    let __tc94 = __SetSlice_bits(32, 1, __tc94, 31, 0b0);
    set_HCPTR(__tc94);
    __tc95 : bits(32) = get_HCPTR();
    let __tc95 = __SetSlice_bits(32, 9, __tc95, 21, 0b000000000);
    set_HCPTR(__tc95);
    __tc96 : bits(32) = get_HCPTR();
    let __tc96 = __SetSlice_bits(32, 1, __tc96, 20, 0b0);
    set_HCPTR(__tc96);
    __tc97 : bits(32) = get_HCPTR();
    let __tc97 = __SetSlice_bits(32, 4, __tc97, 16, 0x0);
    set_HCPTR(__tc97);
    __tc98 : bits(32) = get_HCPTR();
    let __tc98 = __SetSlice_bits(32, 1, __tc98, 15, 0b0);
    set_HCPTR(__tc98);
    __tc99 : bits(32) = get_HCPTR();
    let __tc99 = __SetSlice_bits(32, 1, __tc99, 14, 0b0);
    set_HCPTR(__tc99);
    __tc100 : bits(32) = get_HCPTR();
    let __tc100 = __SetSlice_bits(32, 2, __tc100, 12, 0b01);
    set_HCPTR(__tc100);
    __tc101 : bits(32) = get_HCPTR();
    let __tc101 = __SetSlice_bits(32, 1, __tc101, 11, 0b0);
    set_HCPTR(__tc101);
    __tc102 : bits(32) = get_HCPTR();
    let __tc102 = __SetSlice_bits(32, 1, __tc102, 10, 0b0);
    set_HCPTR(__tc102);
    __tc103 : bits(32) = get_HCPTR();
    let __tc103 = __SetSlice_bits(32, 10, __tc103, 0, 0b0000000001);
    set_HCPTR(__tc103);
    __tc104 : bits(32) = get_HCR();
    let __tc104 = __SetSlice_bits(32, 1, __tc104, 31, 0b0);
    set_HCR(__tc104);
    __tc105 : bits(32) = get_HCR();
    let __tc105 = __SetSlice_bits(32, 1, __tc105, 30, 0b0);
    set_HCR(__tc105);
    __tc106 : bits(32) = get_HCR();
    let __tc106 = __SetSlice_bits(32, 1, __tc106, 29, 0b0);
    set_HCR(__tc106);
    __tc107 : bits(32) = get_HCR();
    let __tc107 = __SetSlice_bits(32, 1, __tc107, 28, 0b0);
    set_HCR(__tc107);
    __tc108 : bits(32) = get_HCR();
    let __tc108 = __SetSlice_bits(32, 1, __tc108, 27, 0b0);
    set_HCR(__tc108);
    __tc109 : bits(32) = get_HCR();
    let __tc109 = __SetSlice_bits(32, 1, __tc109, 26, 0b0);
    set_HCR(__tc109);
    __tc110 : bits(32) = get_HCR();
    let __tc110 = __SetSlice_bits(32, 1, __tc110, 25, 0b0);
    set_HCR(__tc110);
    __tc111 : bits(32) = get_HCR();
    let __tc111 = __SetSlice_bits(32, 1, __tc111, 24, 0b0);
    set_HCR(__tc111);
    __tc112 : bits(32) = get_HCR();
    let __tc112 = __SetSlice_bits(32, 1, __tc112, 23, 0b0);
    set_HCR(__tc112);
    __tc113 : bits(32) = get_HCR();
    let __tc113 = __SetSlice_bits(32, 1, __tc113, 22, 0b0);
    set_HCR(__tc113);
    __tc114 : bits(32) = get_HCR();
    let __tc114 = __SetSlice_bits(32, 1, __tc114, 21, 0b0);
    set_HCR(__tc114);
    __tc115 : bits(32) = get_HCR();
    let __tc115 = __SetSlice_bits(32, 1, __tc115, 20, 0b0);
    set_HCR(__tc115);
    __tc116 : bits(32) = get_HCR();
    let __tc116 = __SetSlice_bits(32, 1, __tc116, 19, 0b0);
    set_HCR(__tc116);
    __tc117 : bits(32) = get_HCR();
    let __tc117 = __SetSlice_bits(32, 1, __tc117, 18, 0b0);
    set_HCR(__tc117);
    __tc118 : bits(32) = get_HCR();
    let __tc118 = __SetSlice_bits(32, 1, __tc118, 17, 0b0);
    set_HCR(__tc118);
    __tc119 : bits(32) = get_HCR();
    let __tc119 = __SetSlice_bits(32, 1, __tc119, 16, 0b0);
    set_HCR(__tc119);
    __tc120 : bits(32) = get_HCR();
    let __tc120 = __SetSlice_bits(32, 1, __tc120, 15, 0b0);
    set_HCR(__tc120);
    __tc121 : bits(32) = get_HCR();
    let __tc121 = __SetSlice_bits(32, 1, __tc121, 14, 0b0);
    set_HCR(__tc121);
    __tc122 : bits(32) = get_HCR();
    let __tc122 = __SetSlice_bits(32, 1, __tc122, 13, 0b0);
    set_HCR(__tc122);
    __tc123 : bits(32) = get_HCR();
    let __tc123 = __SetSlice_bits(32, 1, __tc123, 12, 0b0);
    set_HCR(__tc123);
    __tc124 : bits(32) = get_HCR();
    let __tc124 = __SetSlice_bits(32, 2, __tc124, 10, 0b00);
    set_HCR(__tc124);
    __tc125 : bits(32) = get_HCR();
    let __tc125 = __SetSlice_bits(32, 1, __tc125, 9, 0b0);
    set_HCR(__tc125);
    __tc126 : bits(32) = get_HCR();
    let __tc126 = __SetSlice_bits(32, 1, __tc126, 8, 0b0);
    set_HCR(__tc126);
    __tc127 : bits(32) = get_HCR();
    let __tc127 = __SetSlice_bits(32, 1, __tc127, 7, 0b0);
    set_HCR(__tc127);
    __tc128 : bits(32) = get_HCR();
    let __tc128 = __SetSlice_bits(32, 1, __tc128, 6, 0b0);
    set_HCR(__tc128);
    __tc129 : bits(32) = get_HCR();
    let __tc129 = __SetSlice_bits(32, 1, __tc129, 5, 0b0);
    set_HCR(__tc129);
    __tc130 : bits(32) = get_HCR();
    let __tc130 = __SetSlice_bits(32, 1, __tc130, 4, 0b0);
    set_HCR(__tc130);
    __tc131 : bits(32) = get_HCR();
    let __tc131 = __SetSlice_bits(32, 1, __tc131, 3, 0b0);
    set_HCR(__tc131);
    __tc132 : bits(32) = get_HCR();
    let __tc132 = __SetSlice_bits(32, 1, __tc132, 2, 0b0);
    set_HCR(__tc132);
    __tc133 : bits(32) = get_HCR();
    let __tc133 = __SetSlice_bits(32, 1, __tc133, 1, 0b0);
    set_HCR(__tc133);
    __tc134 : bits(32) = get_HCR();
    let __tc134 = __SetSlice_bits(32, 1, __tc134, 0, 0b0);
    set_HCR(__tc134);
    __tc135 : bits(32) = get_HCR2();
    let __tc135 = __SetSlice_bits(32, 9, __tc135, 23, 0b000000000);
    set_HCR2(__tc135);
    __tc136 : bits(32) = get_HCR2();
    let __tc136 = __SetSlice_bits(32, 3, __tc136, 19, 0b000);
    set_HCR2(__tc136);
    __tc137 : bits(32) = get_HCR2();
    let __tc137 = __SetSlice_bits(32, 9, __tc137, 7, 0b000000000);
    set_HCR2(__tc137);
    __tc138 : bits(32) = get_HCR2();
    let __tc138 = __SetSlice_bits(32, 1, __tc138, 5, 0b0);
    set_HCR2(__tc138);
    __tc139 : bits(32) = get_HCR2();
    let __tc139 = __SetSlice_bits(32, 1, __tc139, 4, 0b0);
    set_HCR2(__tc139);
    __tc140 : bits(32) = get_HCR2();
    let __tc140 = __SetSlice_bits(32, 2, __tc140, 2, 0b00);
    set_HCR2(__tc140);
    __tc141 : bits(32) = get_HCR2();
    let __tc141 = __SetSlice_bits(32, 1, __tc141, 1, 0b0);
    set_HCR2(__tc141);
    __tc142 : bits(32) = get_HCR2();
    let __tc142 = __SetSlice_bits(32, 1, __tc142, 0, 0b0);
    set_HCR2(__tc142);
    __tc143 : bits(32) = get_HDCR();
    let __tc143 = __SetSlice_bits(32, 5, __tc143, 27, 0b00000);
    set_HDCR(__tc143);
    __tc144 : bits(32) = get_HDCR();
    let __tc144 = __SetSlice_bits(32, 1, __tc144, 26, 0b0);
    set_HDCR(__tc144);
    __tc145 : bits(32) = get_HDCR();
    let __tc145 = __SetSlice_bits(32, 2, __tc145, 24, 0b00);
    set_HDCR(__tc145);
    __tc146 : bits(32) = get_HDCR();
    let __tc146 = __SetSlice_bits(32, 1, __tc146, 23, 0b0);
    set_HDCR(__tc146);
    __tc147 : bits(32) = get_HDCR();
    let __tc147 = __SetSlice_bits(32, 3, __tc147, 20, 0b000);
    set_HDCR(__tc147);
    __tc148 : bits(32) = get_HDCR();
    let __tc148 = __SetSlice_bits(32, 1, __tc148, 18, 0b0);
    set_HDCR(__tc148);
    __tc149 : bits(32) = get_HDCR();
    let __tc149 = __SetSlice_bits(32, 1, __tc149, 17, 0b0);
    set_HDCR(__tc149);
    __tc150 : bits(32) = get_HDCR();
    let __tc150 = __SetSlice_bits(32, 5, __tc150, 12, 0b00000);
    set_HDCR(__tc150);
    __tc151 : bits(32) = get_HDCR();
    let __tc151 = __SetSlice_bits(32, 1, __tc151, 11, 0b0);
    set_HDCR(__tc151);
    __tc152 : bits(32) = get_HDCR();
    let __tc152 = __SetSlice_bits(32, 1, __tc152, 10, 0b0);
    set_HDCR(__tc152);
    __tc153 : bits(32) = get_HDCR();
    let __tc153 = __SetSlice_bits(32, 1, __tc153, 9, 0b0);
    set_HDCR(__tc153);
    __tc154 : bits(32) = get_HDCR();
    let __tc154 = __SetSlice_bits(32, 1, __tc154, 8, 0b0);
    set_HDCR(__tc154);
    __tc155 : bits(32) = get_HDCR();
    let __tc155 = __SetSlice_bits(32, 1, __tc155, 6, 0b0);
    set_HDCR(__tc155);
    __tc156 : bits(32) = get_HDCR();
    let __tc156 = __SetSlice_bits(32, 1, __tc156, 5, 0b0);
    set_HDCR(__tc156);
    __tc157 : bits(32) = get_HPFAR();
    let __tc157 = __SetSlice_bits(32, 4, __tc157, 0, 0x0);
    set_HPFAR(__tc157);
    __tc158 : bits(32) = get_HRMR();
    let __tc158 = __SetSlice_bits(32, 30, __tc158, 2, 0b000000000000000000000000000000);
    set_HRMR(__tc158);
    __tc159 : bits(32) = get_HRMR();
    let __tc159 = __SetSlice_bits(32, 1, __tc159, 1, 0b0);
    set_HRMR(__tc159);
    __tc160 : bits(32) = get_HSCTLR();
    let __tc160 = __SetSlice_bits(32, 2, __tc160, 28, 0b01);
    set_HSCTLR(__tc160);
    __tc161 : bits(32) = get_HSCTLR();
    let __tc161 = __SetSlice_bits(32, 2, __tc161, 26, 0b00);
    set_HSCTLR(__tc161);
    __tc162 : bits(32) = get_HSCTLR();
    let __tc162 = __SetSlice_bits(32, 1, __tc162, 24, 0b0);
    set_HSCTLR(__tc162);
    __tc163 : bits(32) = get_HSCTLR();
    let __tc163 = __SetSlice_bits(32, 2, __tc163, 22, 0b01);
    set_HSCTLR(__tc163);
    __tc164 : bits(32) = get_HSCTLR();
    let __tc164 = __SetSlice_bits(32, 2, __tc164, 20, 0b00);
    set_HSCTLR(__tc164);
    __tc165 : bits(32) = get_HSCTLR();
    let __tc165 = __SetSlice_bits(32, 1, __tc165, 18, 0b1);
    set_HSCTLR(__tc165);
    __tc166 : bits(32) = get_HSCTLR();
    let __tc166 = __SetSlice_bits(32, 1, __tc166, 17, 0b0);
    set_HSCTLR(__tc166);
    __tc167 : bits(32) = get_HSCTLR();
    let __tc167 = __SetSlice_bits(32, 1, __tc167, 16, 0b1);
    set_HSCTLR(__tc167);
    __tc168 : bits(32) = get_HSCTLR();
    let __tc168 = __SetSlice_bits(32, 3, __tc168, 13, 0b000);
    set_HSCTLR(__tc168);
    __tc169 : bits(32) = get_HSCTLR();
    let __tc169 = __SetSlice_bits(32, 1, __tc169, 12, 0b0);
    set_HSCTLR(__tc169);
    __tc170 : bits(32) = get_HSCTLR();
    let __tc170 = __SetSlice_bits(32, 1, __tc170, 11, 0b1);
    set_HSCTLR(__tc170);
    __tc171 : bits(32) = get_HSCTLR();
    let __tc171 = __SetSlice_bits(32, 2, __tc171, 9, 0b00);
    set_HSCTLR(__tc171);
    __tc172 : bits(32) = get_HSCTLR();
    let __tc172 = __SetSlice_bits(32, 1, __tc172, 6, 0b0);
    set_HSCTLR(__tc172);
    __tc173 : bits(32) = get_HSCTLR();
    let __tc173 = __SetSlice_bits(32, 1, __tc173, 4, 0b1);
    set_HSCTLR(__tc173);
    __tc174 : bits(32) = get_HSCTLR();
    let __tc174 = __SetSlice_bits(32, 1, __tc174, 3, 0b1);
    set_HSCTLR(__tc174);
    __tc175 : bits(32) = get_HSCTLR();
    let __tc175 = __SetSlice_bits(32, 1, __tc175, 2, 0b0);
    set_HSCTLR(__tc175);
    __tc176 : bits(32) = get_HSCTLR();
    let __tc176 = __SetSlice_bits(32, 1, __tc176, 0, 0b0);
    set_HSCTLR(__tc176);
    __tc177 : bits(32) = get_HSTR();
    let __tc177 = __SetSlice_bits(32, 16, __tc177, 16, 0x0000);
    set_HSTR(__tc177);
    __tc178 : bits(32) = get_HSTR();
    let __tc178 = __SetSlice_bits(32, 16, __tc178, 0, 0x0000);
    set_HSTR(__tc178);
    __tc179 : bits(32) = get_HTCR();
    let __tc179 = __SetSlice_bits(32, 1, __tc179, 31, 0b1);
    set_HTCR(__tc179);
    __tc180 : bits(32) = get_HTCR();
    let __tc180 = __SetSlice_bits(32, 1, __tc180, 29, 0b0);
    set_HTCR(__tc180);
    __tc181 : bits(32) = get_HTCR();
    let __tc181 = __SetSlice_bits(32, 1, __tc181, 23, 0b1);
    set_HTCR(__tc181);
    __tc182 : bits(32) = get_HTCR();
    let __tc182 = __SetSlice_bits(32, 9, __tc182, 14, 0b000000000);
    set_HTCR(__tc182);
    __tc183 : bits(32) = get_HTCR();
    let __tc183 = __SetSlice_bits(32, 5, __tc183, 3, 0b00000);
    set_HTCR(__tc183);
    __tc184 : bits(32) = get_HTRFCR();
    let __tc184 = __SetSlice_bits(32, 25, __tc184, 7, 0b0000000000000000000000000);
    set_HTRFCR(__tc184);
    __tc185 : bits(32) = get_HTRFCR();
    let __tc185 = __SetSlice_bits(32, 2, __tc185, 5, 0b00);
    set_HTRFCR(__tc185);
    __tc186 : bits(32) = get_HTRFCR();
    let __tc186 = __SetSlice_bits(32, 1, __tc186, 4, 0b0);
    set_HTRFCR(__tc186);
    __tc187 : bits(32) = get_HTRFCR();
    let __tc187 = __SetSlice_bits(32, 1, __tc187, 3, 0b0);
    set_HTRFCR(__tc187);
    __tc188 : bits(32) = get_HTRFCR();
    let __tc188 = __SetSlice_bits(32, 1, __tc188, 2, 0b0);
    set_HTRFCR(__tc188);
    __tc189 : bits(32) = get_HTRFCR();
    let __tc189 = __SetSlice_bits(32, 1, __tc189, 1, 0b0);
    set_HTRFCR(__tc189);
    __tc190 : bits(32) = get_HTRFCR();
    let __tc190 = __SetSlice_bits(32, 1, __tc190, 0, 0b0);
    set_HTRFCR(__tc190);
    __tc191 : bits(64) = get_HTTBR();
    let __tc191 = __SetSlice_bits(64, 16, __tc191, 48, 0x0000);
    set_HTTBR(__tc191);
    __tc192 : bits(32) = get_HVBAR();
    let __tc192 = __SetSlice_bits(32, 5, __tc192, 0, 0b00000);
    set_HVBAR(__tc192);
    __tc193 : bits(64) = get_ICC_ASGI1R();
    let __tc193 = __SetSlice_bits(64, 8, __tc193, 56, 0x00);
    set_ICC_ASGI1R(__tc193);
    __tc194 : bits(64) = get_ICC_ASGI1R();
    let __tc194 = __SetSlice_bits(64, 3, __tc194, 41, 0b000);
    set_ICC_ASGI1R(__tc194);
    __tc195 : bits(64) = get_ICC_ASGI1R();
    let __tc195 = __SetSlice_bits(64, 4, __tc195, 28, 0x0);
    set_ICC_ASGI1R(__tc195);
    __tc196 : bits(32) = get_ICC_BPR0();
    let __tc196 = __SetSlice_bits(32, 29, __tc196, 3, 0b00000000000000000000000000000);
    set_ICC_BPR0(__tc196);
    __tc197 : bits(32) = get_ICC_BPR1();
    let __tc197 = __SetSlice_bits(32, 29, __tc197, 3, 0b00000000000000000000000000000);
    set_ICC_BPR1(__tc197);
    __tc198 : bits(32) = get_ICC_CTLR();
    let __tc198 = __SetSlice_bits(32, 13, __tc198, 19, 0b0000000000000);
    set_ICC_CTLR(__tc198);
    __tc199 : bits(32) = get_ICC_CTLR();
    let __tc199 = __SetSlice_bits(32, 2, __tc199, 16, 0b00);
    set_ICC_CTLR(__tc199);
    __tc200 : bits(32) = get_ICC_CTLR();
    let __tc200 = __SetSlice_bits(32, 1, __tc200, 7, 0b0);
    set_ICC_CTLR(__tc200);
    __tc201 : bits(32) = get_ICC_CTLR();
    let __tc201 = __SetSlice_bits(32, 4, __tc201, 2, 0x0);
    set_ICC_CTLR(__tc201);
    __tc202 : bits(32) = get_ICC_DIR();
    let __tc202 = __SetSlice_bits(32, 8, __tc202, 24, 0x00);
    set_ICC_DIR(__tc202);
    __tc203 : bits(32) = get_ICC_EOIR0();
    let __tc203 = __SetSlice_bits(32, 8, __tc203, 24, 0x00);
    set_ICC_EOIR0(__tc203);
    __tc204 : bits(32) = get_ICC_EOIR1();
    let __tc204 = __SetSlice_bits(32, 8, __tc204, 24, 0x00);
    set_ICC_EOIR1(__tc204);
    __tc205 : bits(32) = get_ICC_HPPIR0();
    let __tc205 = __SetSlice_bits(32, 8, __tc205, 24, 0x00);
    set_ICC_HPPIR0(__tc205);
    __tc206 : bits(32) = get_ICC_HPPIR1();
    let __tc206 = __SetSlice_bits(32, 8, __tc206, 24, 0x00);
    set_ICC_HPPIR1(__tc206);
    __tc207 : bits(32) = get_ICC_HSRE();
    let __tc207 = __SetSlice_bits(32, 28, __tc207, 4, 0x0000000);
    set_ICC_HSRE(__tc207);
    __tc208 : bits(32) = get_ICC_HSRE();
    let __tc208 = __SetSlice_bits(32, 1, __tc208, 2, 0b0);
    set_ICC_HSRE(__tc208);
    __tc209 : bits(32) = get_ICC_HSRE();
    let __tc209 = __SetSlice_bits(32, 1, __tc209, 1, 0b0);
    set_ICC_HSRE(__tc209);
    __tc210 : bits(32) = get_ICC_HSRE();
    let __tc210 = __SetSlice_bits(32, 1, __tc210, 0, 0b0);
    set_ICC_HSRE(__tc210);
    __tc211 : bits(32) = get_ICC_IAR0();
    let __tc211 = __SetSlice_bits(32, 8, __tc211, 24, 0x00);
    set_ICC_IAR0(__tc211);
    __tc212 : bits(32) = get_ICC_IAR1();
    let __tc212 = __SetSlice_bits(32, 8, __tc212, 24, 0x00);
    set_ICC_IAR1(__tc212);
    __tc213 : bits(32) = get_ICC_IGRPEN0();
    let __tc213 = __SetSlice_bits(32, 31, __tc213, 1, 0b0000000000000000000000000000000);
    set_ICC_IGRPEN0(__tc213);
    __tc214 : bits(32) = get_ICC_IGRPEN0();
    let __tc214 = __SetSlice_bits(32, 1, __tc214, 0, 0b0);
    set_ICC_IGRPEN0(__tc214);
    __tc215 : bits(32) = get_ICC_IGRPEN1();
    let __tc215 = __SetSlice_bits(32, 31, __tc215, 1, 0b0000000000000000000000000000000);
    set_ICC_IGRPEN1(__tc215);
    __tc216 : bits(32) = get_ICC_IGRPEN1();
    let __tc216 = __SetSlice_bits(32, 1, __tc216, 0, 0b0);
    set_ICC_IGRPEN1(__tc216);
    __tc217 : bits(32) = get_ICC_MCTLR();
    let __tc217 = __SetSlice_bits(32, 13, __tc217, 19, 0b0000000000000);
    set_ICC_MCTLR(__tc217);
    __tc218 : bits(32) = get_ICC_MCTLR();
    let __tc218 = __SetSlice_bits(32, 1, __tc218, 16, 0b0);
    set_ICC_MCTLR(__tc218);
    __tc219 : bits(32) = get_ICC_MCTLR();
    let __tc219 = __SetSlice_bits(32, 1, __tc219, 7, 0b0);
    set_ICC_MCTLR(__tc219);
    __tc220 : bits(32) = get_ICC_MCTLR();
    let __tc220 = __SetSlice_bits(32, 1, __tc220, 6, 0b0);
    set_ICC_MCTLR(__tc220);
    __tc221 : bits(32) = get_ICC_MGRPEN1();
    let __tc221 = __SetSlice_bits(32, 30, __tc221, 2, 0b000000000000000000000000000000);
    set_ICC_MGRPEN1(__tc221);
    __tc222 : bits(32) = get_ICC_MGRPEN1();
    let __tc222 = __SetSlice_bits(32, 1, __tc222, 1, 0b0);
    set_ICC_MGRPEN1(__tc222);
    __tc223 : bits(32) = get_ICC_MGRPEN1();
    let __tc223 = __SetSlice_bits(32, 1, __tc223, 0, 0b0);
    set_ICC_MGRPEN1(__tc223);
    __tc224 : bits(32) = get_ICC_MSRE();
    let __tc224 = __SetSlice_bits(32, 28, __tc224, 4, 0x0000000);
    set_ICC_MSRE(__tc224);
    __tc225 : bits(32) = get_ICC_MSRE();
    let __tc225 = __SetSlice_bits(32, 1, __tc225, 2, 0b0);
    set_ICC_MSRE(__tc225);
    __tc226 : bits(32) = get_ICC_MSRE();
    let __tc226 = __SetSlice_bits(32, 1, __tc226, 1, 0b0);
    set_ICC_MSRE(__tc226);
    __tc227 : bits(32) = get_ICC_MSRE();
    let __tc227 = __SetSlice_bits(32, 1, __tc227, 0, 0b0);
    set_ICC_MSRE(__tc227);
    __tc228 : bits(32) = get_ICC_PMR();
    let __tc228 = __SetSlice_bits(32, 24, __tc228, 8, 0x000000);
    set_ICC_PMR(__tc228);
    __tc229 : bits(32) = get_ICC_PMR();
    let __tc229 = __SetSlice_bits(32, 8, __tc229, 0, 0x00);
    set_ICC_PMR(__tc229);
    __tc230 : bits(32) = get_ICC_RPR();
    let __tc230 = __SetSlice_bits(32, 24, __tc230, 8, 0x000000);
    set_ICC_RPR(__tc230);
    __tc231 : bits(64) = get_ICC_SGI0R();
    let __tc231 = __SetSlice_bits(64, 8, __tc231, 56, 0x00);
    set_ICC_SGI0R(__tc231);
    __tc232 : bits(64) = get_ICC_SGI0R();
    let __tc232 = __SetSlice_bits(64, 3, __tc232, 41, 0b000);
    set_ICC_SGI0R(__tc232);
    __tc233 : bits(64) = get_ICC_SGI0R();
    let __tc233 = __SetSlice_bits(64, 4, __tc233, 28, 0x0);
    set_ICC_SGI0R(__tc233);
    __tc234 : bits(64) = get_ICC_SGI1R();
    let __tc234 = __SetSlice_bits(64, 8, __tc234, 56, 0x00);
    set_ICC_SGI1R(__tc234);
    __tc235 : bits(64) = get_ICC_SGI1R();
    let __tc235 = __SetSlice_bits(64, 3, __tc235, 41, 0b000);
    set_ICC_SGI1R(__tc235);
    __tc236 : bits(64) = get_ICC_SGI1R();
    let __tc236 = __SetSlice_bits(64, 4, __tc236, 28, 0x0);
    set_ICC_SGI1R(__tc236);
    __tc237 : bits(32) = get_ICC_SRE();
    let __tc237 = __SetSlice_bits(32, 29, __tc237, 3, 0b00000000000000000000000000000);
    set_ICC_SRE(__tc237);
    __tc238 : bits(32) = get_ICC_SRE();
    let __tc238 = __SetSlice_bits(32, 1, __tc238, 2, 0b0);
    set_ICC_SRE(__tc238);
    __tc239 : bits(32) = get_ICC_SRE();
    let __tc239 = __SetSlice_bits(32, 1, __tc239, 1, 0b0);
    set_ICC_SRE(__tc239);
    __tc240 : bits(32) = get_ICC_SRE();
    let __tc240 = __SetSlice_bits(32, 1, __tc240, 0, 0b0);
    set_ICC_SRE(__tc240);
    __tc241 : bits(32) = get_ICH_EISR();
    let __tc241 = __SetSlice_bits(32, 16, __tc241, 16, 0x0000);
    set_ICH_EISR(__tc241);
    __tc242 : bits(32) = get_ICH_EISR();
    let __tc242 = __SetSlice_bits(32, 16, __tc242, 0, 0x0000);
    set_ICH_EISR(__tc242);
    __tc243 : bits(32) = get_ICH_ELRSR();
    let __tc243 = __SetSlice_bits(32, 16, __tc243, 16, 0x0000);
    set_ICH_ELRSR(__tc243);
    __tc244 : bits(32) = get_ICH_HCR();
    let __tc244 = __SetSlice_bits(32, 5, __tc244, 27, 0b00000);
    set_ICH_HCR(__tc244);
    __tc245 : bits(32) = get_ICH_HCR();
    let __tc245 = __SetSlice_bits(32, 12, __tc245, 15, 0x000);
    set_ICH_HCR(__tc245);
    __tc246 : bits(32) = get_ICH_HCR();
    let __tc246 = __SetSlice_bits(32, 1, __tc246, 14, 0b0);
    set_ICH_HCR(__tc246);
    __tc247 : bits(32) = get_ICH_HCR();
    let __tc247 = __SetSlice_bits(32, 1, __tc247, 13, 0b0);
    set_ICH_HCR(__tc247);
    __tc248 : bits(32) = get_ICH_HCR();
    let __tc248 = __SetSlice_bits(32, 1, __tc248, 12, 0b0);
    set_ICH_HCR(__tc248);
    __tc249 : bits(32) = get_ICH_HCR();
    let __tc249 = __SetSlice_bits(32, 1, __tc249, 11, 0b0);
    set_ICH_HCR(__tc249);
    __tc250 : bits(32) = get_ICH_HCR();
    let __tc250 = __SetSlice_bits(32, 1, __tc250, 10, 0b0);
    set_ICH_HCR(__tc250);
    __tc251 : bits(32) = get_ICH_HCR();
    let __tc251 = __SetSlice_bits(32, 2, __tc251, 8, 0b00);
    set_ICH_HCR(__tc251);
    __tc252 : bits(32) = get_ICH_HCR();
    let __tc252 = __SetSlice_bits(32, 1, __tc252, 7, 0b0);
    set_ICH_HCR(__tc252);
    __tc253 : bits(32) = get_ICH_HCR();
    let __tc253 = __SetSlice_bits(32, 1, __tc253, 6, 0b0);
    set_ICH_HCR(__tc253);
    __tc254 : bits(32) = get_ICH_HCR();
    let __tc254 = __SetSlice_bits(32, 1, __tc254, 5, 0b0);
    set_ICH_HCR(__tc254);
    __tc255 : bits(32) = get_ICH_HCR();
    let __tc255 = __SetSlice_bits(32, 1, __tc255, 4, 0b0);
    set_ICH_HCR(__tc255);
    __tc256 : bits(32) = get_ICH_HCR();
    let __tc256 = __SetSlice_bits(32, 1, __tc256, 3, 0b0);
    set_ICH_HCR(__tc256);
    __tc257 : bits(32) = get_ICH_HCR();
    let __tc257 = __SetSlice_bits(32, 1, __tc257, 2, 0b0);
    set_ICH_HCR(__tc257);
    __tc258 : bits(32) = get_ICH_HCR();
    let __tc258 = __SetSlice_bits(32, 1, __tc258, 1, 0b0);
    set_ICH_HCR(__tc258);
    __tc259 : bits(32) = get_ICH_HCR();
    let __tc259 = __SetSlice_bits(32, 1, __tc259, 0, 0b0);
    set_ICH_HCR(__tc259);
    __tc260 : bits(32) = get_ICH_MISR();
    let __tc260 = __SetSlice_bits(32, 24, __tc260, 8, 0x000000);
    set_ICH_MISR(__tc260);
    __tc261 : bits(32) = get_ICH_MISR();
    let __tc261 = __SetSlice_bits(32, 1, __tc261, 7, 0b0);
    set_ICH_MISR(__tc261);
    __tc262 : bits(32) = get_ICH_MISR();
    let __tc262 = __SetSlice_bits(32, 1, __tc262, 6, 0b0);
    set_ICH_MISR(__tc262);
    __tc263 : bits(32) = get_ICH_MISR();
    let __tc263 = __SetSlice_bits(32, 1, __tc263, 5, 0b0);
    set_ICH_MISR(__tc263);
    __tc264 : bits(32) = get_ICH_MISR();
    let __tc264 = __SetSlice_bits(32, 1, __tc264, 4, 0b0);
    set_ICH_MISR(__tc264);
    __tc265 : bits(32) = get_ICH_MISR();
    let __tc265 = __SetSlice_bits(32, 1, __tc265, 3, 0b0);
    set_ICH_MISR(__tc265);
    __tc266 : bits(32) = get_ICH_MISR();
    let __tc266 = __SetSlice_bits(32, 1, __tc266, 2, 0b0);
    set_ICH_MISR(__tc266);
    __tc267 : bits(32) = get_ICH_MISR();
    let __tc267 = __SetSlice_bits(32, 1, __tc267, 1, 0b0);
    set_ICH_MISR(__tc267);
    __tc268 : bits(32) = get_ICH_MISR();
    let __tc268 = __SetSlice_bits(32, 1, __tc268, 0, 0b0);
    set_ICH_MISR(__tc268);
    __tc269 : bits(32) = get_ICH_VMCR();
    let __tc269 = __SetSlice_bits(32, 8, __tc269, 10, 0x00);
    set_ICH_VMCR(__tc269);
    __tc270 : bits(32) = get_ICH_VMCR();
    let __tc270 = __SetSlice_bits(32, 4, __tc270, 5, 0x0);
    set_ICH_VMCR(__tc270);
    __tc271 : bits(32) = get_ICH_VTR();
    let __tc271 = __SetSlice_bits(32, 14, __tc271, 5, 0b00000000000000);
    set_ICH_VTR(__tc271);
    __tc272 : bits(32) = get_ICV_BPR0();
    let __tc272 = __SetSlice_bits(32, 29, __tc272, 3, 0b00000000000000000000000000000);
    set_ICV_BPR0(__tc272);
    __tc273 : bits(32) = get_ICV_BPR1();
    let __tc273 = __SetSlice_bits(32, 29, __tc273, 3, 0b00000000000000000000000000000);
    set_ICV_BPR1(__tc273);
    __tc274 : bits(32) = get_ICV_CTLR();
    let __tc274 = __SetSlice_bits(32, 13, __tc274, 19, 0b0000000000000);
    set_ICV_CTLR(__tc274);
    __tc275 : bits(32) = get_ICV_CTLR();
    let __tc275 = __SetSlice_bits(32, 2, __tc275, 16, 0b00);
    set_ICV_CTLR(__tc275);
    __tc276 : bits(32) = get_ICV_CTLR();
    let __tc276 = __SetSlice_bits(32, 6, __tc276, 2, 0b000000);
    set_ICV_CTLR(__tc276);
    __tc277 : bits(32) = get_ICV_DIR();
    let __tc277 = __SetSlice_bits(32, 8, __tc277, 24, 0x00);
    set_ICV_DIR(__tc277);
    __tc278 : bits(32) = get_ICV_EOIR0();
    let __tc278 = __SetSlice_bits(32, 8, __tc278, 24, 0x00);
    set_ICV_EOIR0(__tc278);
    __tc279 : bits(32) = get_ICV_EOIR1();
    let __tc279 = __SetSlice_bits(32, 8, __tc279, 24, 0x00);
    set_ICV_EOIR1(__tc279);
    __tc280 : bits(32) = get_ICV_HPPIR0();
    let __tc280 = __SetSlice_bits(32, 8, __tc280, 24, 0x00);
    set_ICV_HPPIR0(__tc280);
    __tc281 : bits(32) = get_ICV_HPPIR1();
    let __tc281 = __SetSlice_bits(32, 8, __tc281, 24, 0x00);
    set_ICV_HPPIR1(__tc281);
    __tc282 : bits(32) = get_ICV_IAR0();
    let __tc282 = __SetSlice_bits(32, 8, __tc282, 24, 0x00);
    set_ICV_IAR0(__tc282);
    __tc283 : bits(32) = get_ICV_IAR1();
    let __tc283 = __SetSlice_bits(32, 8, __tc283, 24, 0x00);
    set_ICV_IAR1(__tc283);
    __tc284 : bits(32) = get_ICV_IGRPEN0();
    let __tc284 = __SetSlice_bits(32, 31, __tc284, 1, 0b0000000000000000000000000000000);
    set_ICV_IGRPEN0(__tc284);
    __tc285 : bits(32) = get_ICV_IGRPEN0();
    let __tc285 = __SetSlice_bits(32, 1, __tc285, 0, 0b0);
    set_ICV_IGRPEN0(__tc285);
    __tc286 : bits(32) = get_ICV_IGRPEN1();
    let __tc286 = __SetSlice_bits(32, 31, __tc286, 1, 0b0000000000000000000000000000000);
    set_ICV_IGRPEN1(__tc286);
    __tc287 : bits(32) = get_ICV_IGRPEN1();
    let __tc287 = __SetSlice_bits(32, 1, __tc287, 0, 0b0);
    set_ICV_IGRPEN1(__tc287);
    __tc288 : bits(32) = get_ICV_PMR();
    let __tc288 = __SetSlice_bits(32, 24, __tc288, 8, 0x000000);
    set_ICV_PMR(__tc288);
    __tc289 : bits(32) = get_ICV_PMR();
    let __tc289 = __SetSlice_bits(32, 8, __tc289, 0, 0x00);
    set_ICV_PMR(__tc289);
    __tc290 : bits(32) = get_ICV_RPR();
    let __tc290 = __SetSlice_bits(32, 24, __tc290, 8, 0x000000);
    set_ICV_RPR(__tc290);
    __tc291 : bits(32) = get_ID_AFR0();
    let __tc291 = __SetSlice_bits(32, 16, __tc291, 16, 0x0000);
    set_ID_AFR0(__tc291);
    __tc292 : bits(32) = get_ID_ISAR0();
    let __tc292 = __SetSlice_bits(32, 4, __tc292, 28, 0x0);
    set_ID_ISAR0(__tc292);
    __tc293 : bits(32) = get_ID_ISAR5();
    let __tc293 = __SetSlice_bits(32, 4, __tc293, 20, 0x0);
    set_ID_ISAR5(__tc293);
    __tc294 : bits(32) = get_ID_ISAR6();
    let __tc294 = __SetSlice_bits(32, 12, __tc294, 20, 0x000);
    set_ID_ISAR6(__tc294);
    __tc295 : bits(32) = get_ID_PFR2();
    let __tc295 = __SetSlice_bits(32, 20, __tc295, 12, 0x00000);
    set_ID_PFR2(__tc295);
    __tc296 : bits(32) = get_ID_PFR2();
    let __tc296 = __SetSlice_bits(32, 4, __tc296, 8, 0x0);
    set_ID_PFR2(__tc296);
    __tc297 : bits(32) = get_IFSR();
    let __tc297 = __SetSlice_bits(32, 15, __tc297, 17, 0b000000000000000);
    set_IFSR(__tc297);
    __tc298 : bits(32) = get_IFSR();
    let __tc298 = __SetSlice_bits(32, 3, __tc298, 13, 0b000);
    set_IFSR(__tc298);
    __tc299 : bits(32) = get_IFSR();
    let __tc299 = __SetSlice_bits(32, 1, __tc299, 11, 0b0);
    set_IFSR(__tc299);
    __tc300 : bits(32) = get_IFSR();
    let __tc300 = __SetSlice_bits(32, 5, __tc300, 4, 0b00000);
    set_IFSR(__tc300);
    __tc301 : bits(32) = get_IFSR();
    let __tc301 = __SetSlice_bits(32, 15, __tc301, 17, 0b000000000000000);
    set_IFSR(__tc301);
    __tc302 : bits(32) = get_IFSR();
    let __tc302 = __SetSlice_bits(32, 3, __tc302, 13, 0b000);
    set_IFSR(__tc302);
    __tc303 : bits(32) = get_IFSR();
    let __tc303 = __SetSlice_bits(32, 2, __tc303, 10, 0b00);
    set_IFSR(__tc303);
    __tc304 : bits(32) = get_IFSR();
    let __tc304 = __SetSlice_bits(32, 3, __tc304, 6, 0b000);
    set_IFSR(__tc304);
    __tc305 : bits(32) = get_ISR();
    let __tc305 = __SetSlice_bits(32, 23, __tc305, 9, 0b00000000000000000000000);
    set_ISR(__tc305);
    __tc306 : bits(32) = get_ISR();
    let __tc306 = __SetSlice_bits(32, 6, __tc306, 0, 0b000000);
    set_ISR(__tc306);
    __tc307 : bits(32) = get_MPIDR();
    let __tc307 = __SetSlice_bits(32, 5, __tc307, 25, 0b00000);
    set_MPIDR(__tc307);
    __tc308 : bits(32) = get_MVFR2();
    let __tc308 = __SetSlice_bits(32, 24, __tc308, 8, 0x000000);
    set_MVFR2(__tc308);
    NSACR = __SetSlice_bits(32, 11, NSACR, 21, 0b00000000000);
    NSACR = __SetSlice_bits(32, 1, NSACR, 20, 0b0);
    NSACR = __SetSlice_bits(32, 1, NSACR, 19, 0b0);
    NSACR = __SetSlice_bits(32, 1, NSACR, 15, 0b0);
    NSACR = __SetSlice_bits(32, 3, NSACR, 12, 0b000);
    NSACR = __SetSlice_bits(32, 10, NSACR, 0, 0b0000000000);
    __tc309 : bits(64) = get_PAR();
    let __tc309 = __SetSlice_bits(64, 4, __tc309, 12, 0x0);
    set_PAR(__tc309);
    __tc310 : bits(64) = get_PAR();
    let __tc310 = __SetSlice_bits(64, 4, __tc310, 7, 0x0);
    set_PAR(__tc310);
    __tc311 : bits(64) = get_PAR();
    let __tc311 = __SetSlice_bits(64, 16, __tc311, 40, 0x0000);
    set_PAR(__tc311);
    __tc312 : bits(64) = get_PAR();
    let __tc312 = __SetSlice_bits(64, 6, __tc312, 1, 0b000000);
    set_PAR(__tc312);
    __tc313 : bits(64) = get_PAR();
    let __tc313 = __SetSlice_bits(64, 36, __tc313, 12, 0x000000000);
    set_PAR(__tc313);
    __tc314 : bits(64) = get_PAR();
    let __tc314 = __SetSlice_bits(64, 1, __tc314, 10, 0b0);
    set_PAR(__tc314);
    __tc315 : bits(64) = get_PAR();
    let __tc315 = __SetSlice_bits(64, 1, __tc315, 7, 0b0);
    set_PAR(__tc315);
    __tc316 : bits(32) = get_PMCCFILTR();
    let __tc316 = __SetSlice_bits(32, 1, __tc316, 31, 0b0);
    set_PMCCFILTR(__tc316);
    __tc317 : bits(32) = get_PMCCFILTR();
    let __tc317 = __SetSlice_bits(32, 1, __tc317, 30, 0b0);
    set_PMCCFILTR(__tc317);
    __tc318 : bits(32) = get_PMCCFILTR();
    let __tc318 = __SetSlice_bits(32, 1, __tc318, 29, 0b0);
    set_PMCCFILTR(__tc318);
    __tc319 : bits(32) = get_PMCCFILTR();
    let __tc319 = __SetSlice_bits(32, 1, __tc319, 28, 0b0);
    set_PMCCFILTR(__tc319);
    __tc320 : bits(32) = get_PMCCFILTR();
    let __tc320 = __SetSlice_bits(32, 1, __tc320, 27, 0b0);
    set_PMCCFILTR(__tc320);
    __tc321 : bits(32) = get_PMCCFILTR();
    let __tc321 = __SetSlice_bits(32, 27, __tc321, 0, 0b000000000000000000000000000);
    set_PMCCFILTR(__tc321);
    __tc322 : bits(32) = get_PMCR();
    let __tc322 = __SetSlice_bits(32, 3, __tc322, 8, 0b000);
    set_PMCR(__tc322);
    __tc323 : bits(32) = get_PMCR();
    let __tc323 = __SetSlice_bits(32, 1, __tc323, 7, 0b0);
    set_PMCR(__tc323);
    __tc324 : bits(32) = get_PMCR();
    let __tc324 = __SetSlice_bits(32, 1, __tc324, 5, 0b0);
    set_PMCR(__tc324);
    __tc325 : bits(32) = get_PMCR();
    let __tc325 = __SetSlice_bits(32, 1, __tc325, 4, 0b0);
    set_PMCR(__tc325);
    __tc326 : bits(32) = get_PMCR();
    let __tc326 = __SetSlice_bits(32, 1, __tc326, 3, 0b0);
    set_PMCR(__tc326);
    __tc327 : bits(32) = get_PMCR();
    let __tc327 = __SetSlice_bits(32, 1, __tc327, 0, 0b0);
    set_PMCR(__tc327);
    PMMIR = __SetSlice_bits(32, 24, PMMIR, 8, 0x000000);
    __tc328 : bits(32) = get_PMSELR();
    let __tc328 = __SetSlice_bits(32, 27, __tc328, 5, 0b000000000000000000000000000);
    set_PMSELR(__tc328);
    __tc329 : bits(32) = get_PMSWINC();
    let __tc329 = __SetSlice_bits(32, 1, __tc329, 31, 0b0);
    set_PMSWINC(__tc329);
    __tc330 : bits(32) = get_PMUSERENR();
    let __tc330 = __SetSlice_bits(32, 28, __tc330, 4, 0x0000000);
    set_PMUSERENR(__tc330);
    __tc331 : bits(32) = get_PMUSERENR();
    let __tc331 = __SetSlice_bits(32, 1, __tc331, 3, 0b0);
    set_PMUSERENR(__tc331);
    __tc332 : bits(32) = get_PMUSERENR();
    let __tc332 = __SetSlice_bits(32, 1, __tc332, 2, 0b0);
    set_PMUSERENR(__tc332);
    __tc333 : bits(32) = get_PMUSERENR();
    let __tc333 = __SetSlice_bits(32, 1, __tc333, 1, 0b0);
    set_PMUSERENR(__tc333);
    __tc334 : bits(32) = get_PMUSERENR();
    let __tc334 = __SetSlice_bits(32, 1, __tc334, 0, 0b0);
    set_PMUSERENR(__tc334);
    __tc335 : bits(32) = get_PRRR();
    let __tc335 = __SetSlice_bits(32, 4, __tc335, 20, 0x0);
    set_PRRR(__tc335);
    __tc336 : bits(32) = get_RMR();
    let __tc336 = __SetSlice_bits(32, 30, __tc336, 2, 0b000000000000000000000000000000);
    set_RMR(__tc336);
    __tc337 : bits(32) = get_RMR();
    let __tc337 = __SetSlice_bits(32, 1, __tc337, 1, 0b0);
    set_RMR(__tc337);
    RVBAR = __SetSlice_bits(32, 1, RVBAR, 0, 0b1);
    __tc338 : bits(32) = get_SCR();
    let __tc338 = __SetSlice_bits(32, 16, __tc338, 16, 0x0000);
    set_SCR(__tc338);
    __tc339 : bits(32) = get_SCR();
    let __tc339 = __SetSlice_bits(32, 1, __tc339, 15, 0b0);
    set_SCR(__tc339);
    __tc340 : bits(32) = get_SCR();
    let __tc340 = __SetSlice_bits(32, 1, __tc340, 14, 0b0);
    set_SCR(__tc340);
    __tc341 : bits(32) = get_SCR();
    let __tc341 = __SetSlice_bits(32, 1, __tc341, 13, 0b0);
    set_SCR(__tc341);
    __tc342 : bits(32) = get_SCR();
    let __tc342 = __SetSlice_bits(32, 1, __tc342, 12, 0b0);
    set_SCR(__tc342);
    __tc343 : bits(32) = get_SCR();
    let __tc343 = __SetSlice_bits(32, 2, __tc343, 10, 0b00);
    set_SCR(__tc343);
    __tc344 : bits(32) = get_SCR();
    let __tc344 = __SetSlice_bits(32, 1, __tc344, 9, 0b0);
    set_SCR(__tc344);
    __tc345 : bits(32) = get_SCR();
    let __tc345 = __SetSlice_bits(32, 1, __tc345, 8, 0b0);
    set_SCR(__tc345);
    __tc346 : bits(32) = get_SCR();
    let __tc346 = __SetSlice_bits(32, 1, __tc346, 7, 0b0);
    set_SCR(__tc346);
    __tc347 : bits(32) = get_SCR();
    let __tc347 = __SetSlice_bits(32, 1, __tc347, 6, 0b0);
    set_SCR(__tc347);
    __tc348 : bits(32) = get_SCR();
    let __tc348 = __SetSlice_bits(32, 1, __tc348, 5, 0b0);
    set_SCR(__tc348);
    __tc349 : bits(32) = get_SCR();
    let __tc349 = __SetSlice_bits(32, 1, __tc349, 4, 0b0);
    set_SCR(__tc349);
    __tc350 : bits(32) = get_SCR();
    let __tc350 = __SetSlice_bits(32, 1, __tc350, 3, 0b0);
    set_SCR(__tc350);
    __tc351 : bits(32) = get_SCR();
    let __tc351 = __SetSlice_bits(32, 1, __tc351, 2, 0b0);
    set_SCR(__tc351);
    __tc352 : bits(32) = get_SCR();
    let __tc352 = __SetSlice_bits(32, 1, __tc352, 1, 0b0);
    set_SCR(__tc352);
    __tc353 : bits(32) = get_SCR();
    let __tc353 = __SetSlice_bits(32, 1, __tc353, 0, 0b0);
    set_SCR(__tc353);
    __tc354 : bits(32) = get_SCTLR();
    let __tc354 = __SetSlice_bits(32, 1, __tc354, 29, 0b0);
    set_SCTLR(__tc354);
    __tc355 : bits(32) = get_SCTLR();
    let __tc355 = __SetSlice_bits(32, 1, __tc355, 28, 0b0);
    set_SCTLR(__tc355);
    __tc356 : bits(32) = get_SCTLR();
    let __tc356 = __SetSlice_bits(32, 2, __tc356, 26, 0b00);
    set_SCTLR(__tc356);
    __tc357 : bits(32) = get_SCTLR();
    let __tc357 = __SetSlice_bits(32, 1, __tc357, 24, 0b0);
    set_SCTLR(__tc357);
    __tc358 : bits(32) = get_SCTLR();
    let __tc358 = __SetSlice_bits(32, 1, __tc358, 22, 0b1);
    set_SCTLR(__tc358);
    __tc359 : bits(32) = get_SCTLR();
    let __tc359 = __SetSlice_bits(32, 1, __tc359, 21, 0b0);
    set_SCTLR(__tc359);
    __tc360 : bits(32) = get_SCTLR();
    let __tc360 = __SetSlice_bits(32, 1, __tc360, 20, 0b0);
    set_SCTLR(__tc360);
    __tc361 : bits(32) = get_SCTLR();
    let __tc361 = __SetSlice_bits(32, 1, __tc361, 19, 0b0);
    set_SCTLR(__tc361);
    __tc362 : bits(32) = get_SCTLR();
    let __tc362 = __SetSlice_bits(32, 1, __tc362, 18, 0b1);
    set_SCTLR(__tc362);
    __tc363 : bits(32) = get_SCTLR();
    let __tc363 = __SetSlice_bits(32, 1, __tc363, 17, 0b0);
    set_SCTLR(__tc363);
    __tc364 : bits(32) = get_SCTLR();
    let __tc364 = __SetSlice_bits(32, 1, __tc364, 16, 0b1);
    set_SCTLR(__tc364);
    __tc365 : bits(32) = get_SCTLR();
    let __tc365 = __SetSlice_bits(32, 2, __tc365, 14, 0b00);
    set_SCTLR(__tc365);
    __tc366 : bits(32) = get_SCTLR();
    let __tc366 = __SetSlice_bits(32, 1, __tc366, 12, 0b0);
    set_SCTLR(__tc366);
    __tc367 : bits(32) = get_SCTLR();
    let __tc367 = __SetSlice_bits(32, 1, __tc367, 11, 0b1);
    set_SCTLR(__tc367);
    __tc368 : bits(32) = get_SCTLR();
    let __tc368 = __SetSlice_bits(32, 1, __tc368, 9, 0b0);
    set_SCTLR(__tc368);
    __tc369 : bits(32) = get_SCTLR();
    let __tc369 = __SetSlice_bits(32, 1, __tc369, 8, 0b0);
    set_SCTLR(__tc369);
    __tc370 : bits(32) = get_SCTLR();
    let __tc370 = __SetSlice_bits(32, 1, __tc370, 7, 0b0);
    set_SCTLR(__tc370);
    __tc371 : bits(32) = get_SCTLR();
    let __tc371 = __SetSlice_bits(32, 1, __tc371, 5, 0b1);
    set_SCTLR(__tc371);
    __tc372 : bits(32) = get_SCTLR();
    let __tc372 = __SetSlice_bits(32, 1, __tc372, 4, 0b1);
    set_SCTLR(__tc372);
    __tc373 : bits(32) = get_SCTLR();
    let __tc373 = __SetSlice_bits(32, 1, __tc373, 3, 0b1);
    set_SCTLR(__tc373);
    __tc374 : bits(32) = get_SCTLR();
    let __tc374 = __SetSlice_bits(32, 1, __tc374, 2, 0b0);
    set_SCTLR(__tc374);
    __tc375 : bits(32) = get_SCTLR();
    let __tc375 = __SetSlice_bits(32, 1, __tc375, 1, 0b0);
    set_SCTLR(__tc375);
    __tc376 : bits(32) = get_SCTLR();
    let __tc376 = __SetSlice_bits(32, 1, __tc376, 0, 0b0);
    set_SCTLR(__tc376);
    __tc377 : bits(32) = get_SDCR();
    let __tc377 = __SetSlice_bits(32, 8, __tc377, 24, 0x00);
    set_SDCR(__tc377);
    __tc378 : bits(32) = get_SDCR();
    let __tc378 = __SetSlice_bits(32, 1, __tc378, 23, 0b0);
    set_SDCR(__tc378);
    __tc379 : bits(32) = get_SDCR();
    let __tc379 = __SetSlice_bits(32, 1, __tc379, 22, 0b0);
    set_SDCR(__tc379);
    __tc380 : bits(32) = get_SDCR();
    let __tc380 = __SetSlice_bits(32, 1, __tc380, 21, 0b0);
    set_SDCR(__tc380);
    __tc381 : bits(32) = get_SDCR();
    let __tc381 = __SetSlice_bits(32, 1, __tc381, 20, 0b0);
    set_SDCR(__tc381);
    __tc382 : bits(32) = get_SDCR();
    let __tc382 = __SetSlice_bits(32, 1, __tc382, 19, 0b0);
    set_SDCR(__tc382);
    __tc383 : bits(32) = get_SDCR();
    let __tc383 = __SetSlice_bits(32, 1, __tc383, 18, 0b0);
    set_SDCR(__tc383);
    __tc384 : bits(32) = get_SDCR();
    let __tc384 = __SetSlice_bits(32, 1, __tc384, 17, 0b0);
    set_SDCR(__tc384);
    __tc385 : bits(32) = get_SDCR();
    let __tc385 = __SetSlice_bits(32, 1, __tc385, 16, 0b0);
    set_SDCR(__tc385);
    __tc386 : bits(32) = get_SDCR();
    let __tc386 = __SetSlice_bits(32, 2, __tc386, 14, 0b00);
    set_SDCR(__tc386);
    __tc387 : bits(32) = get_SDCR();
    let __tc387 = __SetSlice_bits(32, 14, __tc387, 0, 0b00000000000000);
    set_SDCR(__tc387);
    __tc388 : bits(32) = get_SDER();
    let __tc388 = __SetSlice_bits(32, 30, __tc388, 2, 0b000000000000000000000000000000);
    set_SDER(__tc388);
    __tc389 : bits(32) = get_SDER();
    let __tc389 = __SetSlice_bits(32, 1, __tc389, 1, 0b0);
    set_SDER(__tc389);
    __tc390 : bits(32) = get_SDER();
    let __tc390 = __SetSlice_bits(32, 1, __tc390, 0, 0b0);
    set_SDER(__tc390);
    __tc391 : bits(32) = get_TRFCR();
    let __tc391 = __SetSlice_bits(32, 25, __tc391, 7, 0b0000000000000000000000000);
    set_TRFCR(__tc391);
    __tc392 : bits(32) = get_TRFCR();
    let __tc392 = __SetSlice_bits(32, 3, __tc392, 2, 0b000);
    set_TRFCR(__tc392);
    __tc393 : bits(32) = get_TRFCR();
    let __tc393 = __SetSlice_bits(32, 1, __tc393, 1, 0b0);
    set_TRFCR(__tc393);
    __tc394 : bits(32) = get_TRFCR();
    let __tc394 = __SetSlice_bits(32, 1, __tc394, 0, 0b0);
    set_TRFCR(__tc394);
    __tc395 : bits(32) = get_TTBCR2();
    let __tc395 = __SetSlice_bits(32, 13, __tc395, 19, 0b0000000000000);
    set_TTBCR2(__tc395);
    __tc396 : bits(32) = get_TTBCR2();
    let __tc396 = __SetSlice_bits(32, 9, __tc396, 0, 0b000000000);
    set_TTBCR2(__tc396);
    __tc397 : bits(64) = get_TTBR0();
    let __tc397 = __SetSlice_bits(64, 8, __tc397, 56, 0x00);
    set_TTBR0(__tc397);
    __tc398 : bits(64) = get_TTBR1();
    let __tc398 = __SetSlice_bits(64, 8, __tc398, 56, 0x00);
    set_TTBR1(__tc398);
    __tc399 : bits(32) = get_VBAR();
    let __tc399 = __SetSlice_bits(32, 5, __tc399, 0, 0b00000);
    set_VBAR(__tc399);
    __tc400 : bits(32) = get_VMPIDR();
    let __tc400 = __SetSlice_bits(32, 5, __tc400, 25, 0b00000);
    set_VMPIDR(__tc400);
    __tc401 : bits(32) = get_VTCR();
    let __tc401 = __SetSlice_bits(32, 1, __tc401, 31, 0b1);
    set_VTCR(__tc401);
    __tc402 : bits(32) = get_VTCR();
    let __tc402 = __SetSlice_bits(32, 2, __tc402, 29, 0b00);
    set_VTCR(__tc402);
    __tc403 : bits(32) = get_VTCR();
    let __tc403 = __SetSlice_bits(32, 11, __tc403, 14, 0b00000000000);
    set_VTCR(__tc403);
    __tc404 : bits(32) = get_VTCR();
    let __tc404 = __SetSlice_bits(32, 1, __tc404, 5, 0b0);
    set_VTCR(__tc404);
    __tc405 : bits(64) = get_VTTBR();
    let __tc405 = __SetSlice_bits(64, 8, __tc405, 56, 0x00);
    set_VTTBR(__tc405);
    __tc406 : bits(64) = get_VTTBR();
    let __tc406 = __SetSlice_bits(64, 8, __tc406, 48, 0x00);
    set_VTTBR(__tc406);
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 31, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 30, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 29, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 27, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 26, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 2, EDSCR, 22, 0b00)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 21, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 19, 0b0)
    };
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 17, 0b0);
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 15, 0b0);
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 14, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 6, 0b0)
    };
    EDPCSR = __SetSlice_bits(64, 5, EDPCSR, 56, 0b00000);
    EDPCSR = __SetSlice_bits(64, 64, EDPCSR, 0, 0x0000000000000000);
    EDPRSR = __SetSlice_bits(32, 20, EDPRSR, 12, 0x00000);
    if cold then {
        EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 10, 0b0)
    };
    if cold then {
        EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 8, 0b0)
    };
    EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 3, 0b1);
    if cold then {
        EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 1, 0b1)
    };
    EDLSR = __SetSlice_bits(32, 29, EDLSR, 3, 0b00000000000000000000000000000);
    EDLSR = __SetSlice_bits(32, 1, EDLSR, 1, 0b1);
    EDESR = __SetSlice_bits(32, 29, EDESR, 3, 0b00000000000000000000000000000);
    EDESR = __SetSlice_bits(32, 1, EDESR, 0, 0b0);
    EDECCR = __SetSlice_bits(32, 16, EDECCR, 16, 0x0000);
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 12, 0x0)
    };
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 8, 0x0)
    };
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 4, 0x0)
    };
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 0, 0x0)
    };
    EDECCR = __SetSlice_bits(32, 24, EDECCR, 8, 0x000000);
    EDECR = __SetSlice_bits(32, 29, EDECR, 3, 0b00000000000000000000000000000);
    EDECR = __SetSlice_bits(32, 1, EDECR, 2, 0b0);
    EDECR = __SetSlice_bits(32, 1, EDECR, 1, 0b0);
    EDECR = __SetSlice_bits(32, 1, EDECR, 0, 0b0);
    EDPRCR = __SetSlice_bits(32, 28, EDPRCR, 4, 0x0000000);
    EDPRCR = __SetSlice_bits(32, 1, EDPRCR, 3, 0b0);
    EDPRCR = __SetSlice_bits(32, 1, EDPRCR, 2, 0b0);
    EDPRCR = __SetSlice_bits(32, 1, EDPRCR, 1, 0b0);
    EDVIDSR = __SetSlice_bits(32, 32, EDVIDSR, 0, 0x00000000);
    EDVIDSR = __SetSlice_bits(32, 20, EDVIDSR, 8, 0x00000);
    EDVIDSR = __SetSlice_bits(32, 12, EDVIDSR, 16, 0x000);
    CNTSR = __SetSlice_bits(32, 24, CNTSR, 8, 0x000000);
    CNTSR = __SetSlice_bits(32, 6, CNTSR, 2, 0b000000);
    CNTSR = __SetSlice_bits(32, 1, CNTSR, 0, 0b0);
    CNTCR = __SetSlice_bits(32, 14, CNTCR, 18, 0b00000000000000);
    CNTCR = __SetSlice_bits(32, 10, CNTCR, 8, 0b0000000000);
    CNTCR = __SetSlice_bits(32, 5, CNTCR, 3, 0b00000);
    CNTCR = __SetSlice_bits(32, 1, CNTCR, 0, 0b0);
    EDPFR = __SetSlice_bits(64, 12, EDPFR, 52, 0x000);
    EDPFR = __SetSlice_bits(64, 4, EDPFR, 48, 0x0);
    PMPCSR = __SetSlice_bits(64, 4, PMPCSR, 56, 0x0);
    PMLSR = __SetSlice_bits(32, 29, PMLSR, 3, 0b00000000000000000000000000000);
    PMLSR = __SetSlice_bits(32, 1, PMLSR, 1, 0b1);
    PMVIDSR = __SetSlice_bits(32, 16, PMVIDSR, 16, 0x0000)
}

val S2CacheDisabled : AccType -> bool effect {escape, rreg, undef}

function S2CacheDisabled acctype = {
    disable : bits(1) = undefined : bits(1);
    if ELUsingAArch32(EL2) then {
        disable = if acctype == AccType_IFETCH then [get_HCR2()[1]] else [get_HCR2()[0]]
    } else {
        disable = if acctype == AccType_IFETCH then [HCR_EL2[33]] else [HCR_EL2[32]]
    };
    disable == 0b1
}

val S2ConvertAttrsHints : (bits(2), AccType) -> MemAttrHints effect {escape, rreg, undef}

function S2ConvertAttrsHints (attr, acctype) = {
    assert(~(IsZero(attr)));
    result : MemAttrHints = undefined : MemAttrHints;
    if S2CacheDisabled(acctype) then {
        result.attrs = MemAttr_NC;
        result.hints = MemHint_No
    } else {
        match attr {
          0b01 => {
              result.attrs = MemAttr_NC;
              result.hints = MemHint_No
          },
          0b10 => {
              result.attrs = MemAttr_WT;
              result.hints = MemHint_RWA
          },
          0b11 => {
              result.attrs = MemAttr_WB;
              result.hints = MemHint_RWA
          }
        }
    };
    result.transient = false;
    result
}

val S2AttrDecode : (bits(2), bits(4), AccType) -> MemoryAttributes effect {escape, rreg, undef}

function S2AttrDecode (SH, attr, acctype) = {
    memattrs : MemoryAttributes = undefined : MemoryAttributes;
    let apply_force_writeback : bool = HaveStage2MemAttrControl() & [HCR_EL2[46]] == 0b1;
    if apply_force_writeback & [attr[2]] == 0b0 | slice(attr, 2, 2) == 0b00 then {
        memattrs.typ = MemType_Device;
        match slice(attr, 0, 2) {
          0b00 => {
              memattrs.device = DeviceType_nGnRnE
          },
          0b01 => {
              memattrs.device = DeviceType_nGnRE
          },
          0b10 => {
              memattrs.device = DeviceType_nGRE
          },
          0b11 => {
              memattrs.device = DeviceType_GRE
          }
        }
    } else {
        if slice(attr, 0, 2) != 0b00 then {
            memattrs.typ = MemType_Normal;
            if apply_force_writeback then {
                memattrs.outer = S2ConvertAttrsHints(slice(attr, 0, 2), acctype)
            } else {
                memattrs.outer = S2ConvertAttrsHints(slice(attr, 2, 2), acctype)
            };
            memattrs.inner = S2ConvertAttrsHints(slice(attr, 0, 2), acctype);
            memattrs.shareable = [SH[1]] == 0b1;
            memattrs.outershareable = SH == 0b10
        } else {
            memattrs = undefined : MemoryAttributes
        }
    };
    MemAttrDefaults(memattrs)
}

val IsSecureEL2Enabled : unit -> bool effect {escape, rreg, undef}

function IsSecureEL2Enabled () = {
    ((HaveSecureEL2Ext() & HaveEL(EL2)) & ~(ELUsingAArch32(EL2))) & ((HaveEL(EL3) & ~(ELUsingAArch32(EL3))) & [SCR_EL3[18]] == 0b1 | ~(HaveEL(EL3)) & IsSecure())
}

val UpdateEDSCRFields : unit -> unit effect {escape, rreg, undef, wreg}

function UpdateEDSCRFields () = {
    if ~(Halted()) then {
        EDSCR = __SetSlice_bits(32, 2, EDSCR, 8, 0b00);
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 18, undefined : bits(1));
        EDSCR = __SetSlice_bits(32, 4, EDSCR, 10, 0xF)
    } else {
        EDSCR = __SetSlice_bits(32, 2, EDSCR, 8, PSTATE.EL);
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 18, if IsSecure() then 0b0 else 0b1);
        RW : bits(4) = undefined : bits(4);
        RW = __SetSlice_bits(4, 1, RW, 1, if ELUsingAArch32(EL1) then 0b0 else 0b1);
        if PSTATE.EL != EL0 then {
            RW = __SetSlice_bits(4, 1, RW, 0, [RW[1]])
        } else {
            RW = __SetSlice_bits(4, 1, RW, 0, if UsingAArch32() then 0b0 else 0b1)
        };
        if ~(HaveEL(EL2)) | (HaveEL(EL3) & [SCR_GEN()[0]] == 0b0) & ~(IsSecureEL2Enabled()) then {
            RW = __SetSlice_bits(4, 1, RW, 2, [RW[1]])
        } else {
            RW = __SetSlice_bits(4, 1, RW, 2, if ELUsingAArch32(EL2) then 0b0 else 0b1)
        };
        if ~(HaveEL(EL3)) then {
            RW = __SetSlice_bits(4, 1, RW, 3, [RW[2]])
        } else {
            RW = __SetSlice_bits(4, 1, RW, 3, if ELUsingAArch32(EL3) then 0b0 else 0b1)
        };
        if [RW[3]] == 0b0 then {
            RW = __SetSlice_bits(4, 3, RW, 0, undefined : bits(3))
        } else {
            if [RW[2]] == 0b0 then {
                RW = __SetSlice_bits(4, 2, RW, 0, undefined : bits(2))
            } else {
                if [RW[1]] == 0b0 then {
                    RW = __SetSlice_bits(4, 1, RW, 0, undefined : bits(1))
                }
            }
        };
        EDSCR = __SetSlice_bits(32, 4, EDSCR, 10, RW)
    };
    return()
}

val Halt : bits(6) -> unit effect {escape, rreg, undef, wreg}

function Halt reason = {
    CTI_SignalEvent(CrossTriggerIn_CrossHalt);
    if UsingAArch32() then {
        set_DLR(ThisInstrAddr());
        set_DSPSR(GetPSRFromPSTATE());
        __tc1 : bits(32) = get_DSPSR();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 21, PSTATE.SS);
        set_DSPSR(__tc1)
    } else {
        DLR_EL0 = ThisInstrAddr();
        DSPSR_EL0 = GetPSRFromPSTATE();
        DSPSR_EL0 = __SetSlice_bits(32, 1, DSPSR_EL0, 21, PSTATE.SS)
    };
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 24, 0b1);
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 28, 0b0);
    if IsSecure() then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 16, 0b0)
    } else {
        if HaveEL(EL3) then {
            EDSCR = __SetSlice_bits(32, 1, EDSCR, 16, if ExternalSecureDebugEnabled() then 0b0 else 0b1)
        } else {
            assert([EDSCR[16]] == 0b1)
        }
    };
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 20, 0b0);
    if UsingAArch32() then {
        (PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = undefined : bits(4);
        PSTATE.IT = 0x00;
        PSTATE.T = 0b1
    } else {
        (PSTATE.SS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = undefined : bits(5)
    };
    PSTATE.IL = 0b0;
    StopInstructionPrefetchAndEnableITR();
    EDSCR = __SetSlice_bits(32, 6, EDSCR, 0, reason);
    UpdateEDSCRFields();
    return()
}

val system_exceptions_debug_halt : unit -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_halt () = {
    Halt(DebugHalt_HaltInstruction)
}

val HaveDoubleFaultExt : unit -> bool effect {escape, rreg, undef}

function HaveDoubleFaultExt () = {
    ((HasArchVersion(ARMv8p4) & HaveEL(EL3)) & ~(ELUsingAArch32(EL3))) & HaveIESB()
}

val ELIsInHost : bits(2) -> bool effect {escape, rreg, undef}

function ELIsInHost el = {
    ((((IsSecureEL2Enabled() | ~(IsSecureBelowEL3())) & HaveVirtHostExt()) & ~(ELUsingAArch32(EL2))) & [HCR_EL2[34]] == 0b1) & (el == EL2 | el == EL0 & [HCR_EL2[27]] == 0b1)
}

val S1TranslationRegime__0 : bits(2) -> bits(2) effect {escape, rreg, undef}

val S1TranslationRegime__1 : unit -> bits(2) effect {escape, rreg, undef}

overload S1TranslationRegime = {S1TranslationRegime__0, S1TranslationRegime__1}

function S1TranslationRegime__0 el = {
    if el != EL0 then {
        return(el)
    } else {
        if (HaveEL(EL3) & ELUsingAArch32(EL3)) & [get_SCR()[0]] == 0b0 then {
            return(EL3)
        } else {
            if HaveVirtHostExt() & ELIsInHost(el) then {
                return(EL2)
            } else {
                return(EL1)
            }
        }
    }
}

function S1TranslationRegime__1 () = {
    S1TranslationRegime(PSTATE.EL)
}

val aset_FAR__0 : (bits(2), bits(64)) -> unit effect {escape, wreg}

val aset_FAR__1 : bits(64) -> unit effect {escape, wreg, rreg, undef}

overload aset_FAR = {aset_FAR__0, aset_FAR__1}

overload FAR = {aset_FAR__0, aset_FAR__1}

function aset_FAR__0 (regime, value_name) = {
    let r : bits(64) = value_name;
    match regime {
      ? if ? == EL1 => {
          FAR_EL1 = r
      },
      ? if ? == EL2 => {
          FAR_EL2 = r
      },
      ? if ? == EL3 => {
          FAR_EL3 = r
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

function aset_FAR__1 value_name = {
    aset_FAR(S1TranslationRegime(), value_name);
    return()
}

val aset_ESR__0 : (bits(2), bits(32)) -> unit effect {escape, wreg}

val aset_ESR__1 : bits(32) -> unit effect {escape, wreg, rreg, undef}

overload aset_ESR = {aset_ESR__0, aset_ESR__1}

overload ESR = {aset_ESR__0, aset_ESR__1}

function aset_ESR__0 (regime, value_name) = {
    let r : bits(32) = value_name;
    match regime {
      ? if ? == EL1 => {
          ESR_EL1 = r
      },
      ? if ? == EL2 => {
          ESR_EL2 = r
      },
      ? if ? == EL3 => {
          ESR_EL3 = r
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

function aset_ESR__1 value_name = {
    aset_ESR(S1TranslationRegime(), value_name)
}

val aget_VBAR__0 : bits(2) -> bits(64) effect {escape, rreg, undef}

val aget_VBAR__1 : unit -> bits(64) effect {escape, rreg, undef}

overload aget_VBAR = {aget_VBAR__0, aget_VBAR__1}

overload VBAR = {aget_VBAR__0, aget_VBAR__1}

function aget_VBAR__0 regime = {
    r : bits(64) = undefined : bits(64);
    match regime {
      ? if ? == EL1 => {
          r = VBAR_EL1
      },
      ? if ? == EL2 => {
          r = VBAR_EL2
      },
      ? if ? == EL3 => {
          r = VBAR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    r
}

function aget_VBAR__1 () = {
    VBAR(S1TranslationRegime())
}

val aget_SCTLR__0 : bits(2) -> bits(64) effect {escape, rreg, undef}

val aget_SCTLR__1 : unit -> bits(64) effect {escape, rreg, undef}

overload aget_SCTLR = {aget_SCTLR__0, aget_SCTLR__1}

overload SCTLR = {aget_SCTLR__0, aget_SCTLR__1}

function aget_SCTLR__0 regime = {
    r : bits(64) = undefined : bits(64);
    match regime {
      ? if ? == EL1 => {
          r = SCTLR_EL1
      },
      ? if ? == EL2 => {
          r = SCTLR_EL2
      },
      ? if ? == EL3 => {
          r = SCTLR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    r
}

function aget_SCTLR__1 () = {
    SCTLR(S1TranslationRegime())
}

val BigEndian : unit -> bool effect {escape, rreg, undef}

function BigEndian () = {
    bigend : bool = undefined : bool;
    if UsingAArch32() then {
        bigend = PSTATE.E != 0b0
    } else {
        if PSTATE.EL == EL0 then {
            bigend = [SCTLR()[24]] != 0b0
        } else {
            bigend = [SCTLR()[25]] != 0b0
        }
    };
    bigend
}

val BTypeCompatible_PACIXSP : unit -> bool effect {rreg, undef, escape}

function BTypeCompatible_PACIXSP () = {
    index : int = undefined : int;
    if PSTATE.BTYPE == 0b01 | PSTATE.BTYPE == 0b10 then {
        return(true)
    } else {
        if PSTATE.BTYPE == 0b11 then {
            index = if PSTATE.EL == EL0 then 35 else 36;
            return([aget_SCTLR()[index]] == 0b0)
        } else {
            return(false)
        }
    }
}

val aget_MAIR__0 : bits(2) -> bits(64) effect {escape, rreg, undef}

val aget_MAIR__1 : unit -> bits(64) effect {escape, rreg, undef}

overload aget_MAIR = {aget_MAIR__0, aget_MAIR__1}

overload MAIR = {aget_MAIR__0, aget_MAIR__1}

function aget_MAIR__0 regime = {
    r : bits(64) = undefined : bits(64);
    match regime {
      ? if ? == EL1 => {
          r = MAIR_EL1
      },
      ? if ? == EL2 => {
          r = MAIR_EL2
      },
      ? if ? == EL3 => {
          r = MAIR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    r
}

function aget_MAIR__1 () = {
    MAIR(S1TranslationRegime())
}

val S1CacheDisabled : AccType -> bool effect {escape, rreg, undef}

function S1CacheDisabled acctype = {
    enable : bits(1) = undefined : bits(1);
    if ELUsingAArch32(S1TranslationRegime()) then {
        if PSTATE.EL == EL2 then {
            enable = if acctype == AccType_IFETCH then [get_HSCTLR()[12]] else [get_HSCTLR()[2]]
        } else {
            enable = if acctype == AccType_IFETCH then [get_SCTLR()[12]] else [get_SCTLR()[2]]
        }
    } else {
        enable = if acctype == AccType_IFETCH then [SCTLR()[12]] else [SCTLR()[2]]
    };
    enable == 0b0
}

val ShortConvertAttrsHints : forall ('secondstage : Bool).
  (bits(2), AccType, bool('secondstage)) -> MemAttrHints effect {escape, rreg, undef}

function ShortConvertAttrsHints (RGN, acctype, secondstage) = {
    result : MemAttrHints = undefined : MemAttrHints;
    if ~(secondstage) & S1CacheDisabled(acctype) | secondstage & S2CacheDisabled(acctype) then {
        result.attrs = MemAttr_NC;
        result.hints = MemHint_No
    } else {
        match RGN {
          0b00 => {
              result.attrs = MemAttr_NC;
              result.hints = MemHint_No
          },
          0b01 => {
              result.attrs = MemAttr_WB;
              result.hints = MemHint_RWA
          },
          0b10 => {
              result.attrs = MemAttr_WT;
              result.hints = MemHint_RA
          },
          0b11 => {
              result.attrs = MemAttr_WB;
              result.hints = MemHint_RA
          }
        }
    };
    result.transient = false;
    result
}

val WalkAttrDecode : forall ('secondstage : Bool).
  (bits(2), bits(2), bits(2), bool('secondstage)) -> MemoryAttributes effect {escape, rreg, undef}

function WalkAttrDecode (SH, ORGN, IRGN, secondstage) = {
    memattrs : MemoryAttributes = undefined : MemoryAttributes;
    let acctype : AccType = AccType_NORMAL;
    memattrs.typ = MemType_Normal;
    memattrs.inner = ShortConvertAttrsHints(IRGN, acctype, secondstage);
    memattrs.outer = ShortConvertAttrsHints(ORGN, acctype, secondstage);
    memattrs.shareable = [SH[1]] == 0b1;
    memattrs.outershareable = SH == 0b10;
    memattrs.tagged = false;
    MemAttrDefaults(memattrs)
}

val AArch32_RemappedTEXDecode : (bits(3), bits(1), bits(1), bits(1), AccType) -> MemoryAttributes effect {escape, rreg, undef}

function AArch32_RemappedTEXDecode (TEX, C, B, S, acctype) = {
    memattrs : MemoryAttributes = undefined : MemoryAttributes;
    let region = UInt(([TEX[0]] @ C) @ B);
    __anon1 : Constraint = undefined : Constraint;
    attrfield : bits(2) = undefined : bits(2);
    base : int = undefined : int;
    s_bit : bits(1) = undefined : bits(1);
    if region == 6 then {
        memattrs = undefined
    } else {
        base = 2 * region;
        attrfield = slice(get_PRRR(), base, 2);
        if attrfield == 0b11 then {
            (__anon1, attrfield) = ConstrainUnpredictableBits(Unpredictable_RESPRRR)
        };
        match attrfield {
          0b00 => {
              memattrs.typ = MemType_Device;
              memattrs.device = DeviceType_nGnRnE
          },
          0b01 => {
              memattrs.typ = MemType_Device;
              memattrs.device = DeviceType_nGnRE
          },
          0b10 => {
              memattrs.typ = MemType_Normal;
              memattrs.inner = ShortConvertAttrsHints(slice(get_NMRR(), base, 2), acctype, false);
              memattrs.outer = ShortConvertAttrsHints(slice(get_NMRR(), base + 16, 2), acctype, false);
              s_bit = if S == 0b0 then [get_PRRR()[18]] else [get_PRRR()[19]];
              memattrs.shareable = s_bit == 0b1;
              memattrs.outershareable = s_bit == 0b1 & [get_PRRR()[region + 24]] == 0b0
          },
          0b11 => {
              Unreachable()
          }
        }
    };
    __tc1 : MemAttrHints = memattrs.inner;
    __tc1.transient = false;
    memattrs.inner = __tc1;
    __tc2 : MemAttrHints = memattrs.outer;
    __tc2.transient = false;
    memattrs.outer = __tc2;
    memattrs.tagged = false;
    MemAttrDefaults(memattrs)
}

val AArch32_DefaultTEXDecode : (bits(3), bits(1), bits(1), bits(1), AccType) -> MemoryAttributes effect {escape, rreg, undef}

function AArch32_DefaultTEXDecode (TEX__arg, C__arg, B__arg, S, acctype) = {
    B = B__arg;
    C = C__arg;
    TEX = TEX__arg;
    memattrs : MemoryAttributes = undefined : MemoryAttributes;
    __anon1 : Constraint = undefined : Constraint;
    if (TEX == 0b001 & (C @ B) == 0b01 | TEX == 0b010 & (C @ B) != 0b00) | TEX == 0b011 then {
        texcb : bits(5) = undefined : bits(5);
        (__anon1, texcb) = ConstrainUnpredictableBits(Unpredictable_RESTEXCB);
        TEX = slice(texcb, 2, 3);
        C = [texcb[1]];
        B = [texcb[0]]
    };
    match (TEX @ C) @ B {
      0b00000 => {
          memattrs.typ = MemType_Device;
          memattrs.device = DeviceType_nGnRnE
      },
      0b00001 => {
          memattrs.typ = MemType_Device;
          memattrs.device = DeviceType_nGnRE
      },
      0b01000 => {
          memattrs.typ = MemType_Device;
          memattrs.device = DeviceType_nGnRE
      },
      0b00010 => {
          memattrs.typ = MemType_Normal;
          memattrs.inner = ShortConvertAttrsHints(C @ B, acctype, false);
          memattrs.outer = ShortConvertAttrsHints(C @ B, acctype, false);
          memattrs.shareable = S == 0b1
      },
      0b00011 => {
          memattrs.typ = MemType_Normal;
          memattrs.inner = ShortConvertAttrsHints(C @ B, acctype, false);
          memattrs.outer = ShortConvertAttrsHints(C @ B, acctype, false);
          memattrs.shareable = S == 0b1
      },
      0b00100 => {
          memattrs.typ = MemType_Normal;
          memattrs.inner = ShortConvertAttrsHints(C @ B, acctype, false);
          memattrs.outer = ShortConvertAttrsHints(C @ B, acctype, false);
          memattrs.shareable = S == 0b1
      },
      0b00110 => {
          memattrs = undefined
      },
      0b00111 => {
          memattrs.typ = MemType_Normal;
          memattrs.inner = ShortConvertAttrsHints(0b01, acctype, false);
          memattrs.outer = ShortConvertAttrsHints(0b01, acctype, false);
          memattrs.shareable = S == 0b1
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          memattrs.typ = MemType_Normal;
          memattrs.inner = ShortConvertAttrsHints(C @ B, acctype, false);
          memattrs.outer = ShortConvertAttrsHints(slice(TEX, 0, 2), acctype, false);
          memattrs.shareable = S == 0b1
      },
      _ => {
          Unreachable()
      }
    };
    __tc1 : MemAttrHints = memattrs.inner;
    __tc1.transient = false;
    memattrs.inner = __tc1;
    __tc2 : MemAttrHints = memattrs.outer;
    __tc2.transient = false;
    memattrs.outer = __tc2;
    memattrs.outershareable = memattrs.shareable;
    memattrs.tagged = false;
    MemAttrDefaults(memattrs)
}

val LongConvertAttrsHints : (bits(4), AccType) -> MemAttrHints effect {escape, rreg, undef}

function LongConvertAttrsHints (attrfield, acctype) = {
    assert(~(IsZero(attrfield)));
    result : MemAttrHints = undefined : MemAttrHints;
    if S1CacheDisabled(acctype) then {
        result.attrs = MemAttr_NC;
        result.hints = MemHint_No
    } else {
        if slice(attrfield, 2, 2) == 0b00 then {
            result.attrs = MemAttr_WT;
            result.hints = slice(attrfield, 0, 2);
            result.transient = true
        } else {
            if slice(attrfield, 0, 4) == 0x4 then {
                result.attrs = MemAttr_NC;
                result.hints = MemHint_No;
                result.transient = false
            } else {
                if slice(attrfield, 2, 2) == 0b01 then {
                    result.attrs = MemAttr_WB;
                    result.hints = slice(attrfield, 0, 2);
                    result.transient = true
                } else {
                    result.attrs = slice(attrfield, 2, 2);
                    result.hints = slice(attrfield, 0, 2);
                    result.transient = false
                }
            }
        }
    };
    result
}

val CalculateTBI : (bits(64), bool) -> bool effect {escape, rreg, undef}

function CalculateTBI (ptr, data) = {
    tbi : bool = false;
    if PtrHasUpperAndLowerAddRanges() then {
        assert(S1TranslationRegime() == EL1 | S1TranslationRegime() == EL2);
        if S1TranslationRegime() == EL1 then {
            if data then {
                tbi = if [ptr[55]] == 0b1 then [TCR_EL1[38]] == 0b1 else [TCR_EL1[37]] == 0b1
            } else {
                if [ptr[55]] == 0b1 then {
                    tbi = [TCR_EL1[38]] == 0b1 & [TCR_EL1[52]] == 0b0
                } else {
                    tbi = [TCR_EL1[37]] == 0b1 & [TCR_EL1[51]] == 0b0
                }
            }
        } else {
            if data then {
                tbi = if [ptr[55]] == 0b1 then [TCR_EL2[38]] == 0b1 else [TCR_EL2[37]] == 0b1
            } else {
                if [ptr[55]] == 0b1 then {
                    tbi = [TCR_EL2[38]] == 0b1 & [TCR_EL2[52]] == 0b0
                } else {
                    tbi = [TCR_EL2[37]] == 0b1 & [TCR_EL2[51]] == 0b0
                }
            }
        }
    } else {
        if PSTATE.EL == EL2 then {
            tbi = if data then [TCR_EL2[20]] == 0b1 else [TCR_EL2[20]] == 0b1 & [TCR_EL2[29]] == 0b0
        } else {
            if PSTATE.EL == EL3 then {
                tbi = if data then [TCR_EL3[20]] == 0b1 else [TCR_EL3[20]] == 0b1 & [TCR_EL3[29]] == 0b0
            }
        }
    };
    tbi
}

val IsInHost : unit -> bool effect {escape, rreg, undef}

function IsInHost () = {
    ELIsInHost(PSTATE.EL)
}

val aget_CPACR : unit -> bits(32) effect {escape, rreg, undef}

function aget_CPACR () = {
    r : bits(32) = undefined : bits(32);
    if IsInHost() then {
        r = CPTR_EL2;
        return(r)
    };
    let r = CPACR_EL1;
    r
}

overload CPACR = {aget_CPACR}

val InterruptPending : unit -> bool effect {escape, rreg, undef}

function InterruptPending () = {
    let pending_physical_interrupt : bool = (IsPhysicalSErrorPending() | IRQPending()) | FIQPending();
    let pending_virtual_interrupt : bool = ~(IsInHost()) & ((HCR_EL2[8 .. 8] @ (HCR_EL2[7 .. 7] @ HCR_EL2[6 .. 6])) & (HCR_EL2[5 .. 5] @ (HCR_EL2[4 .. 4] @ HCR_EL2[3 .. 3]))) != 0b000;
    pending_physical_interrupt | pending_virtual_interrupt
}

val EnterLowPowerState : unit -> unit effect {escape, rreg, undef}

function EnterLowPowerState () = {
    if ~(InterruptPending()) then {
        __SleepRequest()
    };
    return()
}

val WaitForInterrupt : unit -> unit effect {escape, rreg, undef}

function WaitForInterrupt () = {
    EnterLowPowerState();
    return()
}

val WaitForEvent : unit -> unit effect {escape, rreg, undef}

function WaitForEvent () = {
    if EventRegister == 0b0 then {
        EnterLowPowerState()
    };
    return()
}

val EffectiveTCMA : (bits(64), bits(2)) -> bits(1) effect {escape, rreg, undef}

function EffectiveTCMA (address, el) = {
    assert(HaveEL(el));
    let regime : vector(2, dec, bit) = S1TranslationRegime(el);
    assert(~(ELUsingAArch32(regime)));
    tcma : bits(1) = undefined : bits(1);
    match regime {
      ? if ? == EL1 => {
          tcma = if [address[55]] == 0b1 then [TCR_EL1[58]] else [TCR_EL1[57]]
      },
      ? if ? == EL2 => {
          if HaveVirtHostExt() & ELIsInHost(el) then {
              tcma = if [address[55]] == 0b1 then [TCR_EL2[58]] else [TCR_EL2[57]]
          } else {
              tcma = [TCR_EL2[30]]
          }
      },
      ? if ? == EL3 => {
          tcma = [TCR_EL3[30]]
      }
    };
    tcma
}

val EffectiveTBI : forall ('IsInstr : Bool).
  (bits(64), bool('IsInstr), bits(2)) -> bits(1) effect {escape, rreg, undef}

function EffectiveTBI (address, IsInstr, el) = {
    assert(HaveEL(el));
    let regime : vector(2, dec, bit) = S1TranslationRegime(el);
    assert(~(ELUsingAArch32(regime)));
    tbi : bits(1) = undefined : bits(1);
    tbid : bits(1) = undefined : bits(1);
    match regime {
      ? if ? == EL1 => {
          tbi = if [address[55]] == 0b1 then [TCR_EL1[38]] else [TCR_EL1[37]];
          if HavePACExt() then {
              tbid = if [address[55]] == 0b1 then [TCR_EL1[52]] else [TCR_EL1[51]]
          }
      },
      ? if ? == EL2 => {
          if HaveVirtHostExt() & ELIsInHost(el) then {
              tbi = if [address[55]] == 0b1 then [TCR_EL2[38]] else [TCR_EL2[37]];
              if HavePACExt() then {
                  tbid = if [address[55]] == 0b1 then [TCR_EL2[52]] else [TCR_EL2[51]]
              }
          } else {
              tbi = [TCR_EL2[20]];
              if HavePACExt() then {
                  tbid = [TCR_EL2[29]]
              }
          }
      },
      ? if ? == EL3 => {
          tbi = [TCR_EL3[20]];
          if HavePACExt() then {
              tbid = [TCR_EL3[29]]
          }
      }
    };
    if tbi == 0b1 & ((~(HavePACExt()) | tbid == 0b0) | ~(IsInstr)) then 0b1 else 0b0
}

val EL2Enabled : unit -> bool effect {escape, rreg, undef}

function EL2Enabled () = {
    IsSecureEL2Enabled() | HaveEL(EL2) & ~(IsSecure())
}

val getMPAM_PMG : forall ('MPAMn : Int) ('InD : Bool).
  (int('MPAMn), bool('InD)) -> bits(8) effect {escape, rreg, undef}

function getMPAM_PMG (MPAMn, InD) = {
    pmg : bits(8) = undefined : bits(8);
    let el2avail : bool = EL2Enabled();
    if InD then {
        match MPAMn {
          3 => {
              pmg = slice(MPAM3_EL3, 32, 8)
          },
          2 => {
              pmg = if el2avail then slice(MPAM2_EL2, 32, 8) else Zeros()
          },
          1 => {
              pmg = slice(MPAM1_EL1, 32, 8)
          },
          0 => {
              pmg = slice(MPAM0_EL1, 32, 8)
          },
          _ => {
              pmg = undefined : bits(8)
          }
        }
    } else {
        match MPAMn {
          3 => {
              pmg = slice(MPAM3_EL3, 40, 8)
          },
          2 => {
              pmg = if el2avail then slice(MPAM2_EL2, 40, 8) else Zeros()
          },
          1 => {
              pmg = slice(MPAM1_EL1, 40, 8)
          },
          0 => {
              pmg = slice(MPAM0_EL1, 40, 8)
          },
          _ => {
              pmg = undefined : bits(8)
          }
        }
    };
    pmg
}

val genPMG : forall ('el : Int) ('InD : Bool) ('partid_err : Bool).
  (int('el), bool('InD), bool('partid_err)) -> bits(8) effect {escape, rreg, undef}

function genPMG (el, InD, partid_err) = {
    let 'pmg_max = UInt(slice(MPAMIDR_EL1, 32, 8));
    if partid_err then {
        return(DefaultPMG)
    };
    let groupel : vector(8, dec, bit) = getMPAM_PMG(el, InD);
    if UInt(groupel) <= pmg_max then {
        return(groupel)
    };
    DefaultPMG
}

val getMPAM_PARTID : forall ('MPAMn : Int) ('InD : Bool).
  (int('MPAMn), bool('InD)) -> bits(16) effect {escape, rreg, undef}

function getMPAM_PARTID (MPAMn, InD) = {
    partid : bits(16) = undefined : bits(16);
    let el2avail : bool = EL2Enabled();
    if InD then {
        match MPAMn {
          3 => {
              partid = slice(MPAM3_EL3, 0, 16)
          },
          2 => {
              partid = if el2avail then slice(MPAM2_EL2, 0, 16) else Zeros()
          },
          1 => {
              partid = slice(MPAM1_EL1, 0, 16)
          },
          0 => {
              partid = slice(MPAM0_EL1, 0, 16)
          },
          _ => {
              partid = undefined : bits(16)
          }
        }
    } else {
        match MPAMn {
          3 => {
              partid = slice(MPAM3_EL3, 16, 16)
          },
          2 => {
              partid = if el2avail then slice(MPAM2_EL2, 16, 16) else Zeros()
          },
          1 => {
              partid = slice(MPAM1_EL1, 16, 16)
          },
          0 => {
              partid = slice(MPAM0_EL1, 16, 16)
          },
          _ => {
              partid = undefined : bits(16)
          }
        }
    };
    partid
}

val getISR : unit -> bits(32) effect {escape, rreg, undef}

function getISR () = {
    value_name : bits(32) = Zeros();
    value_name = __SetSlice_bits(32, 1, value_name, 8, if IsPhysicalSErrorPending() then 0b1 else 0b0);
    value_name = __SetSlice_bits(32, 1, value_name, 7, if IRQPending() then 0b1 else 0b0);
    value_name = __SetSlice_bits(32, 1, value_name, 6, if FIQPending() then 0b1 else 0b0);
    if (PSTATE.EL == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b0 then {
        if [HCR_EL2[5]] == 0b1 then {
            value_name = __SetSlice_bits(32, 1, value_name, 8, [value_name[8]] | [HCR_EL2[8]])
        };
        if [HCR_EL2[4]] == 0b1 then {
            value_name = __SetSlice_bits(32, 1, value_name, 7, [HCR_EL2[7]])
        };
        if [HCR_EL2[3]] == 0b1 then {
            value_name = __SetSlice_bits(32, 1, value_name, 6, [HCR_EL2[6]])
        }
    };
    value_name
}

val MPAMisVirtual : forall ('el : Int).
  int('el) -> bool effect {escape, rreg, undef}

function MPAMisVirtual el = {
    ([MPAMIDR_EL1[17]] == 0b1 & EL2Enabled()) & (el == 0 & [MPAMHCR_EL2[0]] == 0b1 | el == 1 & [MPAMHCR_EL2[1]] == 0b1)
}

val genPARTID : forall ('el : Int) ('InD : Bool).
  (int('el), bool('InD)) -> (bits(16), bool) effect {escape, rreg, undef}

function genPARTID (el, InD) = {
    let partidel : vector(16, dec, bit) = getMPAM_PARTID(el, InD);
    let 'partid_max = UInt(slice(MPAMIDR_EL1, 0, 16));
    if UInt(partidel) > partid_max then {
        return((DefaultPARTID, true))
    };
    if MPAMisVirtual(el) then {
        return(MAP_vPARTID(partidel))
    } else {
        return((partidel, false))
    }
}

val genMPAM : forall ('el : Int) ('InD : Bool) ('secure : Bool).
  (int('el), bool('InD), bool('secure)) -> MPAMinfo effect {escape, rreg, undef}

function genMPAM (el, InD, secure) = {
    returnInfo : MPAMinfo = undefined : MPAMinfo;
    partidel : bits(16) = undefined : bits(16);
    perr : bool = undefined : bool;
    let gstplk : bool = ((el == 0 & EL2Enabled()) & [MPAMHCR_EL2[8]] == 0b1) & [HCR_EL2[27]] == 0b0;
    let 'eff_el : {'n, ('n == 1 | 'n == 'el). int('n)} = if gstplk then 1 else el;
    (partidel, perr) = genPARTID(eff_el, InD);
    let groupel : bits(8) = genPMG(eff_el, InD, perr);
    returnInfo.mpam_ns = if secure then 0b0 else 0b1;
    returnInfo.partid = partidel;
    returnInfo.pmg = groupel;
    returnInfo
}

val HasS2Translation : unit -> bool effect {escape, rreg, undef}

function HasS2Translation () = {
    (EL2Enabled() & ~(IsInHost())) & (PSTATE.EL == EL0 | PSTATE.EL == EL1)
}

val AArch64_vESBOperation : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_vESBOperation () = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    let vSEI_enabled : bool = [HCR_EL2[27]] == 0b0 & [HCR_EL2[5]] == 0b1;
    let vSEI_pending : bool = vSEI_enabled & [HCR_EL2[8]] == 0b1;
    let vintdis : bool = Halted() | ExternalDebugInterruptsDisabled(EL1);
    let vmasked : bool = vintdis | PSTATE.A == 0b1;
    if vSEI_pending & vmasked then {
        if ELUsingAArch32(EL1) then {
            set_VDISR(AArch32_ReportDeferredSError(slice(get_VDFSR(), 14, 2), [get_VDFSR()[12]]))
        } else {
            VDISR_EL2 = AArch64_ReportDeferredSError(slice(VSESR_EL2, 0, 25))
        };
        HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 8, 0b0)
    };
    return()
}

val AArch64_PendingUnmaskedVirtualInterrupts : bits(3) -> (bool, bool, bool) effect {escape, rreg, undef}

function AArch64_PendingUnmaskedVirtualInterrupts mask = {
    pending : bits(3) = undefined : bits(3);
    if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & [HCR_EL2[27]] == 0b0 then {
        pending = (HCR_EL2[8 .. 8] @ (HCR_EL2[7 .. 7] @ HCR_EL2[6 .. 6])) & (HCR_EL2[5 .. 5] @ (HCR_EL2[4 .. 4] @ HCR_EL2[3 .. 3]))
    } else {
        pending = 0b000
    };
    let unmasked_pending : bits(3) = pending & ~(mask);
    return(([unmasked_pending[2]] == 0b1, [unmasked_pending[1]] == 0b1, [unmasked_pending[0]] == 0b1))
}

val AArch64_CheckNVCondsIfCurrentEL : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bool effect {escape, rreg, undef}

function AArch64_CheckNVCondsIfCurrentEL (op0, op1, crn, crm, op2) = {
    let is_reg_current_el : bool = (((op0 == 3 & op1 == 0) & crn == 4) & crm == 2) & op2 == 2;
    let have_nv_trap_conds : bool = ((HaveNVExt() & EL2Enabled()) & PSTATE.EL == EL1) & [HCR_EL2[42]] == 0b1;
    is_reg_current_el & have_nv_trap_conds
}

val DoubleLockStatus : unit -> bool effect {escape, rreg, undef}

function DoubleLockStatus () = {
    if ~(HaveDoubleLock()) then {
        return(false)
    } else {
        if ELUsingAArch32(EL1) then {
            return(([get_DBGOSDLR()[0]] == 0b1 & [get_DBGPRCR()[0]] == 0b0) & ~(Halted()))
        } else {
            return(([OSDLR_EL1[0]] == 0b1 & [DBGPRCR_EL1[0]] == 0b0) & ~(Halted()))
        }
    }
}

val HaltingAllowed : unit -> bool effect {escape, rreg, undef}

function HaltingAllowed () = {
    if Halted() | DoubleLockStatus() then {
        return(false)
    } else {
        if IsSecure() then {
            return(ExternalSecureDebugEnabled())
        } else {
            return(ExternalDebugEnabled())
        }
    }
}

val HaltOnBreakpointOrWatchpoint : unit -> bool effect {escape, rreg, undef}

function HaltOnBreakpointOrWatchpoint () = {
    (HaltingAllowed() & [EDSCR[14]] == 0b1) & [OSLSR_EL1[1]] == 0b0
}

val DebugTargetFrom : forall ('secure : Bool).
  bool('secure) -> bits(2) effect {escape, rreg, undef}

function DebugTargetFrom secure = {
    route_to_el2 : bool = undefined : bool;
    if HaveEL(EL2) & ~(secure) then {
        if ELUsingAArch32(EL2) then {
            route_to_el2 = [get_HDCR()[8]] == 0b1 | [get_HCR()[27]] == 0b1
        } else {
            route_to_el2 = [MDCR_EL2[8]] == 0b1 | [HCR_EL2[27]] == 0b1
        }
    } else {
        route_to_el2 = false
    };
    target : bits(2) = undefined : bits(2);
    if route_to_el2 then {
        target = EL2
    } else {
        if (HaveEL(EL3) & HighestELUsingAArch32()) & secure then {
            target = EL3
        } else {
            target = EL1
        }
    };
    target
}

val DebugTarget : unit -> bits(2) effect {escape, rreg, undef}

function DebugTarget () = {
    let secure : bool = IsSecure();
    DebugTargetFrom(secure)
}

val SSAdvance : unit -> unit effect {escape, rreg, undef, wreg}

function SSAdvance () = {
    let target : vector(2, dec, bit) = DebugTarget();
    let step_enabled : bool = ~(ELUsingAArch32(target)) & [MDSCR_EL1[0]] == 0b1;
    let active_not_pending : bool = step_enabled & PSTATE.SS == 0b1;
    if active_not_pending then {
        PSTATE.SS = 0b0
    };
    return()
}

val __PostExecute : forall ('pc : Int) ('len : Int) ('ok : Bool).
  (int('pc), int('len), bits(32), bool('ok)) -> bool effect {escape, rreg, undef, wreg}

function __PostExecute (pc, len, instr, ok) = {
    InGuardedPage = false;
    PSTATE.BTYPE = BTypeNext;
    if ~(__PC_changed) then {
        _PC = __GetSlice_int(64, pc + len, 0)
    };
    if ShouldAdvanceIT then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    __UpdateSystemCounter();
    ok
}

val ConditionHolds : bits(4) -> bool effect {rreg, undef}

function ConditionHolds cond = {
    result : bool = undefined : bool;
    match slice(cond, 1, 3) {
      0b000 => {
          result = PSTATE.Z == 0b1
      },
      0b001 => {
          result = PSTATE.C == 0b1
      },
      0b010 => {
          result = PSTATE.N == 0b1
      },
      0b011 => {
          result = PSTATE.V == 0b1
      },
      0b100 => {
          result = PSTATE.C == 0b1 & PSTATE.Z == 0b0
      },
      0b101 => {
          result = PSTATE.N == PSTATE.V
      },
      0b110 => {
          result = PSTATE.N == PSTATE.V & PSTATE.Z == 0b0
      },
      0b111 => {
          result = true
      }
    };
    if [cond[0]] == 0b1 & cond != 0xF then {
        result = ~(result)
    };
    result
}

val integer_conditional_select : forall 'd 'datasize ('else_inc : Bool) ('else_inv : Bool) 'm 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (bits(4), int('d), int('datasize), bool('else_inc), bool('else_inv), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_select (condition, d, datasize, else_inc, else_inv, m, n) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    if ConditionHolds(condition) then {
        result = operand1
    } else {
        result = operand2;
        if else_inv then {
            result = ~(result)
        };
        if else_inc then {
            result = result + 1
        }
    };
    X(d) = result
}

val integer_conditional_compare_register : forall 'datasize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31).
  (bits(4), int('datasize), bits(4), int('m), int('n), bool('sub_op)) -> unit effect {rreg, undef, wreg}

function integer_conditional_compare_register (condition, datasize, flags__arg, m, n, sub_op) = {
    flags = flags__arg;
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = X(m);
    carry_in : bits(1) = 0b0;
    __anon1 : bits('datasize) = undefined : bits('datasize);
    if ConditionHolds(condition) then {
        if sub_op then {
            operand2 = ~(operand2);
            carry_in = 0b1
        };
        (__anon1, flags) = AddWithCarry(operand1, operand2, carry_in)
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val integer_conditional_compare_immediate : forall 'datasize 'n ('sub_op : Bool),
  'datasize >= 0 & ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (bits(4), int('datasize), bits(4), bits('datasize), int('n), bool('sub_op)) -> unit effect {rreg, undef, wreg}

function integer_conditional_compare_immediate (condition, datasize, flags__arg, imm, n, sub_op) = {
    flags = flags__arg;
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = imm;
    carry_in : bits(1) = 0b0;
    __anon1 : bits('datasize) = undefined : bits('datasize);
    if ConditionHolds(condition) then {
        if sub_op then {
            operand2 = ~(operand2);
            carry_in = 0b1
        };
        (__anon1, flags) = AddWithCarry(operand1, operand2, carry_in)
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val ConditionSyndrome : unit -> bits(5) effect {escape, rreg, undef}

function ConditionSyndrome () = {
    syndrome : bits(5) = undefined : bits(5);
    cond : bits(4) = undefined : bits(4);
    if UsingAArch32() then {
        cond = AArch32_CurrentCond();
        if PSTATE.T == 0b0 then {
            syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b1);
            if ConditionHolds(cond) & ConstrainUnpredictableBool(Unpredictable_ESRCONDPASS) then {
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, 0xE)
            } else {
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, cond)
            }
        } else {
            if __IMPDEF_boolean("Condition valid for trapped T32") then {
                syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b1);
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, cond)
            } else {
                syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b0);
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, undefined : bits(4))
            }
        }
    } else {
        syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b1);
        syndrome = __SetSlice_bits(5, 4, syndrome, 0, 0xE)
    };
    syndrome
}

val CalculateBottomPACBit : bits(1) -> int effect {escape, rreg, undef}

function CalculateBottomPACBit top_bit = {
    tsz_field : int = undefined : int;
    using64k : bool = undefined : bool;
    if PtrHasUpperAndLowerAddRanges() then {
        assert(S1TranslationRegime() == EL1 | S1TranslationRegime() == EL2);
        if S1TranslationRegime() == EL1 then {
            tsz_field = if top_bit == 0b1 then UInt(slice(TCR_EL1, 16, 6)) else UInt(slice(TCR_EL1, 0, 6));
            using64k = if top_bit == 0b1 then slice(TCR_EL1, 30, 2) == 0b11 else slice(TCR_EL1, 14, 2) == 0b01
        } else {
            assert(HaveEL(EL2));
            tsz_field = if top_bit == 0b1 then UInt(slice(TCR_EL2, 16, 6)) else UInt(slice(TCR_EL2, 0, 6));
            using64k = if top_bit == 0b1 then slice(TCR_EL2, 30, 2) == 0b11 else slice(TCR_EL2, 14, 2) == 0b01
        }
    } else {
        tsz_field = if PSTATE.EL == EL2 then UInt(slice(TCR_EL2, 0, 6)) else UInt(slice(TCR_EL3, 0, 6));
        using64k = if PSTATE.EL == EL2 then slice(TCR_EL2, 14, 2) == 0b01 else slice(TCR_EL3, 14, 2) == 0b01
    };
    let max_limit_tsz_field : int = if ~(HaveSmallPageTblExt()) then 39 else if using64k then 47 else 48;
    c : Constraint = undefined : Constraint;
    if tsz_field > max_limit_tsz_field then {
        c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
        assert(c == Constraint_FORCE | c == Constraint_NONE);
        if c == Constraint_FORCE then {
            tsz_field = max_limit_tsz_field
        }
    };
    let tszmin : int = if using64k & VAMax() == 52 then 12 else 16;
    if tsz_field < tszmin then {
        c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
        assert(c == Constraint_FORCE | c == Constraint_NONE);
        if c == Constraint_FORCE then {
            tsz_field = tszmin
        }
    };
    64 - tsz_field
}

val Auth : (bits(64), bits(64), bits(128), bool, bits(1)) -> bits(64) effect {escape, rreg, undef, wreg}

function Auth (ptr, modifier, K, data, keynumber) = {
    PAC : bits(64) = undefined : bits(64);
    result : bits(64) = undefined : bits(64);
    original_ptr : bits(64) = undefined : bits(64);
    error_code : bits(2) = undefined : bits(2);
    extfield : bits(64) = undefined : bits(64);
    let tbi : bool = CalculateTBI(ptr, data);
    let 'bottom_PAC_bit : int = CalculateBottomPACBit([ptr[55]]);
    assert(constraint((- 'bottom_PAC_bit + 55 >= 0 & 'bottom_PAC_bit >= 0)));
    let extfield = replicate_bits([ptr[55]], 64);
    if tbi then {
        original_ptr = (slice(ptr, 56, 8) @ slice(extfield, 0, negate(bottom_PAC_bit) + 56)) @ slice(ptr, 0, bottom_PAC_bit)
    } else {
        original_ptr = slice(extfield, 0, negate(bottom_PAC_bit) + 64) @ slice(ptr, 0, bottom_PAC_bit)
    };
    let PAC = ComputePAC(original_ptr, modifier, slice(K, 64, 64), slice(K, 0, 64));
    if tbi then {
        if slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) == slice(ptr, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) then {
            result = original_ptr
        } else {
            error_code = keynumber @ ~(keynumber);
            result = (slice(original_ptr, 55, 9) @ error_code) @ slice(original_ptr, 0, 53)
        }
    } else {
        if slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) == slice(ptr, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) & slice(PAC, 56, 8) == slice(ptr, 56, 8) then {
            result = original_ptr
        } else {
            error_code = keynumber @ ~(keynumber);
            result = ([original_ptr[63]] @ error_code) @ slice(original_ptr, 0, 61)
        }
    };
    result
}

val BranchToAddr : forall ('N : Int), 'N >= 0.
  (bits('N), BranchType) -> unit effect {escape, rreg, wreg}

function BranchToAddr (target, branch_type) = {
    Hint_Branch(branch_type);
    if 'N == 32 then {
        assert(UsingAArch32());
        _PC = ZeroExtend(target)
    } else {
        assert('N == 64 & ~(UsingAArch32()));
        _PC = slice(target, 0, 64)
    };
    __PC_changed = true;
    return()
}

val BadMode : bits(5) -> bool effect {escape, rreg, undef}

function BadMode mode = {
    valid_name : bool = undefined : bool;
    match mode {
      ? if ? == M32_Monitor => {
          valid_name = HaveAArch32EL(EL3)
      },
      ? if ? == M32_Hyp => {
          valid_name = HaveAArch32EL(EL2)
      },
      ? if ? == M32_FIQ => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_IRQ => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_Svc => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_Abort => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_Undef => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_System => {
          valid_name = HaveAArch32EL(EL1)
      },
      ? if ? == M32_User => {
          valid_name = HaveAArch32EL(EL0)
      },
      _ => {
          valid_name = false
      }
    };
    let valid_name = valid_name;
    ~(valid_name)
}

val aset_Rmode : forall ('n : Int), ('n >= 0 & 'n <= 14).
  (int('n), bits(5), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function aset_Rmode (n, mode, value_name) = {
    assert(n >= 0 & n <= 14);
    if ~(IsSecure()) then {
        assert(mode != M32_Monitor)
    };
    assert(~(BadMode(mode)));
    if mode == M32_Monitor then {
        if n == 13 then {
            SP_mon = value_name
        } else {
            if n == 14 then {
                LR_mon = value_name
            } else {
                __tc1 : bits(64) = _R[n];
                __tc1 = __SetSlice_bits(64, 32, __tc1, 0, value_name);
                _R[n] = __tc1
            }
        }
    } else {
        if ~(HighestELUsingAArch32()) & ConstrainUnpredictableBool(Unpredictable_ZEROUPPER) then {
            _R[LookUpRIndex(n, mode)] = ZeroExtend(value_name)
        } else {
            __tc2 : bits(64) = _R[LookUpRIndex(n, mode)];
            __tc2 = __SetSlice_bits(64, 32, __tc2, 0, value_name);
            _R[LookUpRIndex(n, mode)] = __tc2
        }
    };
    return()
}

overload Rmode = {aset_Rmode}

val aset_R : forall ('n : Int), ('n >= 0 & 'n <= 14).
  (int('n), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function aset_R (n, value_name) = {
    Rmode(n, PSTATE.M) = value_name;
    return()
}

overload R = {aset_R}

val set_LR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_LR value_name = {
    R(14) = value_name;
    return()
}

val AArch32_ResetGeneralRegisters : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_ResetGeneralRegisters () = {
    foreach (i from 0 to 7 by 1 in inc) {
        R(i) = undefined : bits(32)
    };
    foreach (i from 8 to 12 by 1 in inc) {
        Rmode(i, M32_User) = undefined : bits(32);
        Rmode(i, M32_FIQ) = undefined : bits(32)
    };
    if HaveEL(EL2) then {
        Rmode(13, M32_Hyp) = undefined : bits(32)
    };
    foreach (i from 13 to 14 by 1 in inc) {
        Rmode(i, M32_User) = undefined : bits(32);
        Rmode(i, M32_FIQ) = undefined : bits(32);
        Rmode(i, M32_IRQ) = undefined : bits(32);
        Rmode(i, M32_Svc) = undefined : bits(32);
        Rmode(i, M32_Abort) = undefined : bits(32);
        Rmode(i, M32_Undef) = undefined : bits(32);
        if HaveEL(EL3) then {
            Rmode(i, M32_Monitor) = undefined : bits(32)
        }
    };
    return()
}

val ELFromM32 : bits(5) -> (bool, bits(2)) effect {escape, rreg, undef}

function ELFromM32 mode = {
    el : bits(2) = undefined : bits(2);
    valid_name : bool = ~(BadMode(mode));
    match mode {
      ? if ? == M32_Monitor => {
          el = EL3
      },
      ? if ? == M32_Hyp => {
          el = EL2;
          valid_name = valid_name & (~(HaveEL(EL3)) | [SCR_GEN()[0]] == 0b1)
      },
      ? if ? == M32_FIQ => {
          el = if (HaveEL(EL3) & HighestELUsingAArch32()) & [get_SCR()[0]] == 0b0 then EL3 else EL1
      },
      ? if ? == M32_IRQ => {
          el = if (HaveEL(EL3) & HighestELUsingAArch32()) & [get_SCR()[0]] == 0b0 then EL3 else EL1
      },
      ? if ? == M32_Svc => {
          el = if (HaveEL(EL3) & HighestELUsingAArch32()) & [get_SCR()[0]] == 0b0 then EL3 else EL1
      },
      ? if ? == M32_Abort => {
          el = if (HaveEL(EL3) & HighestELUsingAArch32()) & [get_SCR()[0]] == 0b0 then EL3 else EL1
      },
      ? if ? == M32_Undef => {
          el = if (HaveEL(EL3) & HighestELUsingAArch32()) & [get_SCR()[0]] == 0b0 then EL3 else EL1
      },
      ? if ? == M32_System => {
          el = if (HaveEL(EL3) & HighestELUsingAArch32()) & [get_SCR()[0]] == 0b0 then EL3 else EL1
      },
      ? if ? == M32_User => {
          el = EL0
      },
      _ => {
          valid_name = false
      }
    };
    if ~(valid_name) then {
        el = undefined : bits(2)
    };
    return((valid_name, el))
}

val GenMPAMcurEL : forall ('InD : Bool).
  bool('InD) -> MPAMinfo effect {escape, rreg, undef}

function GenMPAMcurEL InD = {
    mpamel : bits(2) = undefined : bits(2);
    validEL_name : bool = undefined : bool;
    let secure : bool = IsSecure();
    if HaveMPAMExt() & MPAMisEnabled() then {
        if UsingAArch32() then {
            (validEL_name, mpamel) = ELFromM32(PSTATE.M)
        } else {
            validEL_name = true;
            mpamel = PSTATE.EL
        };
        if validEL_name then {
            return(genMPAM(UInt(mpamel), InD, secure))
        }
    };
    DefaultMPAMinfo(secure)
}

val CreateAccessDescriptorPTW : forall ('secondstage : Bool) ('s2fs1walk : Bool) 'level.
  (AccType, bool('secondstage), bool('s2fs1walk), int('level)) -> AccessDescriptor effect {escape, rreg, undef}

function CreateAccessDescriptorPTW (acctype, secondstage, s2fs1walk, level) = {
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype == AccType_IFETCH | acctype == AccType_IC);
    accdesc.page_table_walk = true;
    accdesc.secondstage = s2fs1walk;
    accdesc.secondstage = secondstage;
    accdesc.level = level;
    accdesc
}

val CreateAccessDescriptor : AccType -> AccessDescriptor effect {escape, rreg, undef}

function CreateAccessDescriptor acctype = {
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype == AccType_IFETCH | acctype == AccType_IC);
    accdesc.page_table_walk = false;
    accdesc
}

val ELFromSPSR : bits(32) -> (bool, bits(2)) effect {escape, rreg, undef}

function ELFromSPSR spsr = {
    el : bits(2) = undefined : bits(2);
    valid_name : bool = undefined : bool;
    if [spsr[4]] == 0b0 then {
        el = slice(spsr, 2, 2);
        if HighestELUsingAArch32() then {
            valid_name = false
        } else {
            if ~(HaveEL(el)) then {
                valid_name = false
            } else {
                if [spsr[1]] == 0b1 then {
                    valid_name = false
                } else {
                    if el == EL0 & [spsr[0]] == 0b1 then {
                        valid_name = false
                    } else {
                        if ((el == EL2 & HaveEL(EL3)) & ~(IsSecureEL2Enabled())) & [SCR_EL3[0]] == 0b0 then {
                            valid_name = false
                        } else {
                            valid_name = true
                        }
                    }
                }
            }
        }
    } else {
        if ~(HaveAnyAArch32()) then {
            valid_name = false
        } else {
            (valid_name, el) = ELFromM32(slice(spsr, 0, 5))
        }
    };
    if ~(valid_name) then {
        el = undefined : bits(2)
    };
    return((valid_name, el))
}

val IllegalExceptionReturn : bits(32) -> bool effect {escape, rreg, undef}

function IllegalExceptionReturn spsr = {
    target : bits(2) = undefined : bits(2);
    valid_name : bool = undefined : bool;
    (valid_name, target) = ELFromSPSR(spsr);
    if ~(valid_name) then {
        return(true)
    };
    if UInt(target) > UInt(PSTATE.EL) then {
        return(true)
    };
    let spsr_mode_is_aarch32 : bool = [spsr[4]] == 0b1;
    known : bool = undefined : bool;
    target_el_is_aarch32 : bool = undefined : bool;
    (known, target_el_is_aarch32) = ELUsingAArch32K(target);
    assert(known | target == EL0 & ~(ELUsingAArch32(EL1)));
    if known & spsr_mode_is_aarch32 != target_el_is_aarch32 then {
        return(true)
    };
    if UsingAArch32() & ~(spsr_mode_is_aarch32) then {
        return(true)
    };
    if (HaveEL(EL2) & target == EL1) & [HCR_EL2[27]] == 0b1 then {
        if ~(IsSecureBelowEL3()) | IsSecureEL2Enabled() then {
            return(true)
        }
    };
    false
}

val AArch32_WriteMode : bits(5) -> unit effect {escape, rreg, undef, wreg}

function AArch32_WriteMode mode = {
    el : bits(2) = undefined : bits(2);
    valid_name : bool = undefined : bool;
    (valid_name, el) = ELFromM32(mode);
    assert(valid_name);
    PSTATE.M = mode;
    PSTATE.EL = el;
    PSTATE.nRW = 0b1;
    PSTATE.SP = if mode == M32_User | mode == M32_System then 0b0 else 0b1;
    return()
}

val AddrTop : forall ('IsInstr : Bool).
  (bits(64), bool('IsInstr), bits(2)) -> int effect {escape, rreg, undef}

function AddrTop (address, IsInstr, el) = {
    assert(HaveEL(el));
    let regime : vector(2, dec, bit) = S1TranslationRegime(el);
    tbi : bits(1) = undefined : bits(1);
    tbid : bits(1) = undefined : bits(1);
    if ELUsingAArch32(regime) then {
        return(31)
    } else {
        match regime {
          ? if ? == EL1 => {
              tbi = if [address[55]] == 0b1 then [TCR_EL1[38]] else [TCR_EL1[37]];
              if HavePACExt() then {
                  tbid = if [address[55]] == 0b1 then [TCR_EL1[52]] else [TCR_EL1[51]]
              }
          },
          ? if ? == EL2 => {
              if HaveVirtHostExt() & ELIsInHost(el) then {
                  tbi = if [address[55]] == 0b1 then [TCR_EL2[38]] else [TCR_EL2[37]];
                  if HavePACExt() then {
                      tbid = if [address[55]] == 0b1 then [TCR_EL2[52]] else [TCR_EL2[51]]
                  }
              } else {
                  tbi = [TCR_EL2[20]];
                  if HavePACExt() then {
                      tbid = [TCR_EL2[29]]
                  }
              }
          },
          ? if ? == EL3 => {
              tbi = [TCR_EL3[20]];
              if HavePACExt() then {
                  tbid = [TCR_EL3[29]]
              }
          }
        }
    };
    if tbi == 0b1 & ((~(HavePACExt()) | tbid == 0b0) | ~(IsInstr)) then 55 else 63
}

val getTLBContext : forall ('secondstage : Bool).
  (bits(64), bool('secondstage), bits(1), AccType) -> TLBContext effect {escape, rreg, undef}

function getTLBContext (inputaddr, secondstage, s1_nonsecure, acctype) = {
    context : TLBContext = undefined : TLBContext;
    context.secondstage = secondstage;
    context.twostage = HasS2Translation();
    context.el = PSTATE.EL;
    secure : bool = undefined : bool;
    asidregister : bits(64) = undefined : bits(64);
    granule : bits(2) = undefined : bits(2);
    t_sz : bits(6) = undefined : bits(6);
    secure = IsSecure();
    let top : int = AddrTop(inputaddr, acctype == AccType_IFETCH, PSTATE.EL);
    if ~(secondstage) then {
        if PSTATE.nRW == 0b1 then {
            if PSTATE.EL == EL2 then {
                asidregister = Zeros();
                t_sz = ZeroExtend(slice(get_HTCR(), 0, 3))
            } else {
                asidregister = if [get_TTBCR()[22]] == 0b0 then get_TTBR0() else get_TTBR1();
                t_sz = ZeroExtend(slice(get_TTBCR(), 0, 3))
            };
            granule = 0b00
        } else {
            if PSTATE.EL == EL3 then {
                asidregister = TTBR0_EL3;
                granule = slice(TCR_EL3, 14, 2);
                t_sz = slice(TCR_EL3, 0, 6)
            } else {
                if IsInHost() then {
                    asidregister = if [TCR_EL2[22]] == 0b0 then TTBR0_EL2 else TTBR1_EL2;
                    if [inputaddr[top]] == 0b0 then {
                        granule = slice(TCR_EL2, 14, 2);
                        t_sz = slice(TCR_EL2, 0, 6)
                    } else {
                        granule = GranuleSizeTG0(slice(TCR_EL2, 30, 2));
                        t_sz = slice(TCR_EL2, 16, 6)
                    }
                } else {
                    if PSTATE.EL == EL2 then {
                        asidregister = TTBR0_EL2;
                        granule = slice(TCR_EL2, 14, 2);
                        t_sz = slice(TCR_EL2, 0, 6)
                    } else {
                        asidregister = if [TCR_EL1[22]] == 0b0 then TTBR0_EL1 else TTBR1_EL1;
                        if [inputaddr[top]] == 0b0 then {
                            granule = slice(TCR_EL1, 14, 2);
                            t_sz = slice(TCR_EL1, 0, 6)
                        } else {
                            granule = GranuleSizeTG0(slice(TCR_EL1, 30, 2));
                            t_sz = slice(TCR_EL1, 16, 6)
                        }
                    }
                }
            }
        }
    } else {
        if PSTATE.nRW == 0b1 then {
            asidregister = get_VTTBR();
            granule = 0b00;
            t_sz = ZeroExtend(slice(get_VTCR(), 0, 4))
        } else {
            secure = if IsSecureEL2Enabled() & IsSecure() then s1_nonsecure == 0b0 else false;
            if secure then {
                asidregister = VSTTBR_EL2;
                granule = slice(VSTCR_EL2, 14, 2);
                t_sz = slice(VSTCR_EL2, 0, 6)
            } else {
                asidregister = VTTBR_EL2;
                granule = slice(VTCR_EL2, 14, 2);
                t_sz = slice(VTCR_EL2, 0, 6)
            }
        }
    };
    context.secure = secure;
    context.asid = slice(asidregister, 48, 16);
    context.vmid = VTTBR_EL2[56 .. 49] @ VTTBR_EL2[48 .. 41];
    context.t_sz = t_sz;
    if granule == 0b00 then {
        context.granule_size = 12
    } else {
        if granule == 0b10 then {
            context.granule_size = 14
        } else {
            context.granule_size = 16
        }
    };
    context
}

val TLBLookup : (bits(64), bool, bits(1), AccType) -> TLBLine effect {escape, rreg, undef, wreg}

function TLBLookup (address, secondstage, s1_nonsecure, acctype) = {
    let context : TLBContext = getTLBContext(address, secondstage, s1_nonsecure, acctype);
    let 'idx = UInt(TLBIndex(address, context));
    let 'granule_size = context.granule_size;
    assert(constraint((- 'granule_size + 52 >= 0 & 'granule_size >= 0)));
    result : TLBLine = undefined : TLBLine;
    result = _TLB[idx];
    if (~(result.valid_name) | slice(result.address, granule_size, negate(granule_size) + 64) != slice(address, granule_size, negate(granule_size) + 64)) | ~(TLBContextMatch(result.context, context)) then {
        TLBMisses = TLBMisses + 1;
        result.valid_name = false
    } else {
        TLBHits = TLBHits + 1;
        __tc1 : FullAddress = result.data.addrdesc.paddress;
        __tc1.address = slice(result.data.addrdesc.paddress.address, granule_size, negate(granule_size) + 52) @ slice(address, 0, granule_size);
        __tc2 : AddressDescriptor = result.data.addrdesc;
        __tc2.paddress = __tc1;
        __tc3 : TLBRecord = result.data;
        __tc3.addrdesc = __tc2;
        result.data = __tc3
    };
    result
}

val TLBCache : forall ('secondstage : Bool).
  (bits(64), bool('secondstage), bits(1), AccType, TLBRecord) -> unit effect {escape, rreg, undef, wreg}

function TLBCache (address, secondstage, s1_nonsecure, acctype, data) = {
    let context : TLBContext = getTLBContext(address, secondstage, s1_nonsecure, acctype);
    let idx = UInt(TLBIndex(address, context));
    __tc1 : TLBLine = _TLB[idx];
    __tc1.address = address;
    _TLB[idx] = __tc1;
    __tc2 : TLBLine = _TLB[idx];
    __tc2.context = context;
    _TLB[idx] = __tc2;
    __tc3 : TLBLine = _TLB[idx];
    __tc3.data = data;
    _TLB[idx] = __tc3;
    __tc4 : DescriptorUpdate = _TLB[idx].data.descupdate;
    __tc4.AF = false;
    __tc5 : TLBRecord = _TLB[idx].data;
    __tc5.descupdate = __tc4;
    __tc6 : TLBLine = _TLB[idx];
    __tc6.data = __tc5;
    _TLB[idx] = __tc6;
    __tc7 : TLBLine = _TLB[idx];
    __tc7.valid_name = true;
    _TLB[idx] = __tc7
}

val AddPAC : (bits(64), bits(64), bits(128), bool) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPAC (ptr, modifier, K, data) = {
    PAC : bits(64) = undefined : bits(64);
    result : bits(64) = undefined : bits(64);
    ext_ptr : bits(64) = undefined : bits(64);
    extfield : bits(64) = undefined : bits(64);
    selbit : bits(1) = undefined : bits(1);
    let tbi : bool = CalculateTBI(ptr, data);
    let 'top_bit : {|55, 63|} = if tbi then 55 else 63;
    if PtrHasUpperAndLowerAddRanges() then {
        assert(S1TranslationRegime() == EL1 | S1TranslationRegime() == EL2);
        if S1TranslationRegime() == EL1 then {
            if data then {
                selbit = if [TCR_EL1[38]] == 0b1 | [TCR_EL1[37]] == 0b1 then [ptr[55]] else [ptr[63]]
            } else {
                if [TCR_EL1[38]] == 0b1 & [TCR_EL1[52]] == 0b0 | [TCR_EL1[37]] == 0b1 & [TCR_EL1[51]] == 0b0 then {
                    selbit = [ptr[55]]
                } else {
                    selbit = [ptr[63]]
                }
            }
        } else {
            if data then {
                selbit = if HaveEL(EL2) & [TCR_EL2[38]] == 0b1 | HaveEL(EL2) & [TCR_EL2[37]] == 0b1 then [ptr[55]] else [ptr[63]]
            } else {
                selbit = if (HaveEL(EL2) & [TCR_EL2[38]] == 0b1) & [TCR_EL1[52]] == 0b0 | (HaveEL(EL2) & [TCR_EL2[37]] == 0b1) & [TCR_EL1[51]] == 0b0 then [ptr[55]] else [ptr[63]]
            }
        }
    } else {
        selbit = if tbi then [ptr[55]] else [ptr[63]]
    };
    let 'bottom_PAC_bit : int = CalculateBottomPACBit(selbit);
    assert(constraint((- 'bottom_PAC_bit + 55 >= 0 & 'bottom_PAC_bit >= 0)));
    let extfield = replicate_bits(selbit, 64);
    if tbi then {
        ext_ptr = (slice(ptr, 56, 8) @ slice(extfield, 0, negate(bottom_PAC_bit) + 56)) @ slice(ptr, 0, bottom_PAC_bit)
    } else {
        ext_ptr = slice(extfield, 0, negate(bottom_PAC_bit) + 64) @ slice(ptr, 0, bottom_PAC_bit)
    };
    PAC = ComputePAC(ext_ptr, modifier, slice(K, 64, 64), slice(K, 0, 64));
    if ~(IsZero(slice(ptr, bottom_PAC_bit, top_bit - bottom_PAC_bit + 1))) & ~(IsOnes(slice(ptr, bottom_PAC_bit, top_bit - bottom_PAC_bit + 1))) then {
        PAC = __SetSlice_bits(64, 1, PAC, top_bit - 1, ~([PAC[top_bit - 1]]))
    };
    if tbi then {
        result = ((slice(ptr, 56, 8) @ selbit) @ slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55)) @ slice(ptr, 0, bottom_PAC_bit)
    } else {
        result = ((slice(PAC, 56, 8) @ selbit) @ slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55)) @ slice(ptr, 0, bottom_PAC_bit)
    };
    result
}

val AccessIsTagChecked : (bits(64), AccType) -> bool effect {escape, rreg, undef}

function AccessIsTagChecked (vaddr, acctype) = {
    if [PSTATE.M[4]] == 0b1 then {
        return(false)
    };
    if EffectiveTBI(vaddr, false, PSTATE.EL) == 0b0 then {
        return(false)
    };
    if EffectiveTCMA(vaddr, PSTATE.EL) == 0b1 & (slice(vaddr, 55, 5) == 0b00000 | slice(vaddr, 55, 5) == 0b11111) then {
        return(false)
    };
    if ~(AllocationTagAccessIsEnabled()) then {
        return(false)
    };
    if acctype == AccType_IFETCH | acctype == AccType_PTW then {
        return(false)
    };
    if acctype == AccType_NV2REGISTER then {
        return(false)
    };
    if PSTATE.TCO == 0b1 then {
        return(false)
    };
    if IsNonTagCheckedInstruction() then {
        return(false)
    };
    true
}

val AArch64_WatchpointByteMatch : forall ('n : Int).
  (int('n), AccType, bits(64)) -> bool effect {escape, rreg, undef}

function AArch64_WatchpointByteMatch (n, acctype, vaddress) = {
    let el : bits(2) = if HaveNV2Ext() & acctype == AccType_NV2REGISTER then EL2 else PSTATE.EL;
    let 'top = AddrTop(vaddress, false, el);
    bottom : int = undefined : int;
    bottom = if [DBGWVR_EL1[n][2]] == 0b1 then 2 else 3;
    let 'bottom_fixed = bottom;
    assert(constraint('bottom_fixed in {2, 3}));
    byte_select_match : bool = undefined : bool;
    byte_select_match = [slice(DBGWCR_EL1[n], 5, 8)[UInt(slice(vaddress, 0, bottom_fixed))]] != 0b0;
    mask : int = undefined : int;
    mask = UInt(slice(DBGWCR_EL1[n], 24, 5));
    LSB : bits(8) = undefined : bits(8);
    MSB : bits(8) = undefined : bits(8);
    if mask > 0 & ~(IsOnes(slice(DBGWCR_EL1[n], 5, 8))) then {
        byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPMASKANDBAS)
    } else {
        LSB = slice(DBGWCR_EL1[n], 5, 8) & ~(slice(DBGWCR_EL1[n], 5, 8) - 1);
        MSB = slice(DBGWCR_EL1[n], 5, 8) + LSB;
        if ~(IsZero(MSB & MSB - 1)) then {
            byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPBASCONTIGUOUS);
            bottom = 3
        }
    };
    c : Constraint = undefined : Constraint;
    if mask > 0 & mask <= 2 then {
        (c, mask) = ConstrainUnpredictableInteger(3, 31, Unpredictable_RESWPMASK);
        assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
        match c {
          Constraint_DISABLED => {
              return(false)
          },
          Constraint_NONE => {
              mask = 0
          }
        }
    };
    WVR_match : bool = undefined : bool;
    let 'bottom = bottom;
    assert(constraint('bottom in {2, 3}));
    if mask > bottom then {
        let 'mask = mask;
        assert(constraint(('top - 'mask + 1 >= 0 & 'mask - 'bottom >= 0)));
        WVR_match = slice(vaddress, mask, top - mask + 1) == slice(DBGWVR_EL1[n], mask, top - mask + 1);
        if WVR_match & ~(IsZero(slice(DBGWVR_EL1[n], bottom, mask - bottom))) then {
            WVR_match = ConstrainUnpredictableBool(Unpredictable_WPMASKEDBITS)
        }
    } else {
        let 'mask = mask;
        assert(constraint('top - 'bottom + 1 >= 0));
        WVR_match = slice(vaddress, bottom, top - bottom + 1) == slice(DBGWVR_EL1[n], bottom, top - bottom + 1)
    };
    WVR_match & byte_select_match
}

val AArch64_TranslateAddressS1Off : (bits(64), AccType, bool) -> TLBRecord effect {escape, rreg, undef}

function AArch64_TranslateAddressS1Off (vaddress, acctype, iswrite) = {
    assert(~(ELUsingAArch32(S1TranslationRegime())));
    result : TLBRecord = undefined : TLBRecord;
    let 'Top = AddrTop(vaddress, acctype == AccType_IFETCH, PSTATE.EL);
    ipaddress : bits(52) = undefined : bits(52);
    level : int = undefined : int;
    s2fs1walk : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    let 'pa_max = PAMax();
    assert(constraint('Top + 1 - 'pa_max >= 0));
    if ~(IsZero(slice(vaddress, pa_max, Top + 1 - pa_max))) then {
        level = 0;
        ipaddress = undefined : bits(52);
        secondstage = false;
        s2fs1walk = false;
        __tc1 : AddressDescriptor = result.addrdesc;
        __tc1.fault = AArch64_AddressSizeFault(ipaddress, undefined : bits(1), level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc1;
        return(result)
    };
    let default_cacheable : bool = HasS2Translation() & [HCR_EL2[12]] == 0b1;
    cacheable : bool = undefined : bool;
    if default_cacheable then {
        __tc2 : MemoryAttributes = result.addrdesc.memattrs;
        __tc2.typ = MemType_Normal;
        __tc3 : AddressDescriptor = result.addrdesc;
        __tc3.memattrs = __tc2;
        result.addrdesc = __tc3;
        __tc4 : MemAttrHints = result.addrdesc.memattrs.inner;
        __tc4.attrs = MemAttr_WB;
        __tc5 : MemoryAttributes = result.addrdesc.memattrs;
        __tc5.inner = __tc4;
        __tc6 : AddressDescriptor = result.addrdesc;
        __tc6.memattrs = __tc5;
        result.addrdesc = __tc6;
        __tc7 : MemAttrHints = result.addrdesc.memattrs.inner;
        __tc7.hints = MemHint_RWA;
        __tc8 : MemoryAttributes = result.addrdesc.memattrs;
        __tc8.inner = __tc7;
        __tc9 : AddressDescriptor = result.addrdesc;
        __tc9.memattrs = __tc8;
        result.addrdesc = __tc9;
        __tc10 : MemoryAttributes = result.addrdesc.memattrs;
        __tc10.shareable = false;
        __tc11 : AddressDescriptor = result.addrdesc;
        __tc11.memattrs = __tc10;
        result.addrdesc = __tc11;
        __tc12 : MemoryAttributes = result.addrdesc.memattrs;
        __tc12.outershareable = false;
        __tc13 : AddressDescriptor = result.addrdesc;
        __tc13.memattrs = __tc12;
        result.addrdesc = __tc13;
        __tc14 : MemoryAttributes = result.addrdesc.memattrs;
        __tc14.tagged = [HCR_EL2[57]] == 0b1;
        __tc15 : AddressDescriptor = result.addrdesc;
        __tc15.memattrs = __tc14;
        result.addrdesc = __tc15
    } else {
        if acctype != AccType_IFETCH then {
            __tc16 : MemoryAttributes = result.addrdesc.memattrs;
            __tc16.typ = MemType_Device;
            __tc17 : AddressDescriptor = result.addrdesc;
            __tc17.memattrs = __tc16;
            result.addrdesc = __tc17;
            __tc18 : MemoryAttributes = result.addrdesc.memattrs;
            __tc18.device = DeviceType_nGnRnE;
            __tc19 : AddressDescriptor = result.addrdesc;
            __tc19.memattrs = __tc18;
            result.addrdesc = __tc19;
            __tc20 : MemoryAttributes = result.addrdesc.memattrs;
            __tc20.inner = undefined : MemAttrHints;
            __tc21 : AddressDescriptor = result.addrdesc;
            __tc21.memattrs = __tc20;
            result.addrdesc = __tc21;
            __tc22 : MemoryAttributes = result.addrdesc.memattrs;
            __tc22.tagged = false;
            __tc23 : AddressDescriptor = result.addrdesc;
            __tc23.memattrs = __tc22;
            result.addrdesc = __tc23
        } else {
            cacheable = [aget_SCTLR()[12]] == 0b1;
            __tc24 : MemoryAttributes = result.addrdesc.memattrs;
            __tc24.typ = MemType_Normal;
            __tc25 : AddressDescriptor = result.addrdesc;
            __tc25.memattrs = __tc24;
            result.addrdesc = __tc25;
            if cacheable then {
                __tc26 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc26.attrs = MemAttr_WT;
                __tc27 : MemoryAttributes = result.addrdesc.memattrs;
                __tc27.inner = __tc26;
                __tc28 : AddressDescriptor = result.addrdesc;
                __tc28.memattrs = __tc27;
                result.addrdesc = __tc28;
                __tc29 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc29.hints = MemHint_RA;
                __tc30 : MemoryAttributes = result.addrdesc.memattrs;
                __tc30.inner = __tc29;
                __tc31 : AddressDescriptor = result.addrdesc;
                __tc31.memattrs = __tc30;
                result.addrdesc = __tc31
            } else {
                __tc32 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc32.attrs = MemAttr_NC;
                __tc33 : MemoryAttributes = result.addrdesc.memattrs;
                __tc33.inner = __tc32;
                __tc34 : AddressDescriptor = result.addrdesc;
                __tc34.memattrs = __tc33;
                result.addrdesc = __tc34;
                __tc35 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc35.hints = MemHint_No;
                __tc36 : MemoryAttributes = result.addrdesc.memattrs;
                __tc36.inner = __tc35;
                __tc37 : AddressDescriptor = result.addrdesc;
                __tc37.memattrs = __tc36;
                result.addrdesc = __tc37
            };
            __tc38 : MemoryAttributes = result.addrdesc.memattrs;
            __tc38.shareable = true;
            __tc39 : AddressDescriptor = result.addrdesc;
            __tc39.memattrs = __tc38;
            result.addrdesc = __tc39;
            __tc40 : MemoryAttributes = result.addrdesc.memattrs;
            __tc40.outershareable = true;
            __tc41 : AddressDescriptor = result.addrdesc;
            __tc41.memattrs = __tc40;
            result.addrdesc = __tc41;
            __tc42 : MemoryAttributes = result.addrdesc.memattrs;
            __tc42.tagged = false;
            __tc43 : AddressDescriptor = result.addrdesc;
            __tc43.memattrs = __tc42;
            result.addrdesc = __tc43
        }
    };
    __tc44 : MemoryAttributes = result.addrdesc.memattrs;
    __tc44.outer = result.addrdesc.memattrs.inner;
    __tc45 : AddressDescriptor = result.addrdesc;
    __tc45.memattrs = __tc44;
    result.addrdesc = __tc45;
    __tc46 : AddressDescriptor = result.addrdesc;
    __tc46.memattrs = MemAttrDefaults(result.addrdesc.memattrs);
    result.addrdesc = __tc46;
    __tc47 : Permissions = result.perms;
    __tc47.ap = undefined : bits(3);
    result.perms = __tc47;
    __tc48 : Permissions = result.perms;
    __tc48.xn = 0b0;
    result.perms = __tc48;
    __tc49 : Permissions = result.perms;
    __tc49.pxn = 0b0;
    result.perms = __tc49;
    result.nG = undefined : bits(1);
    result.contiguous = undefined : bool;
    result.domain = undefined : bits(4);
    result.level = undefined : int;
    result.blocksize = undefined : int;
    __tc50 : FullAddress = result.addrdesc.paddress;
    __tc50.address = slice(vaddress, 0, 52);
    __tc51 : AddressDescriptor = result.addrdesc;
    __tc51.paddress = __tc50;
    result.addrdesc = __tc51;
    __tc52 : FullAddress = result.addrdesc.paddress;
    __tc52.NS = if IsSecure() then 0b0 else 0b1;
    __tc53 : AddressDescriptor = result.addrdesc;
    __tc53.paddress = __tc52;
    result.addrdesc = __tc53;
    __tc54 : AddressDescriptor = result.addrdesc;
    __tc54.fault = AArch64_NoFault();
    result.addrdesc = __tc54;
    result
}

val AArch64_S1AttrDecode : (bits(2), bits(3), AccType) -> MemoryAttributes effect {escape, rreg, undef}

function AArch64_S1AttrDecode (SH, attr, acctype) = {
    memattrs : MemoryAttributes = undefined : MemoryAttributes;
    let mair : vector(64, dec, bit) = MAIR();
    let index : {'ex140927#, (0 <= 'ex140927# & 'ex140927# <= 2 ^ 3 - 1). int(8 * 'ex140927#)} = 8 * UInt(attr);
    attrfield : bits(8) = undefined : bits(8);
    attrfield = slice(mair, index, 8);
    memattrs.tagged = false;
    __anon1 : Constraint = undefined : Constraint;
    if (slice(attrfield, 4, 4) != 0x0 & slice(attrfield, 4, 4) != 0xF) & slice(attrfield, 0, 4) == 0x0 | slice(attrfield, 4, 4) == 0x0 & (slice(attrfield, 0, 4) & 0x3) != 0x0 then {
        (__anon1, attrfield) = ConstrainUnpredictableBits(Unpredictable_RESMAIR)
    };
    __anon2 : Constraint = undefined : Constraint;
    if (~(HaveMTEExt()) & slice(attrfield, 4, 4) == 0xF) & slice(attrfield, 0, 4) == 0x0 then {
        (__anon2, attrfield) = ConstrainUnpredictableBits(Unpredictable_RESMAIR)
    };
    if slice(attrfield, 4, 4) == 0x0 then {
        memattrs.typ = MemType_Device;
        match slice(attrfield, 0, 4) {
          0x0 => {
              memattrs.device = DeviceType_nGnRnE
          },
          0x4 => {
              memattrs.device = DeviceType_nGnRE
          },
          0x8 => {
              memattrs.device = DeviceType_nGRE
          },
          0xC => {
              memattrs.device = DeviceType_GRE
          },
          _ => {
              Unreachable()
          }
        }
    } else {
        if slice(attrfield, 0, 4) != 0x0 then {
            memattrs.typ = MemType_Normal;
            memattrs.outer = LongConvertAttrsHints(slice(attrfield, 4, 4), acctype);
            memattrs.inner = LongConvertAttrsHints(slice(attrfield, 0, 4), acctype);
            memattrs.shareable = [SH[1]] == 0b1;
            memattrs.outershareable = SH == 0b10
        } else {
            if HaveMTEExt() & attrfield == 0xF0 then {
                memattrs.tagged = true;
                memattrs.typ = MemType_Normal;
                __tc1 : MemAttrHints = memattrs.outer;
                __tc1.attrs = MemAttr_WB;
                memattrs.outer = __tc1;
                __tc2 : MemAttrHints = memattrs.inner;
                __tc2.attrs = MemAttr_WB;
                memattrs.inner = __tc2;
                __tc3 : MemAttrHints = memattrs.outer;
                __tc3.hints = MemHint_RWA;
                memattrs.outer = __tc3;
                __tc4 : MemAttrHints = memattrs.inner;
                __tc4.hints = MemHint_RWA;
                memattrs.inner = __tc4;
                memattrs.shareable = [SH[1]] == 0b1;
                memattrs.outershareable = SH == 0b10
            } else {
                Unreachable()
            }
        }
    };
    MemAttrDefaults(memattrs)
}

val AArch64_PendingUnmaskedPhysicalInterrupts : bits(3) -> (bool, bool, bool) effect {escape, rreg, undef}

function AArch64_PendingUnmaskedPhysicalInterrupts mask__arg = {
    mask = mask__arg;
    let se_pending : vector(1, dec, bit) = if IsPhysicalSErrorPending() then 0b1 else 0b0;
    let irq_pending : vector(1, dec, bit) = if IRQPending() then 0b1 else 0b0;
    let fiq_pending : vector(1, dec, bit) = if FIQPending() then 0b1 else 0b0;
    let pending : bits(3) = (se_pending @ irq_pending) @ fiq_pending;
    mask_override : bits(3) = undefined : bits(3);
    if EL2Enabled() then {
        if (HaveVirtHostExt() & [HCR_EL2[34]] == 0b1) & [HCR_EL2[27]] == 0b1 then {
            mask_override = 0b000
        } else {
            if [HCR_EL2[27]] == 0b1 then {
                mask_override = 0b111
            } else {
                mask_override = HCR_EL2[5 .. 5] @ (HCR_EL2[4 .. 4] @ HCR_EL2[3 .. 3])
            }
        };
        if PSTATE.EL == EL1 | PSTATE.EL == EL0 then {
            mask = mask & ~(mask_override)
        } else {
            if ~(ELUsingAArch32(EL2)) & [HCR_EL2[27]] == 0b0 then {
                mask = mask | ~(mask_override)
            }
        }
    };
    if HaveEL(EL3) then {
        if PSTATE.EL != EL3 then {
            mask = mask & ~(SCR_EL3[3 .. 3] @ (SCR_EL3[1 .. 1] @ SCR_EL3[2 .. 2]))
        } else {
            mask = mask | ~(SCR_EL3[3 .. 3] @ (SCR_EL3[1 .. 1] @ SCR_EL3[2 .. 2]))
        }
    };
    let unmasked_pending : bits(3) = pending & ~(mask);
    return(([unmasked_pending[2]] == 0b1, [unmasked_pending[1]] == 0b1, [unmasked_pending[0]] == 0b1))
}

val AArch64_MaybeZeroRegisterUppers : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_MaybeZeroRegisterUppers () = {
    assert(UsingAArch32());
    first : int = undefined : int;
    include_R15_name : bool = undefined : bool;
    last : int = undefined : int;
    if PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1)) then {
        first = 0;
        last = 14;
        include_R15_name = false
    } else {
        if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & ~(ELUsingAArch32(EL2)) then {
            first = 0;
            last = 30;
            include_R15_name = false
        } else {
            first = 0;
            last = 30;
            include_R15_name = true
        }
    };
    foreach (n from first to last by 1 in inc) {
        if (n != 15 | include_R15_name) & ConstrainUnpredictableBool(Unpredictable_ZEROUPPER) then {
            __tc1 : bits(64) = _R[n];
            __tc1 = __SetSlice_bits(64, 32, __tc1, 32, Zeros());
            _R[n] = __tc1
        }
    };
    return()
}

val AArch64_IMPDEFResets : unit -> unit effect {rreg, wreg}

function AArch64_IMPDEFResets () = {
    DCZID_EL0 = __SetSlice_bits(32, 1, DCZID_EL0, 4, 0b0);
    DCZID_EL0 = __SetSlice_bits(32, 4, DCZID_EL0, 0, 0x4);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 32, 0x6);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 28, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 20, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 12, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 8, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 4, 0x0);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 0, 0x6);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 60, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 44, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 40, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 36, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 32, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 28, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 20, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 16, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 12, 0x1);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 8, 0x1);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 4, 0x2);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 28, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 24, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 20, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 16, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 12, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 8, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 4, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 0, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 28, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 24, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 20, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 16, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 12, 0x1);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 8, 0x1);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 4, 0x2);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 0, 0x5);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 28, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 24, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 20, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 16, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 12, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 8, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 4, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 0, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 36, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 32, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 28, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 24, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 20, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 16, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 12, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 8, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 4, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 0, 0x2);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 32, 0x00);
    VMPIDR_EL2 = __SetSlice_bits(64, 1, VMPIDR_EL2, 30, 0b0);
    VMPIDR_EL2 = __SetSlice_bits(64, 1, VMPIDR_EL2, 24, 0b0);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 16, 0x00);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 8, 0x00);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 0, 0x00);
    if HasArchVersion(ARMv8p1) then {
        ID_ISAR5_EL1 = __SetSlice_bits(32, 4, ID_ISAR5_EL1, 24, 0x1);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 20, 0x2);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 28, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 16, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 12, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 8, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 0, 0x2)
    };
    if __crc32_implemented then {
        ID_ISAR5_EL1 = __SetSlice_bits(32, 4, ID_ISAR5_EL1, 16, 0x1);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 16, 0x1)
    };
    if __vmid16_implemented then {
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 4, 0x2)
    };
    if __pan_implemented then {
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 20, 0x1);
        ID_MMFR3_EL1 = __SetSlice_bits(32, 4, ID_MMFR3_EL1, 16, 0x1)
    };
    if __crypto_aes_implemented == 0 then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 4, 0x0)
    };
    if __crypto_aes_implemented == 1 then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 4, 0x1)
    };
    if ~(__crypto_sha1_implemented) then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 8, 0x0)
    };
    if ~(__crypto_sha256_implemented) then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 12, 0x0)
    };
    if HasArchVersion(ARMv8p2) then {
        ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 0, 0x6);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 28, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 20, 0x2);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 0, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 4, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 8, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 16, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 12, 0x1);
        ID_MMFR3_EL1 = __SetSlice_bits(32, 4, ID_MMFR3_EL1, 16, 0x2);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 8, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 12, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 20, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 4, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 0, 0x1);
        ID_ISAR6_EL1 = __SetSlice_bits(32, 4, ID_ISAR6_EL1, 4, 0x1)
    };
    if __dot_product_implemented then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 44, 0x1)
    };
    if __fp16_implemented then {
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 16, 0x1);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 20, 0x1)
    };
    if __aa32_hpd_implemented then {
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 12, 0x2);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 16, 0x2)
    };
    if __mpam_implemented then {
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 40, CFG_ID_AA64PFR0_EL1_MPAM);
        MPAMIDR_EL1 = __SetSlice_bits(64, 16, MPAMIDR_EL1, 0, __mpam_partid_max);
        MPAMIDR_EL1 = __SetSlice_bits(64, 8, MPAMIDR_EL1, 32, __mpam_pmg_max);
        MPAMIDR_EL1 = __SetSlice_bits(64, 1, MPAMIDR_EL1, 17, if __mpam_has_hcr then 0b1 else 0b0);
        MPAMIDR_EL1 = __SetSlice_bits(64, 3, MPAMIDR_EL1, 18, __mpam_vpmr_max)
    };
    if HasArchVersion(ARMv8p3) then {
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 4, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 8, 0x0);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 24, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 28, 0x0);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 12, 0x1);
        ID_ISAR6_EL1 = __SetSlice_bits(32, 4, ID_ISAR6_EL1, 0, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 20, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 24, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 24, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 20, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 16, 0x1)
    };
    if HasArchVersion(ARMv8p4) then {
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 20, 0x2);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 24, 0x2);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 28, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 32, 0x1);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 36, 0x1);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 56, 0x2);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 52, 0x0);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 48, 0x1);
        ID_ISAR6_EL1 = __SetSlice_bits(32, 4, ID_ISAR6_EL1, 8, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 52, __GetSlice_int(4, __block_bbm_implemented, 0));
        if __crypto_sha512_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 12, 0x2)
        };
        if __crypto_sha3_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 32, 0x1)
        };
        if __crypto_sm3_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 36, 0x1)
        };
        if __crypto_sm4_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 40, 0x1)
        }
    };
    if HasArchVersion(ARMv8p5) then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 52, 0x2);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 32, 0x1);
        ID_AA64PFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64PFR1_EL1, 0, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 60, 0x1)
    };
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 18, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 17, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 16, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 15, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 14, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 13, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 12, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 11, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 10, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 9, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 8, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 7, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 3, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 2, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 1, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 0, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 31, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, if [HCR_EL2[34]] == 0 then 20 else 28, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 10, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 8, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 31, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, if [HCR_EL2[34]] == 0 then 20 else 28, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 20, 0b11);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 16, 0b11);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 49, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 52, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 50, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 44, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 43, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 42, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 41, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 40, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 38, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 37, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 36, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 35, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 34, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 33, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 32, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 31, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 30, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 29, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 28, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 27, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 26, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 25, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 24, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 23, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 22, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 21, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 20, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 19, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 18, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 17, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 16, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 15, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 14, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 13, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 12, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 2, HCR_EL2, 10, 0b00);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 9, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 8, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 7, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 6, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 5, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 4, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 3, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 2, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 1, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 0, 0b0);
    HSTR_EL2 = __SetSlice_bits(32, 16, HSTR_EL2, 0, Zeros());
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 31, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 30, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 27, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 25, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 13, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 31, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 30, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 27, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 25, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 13, 0b0);
    CPACR_EL1 = __SetSlice_bits(32, 1, CPACR_EL1, 28, 0b0);
    CPACR_EL1 = __SetSlice_bits(32, 2, CPACR_EL1, 20, 0b00);
    CPACR_EL1 = __SetSlice_bits(32, 2, CPACR_EL1, 16, 0b00);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 31, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 30, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 27, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 25, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 13, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 31, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 30, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 27, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 25, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 13, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 14, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 2, MDCR_EL2, 12, 0b10);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 0, 0b1);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 0, 0b1);
    ICC_SRE_EL1_S = __SetSlice_bits(32, 1, ICC_SRE_EL1_S, 0, 0b1);
    ICC_SRE_EL1_NS = __SetSlice_bits(32, 1, ICC_SRE_EL1_NS, 0, 0b1);
    CTR_EL0 = __SetSlice_bits(64, 4, CTR_EL0, 20, __exclusive_granule_size);
    return()
}

val ResetControlRegisters : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function ResetControlRegisters cold = {
    if ~(HighestELUsingAArch32()) then {
        AArch64_AutoGen_ArchitectureReset(cold)
    } else {
        AArch32_AutoGen_ArchitectureReset(cold)
    };
    AArch32_IMPDEFResets();
    AArch64_IMPDEFResets();
    __Reset(cold);
    return()
}

val AArch64_ResetControlRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit effect {escape, rreg, undef, wreg}

function AArch64_ResetControlRegisters cold_reset = {
    ResetControlRegisters(cold_reset);
    _TLB_Invalidate()
}

val AArch32_ResetControlRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit effect {escape, rreg, undef, wreg}

function AArch32_ResetControlRegisters cold_reset = {
    PSTATE.SS = 0b0;
    ResetControlRegisters(cold_reset);
    _TLB_Invalidate()
}

val AArch64_GenerateDebugExceptionsFrom : forall ('secure : Bool).
  (bits(2), bool('secure), bits(1)) -> bool effect {escape, rreg, undef}

function AArch64_GenerateDebugExceptionsFrom (from, secure, mask) = {
    if ([OSLSR_EL1[1]] == 0b1 | DoubleLockStatus()) | Halted() then {
        return(false)
    };
    let route_to_el2 : bool = (HaveEL(EL2) & ~(secure)) & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1);
    let target : bits(2) = if route_to_el2 then EL2 else EL1;
    enabled : bool = undefined : bool;
    enabled = (~(HaveEL(EL3)) | ~(secure)) | [MDCR_EL3[16]] == 0b0;
    if from == target then {
        enabled = (enabled & [MDSCR_EL1[13]] == 0b1) & mask == 0b0
    } else {
        enabled = enabled & UInt(target) > UInt(from)
    };
    enabled
}

val AArch64_GenerateDebugExceptions : unit -> bool effect {escape, rreg, undef}

function AArch64_GenerateDebugExceptions () = {
    AArch64_GenerateDebugExceptionsFrom(PSTATE.EL, IsSecure(), PSTATE.D)
}

val AArch64_FaultSyndrome : forall ('d_side : Bool).
  (bool('d_side), FaultRecord) -> bits(25) effect {escape, rreg, undef}

function AArch64_FaultSyndrome (d_side, fault) = {
    assert(fault.typ != Fault_None);
    iss : bits(25) = Zeros();
    if HaveRASExt() & IsExternalSyncAbort(fault) then {
        iss = __SetSlice_bits(25, 2, iss, 11, fault.errortype)
    };
    if d_side then {
        if IsSecondStage(fault) & ~(fault.s2fs1walk) then {
            iss = __SetSlice_bits(25, 11, iss, 14, LSInstructionSyndrome())
        };
        if HaveNV2Ext() & fault.acctype == AccType_NV2REGISTER then {
            iss = __SetSlice_bits(25, 1, iss, 13, 0b1)
        };
        if fault.acctype == AccType_DC | fault.acctype == AccType_DC_UNPRIV | fault.acctype == AccType_IC | fault.acctype == AccType_AT then {
            iss = __SetSlice_bits(25, 1, iss, 8, 0b1);
            iss = __SetSlice_bits(25, 1, iss, 6, 0b1)
        } else {
            iss = __SetSlice_bits(25, 1, iss, 6, if fault.write then 0b1 else 0b0)
        }
    };
    if IsExternalAbort(fault) then {
        iss = __SetSlice_bits(25, 1, iss, 9, fault.extflag)
    };
    iss = __SetSlice_bits(25, 1, iss, 7, if fault.s2fs1walk then 0b1 else 0b0);
    let iss = __SetSlice_bits(25, 6, iss, 0, EncodeLDFSC(fault.typ, fault.level));
    iss
}

val AArch64_AbortSyndrome : (Exception, FaultRecord, bits(64)) -> ExceptionRecord effect {escape, rreg, undef}

function AArch64_AbortSyndrome (typ, fault, vaddress) = {
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(typ);
    let d_side : bool = typ == Exception_DataAbort | typ == Exception_NV2DataAbort | typ == Exception_Watchpoint;
    exception.syndrome = AArch64_FaultSyndrome(d_side, fault);
    exception.vaddress = ZeroExtend(vaddress);
    if IPAValid(fault) then {
        exception.ipavalid = true;
        exception.NS = fault.ipaddress.NS;
        exception.ipaddress = fault.ipaddress.address
    } else {
        exception.ipavalid = false
    };
    exception
}

val AArch64_ExecutingBTIInstr : unit -> bool effect {rreg, undef}

function AArch64_ExecutingBTIInstr () = {
    if ~(HaveBTIExt()) then {
        return(false)
    };
    let instr : vector(32, dec, bit) = ThisInstr();
    CRm : bits(4) = undefined : bits(4);
    op2 : bits(3) = undefined : bits(3);
    if (slice(instr, 22, 10) == 0b1101010100 & slice(instr, 12, 10) == 0b0000110010) & slice(instr, 0, 5) == 0b11111 then {
        CRm = slice(instr, 8, 4);
        op2 = slice(instr, 5, 3);
        return(CRm == 0x4 & [op2[0]] == 0b0)
    } else {
        return(false)
    }
}

val AArch64_ExecutingBROrBLROrRetInstr : unit -> bool effect {rreg, undef}

function AArch64_ExecutingBROrBLROrRetInstr () = {
    if ~(HaveBTIExt()) then {
        return(false)
    };
    let instr : vector(32, dec, bit) = ThisInstr();
    opc : bits(4) = undefined : bits(4);
    if slice(instr, 25, 7) == 0b1101011 & slice(instr, 16, 5) == 0b11111 then {
        opc = slice(instr, 21, 4);
        return(opc != 0x5)
    } else {
        return(false)
    }
}

val AArch64_ExecutingATS1xPInstr : unit -> bool effect {rreg, undef}

function AArch64_ExecutingATS1xPInstr () = {
    if ~(HavePrivATExt()) then {
        return(false)
    };
    let instr : vector(32, dec, bit) = ThisInstr();
    CRm : bits(4) = undefined : bits(4);
    CRn : bits(4) = undefined : bits(4);
    op1 : bits(3) = undefined : bits(3);
    op2 : bits(3) = undefined : bits(3);
    if slice(instr, 22, 10) == 0b1101010100 then {
        op1 = slice(instr, 16, 3);
        CRn = slice(instr, 12, 4);
        CRm = slice(instr, 8, 4);
        op2 = slice(instr, 5, 3);
        return(((op1 == 0b000 & CRn == 0x7) & CRm == 0x9) & (op2 == 0b000 | op2 == 0b001))
    } else {
        return(false)
    }
}

val AArch64_ExceptionClass : (Exception, bits(2)) -> (int, bits(1)) effect {escape, rreg, undef}

function AArch64_ExceptionClass (typ, target_el) = {
    il : bits(1) = undefined : bits(1);
    il = if ThisInstrLength() == 32 then 0b1 else 0b0;
    let from_32 : bool = UsingAArch32();
    assert(from_32 | il == 0b1);
    ec : int = undefined : int;
    match typ {
      Exception_Uncategorized => {
          ec = 0;
          il = 0b1
      },
      Exception_WFxTrap => {
          ec = 1
      },
      Exception_CP15RTTrap => {
          ec = 3;
          assert(from_32)
      },
      Exception_CP15RRTTrap => {
          ec = 4;
          assert(from_32)
      },
      Exception_CP14RTTrap => {
          ec = 5;
          assert(from_32)
      },
      Exception_CP14DTTrap => {
          ec = 6;
          assert(from_32)
      },
      Exception_AdvSIMDFPAccessTrap => {
          ec = 7
      },
      Exception_FPIDTrap => {
          ec = 8
      },
      Exception_PACTrap => {
          ec = 9
      },
      Exception_CP14RRTTrap => {
          ec = 12;
          assert(from_32)
      },
      Exception_BranchTarget => {
          ec = 13
      },
      Exception_IllegalState => {
          ec = 14;
          il = 0b1
      },
      Exception_SupervisorCall => {
          ec = 17
      },
      Exception_HypervisorCall => {
          ec = 18
      },
      Exception_MonitorCall => {
          ec = 19
      },
      Exception_SystemRegisterTrap => {
          ec = 24;
          assert(~(from_32))
      },
      Exception_ERetTrap => {
          ec = 26
      },
      Exception_InstructionAbort => {
          ec = 32;
          il = 0b1
      },
      Exception_PCAlignment => {
          ec = 34;
          il = 0b1
      },
      Exception_DataAbort => {
          ec = 36
      },
      Exception_NV2DataAbort => {
          ec = 37
      },
      Exception_SPAlignment => {
          ec = 38;
          il = 0b1;
          assert(~(from_32))
      },
      Exception_FPTrappedException => {
          ec = 40
      },
      Exception_SError => {
          ec = 47;
          il = 0b1
      },
      Exception_Breakpoint => {
          ec = 48;
          il = 0b1
      },
      Exception_SoftwareStep => {
          ec = 50;
          il = 0b1
      },
      Exception_Watchpoint => {
          ec = 52;
          il = 0b1
      },
      Exception_SoftwareBreakpoint => {
          ec = 56
      },
      Exception_VectorCatch => {
          ec = 58;
          il = 0b1;
          assert(from_32)
      },
      _ => {
          Unreachable()
      }
    };
    if (ec == 32 | ec == 36 | ec == 48 | ec == 50 | ec == 52) & target_el == PSTATE.EL then {
        ec = ec + 1
    };
    if (ec == 17 | ec == 18 | ec == 19 | ec == 40 | ec == 56) & ~(from_32) then {
        ec = ec + 4
    };
    return((ec, il))
}

val AArch64_ReportException : (ExceptionRecord, bits(2)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_ReportException (exception, target_el) = {
    let typ : Exception = exception.typ;
    ec : int = undefined : int;
    il : bits(1) = undefined : bits(1);
    (ec, il) = AArch64_ExceptionClass(typ, target_el);
    let iss : vector(25, dec, bit) = exception.syndrome;
    if (ec == 36 | ec == 37) & [iss[24]] == 0b0 then {
        il = 0b1
    };
    ESR(target_el) = (__GetSlice_int(6, ec, 0) @ il) @ iss;
    if typ == Exception_InstructionAbort | typ == Exception_PCAlignment | typ == Exception_DataAbort | typ == Exception_NV2DataAbort | typ == Exception_Watchpoint then {
        FAR(target_el) = exception.vaddress
    } else {
        FAR(target_el) = undefined : bits(64)
    };
    if target_el == EL2 then {
        if exception.ipavalid then {
            HPFAR_EL2 = __SetSlice_bits(64, 40, HPFAR_EL2, 4, slice(exception.ipaddress, 12, 40));
            if HaveSecureEL2Ext() then {
                if IsSecureEL2Enabled() then {
                    HPFAR_EL2 = __SetSlice_bits(64, 1, HPFAR_EL2, 63, exception.NS)
                } else {
                    HPFAR_EL2 = __SetSlice_bits(64, 1, HPFAR_EL2, 63, 0b0)
                }
            }
        } else {
            HPFAR_EL2 = __SetSlice_bits(64, 40, HPFAR_EL2, 4, undefined : bits(40))
        }
    };
    return()
}

val AArch64_EncodePAR : AddressDescriptor -> unit effect {escape, rreg, undef, wreg}

function AArch64_EncodePAR addrdesc = {
    par : bits(64) = undefined : bits(64);
    par = __GetSlice_int(64, 2048, 0);
    if ~(IsFault(addrdesc)) then {
        par = __SetSlice_bits(64, 1, par, 0, 0b0);
        par = __SetSlice_bits(64, 2, par, 7, PARShareabilityDecode(addrdesc.memattrs));
        par = __SetSlice_bits(64, 1, par, 9, addrdesc.paddress.NS);
        par = __SetSlice_bits(64, 40, par, 12, slice(addrdesc.paddress.address, 12, 40));
        par = __SetSlice_bits(64, 8, par, 56, PARAttrsDecode(addrdesc.memattrs))
    } else {
        par = __SetSlice_bits(64, 1, par, 0, 0b1);
        par = __SetSlice_bits(64, 6, par, 1, AArch64_PARFaultStatus(addrdesc.fault));
        par = __SetSlice_bits(64, 1, par, 8, if addrdesc.fault.s2fs1walk then 0b1 else 0b0);
        par = __SetSlice_bits(64, 1, par, 9, if addrdesc.fault.secondstage then 0b1 else 0b0)
    };
    PAR_EL1 = __SetSlice_bits(64, 64, PAR_EL1, 0, par)
}

val AArch64_ESBOperation : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_ESBOperation () = {
    let route_to_el3 : bool = HaveEL(EL3) & [SCR_EL3[3]] == 0b1;
    let route_to_el2 : bool = EL2Enabled() & ([HCR_EL2[27]] == 0b1 | [HCR_EL2[5]] == 0b1);
    let target : bits(2) = if route_to_el3 then EL3 else if route_to_el2 then EL2 else EL1;
    mask_active : bool = undefined : bool;
    if target == EL1 then {
        mask_active = PSTATE.EL == EL0 | PSTATE.EL == EL1
    } else {
        if (HaveVirtHostExt() & target == EL2) & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) == 0b11 then {
            mask_active = PSTATE.EL == EL0 | PSTATE.EL == EL2
        } else {
            mask_active = PSTATE.EL == target
        }
    };
    let mask_set : bool = PSTATE.A == 0b1 & (((~(HaveDoubleFaultExt()) | [SCR_EL3[3]] == 0b0) | PSTATE.EL != EL3) | [SCR_EL3[20]] == 0b0);
    let intdis : bool = Halted() | ExternalDebugInterruptsDisabled(target);
    let masked : bool = (UInt(target) < UInt(PSTATE.EL) | intdis) | mask_active & mask_set;
    implicit_esb : bool = undefined : bool;
    syndrome32 : AArch32_SErrorSyndrome = undefined : AArch32_SErrorSyndrome;
    syndrome64 : bits(25) = undefined : bits(25);
    if IsPhysicalSErrorPending() & masked then {
        if ELUsingAArch32(S1TranslationRegime()) then {
            syndrome32 = AArch32_PhysicalSErrorSyndrome();
            set_DISR(AArch32_ReportDeferredSError(syndrome32.AET, syndrome32.ExT))
        } else {
            implicit_esb = false;
            syndrome64 = AArch64_PhysicalSErrorSyndrome(implicit_esb);
            DISR_EL1 = AArch64_ReportDeferredSError(syndrome64)
        };
        ClearPendingPhysicalSError()
    };
    return()
}

val AArch64_CheckUnallocatedSystemAccess : (bits(2), bits(2), bits(3), bits(4), bits(4), bits(3), bits(1)) -> bool effect {escape, rreg, undef}

function AArch64_CheckUnallocatedSystemAccess (el, op0, op1, crn, crm, op2, read) = {
    if (((((((op0 == 0b11 & crn == 0x4) & op1 == 0b011) & op2 == 0b001) & crm == 0x2) & PSTATE.EL == EL0) & ~(IsSecure())) & [HCR_EL2[34]] == 1) & [HCR_EL2[27]] == 1 then {
        return(false)
    };
    let allocated : bool = AArch64_AutoGen_SysRegAlloc(el, op0, op1, crn, op2, crm, read);
    ~(allocated)
}

val AArch64_CheckS2Permission : forall 'level ('iswrite : Bool) ('s2fs1walk : Bool) ('hwupdatewalk : Bool).
  (Permissions, bits(64), bits(52), int('level), AccType, bool('iswrite), bits(1), bool('s2fs1walk), bool('hwupdatewalk)) -> FaultRecord effect {escape, rreg, undef}

function AArch64_CheckS2Permission (perms, vaddress, ipaddress, level, acctype, iswrite, NS, s2fs1walk, hwupdatewalk) = {
    assert((IsSecureEL2Enabled() | (HaveEL(EL2) & ~(IsSecure())) & ~(ELUsingAArch32(EL2))) & HasS2Translation());
    let r : bool = [perms.ap[1]] == 0b1;
    let w : bool = [perms.ap[2]] == 0b1;
    xn : bool = undefined : bool;
    if HaveExtendedExecuteNeverExt() then {
        match perms.xn @ perms.xxn {
          0b00 => {
              xn = false
          },
          0b01 => {
              xn = PSTATE.EL == EL1
          },
          0b10 => {
              xn = true
          },
          0b11 => {
              xn = PSTATE.EL == EL0
          }
        }
    } else {
        xn = perms.xn == 0b1
    };
    fail : bool = undefined : bool;
    failedread : bool = undefined : bool;
    if acctype == AccType_IFETCH & ~(s2fs1walk) then {
        fail = xn;
        failedread = true
    } else {
        if (acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW) & ~(s2fs1walk) then {
            fail = ~(r) | ~(w);
            failedread = ~(r)
        } else {
            if iswrite & ~(s2fs1walk) then {
                fail = ~(w);
                failedread = false
            } else {
                if (acctype == AccType_DC & PSTATE.EL != EL0) & ~(s2fs1walk) then {
                    fail = false
                } else {
                    if hwupdatewalk then {
                        fail = ~(w);
                        failedread = ~(iswrite)
                    } else {
                        fail = ~(r);
                        failedread = ~(iswrite)
                    }
                }
            }
        }
    };
    domain : bits(4) = undefined : bits(4);
    secondstage : bool = undefined : bool;
    if fail then {
        domain = undefined : bits(4);
        secondstage = true;
        return(AArch64_PermissionFault(ipaddress, NS, level, acctype, ~(failedread), secondstage, s2fs1walk))
    } else {
        return(AArch64_NoFault())
    }
}

val AArch64_SecondStageTranslate : forall ('iswrite : Bool) ('wasaligned : Bool) ('s2fs1walk : Bool) 'size ('hwupdatewalk : Bool).
  (AddressDescriptor, bits(64), AccType, bool('iswrite), bool('wasaligned), bool('s2fs1walk), int('size), bool('hwupdatewalk)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SecondStageTranslate (S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size, hwupdatewalk) = {
    assert(HasS2Translation());
    let s2_enabled : bool = [HCR_EL2[0]] == 0b1 | [HCR_EL2[12]] == 0b1;
    let secondstage : bool(true) = true;
    NS : bits(1) = undefined : bits(1);
    S2 : TLBRecord = undefined : TLBRecord;
    ipaddress : bits(52) = undefined : bits(52);
    result : AddressDescriptor = undefined : AddressDescriptor;
    if s2_enabled then {
        ipaddress = slice(S1.paddress.address, 0, 52);
        NS = S1.paddress.NS;
        S2 = AArch64_TranslationTableWalk(ipaddress, NS, vaddress, acctype, iswrite, secondstage, s2fs1walk, size);
        if ((~(wasaligned) & acctype != AccType_IFETCH | acctype == AccType_DCZVA) & S2.addrdesc.memattrs.typ == MemType_Device) & ~(IsFault(S2.addrdesc)) then {
            __tc1 : AddressDescriptor = S2.addrdesc;
            __tc1.fault = AArch64_AlignmentFault(acctype, iswrite, secondstage);
            S2.addrdesc = __tc1
        };
        if ~(IsFault(S2.addrdesc)) then {
            __tc2 : AddressDescriptor = S2.addrdesc;
            __tc2.fault = AArch64_CheckS2Permission(S2.perms, vaddress, ipaddress, S2.level, acctype, iswrite, NS, s2fs1walk, hwupdatewalk);
            S2.addrdesc = __tc2
        };
        if ((~(s2fs1walk) & ~(IsFault(S2.addrdesc))) & S2.addrdesc.memattrs.typ == MemType_Device) & acctype == AccType_IFETCH then {
            S2.addrdesc = AArch64_InstructionDevice(S2.addrdesc, vaddress, ipaddress, S2.level, acctype, iswrite, secondstage, s2fs1walk)
        };
        if ((s2fs1walk & ~(IsFault(S2.addrdesc))) & [HCR_EL2[2]] == 0b1) & S2.addrdesc.memattrs.typ == MemType_Device then {
            __tc3 : AddressDescriptor = S2.addrdesc;
            __tc3.fault = AArch64_PermissionFault(ipaddress, S1.paddress.NS, S2.level, acctype, iswrite, secondstage, s2fs1walk);
            S2.addrdesc = __tc3
        };
        __tc4 : AddressDescriptor = S2.addrdesc;
        __tc4.fault = AArch64_CheckAndUpdateDescriptor(S2.descupdate, S2.addrdesc.fault, secondstage, vaddress, acctype, iswrite, s2fs1walk, hwupdatewalk);
        S2.addrdesc = __tc4;
        result = CombineS1S2Desc(S1, S2.addrdesc)
    } else {
        result = S1
    };
    result
}

val AArch64_SecondStageWalk : forall ('iswrite : Bool) 'size ('hwupdatewalk : Bool).
  (AddressDescriptor, bits(64), AccType, bool('iswrite), int('size), bool('hwupdatewalk)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SecondStageWalk (S1, vaddress, acctype, iswrite, size, hwupdatewalk) = {
    assert(HasS2Translation());
    let s2fs1walk : bool(true) = true;
    let wasaligned : bool(true) = true;
    AArch64_SecondStageTranslate(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size, hwupdatewalk)
}

val AArch64_BreakpointValueMatch : forall ('n : Int).
  (int('n), bits(64), bool) -> bool effect {escape, rreg, undef}

function AArch64_BreakpointValueMatch (n__arg, vaddress, linked_to) = {
    n : int = n__arg;
    c : Constraint = undefined : Constraint;
    if n > UInt(slice(ID_AA64DFR0_EL1, 12, 4)) then {
        (c, n) = ConstrainUnpredictableInteger(0, UInt(slice(ID_AA64DFR0_EL1, 12, 4)), Unpredictable_BPNOTIMPL);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return(false)
        }
    };
    if [DBGBCR_EL1[n][0]] == 0b0 then {
        return(false)
    };
    let context_aware : bool = n >= UInt(slice(ID_AA64DFR0_EL1, 12, 4)) - UInt(slice(ID_AA64DFR0_EL1, 28, 4));
    typ : bits(4) = undefined : bits(4);
    typ = slice(DBGBCR_EL1[n], 20, 4);
    if ((((typ & 0xE) == 0x6 | (typ & 0xC) == 0xC) & ~(HaveVirtHostExt()) | (typ & 0xE) == 0x4) | (typ & 0xA) != 0x0 & ~(context_aware)) | (typ & 0x8) == 0x8 & ~(HaveEL(EL2)) then {
        (c, typ) = ConstrainUnpredictableBits(Unpredictable_RESBPTYPE);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return(false)
        }
    };
    let match_addr : bool = (typ & 0xA) == 0x0;
    let match_vmid : bool = (typ & 0xC) == 0x8;
    let match_cid : bool = (typ & 0xE) == 0x2;
    let match_cid1 : bool = (typ & 0xE) == 0xA | (typ & 0x6) == 0x6;
    let match_cid2 : bool = (typ & 0xC) == 0xC;
    let linked : bool = (typ & 0x1) == 0x1;
    if linked_to & (~(linked) | match_addr) then {
        return(false)
    };
    if (~(linked_to) & linked) & ~(match_addr) then {
        return(false)
    };
    BVR_match : bool = undefined : bool;
    byte : int = undefined : int;
    byte_select_match : bool = undefined : bool;
    if match_addr then {
        byte = UInt(slice(vaddress, 0, 2));
        if HaveAnyAArch32() then {
            assert(byte == 0 | byte == 2);
            byte_select_match = [slice(DBGBCR_EL1[n], 5, 4)[byte]] == 0b1
        } else {
            assert(byte == 0);
            byte_select_match = true
        };
        let 'top = AddrTop(vaddress, true, PSTATE.EL);
        assert(constraint('top - 1 >= 0));
        BVR_match = slice(vaddress, 2, top - 1) == slice(DBGBVR_EL1[n], 2, top - 1) & byte_select_match
    } else {
        if match_cid then {
            if IsInHost() then {
                BVR_match = CONTEXTIDR_EL2 == slice(DBGBVR_EL1[n], 0, 32)
            } else {
                BVR_match = (PSTATE.EL == EL0 | PSTATE.EL == EL1) & CONTEXTIDR_EL1 == slice(DBGBVR_EL1[n], 0, 32)
            }
        } else {
            if match_cid1 then {
                BVR_match = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & ~(IsInHost())) & CONTEXTIDR_EL1 == slice(DBGBVR_EL1[n], 0, 32)
            }
        }
    };
    BXVR_match : bool = undefined : bool;
    bvr_vmid : bits(16) = undefined : bits(16);
    vmid : bits(16) = undefined : bits(16);
    if match_vmid then {
        if ~(Have16bitVMID()) | [VTCR_EL2[19]] == 0b0 then {
            vmid = ZeroExtend(slice(VTTBR_EL2[56 .. 49] @ VTTBR_EL2[48 .. 41], 0, 8), 16);
            bvr_vmid = ZeroExtend(slice(DBGBVR_EL1[n], 32, 8), 16)
        } else {
            vmid = VTTBR_EL2[56 .. 49] @ VTTBR_EL2[48 .. 41];
            bvr_vmid = slice(DBGBVR_EL1[n], 32, 16)
        };
        BXVR_match = ((EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ~(IsInHost())) & vmid == bvr_vmid
    } else {
        if match_cid2 then {
            BXVR_match = (~(IsSecure()) & HaveVirtHostExt()) & slice(DBGBVR_EL1[n], 32, 32) == CONTEXTIDR_EL2
        }
    };
    let bvr_match_valid : bool = (match_addr | match_cid) | match_cid1;
    let bxvr_match_valid : bool = match_vmid | match_cid2;
    let val_match : bool = (~(bxvr_match_valid) | BXVR_match) & (~(bvr_match_valid) | BVR_match);
    val_match
}

val AArch64_StateMatch : forall ('linked : Bool) ('isbreakpnt : Bool) ('ispriv : Bool).
  (bits(2), bits(1), bits(2), bool('linked), bits(4), bool('isbreakpnt), AccType, bool('ispriv)) -> bool effect {escape, rreg, undef}

function AArch64_StateMatch (SSC__arg, HMC__arg, PxC__arg, linked__arg, LBN, isbreakpnt, acctype, ispriv) = {
    HMC = HMC__arg;
    PxC = PxC__arg;
    SSC = SSC__arg;
    linked : bool = linked__arg;
    c : Constraint = undefined : Constraint;
    if (((((((HMC @ SSC) @ PxC) & 0b11100) == 0b01100 | (((HMC @ SSC) @ PxC) & 0b11101) == 0b10000 | (((HMC @ SSC) @ PxC) & 0b11101) == 0b10100 | ((HMC @ SSC) @ PxC) == 0b11010 | ((HMC @ SSC) @ PxC) == 0b11101 | (((HMC @ SSC) @ PxC) & 0b11110) == 0b11110) | (HMC == 0b0 & PxC == 0b00) & (~(isbreakpnt) | ~(HaveAArch32EL(EL1)))) | (SSC == 0b01 | SSC == 0b10) & ~(HaveEL(EL3))) | (((HMC @ SSC) != 0b000 & (HMC @ SSC) != 0b111) & ~(HaveEL(EL3))) & ~(HaveEL(EL2))) | ((HMC @ SSC) @ PxC) == 0b11100 & ~(HaveEL(EL2)) then {
        __tc1 : bits(5) = undefined : bits(5);
        (c, __tc1) = ConstrainUnpredictableBits(Unpredictable_RESBPWPCTRL);
        let __tc2 : bits(5) = __tc1;
        HMC = [__tc2[4]];
        let __tc3 : bits(4) = slice(__tc2, 0, 4);
        SSC = slice(__tc3, 2, 2);
        PxC = slice(__tc3, 0, 2);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return(false)
        }
    };
    let EL3_match : bool = (HaveEL(EL3) & HMC == 0b1) & [SSC[0]] == 0b0;
    let EL2_match : bool = HaveEL(EL2) & HMC == 0b1;
    let EL1_match : bool = [PxC[0]] == 0b1;
    let EL0_match : bool = [PxC[1]] == 0b1;
    let el : vector(2, dec, bit) = if HaveNV2Ext() & acctype == AccType_NV2REGISTER then EL2 else PSTATE.EL;
    priv_match : bool = undefined : bool;
    if ~(ispriv) & ~(isbreakpnt) then {
        priv_match = EL0_match
    } else {
        match el {
          ? if ? == EL3 => {
              priv_match = EL3_match
          },
          ? if ? == EL2 => {
              priv_match = EL2_match
          },
          ? if ? == EL1 => {
              priv_match = EL1_match
          },
          ? if ? == EL0 => {
              priv_match = EL0_match
          }
        }
    };
    security_state_match : bool = undefined : bool;
    match SSC {
      0b00 => {
          security_state_match = true
      },
      0b01 => {
          security_state_match = ~(IsSecure())
      },
      0b10 => {
          security_state_match = IsSecure()
      },
      0b11 => {
          security_state_match = true
      }
    };
    first_ctx_cmp : int = undefined : int;
    last_ctx_cmp : int = undefined : int;
    lbn : int = undefined : int;
    if linked then {
        lbn = UInt(LBN);
        first_ctx_cmp = UInt(slice(ID_AA64DFR0_EL1, 12, 4)) - UInt(slice(ID_AA64DFR0_EL1, 28, 4));
        last_ctx_cmp = UInt(slice(ID_AA64DFR0_EL1, 12, 4));
        if lbn < first_ctx_cmp | lbn > last_ctx_cmp then {
            (c, lbn) = ConstrainUnpredictableInteger(first_ctx_cmp, last_ctx_cmp, Unpredictable_BPNOTCTXCMP);
            assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
            match c {
              Constraint_DISABLED => {
                  return(false)
              },
              Constraint_NONE => {
                  linked = false
              }
            }
        }
    };
    linked_match : bool = undefined : bool;
    linked_to : bool = undefined : bool;
    vaddress : bits(64) = undefined : bits(64);
    if linked then {
        vaddress = undefined : bits(64);
        linked_to = true;
        linked_match = AArch64_BreakpointValueMatch(lbn, vaddress, linked_to)
    };
    (priv_match & security_state_match) & (~(linked) | linked_match)
}

val AArch64_WatchpointMatch : forall 'n 'size ('ispriv : Bool) ('iswrite : Bool).
  (int('n), bits(64), int('size), bool('ispriv), AccType, bool('iswrite)) -> bool effect {escape, rreg, undef}

function AArch64_WatchpointMatch (n, vaddress, size, ispriv, acctype, iswrite) = {
    assert(~(ELUsingAArch32(S1TranslationRegime())));
    assert(n <= UInt(slice(ID_AA64DFR0_EL1, 20, 4)));
    let enabled : bool = [DBGWCR_EL1[n][0]] == 0b1;
    let linked : bool = [DBGWCR_EL1[n][20]] == 0b1;
    let isbreakpnt : bool(false) = false;
    let state_match : bool = AArch64_StateMatch(slice(DBGWCR_EL1[n], 14, 2), [DBGWCR_EL1[n][13]], slice(DBGWCR_EL1[n], 1, 2), linked, slice(DBGWCR_EL1[n], 16, 4), isbreakpnt, acctype, ispriv);
    let ls_match : bool = [slice(DBGWCR_EL1[n], 3, 2)[if iswrite then 1 else 0]] == 0b1;
    value_match_name : bool = undefined : bool;
    value_match_name = false;
    foreach (byte from 0 to (size - 1) by 1 in inc) {
        value_match_name = value_match_name | AArch64_WatchpointByteMatch(n, acctype, vaddress + byte)
    };
    ((value_match_name & state_match) & ls_match) & enabled
}

val AArch64_BreakpointMatch : forall ('n : Int) ('size : Int).
  (int('n), bits(64), AccType, int('size)) -> bool effect {escape, rreg, undef}

function AArch64_BreakpointMatch (n, vaddress, acctype, size) = {
    assert(~(ELUsingAArch32(S1TranslationRegime())));
    assert(n <= UInt(slice(ID_AA64DFR0_EL1, 12, 4)));
    let enabled : bool = [DBGBCR_EL1[n][0]] == 0b1;
    let ispriv : bool = PSTATE.EL != EL0;
    let linked : bool = (slice(DBGBCR_EL1[n], 20, 4) & 0xB) == 0x1;
    let isbreakpnt : bool(true) = true;
    let linked_to : bool(false) = false;
    let state_match : bool = AArch64_StateMatch(slice(DBGBCR_EL1[n], 14, 2), [DBGBCR_EL1[n][13]], slice(DBGBCR_EL1[n], 1, 2), linked, slice(DBGBCR_EL1[n], 16, 4), isbreakpnt, acctype, ispriv);
    value_match_name : bool = undefined : bool;
    value_match_name = AArch64_BreakpointValueMatch(n, vaddress, linked_to);
    match_i : bool = undefined : bool;
    if HaveAnyAArch32() & size == 4 then {
        match_i = AArch64_BreakpointValueMatch(n, vaddress + 2, linked_to);
        if ~(value_match_name) & match_i then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        }
    };
    if [vaddress[1]] == 0b1 & slice(DBGBCR_EL1[n], 5, 4) == 0xF then {
        if value_match_name then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        }
    };
    let val_match : bool = (value_match_name & state_match) & enabled;
    val_match
}

val AArch64_CheckBreakpoint : forall ('size : Int).
  (bits(64), AccType, int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch64_CheckBreakpoint (vaddress, acctype__arg, size) = {
    acctype = acctype__arg;
    assert(~(ELUsingAArch32(S1TranslationRegime())));
    assert(UsingAArch32() & (size == 2 | size == 4) | size == 4);
    val_match : bool = undefined : bool;
    val_match = false;
    match_i : bool = undefined : bool;
    foreach (i from 0 to UInt(slice(ID_AA64DFR0_EL1, 12, 4)) by 1 in inc) {
        match_i = AArch64_BreakpointMatch(i, vaddress, acctype, size);
        val_match = val_match | match_i
    };
    iswrite : bool = undefined : bool;
    reason : bits(6) = undefined : bits(6);
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        reason = DebugHalt_Breakpoint;
        Halt(reason);
        return(AArch64_NoFault())
    } else {
        if (val_match & [MDSCR_EL1[15]] == 0b1) & AArch64_GenerateDebugExceptions() then {
            acctype = AccType_IFETCH;
            iswrite = false;
            return(AArch64_DebugFault(acctype, iswrite))
        } else {
            return(AArch64_NoFault())
        }
    }
}

val AArch64_BranchAddr : bits(64) -> bits(64) effect {escape, rreg, undef}

function AArch64_BranchAddr vaddress = {
    assert(~(UsingAArch32()));
    let msbit = AddrTop(vaddress, true, PSTATE.EL);
    assert(msbit + 1 >= 0);
    if msbit == 63 then {
        return(vaddress)
    } else {
        if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) | IsInHost()) & [vaddress[msbit]] == 0b1 then {
            return(SignExtend(slice(vaddress, 0, msbit + 1)))
        } else {
            return(ZeroExtend(slice(vaddress, 0, msbit + 1)))
        }
    }
}

val BranchTo : forall ('N : Int), 'N >= 0.
  (bits('N), BranchType) -> unit effect {escape, rreg, undef, wreg}

function BranchTo (target, branch_type) = {
    Hint_Branch(branch_type);
    if 'N == 32 then {
        assert(UsingAArch32());
        _PC = ZeroExtend(target)
    } else {
        assert('N == 64 & ~(UsingAArch32()));
        _PC = AArch64_BranchAddr(slice(target, 0, 64))
    };
    __PC_changed = true;
    return()
}

val branch_unconditional_immediate : (BranchType, bits(64)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_immediate (branch_type, offset) = {
    if branch_type == BranchType_DIRCALL then {
        X(30) = PC() + 4
    };
    BranchTo(PC() + offset, branch_type)
}

val branch_conditional_test : forall 'bit_pos 'datasize 't,
  ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('bit_pos), bits(1), int('datasize), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_test (bit_pos, bit_val, datasize, offset, t) = {
    let operand : bits('datasize) = X(t);
    if [operand[bit_pos]] == bit_val then {
        BranchTo(PC() + offset, BranchType_DIR)
    }
}

val branch_conditional_cond : (bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_cond (condition, offset) = {
    if ConditionHolds(condition) then {
        BranchTo(PC() + offset, BranchType_DIR)
    }
}

val branch_conditional_compare : forall 'datasize ('iszero : Bool) 't,
  ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), bool('iszero), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_compare (datasize, iszero, offset, t) = {
    let operand1 : bits('datasize) = X(t);
    if IsZero(operand1) == iszero then {
        BranchTo(PC() + offset, BranchType_DIR)
    }
}

val AArch64_TakeReset : bool -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeReset cold_reset = {
    assert(~(HighestELUsingAArch32()));
    PSTATE.nRW = 0b0;
    if HaveEL(EL3) then {
        PSTATE.EL = EL3
    } else {
        if HaveEL(EL2) then {
            PSTATE.EL = EL2
        } else {
            PSTATE.EL = EL1
        }
    };
    AArch64_ResetControlRegisters(cold_reset);
    PSTATE.SP = 0b1;
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = 0xF;
    PSTATE.SS = 0b0;
    PSTATE.DIT = 0b0;
    PSTATE.IL = 0b0;
    AArch64_ResetGeneralRegisters();
    AArch64_ResetSIMDFPRegisters();
    AArch64_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);
    rv : bits(64) = undefined : bits(64);
    if HaveEL(EL3) then {
        rv = RVBAR_EL3
    } else {
        if HaveEL(EL2) then {
            rv = RVBAR_EL2
        } else {
            rv = RVBAR_EL1
        }
    };
    let pa_max = PAMax();
    assert(64 - pa_max >= 0);
    assert(IsZero(slice(rv, pa_max, 64 - pa_max)) & IsZero(slice(rv, 0, 2)));
    BranchTo(rv, BranchType_RESET)
}

val AArch64_TakeException : forall ('vect_offset : Int).
  (bits(2), ExceptionRecord, bits(64), int('vect_offset)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeException (target_el, exception, preferred_exception_return, vect_offset__arg) = {
    vect_offset : int = vect_offset__arg;
    assert((HaveEL(target_el) & ~(ELUsingAArch32(target_el))) & UInt(target_el) >= UInt(PSTATE.EL));
    sync_errors : bool = undefined : bool;
    sync_errors = HaveIESB() & [aget_SCTLR()[21]] == 0b1;
    if HaveDoubleFaultExt() then {
        sync_errors = sync_errors | ([SCR_EL3[3]] == 0b1 & [SCR_EL3[20]] == 0b1) & PSTATE.EL == EL3
    };
    iesb_req : bool = undefined : bool;
    if sync_errors & InsertIESBBeforeException(target_el) then {
        SynchronizeErrors();
        iesb_req = false;
        sync_errors = false;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    };
    SynchronizeContext();
    let from_32 : bool = UsingAArch32();
    if from_32 then {
        AArch64_MaybeZeroRegisterUppers()
    };
    if UInt(target_el) > UInt(PSTATE.EL) then {
        lower_32 : bool = undefined : bool;
        if target_el == EL3 then {
            if EL2Enabled() then {
                lower_32 = ELUsingAArch32(EL2)
            } else {
                lower_32 = ELUsingAArch32(EL1)
            }
        } else {
            if (IsInHost() & PSTATE.EL == EL0) & target_el == EL2 then {
                lower_32 = ELUsingAArch32(EL0)
            } else {
                lower_32 = ELUsingAArch32(target_el - 1)
            }
        };
        vect_offset = vect_offset + (if lower_32 then 1536 else 1024)
    } else {
        if PSTATE.SP == 0b1 then {
            vect_offset = vect_offset + 512
        }
    };
    spsr : bits(32) = undefined : bits(32);
    spsr = GetPSRFromPSTATE();
    if (((PSTATE.EL == EL1 & target_el == EL1) & HaveNVExt()) & EL2Enabled()) & (HCR_EL2[42 .. 42] @ HCR_EL2[43 .. 43]) == 0b10 then {
        spsr = __SetSlice_bits(32, 2, spsr, 2, 0b10)
    };
    if HaveUAOExt() then {
        PSTATE.UAO = 0b0
    };
    if ~(exception.typ == Exception_IRQ | exception.typ == Exception_FIQ) then {
        AArch64_ReportException(exception, target_el)
    };
    PSTATE.EL = target_el;
    PSTATE.nRW = 0b0;
    PSTATE.SP = 0b1;
    spsr_btype : bits(2) = undefined : bits(2);
    if HaveBTIExt() then {
        if exception.typ == Exception_SError | exception.typ == Exception_IRQ | exception.typ == Exception_FIQ | exception.typ == Exception_SoftwareStep | exception.typ == Exception_PCAlignment | exception.typ == Exception_InstructionAbort | exception.typ == Exception_SoftwareBreakpoint | exception.typ == Exception_IllegalState | exception.typ == Exception_BranchTarget then {
            spsr_btype = PSTATE.BTYPE
        } else {
            spsr_btype = if ConstrainUnpredictableBool(Unpredictable_ZEROBTYPE) then 0b00 else PSTATE.BTYPE
        };
        spsr = __SetSlice_bits(32, 2, spsr, 10, spsr_btype)
    };
    aset_SPSR(spsr);
    aset_ELR(preferred_exception_return);
    if HaveBTIExt() then {
        PSTATE.BTYPE = 0b00
    };
    PSTATE.SS = 0b0;
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = 0xF;
    PSTATE.IL = 0b0;
    if from_32 then {
        PSTATE.IT = 0x00;
        PSTATE.T = 0b0
    };
    if (HavePANExt() & (PSTATE.EL == EL1 | PSTATE.EL == EL2 & ELIsInHost(EL0))) & [aget_SCTLR()[23]] == 0b0 then {
        PSTATE.PAN = 0b1
    };
    if HaveMTEExt() then {
        PSTATE.TCO = 0b1
    };
    BranchTo(slice(aget_VBAR(), 11, 53) @ __GetSlice_int(11, vect_offset, 0), BranchType_EXCEPTION);
    if sync_errors then {
        SynchronizeErrors();
        iesb_req = true;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    };
    EndOfInstruction()
}

val TrapPACUse : bits(2) -> unit effect {escape, rreg, undef, wreg}

function TrapPACUse target_el = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    exception : ExceptionRecord = undefined : ExceptionRecord;
    let vect_offset : int(0) = 0;
    let exception = ExceptionSyndrome(Exception_PACTrap);
    AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
}

val Strip : (bits(64), bool) -> bits(64) effect {escape, rreg, undef, wreg}

function Strip (A, data) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    original_ptr : bits(64) = undefined : bits(64);
    extfield : bits(64) = undefined : bits(64);
    let tbi : bool = CalculateTBI(A, data);
    let bottom_PAC_bit : int = CalculateBottomPACBit([A[55]]);
    assert(negate(bottom_PAC_bit) + 56 >= 0 & bottom_PAC_bit >= 0);
    let extfield = replicate_bits([A[55]], 64);
    if tbi then {
        original_ptr = (slice(A, 56, 8) @ slice(extfield, 0, negate(bottom_PAC_bit) + 56)) @ slice(A, 0, bottom_PAC_bit)
    } else {
        original_ptr = slice(extfield, 0, negate(bottom_PAC_bit) + 64) @ slice(A, 0, bottom_PAC_bit)
    };
    match PSTATE.EL {
      ? if ? == EL0 => {
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if TrapEL2 then {
        TrapPACUse(EL2);
        Zeros()
    } else {
        if TrapEL3 then {
            TrapPACUse(EL3);
            Zeros()
        } else {
            return(original_ptr)
        }
    }
}

val integer_pac_strip_dp_1src : forall ('d : Int) ('data : Bool), ('d >= 0 & 'd <= 31).
  (int('d), bool('data)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_strip_dp_1src (d, data) = {
    if HavePACExt() then {
        X(d) = Strip(X(d), data)
    }
}

val AuthIB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthIB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIBKey_EL1 : bits(128) = slice(APIBKeyHi_EL1, 0, 64) @ slice(APIBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[30]] else [SCTLR_EL2[30]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[30]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[30]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[30]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APIBKey_EL1, false, 0b1))
            }
        }
    }
}

val integer_pac_autib_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autib_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AuthIB(X(d), SP())
        } else {
            X(d) = AuthIB(X(d), X(n))
        }
    }
}

val AuthIA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthIA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIAKey_EL1 : bits(128) = slice(APIAKeyHi_EL1, 0, 64) @ slice(APIAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[31]] else [SCTLR_EL2[31]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[31]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[31]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[31]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APIAKey_EL1, false, 0b0))
            }
        }
    }
}

val integer_pac_autia_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autia_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AuthIA(X(d), SP())
        } else {
            X(d) = AuthIA(X(d), X(n))
        }
    }
}

val branch_unconditional_register : forall 'm 'n ('pac : Bool) ('source_is_sp : Bool) ('use_key_a : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31 | not(not('source_is_sp)) | not('pac)).
  (BranchType, int('m), int('n), bool('pac), bool('source_is_sp), bool('use_key_a)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_register (branch_type, m, n, pac, source_is_sp, use_key_a) = {
    target : bits(64) = X(n);
    match branch_type {
      BranchType_INDIR => {
          if InGuardedPage then {
              if n == 16 | n == 17 then {
                  BTypeNext = 0b01
              } else {
                  BTypeNext = 0b11
              }
          } else {
              BTypeNext = 0b01
          }
      },
      BranchType_INDCALL => {
          BTypeNext = 0b10
      },
      BranchType_RET => {
          BTypeNext = 0b00
      }
    };
    if pac then {
        let modifier : bits(64) = if source_is_sp then SP() else X(m);
        if use_key_a then {
            target = AuthIA(target, modifier)
        } else {
            target = AuthIB(target, modifier)
        }
    };
    if branch_type == BranchType_INDCALL then {
        X(30) = PC() + 4
    };
    BranchTo(target, branch_type)
}

val AuthDB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthDB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDBKey_EL1 : bits(128) = slice(APDBKeyHi_EL1, 0, 64) @ slice(APDBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[13]] else [SCTLR_EL2[13]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[13]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[13]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[13]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APDBKey_EL1, true, 0b1))
            }
        }
    }
}

val integer_pac_autdb_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autdb_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AuthDB(X(d), SP())
    } else {
        X(d) = AuthDB(X(d), X(n))
    }
}

val AuthDA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthDA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDAKey_EL1 : bits(128) = slice(APDAKeyHi_EL1, 0, 64) @ slice(APDAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[27]] else [SCTLR_EL2[27]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[27]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[27]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[27]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APDAKey_EL1, true, 0b0))
            }
        }
    }
}

val integer_pac_autda_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autda_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AuthDA(X(d), SP())
    } else {
        X(d) = AuthDA(X(d), X(n))
    }
}

val AddPACIB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACIB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIBKey_EL1 : bits(128) = slice(APIBKeyHi_EL1, 0, 64) @ slice(APIBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[30]] else [SCTLR_EL2[30]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[30]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[30]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[30]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(AddPAC(X, Y, APIBKey_EL1, false))
            }
        }
    }
}

val integer_pac_pacib_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacib_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AddPACIB(X(d), SP())
        } else {
            X(d) = AddPACIB(X(d), X(n))
        }
    }
}

val AddPACIA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACIA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIAKey_EL1 : bits(128) = slice(APIAKeyHi_EL1, 0, 64) @ slice(APIAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[31]] else [SCTLR_EL2[31]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[31]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[31]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[31]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros()
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros()
            } else {
                return(AddPAC(X, Y, APIAKey_EL1, false))
            }
        }
    }
}

val integer_pac_pacia_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacia_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AddPACIA(X(d), SP())
        } else {
            X(d) = AddPACIA(X(d), X(n))
        }
    }
}

val AddPACGA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACGA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    let APGAKey_EL1 : bits(128) = slice(APGAKeyHi_EL1, 0, 64) @ slice(APGAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if TrapEL2 then {
        TrapPACUse(EL2);
        Zeros()
    } else {
        if TrapEL3 then {
            TrapPACUse(EL3);
            Zeros()
        } else {
            return(slice(ComputePAC(X, Y, slice(APGAKey_EL1, 64, 64), slice(APGAKey_EL1, 0, 64)), 32, 32) @ Zeros(32))
        }
    }
}

val integer_pac_pacga_dp_2src : forall 'd 'm 'n ('source_is_sp : Bool),
  ('n >= 0 & 'n <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))) & ('m >= 0 & 'm <= 31 | not(not('source_is_sp))) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))).
  (int('d), int('m), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacga_dp_2src (d, m, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AddPACGA(X(n), SP())
    } else {
        X(d) = AddPACGA(X(n), X(m))
    }
}

val AddPACDB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACDB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDBKey_EL1 : bits(128) = slice(APDBKeyHi_EL1, 0, 64) @ slice(APDBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[13]] else [SCTLR_EL2[13]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[13]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[13]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[13]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros()
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros()
            } else {
                return(AddPAC(X, Y, APDBKey_EL1, true))
            }
        }
    }
}

val integer_pac_pacdb_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacdb_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AddPACDB(X(d), SP())
    } else {
        X(d) = AddPACDB(X(d), X(n))
    }
}

val AddPACDA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACDA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDAKey_EL1 : bits(128) = slice(APDAKeyHi_EL1, 0, 64) @ slice(APDAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[27]] else [SCTLR_EL2[27]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[27]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[27]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[27]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros()
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros()
            } else {
                return(AddPAC(X, Y, APDAKey_EL1, true))
            }
        }
    }
}

val integer_pac_pacda_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacda_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AddPACDA(X(d), SP())
    } else {
        X(d) = AddPACDA(X(d), X(n))
    }
}

val TagCheckFault : forall ('write : Bool).
  (bits(64), bool('write)) -> unit effect {escape, rreg, undef, wreg}

function TagCheckFault (va, write) = {
    target_el : bits(2) = undefined : bits(2);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let 'vect_offset : {'n, 'n == 0. int('n)} = 0;
    if PSTATE.EL == EL0 then {
        target_el = if [HCR_EL2[27]] == 0 then EL1 else EL2
    } else {
        target_el = PSTATE.EL
    };
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_DataAbort);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 6, __tc1, 0, 0b010001);
    exception.syndrome = __tc1;
    if write then {
        __tc2 : bits(25) = exception.syndrome;
        __tc2 = __SetSlice_bits(25, 1, __tc2, 6, 0b1);
        exception.syndrome = __tc2
    };
    exception.vaddress = va;
    AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
}

val TagCheckFail : forall ('iswrite : Bool).
  (bits(64), bool('iswrite)) -> unit effect {escape, rreg, undef, wreg}

function TagCheckFail (vaddress, iswrite) = {
    let tcf : vector(2, dec, bit) = EffectiveTCF(PSTATE.EL);
    if tcf == 0b01 then {
        TagCheckFault(vaddress, iswrite)
    } else {
        if tcf == 0b10 then {
            ReportTagCheckFail(PSTATE.EL, [vaddress[55]])
        }
    }
}

val AArch64_WatchpointException : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_WatchpointException (vaddress, fault) = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_Watchpoint, fault, vaddress);
    if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_WFxTrap : forall ('is_wfe : Bool).
  (bits(2), bool('is_wfe)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_WFxTrap (target_el, is_wfe) = {
    assert(UInt(target_el) > UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_WFxTrap);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 1, __tc2, 0, if is_wfe then 0b1 else 0b0);
    exception.syndrome = __tc2;
    if (target_el == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckForWFxTrap : forall ('is_wfe : Bool).
  (bits(2), bool('is_wfe)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForWFxTrap (target_el, is_wfe) = {
    assert(HaveEL(target_el));
    trap : bool = undefined : bool;
    match target_el {
      ? if ? == EL1 => {
          trap = (if is_wfe then [SCTLR()[18]] else [SCTLR()[16]]) == 0b0
      },
      ? if ? == EL2 => {
          trap = (if is_wfe then [HCR_EL2[14]] else [HCR_EL2[13]]) == 0b1
      },
      ? if ? == EL3 => {
          trap = (if is_wfe then [SCR_EL3[13]] else [SCR_EL3[12]]) == 0b1
      }
    };
    let trap = trap;
    if trap then {
        AArch64_WFxTrap(target_el, is_wfe)
    }
}

val system_hints : SystemHintOp -> unit effect {escape, rreg, undef, wreg}

function system_hints op = {
    match op {
      SystemHintOp_YIELD => {
          Hint_Yield()
      },
      SystemHintOp_WFE => {
          if IsEventRegisterSet() then {
              ClearEventRegister()
          } else {
              if PSTATE.EL == EL0 then {
                  AArch64_CheckForWFxTrap(EL1, true)
              };
              if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ~(IsInHost()) then {
                  AArch64_CheckForWFxTrap(EL2, true)
              };
              if HaveEL(EL3) & PSTATE.EL != EL3 then {
                  AArch64_CheckForWFxTrap(EL3, true)
              };
              WaitForEvent()
          }
      },
      SystemHintOp_WFI => {
          if ~(InterruptPending()) then {
              if PSTATE.EL == EL0 then {
                  AArch64_CheckForWFxTrap(EL1, false)
              };
              if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ~(IsInHost()) then {
                  AArch64_CheckForWFxTrap(EL2, false)
              };
              if HaveEL(EL3) & PSTATE.EL != EL3 then {
                  AArch64_CheckForWFxTrap(EL3, false)
              };
              WaitForInterrupt()
          }
      },
      SystemHintOp_SEV => {
          SendEvent()
      },
      SystemHintOp_SEVL => {
          SendEventLocal()
      },
      SystemHintOp_ESB => {
          SynchronizeErrors();
          AArch64_ESBOperation();
          if EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
              AArch64_vESBOperation()
          };
          TakeUnmaskedSErrorInterrupts()
      },
      SystemHintOp_PSB => {
          ProfilingSynchronizationBarrier()
      },
      SystemHintOp_TSB => {
          TraceSynchronizationBarrier()
      },
      SystemHintOp_CSDB => {
          ConsumptionOfSpeculativeDataBarrier()
      },
      SystemHintOp_BTI => {
          BTypeNext = 0b00
      },
      _ => ()
    }
}

val AArch64_VectorCatchException : FaultRecord -> unit effect {escape, rreg, undef, wreg}

function AArch64_VectorCatchException fault = {
    assert(PSTATE.EL != EL2);
    assert(EL2Enabled() & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    let vaddress : vector(64, dec, bit) = undefined : bits(64);
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_VectorCatch, fault, vaddress);
    AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
}

val AArch64_UndefinedFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_UndefinedFault () = {
    let route_to_el2 : bool = (EL2Enabled() & PSTATE.EL == EL0) & [HCR_EL2[27]] == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_TakeVirtualSErrorException : forall ('impdef_syndrome : Bool).
  (bool('impdef_syndrome), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeVirtualSErrorException (impdef_syndrome, syndrome) = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    assert([HCR_EL2[27]] == 0b0 & [HCR_EL2[5]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(384) = 384;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SError);
    if HaveRASExt() then {
        __tc1 : bits(25) = exception.syndrome;
        __tc1 = __SetSlice_bits(25, 1, __tc1, 24, [VSESR_EL2[24]]);
        exception.syndrome = __tc1;
        __tc2 : bits(25) = exception.syndrome;
        __tc2 = __SetSlice_bits(25, 24, __tc2, 0, slice(VSESR_EL2, 0, 24));
        exception.syndrome = __tc2
    } else {
        __tc3 : bits(25) = exception.syndrome;
        __tc3 = __SetSlice_bits(25, 1, __tc3, 24, if impdef_syndrome then 0b1 else 0b0);
        exception.syndrome = __tc3;
        if impdef_syndrome then {
            __tc4 : bits(25) = exception.syndrome;
            __tc4 = __SetSlice_bits(25, 24, __tc4, 0, syndrome);
            exception.syndrome = __tc4
        }
    };
    ClearPendingVirtualSError();
    AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
}

val AArch64_TakeVirtualIRQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeVirtualIRQException () = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    assert([HCR_EL2[27]] == 0b0 & [HCR_EL2[4]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(128) = 128;
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_IRQ);
    AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
}

val AArch64_TakeVirtualFIQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeVirtualFIQException () = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    assert([HCR_EL2[27]] == 0b0 & [HCR_EL2[3]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(256) = 256;
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_FIQ);
    AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
}

val AArch64_TakePhysicalSErrorException : forall ('impdef_syndrome : Bool).
  (bool('impdef_syndrome), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakePhysicalSErrorException (impdef_syndrome, syndrome) = {
    let route_to_el3 : bool = HaveEL(EL3) & [SCR_EL3[3]] == 0b1;
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | ~(IsInHost()) & [HCR_EL2[5]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(384) = 384;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SError);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 1, __tc1, 24, if impdef_syndrome then 0b1 else 0b0);
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 24, __tc2, 0, syndrome);
    exception.syndrome = __tc2;
    ClearPendingPhysicalSError();
    if PSTATE.EL == EL3 | route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_TakePhysicalIRQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakePhysicalIRQException () = {
    let route_to_el3 : bool = HaveEL(EL3) & [SCR_EL3[1]] == 0b1;
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | [HCR_EL2[4]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(128) = 128;
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_IRQ);
    if route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_el2 then {
            assert(PSTATE.EL != EL3);
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            assert(PSTATE.EL == EL0 | PSTATE.EL == EL1);
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_TakePhysicalFIQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakePhysicalFIQException () = {
    let route_to_el3 : bool = HaveEL(EL3) & [SCR_EL3[2]] == 0b1;
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | [HCR_EL2[3]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(256) = 256;
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_FIQ);
    if route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_el2 then {
            assert(PSTATE.EL != EL3);
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            assert(PSTATE.EL == EL0 | PSTATE.EL == EL1);
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_SystemRegisterTrap : (bits(2), bits(2), bits(3), bits(3), bits(4), bits(5), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SystemRegisterTrap (target_el, op0, op2, op1, crn, rt, crm, dir) = {
    assert(UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SystemRegisterTrap);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 2, __tc1, 20, op0);
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 3, __tc2, 17, op2);
    exception.syndrome = __tc2;
    __tc3 : bits(25) = exception.syndrome;
    let __tc3 = __SetSlice_bits(25, 3, __tc3, 14, op1);
    exception.syndrome = __tc3;
    __tc4 : bits(25) = exception.syndrome;
    let __tc4 = __SetSlice_bits(25, 4, __tc4, 10, crn);
    exception.syndrome = __tc4;
    __tc5 : bits(25) = exception.syndrome;
    let __tc5 = __SetSlice_bits(25, 5, __tc5, 5, rt);
    exception.syndrome = __tc5;
    __tc6 : bits(25) = exception.syndrome;
    let __tc6 = __SetSlice_bits(25, 4, __tc6, 1, crm);
    exception.syndrome = __tc6;
    __tc7 : bits(25) = exception.syndrome;
    let __tc7 = __SetSlice_bits(25, 1, __tc7, 0, dir);
    exception.syndrome = __tc7;
    if (target_el == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_SoftwareStepException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_SoftwareStepException () = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SoftwareStep);
    if SoftwareStep_DidNotStep() then {
        __tc1 : bits(25) = exception.syndrome;
        __tc1 = __SetSlice_bits(25, 1, __tc1, 24, 0b0);
        exception.syndrome = __tc1
    } else {
        __tc2 : bits(25) = exception.syndrome;
        __tc2 = __SetSlice_bits(25, 1, __tc2, 24, 0b1);
        exception.syndrome = __tc2;
        __tc3 : bits(25) = exception.syndrome;
        __tc3 = __SetSlice_bits(25, 1, __tc3, 6, if SoftwareStep_SteppedEX() then 0b1 else 0b0);
        exception.syndrome = __tc3
    };
    if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val CheckSoftwareStep : unit -> unit effect {escape, rreg, undef, wreg}

function CheckSoftwareStep () = {
    if ~(ELUsingAArch32(DebugTarget())) & AArch64_GenerateDebugExceptions() then {
        if [MDSCR_EL1[0]] == 0b1 & PSTATE.SS == 0b0 then {
            AArch64_SoftwareStepException()
        }
    }
}

val AArch64_SoftwareBreakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SoftwareBreakpoint immediate = {
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SoftwareBreakpoint);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val system_exceptions_debug_breakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_breakpoint comment = {
    AArch64_SoftwareBreakpoint(comment)
}

val AArch64_SPAlignmentFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_SPAlignmentFault () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_SPAlignment);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if EL2Enabled() & [HCR_EL2[27]] == 0b1 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val CheckSPAlignment : unit -> unit effect {escape, rreg, undef, wreg}

function CheckSPAlignment () = {
    let sp : bits(64) = SP();
    stack_align_check : bool = undefined : bool;
    if PSTATE.EL == EL0 then {
        stack_align_check = [SCTLR()[4]] != 0b0
    } else {
        stack_align_check = [SCTLR()[3]] != 0b0
    };
    if stack_align_check & sp != Align(sp, 16) then {
        AArch64_SPAlignmentFault()
    };
    return()
}

val AArch64_PCAlignmentFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_PCAlignmentFault () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_PCAlignment);
    exception.vaddress = ThisInstrAddr();
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if EL2Enabled() & [HCR_EL2[27]] == 0b1 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_CheckPCAlignment : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckPCAlignment () = {
    let pc : bits(64) = ThisInstrAddr();
    if slice(pc, 0, 2) != 0b00 then {
        AArch64_PCAlignmentFault()
    }
}

val AArch64_InstructionAbort : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_InstructionAbort (vaddress, fault) = {
    if HaveDoubleFaultExt() then {
        assert(fault.typ != Fault_AsyncExternal)
    };
    let route_to_el3 : bool = (HaveEL(EL3) & [SCR_EL3[3]] == 0b1) & IsExternalAbort(fault);
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & (([HCR_EL2[27]] == 0b1 | IsSecondStage(fault)) | (HaveRASExt() & [HCR_EL2[37]] == 0b1) & IsExternalAbort(fault));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_InstructionAbort, fault, vaddress);
    if PSTATE.EL == EL3 | route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_DataAbort : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_DataAbort (vaddress, fault) = {
    let route_to_el3 : bool = (HaveEL(EL3) & [SCR_EL3[3]] == 0b1) & IsExternalAbort(fault);
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ((([HCR_EL2[27]] == 0b1 | (HaveRASExt() & [HCR_EL2[37]] == 0b1) & IsExternalAbort(fault)) | HaveNV2Ext() & fault.acctype == AccType_NV2REGISTER) | IsSecondStage(fault));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    vect_offset : int = undefined : int;
    if ((HaveDoubleFaultExt() & (PSTATE.EL == EL3 | route_to_el3)) & IsExternalAbort(fault)) & [SCR_EL3[19]] == 0b1 then {
        vect_offset = 384
    } else {
        vect_offset = 0
    };
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if HaveNV2Ext() & fault.acctype == AccType_NV2REGISTER then {
        exception = AArch64_AbortSyndrome(Exception_NV2DataAbort, fault, vaddress)
    } else {
        exception = AArch64_AbortSyndrome(Exception_DataAbort, fault, vaddress)
    };
    if PSTATE.EL == EL3 | route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_CheckIllegalState : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckIllegalState () = {
    exception : ExceptionRecord = undefined : ExceptionRecord;
    route_to_el2 : bool = undefined : bool;
    vect_offset : int = undefined : int;
    if PSTATE.IL == 0b1 then {
        route_to_el2 = (EL2Enabled() & PSTATE.EL == EL0) & [HCR_EL2[27]] == 0b1;
        let preferred_exception_return : bits(64) = ThisInstrAddr();
        vect_offset = 0;
        exception = ExceptionSyndrome(Exception_IllegalState);
        if UInt(PSTATE.EL) > UInt(EL1) then {
            AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
        } else {
            if route_to_el2 then {
                AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
            } else {
                AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
            }
        }
    }
}

val AArch64_CheckForSMCUndefOrTrap : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForSMCUndefOrTrap imm = {
    route_to_el2 : bool = undefined : bool;
    route_to_el2 = (EL2Enabled() & PSTATE.EL == EL1) & [HCR_EL2[19]] == 0b1;
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    if ~(HaveEL(EL3)) then {
        if EL2Enabled() & PSTATE.EL == EL1 then {
            if (HaveNVExt() & [HCR_EL2[42]] == 0b1) & [HCR_EL2[19]] == 0b1 then {
                route_to_el2 = true
            } else {
                throw(Error_Undefined())
            }
        } else {
            throw(Error_Undefined())
        }
    } else {
        route_to_el2 = (EL2Enabled() & PSTATE.EL == EL1) & [HCR_EL2[19]] == 0b1
    };
    exception : ExceptionRecord = undefined : ExceptionRecord;
    vect_offset : int = undefined : int;
    if route_to_el2 then {
        let preferred_exception_return : bits(64) = ThisInstrAddr();
        vect_offset = 0;
        exception = ExceptionSyndrome(Exception_MonitorCall);
        __tc1 : bits(25) = exception.syndrome;
        __tc1 = __SetSlice_bits(25, 16, __tc1, 0, imm);
        exception.syndrome = __tc1;
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckForERetTrap : forall ('eret_with_pac : Bool) ('pac_uses_key_a : Bool).
  (bool('eret_with_pac), bool('pac_uses_key_a)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForERetTrap (eret_with_pac, pac_uses_key_a) = {
    let route_to_el2 : bool = ((HaveNVExt() & EL2Enabled()) & PSTATE.EL == EL1) & [HCR_EL2[42]] == 0b1;
    vect_offset : int = undefined : int;
    if route_to_el2 then {
        exception : ExceptionRecord = undefined : ExceptionRecord;
        let preferred_exception_return : bits(64) = ThisInstrAddr();
        vect_offset = 0;
        exception = ExceptionSyndrome(Exception_ERetTrap);
        if ~(eret_with_pac) then {
            __tc1 : bits(25) = exception.syndrome;
            __tc1 = __SetSlice_bits(25, 1, __tc1, 1, 0b0);
            exception.syndrome = __tc1;
            __tc2 : bits(25) = exception.syndrome;
            __tc2 = __SetSlice_bits(25, 1, __tc2, 0, 0b0);
            exception.syndrome = __tc2
        } else {
            __tc3 : bits(25) = exception.syndrome;
            __tc3 = __SetSlice_bits(25, 1, __tc3, 1, 0b1);
            exception.syndrome = __tc3;
            if pac_uses_key_a then {
                __tc4 : bits(25) = exception.syndrome;
                __tc4 = __SetSlice_bits(25, 1, __tc4, 0, 0b0);
                exception.syndrome = __tc4
            } else {
                __tc5 : bits(25) = exception.syndrome;
                __tc5 = __SetSlice_bits(25, 1, __tc5, 0, 0b1);
                exception.syndrome = __tc5
            }
        };
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CallSupervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallSupervisor immediate = {
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let route_to_el2 : bool = (EL2Enabled() & PSTATE.EL == EL0) & [HCR_EL2[27]] == 0b1;
    let preferred_exception_return : bits(64) = NextInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SupervisorCall);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val system_exceptions_runtime_svc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_svc imm = {
    AArch64_CallSupervisor(imm)
}

val AArch64_CallSecureMonitor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallSecureMonitor immediate = {
    assert(HaveEL(EL3) & ~(ELUsingAArch32(EL3)));
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_MonitorCall);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
}

val system_exceptions_runtime_smc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_smc imm = {
    AArch64_CheckForSMCUndefOrTrap(imm);
    if [SCR_EL3[7]] == 0b1 then {
        AArch64_UndefinedFault()
    } else {
        AArch64_CallSecureMonitor(imm)
    }
}

val AArch64_CallHypervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallHypervisor immediate = {
    assert(HaveEL(EL2));
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_HypervisorCall);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    if PSTATE.EL == EL3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    }
}

val system_exceptions_runtime_hvc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_hvc imm = {
    if (~(HaveEL(EL2)) | PSTATE.EL == EL0) | PSTATE.EL == EL1 & ~(IsSecureEL2Enabled()) & IsSecure() then {
        throw(Error_Undefined())
    };
    let hvc_enable : vector(1, dec, bit) = if HaveEL(EL3) then [SCR_EL3[8]] else ~([HCR_EL2[29]]);
    if hvc_enable == 0b0 then {
        AArch64_UndefinedFault()
    } else {
        AArch64_CallHypervisor(imm)
    }
}

val AArch64_BreakpointException : FaultRecord -> unit effect {escape, rreg, undef, wreg}

function AArch64_BreakpointException fault = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    let vaddress : vector(64, dec, bit) = undefined : bits(64);
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_Breakpoint, fault, vaddress);
    if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_Abort : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_Abort (vaddress, fault) = {
    if IsDebugException(fault) then {
        if fault.acctype == AccType_IFETCH then {
            if UsingAArch32() & fault.debugmoe == DebugException_VectorCatch then {
                AArch64_VectorCatchException(fault)
            } else {
                AArch64_BreakpointException(fault)
            }
        } else {
            AArch64_WatchpointException(vaddress, fault)
        }
    } else {
        if fault.acctype == AccType_IFETCH then {
            AArch64_InstructionAbort(vaddress, fault)
        } else {
            AArch64_DataAbort(vaddress, fault)
        }
    }
}

val AArch64_CheckAlignment : forall ('alignment : Int) ('iswrite : Bool).
  (bits(64), int('alignment), AccType, bool('iswrite)) -> bool effect {escape, rreg, undef, wreg}

function AArch64_CheckAlignment (address, alignment, acctype, iswrite) = {
    let aligned : bool = address == Align(address, alignment);
    let atomic : bool = acctype == AccType_ATOMIC | acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    let ordered : bool = acctype == AccType_ORDERED | acctype == AccType_ORDEREDRW | acctype == AccType_LIMITEDORDERED | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    let vector_name : bool = acctype == AccType_VEC;
    check : bool = undefined : bool;
    if [SCTLR()[1]] == 0b1 then {
        check = true
    } else {
        if HaveUA16Ext() then {
            check = UInt(slice(address, 0, 4)) + alignment > 16 & (ordered & [SCTLR()[6]] == 0b0 | atomic)
        } else {
            check = atomic | ordered
        }
    };
    secondstage : bool = undefined : bool;
    if check & ~(aligned) then {
        secondstage = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    };
    aligned
}

val AArch64_BranchTargetException : bits(52) -> unit effect {escape, rreg, undef, wreg}

function AArch64_BranchTargetException vaddress = {
    let route_to_el2 : bool = (EL2Enabled() & PSTATE.EL == EL0) & [HCR_EL2[27]] == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_BranchTarget);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 2, __tc1, 0, PSTATE.BTYPE);
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 23, __tc2, 2, Zeros());
    exception.syndrome = __tc2;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val BranchTargetCheck : unit -> unit effect {escape, rreg, undef, wreg}

function BranchTargetCheck () = {
    assert(HaveBTIExt() & ~(UsingAArch32()));
    if ((InGuardedPage & PSTATE.BTYPE != 0b00) & ~(BTypeCompatible)) & ~(Halted()) then {
        let pc : bits(64) = ThisInstrAddr();
        AArch64_BranchTargetException(slice(pc, 0, 52))
    };
    let branch_instr : bool = AArch64_ExecutingBROrBLROrRetInstr();
    let bti_instr : bool = AArch64_ExecutingBTIInstr();
    if ~(branch_instr | bti_instr) then {
        BTypeNext = 0b00
    }
}

val __PostDecode : unit -> unit effect {escape, rreg, undef, wreg}

function __PostDecode () = {
    if HaveBTIExt() & ~(UsingAArch32()) then {
        BranchTargetCheck()
    }
}

val system_monitors_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_monitors_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    __PostDecode();
    system_monitors()
}

val system_hints_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_hints_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    op : SystemHintOp = undefined : SystemHintOp;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          throw(Error_See("PACIA1716, PACIB1716, AUTIA1716, AUTIB1716"))
      },
      0b0010000 => {
          if ~(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if ~(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if ~(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          throw(Error_See("PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP"))
      },
      [bitzero] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitzero] => {
          op = SystemHintOp_BTI;
          BTypeCompatible = BTypeCompatible_BTI(slice(op2, 1, 2))
      },
      _ => {
          EndOfInstruction()
      }
    };
    __PostDecode();
    system_hints(op)
}

val system_exceptions_runtime_svc_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_svc_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let imm : vector(16, dec, bit) = imm16;
    __PostDecode();
    system_exceptions_runtime_svc(imm)
}

val system_exceptions_runtime_smc_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_smc_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let imm : vector(16, dec, bit) = imm16;
    __PostDecode();
    system_exceptions_runtime_smc(imm)
}

val system_exceptions_runtime_hvc_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_hvc_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let imm : vector(16, dec, bit) = imm16;
    __PostDecode();
    system_exceptions_runtime_hvc(imm)
}

val system_exceptions_debug_breakpoint_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_breakpoint_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let comment : vector(16, dec, bit) = imm16;
    if HaveBTIExt() then {
        BTypeCompatible = true
    };
    __PostDecode();
    system_exceptions_debug_breakpoint(comment)
}

val system_barriers_decode : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_barriers_decode (Rt, opc, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    op : MemBarrierOp = undefined : MemBarrierOp;
    domain : MBReqDomain = undefined : MBReqDomain;
    types : MBReqTypes = undefined : MBReqTypes;
    match opc {
      0b00 => {
          op = MemBarrierOp_DSB
      },
      0b01 => {
          op = MemBarrierOp_DMB
      },
      0b10 => {
          op = MemBarrierOp_ISB
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    match slice(CRm, 2, 2) {
      0b00 => {
          domain = MBReqDomain_OuterShareable
      },
      0b01 => {
          domain = MBReqDomain_Nonshareable
      },
      0b10 => {
          domain = MBReqDomain_InnerShareable
      },
      0b11 => {
          domain = MBReqDomain_FullSystem
      }
    };
    match slice(CRm, 0, 2) {
      0b01 => {
          types = MBReqTypes_Reads
      },
      0b10 => {
          types = MBReqTypes_Writes
      },
      0b11 => {
          types = MBReqTypes_All
      },
      _ => {
          if slice(CRm, 2, 2) == 0b01 then {
              op = MemBarrierOp_PSSBB
          } else {
              if slice(CRm, 2, 2) == 0b00 & opc == 0b00 then {
                  op = MemBarrierOp_SSBB
              } else {
                  types = MBReqTypes_All;
                  domain = MBReqDomain_FullSystem
              }
          }
      }
    };
    __PostDecode();
    system_barriers(domain, op, types)
}

val integer_tags_mcsubtag_decode : (bits(5), bits(5), bits(4), bits(2), bits(6)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcsubtag_decode (Xd, Xn, uimm4, op3, uimm6) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let tag_offset : bits(4) = uimm4;
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(ZeroExtend(uimm6, 64), log2_tag_granule);
    let ADD : bool = false;
    __PostDecode();
    integer_tags_mcsubtag(ADD, d, n, offset, tag_offset)
}

val integer_tags_mcinserttagmask_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcinserttagmask_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    __PostDecode();
    integer_tags_mcinserttagmask(d, m, n)
}

val integer_tags_mcinsertrandomtag_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcinsertrandomtag_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    __PostDecode();
    integer_tags_mcinsertrandomtag(d, m, n)
}

val integer_tags_mcaddtag_decode : (bits(5), bits(5), bits(4), bits(2), bits(6)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcaddtag_decode (Xd, Xn, uimm4, op3, uimm6) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let tag_offset : bits(4) = uimm4;
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(ZeroExtend(uimm6, 64), log2_tag_granule);
    let ADD : bool = true;
    __PostDecode();
    integer_tags_mcaddtag(ADD, d, n, offset, tag_offset)
}

val integer_shift_variable_decode : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_shift_variable_decode (Rd, Rn, op2, opcode2_5_2_, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    __PostDecode();
    integer_shift_variable(d, datasize, m, n, shift_type)
}

val integer_pac_strip_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_strip_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    let 'd : {'n, 'n == 30. int('n)} = 30;
    let data : bool(false) = false;
    __PostDecode();
    integer_pac_strip_dp_1src(d, data)
}

val integer_pac_strip_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_strip_dp_1src_decode (Rd, Rn, D, opcode2, S, sf) = {
    __unconditional = true;
    let data : bool = D == 0b1;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if n != 31 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_pac_strip_dp_1src(d, data)
}

val integer_pac_pacib_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacib_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011010 => {
          d = 30;
          n = 31
      },
      0b0011011 => {
          d = 30;
          source_is_sp = true;
          if HaveBTIExt() then {
              BTypeCompatible = BTypeCompatible_PACIXSP()
          }
      },
      0b0001010 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("PACIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("AUTIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      }
    };
    __PostDecode();
    let 'n = n;
    let 'd = d;
    assert(constraint((0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31)));
    integer_pac_pacib_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacib_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacib_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacib_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacia_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacia_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011000 => {
          d = 30;
          n = 31
      },
      0b0011001 => {
          d = 30;
          source_is_sp = true;
          if HaveBTIExt() then {
              BTypeCompatible = BTypeCompatible_PACIXSP()
          }
      },
      0b0001000 => {
          d = 17;
          n = 16
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("PACIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("AUTIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      }
    };
    __PostDecode();
    let 'd = d;
    let 'n = n;
    assert(constraint((0 <= 'd & 'd <= 31 & 0 <= 'n & 'n <= 31)));
    integer_pac_pacia_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacia_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacia_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacia_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacga_dp_2src_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacga_dp_2src_decode (Rd, Rn, opcode2, Rm, S, op, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if m == 31 then {
        source_is_sp = true
    };
    __PostDecode();
    integer_pac_pacga_dp_2src(d, m, n, source_is_sp)
}

val integer_pac_pacdb_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacdb_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacdb_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacda_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacda_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacda_dp_1src(d, n, source_is_sp)
}

val integer_pac_autib_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autib_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011110 => {
          d = 30;
          n = 31
      },
      0b0011111 => {
          d = 30;
          source_is_sp = true
      },
      0b0001110 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("PACIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("PACIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("AUTIA"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      }
    };
    __PostDecode();
    let 'd = d;
    let 'n = n;
    assert(constraint((0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31)));
    integer_pac_autib_dp_1src(d, n, source_is_sp)
}

val integer_pac_autib_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autib_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autib_dp_1src(d, n, source_is_sp)
}

val integer_pac_autia_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autia_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011100 => {
          d = 30;
          n = 31
      },
      0b0011101 => {
          d = 30;
          source_is_sp = true
      },
      0b0001100 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("PACIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("PACIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      _ => {
          throw(Error_See("HINT"))
      }
    };
    __PostDecode();
    let 'd = d;
    let 'n = n;
    assert(constraint((0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31)));
    integer_pac_autia_dp_1src(d, n, source_is_sp)
}

val integer_pac_autia_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autia_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autia_dp_1src(d, n, source_is_sp)
}

val integer_pac_autdb_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autdb_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autdb_dp_1src(d, n, source_is_sp)
}

val integer_pac_autda_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autda_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autda_dp_1src(d, n, source_is_sp)
}

val integer_logical_shiftedreg_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_shiftedreg_decode (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined : bool;
    op : LogicalOp = undefined : LogicalOp;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    __PostDecode();
    integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

val integer_logical_immediate_decode : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_immediate_decode (Rd, Rn, imms, immr, N, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined : bool;
    op : LogicalOp = undefined : LogicalOp;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined : bits('datasize);
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    };
    __anon1 : bits('datasize) = undefined : bits('datasize);
    (imm, __anon1) = DecodeBitMasks(N, imms, immr, true);
    __PostDecode();
    integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

val integer_insext_insert_movewide_decode : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_insert_movewide_decode (Rd, imm16, hw, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let imm : vector(16, dec, bit) = imm16;
    pos : int = undefined : int;
    opcode : MoveWideOp = undefined : MoveWideOp;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let pos = UInt(hw @ 0x0);
    __PostDecode();
    integer_insext_insert_movewide(d, datasize, imm, opcode, pos)
}

val integer_insext_extract_immediate_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_extract_immediate_decode (Rd, Rn, imms, Rm, o0, N, op21, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    lsb : int = undefined : int;
    if N != sf then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imms[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let lsb = UInt(imms);
    __PostDecode();
    integer_insext_extract_immediate(d, datasize, lsb, m, n)
}

val integer_flags_xaflag_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_xaflag_decode CRm = {
    __unconditional = true;
    if ~(HaveFlagFormatExt()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_flags_xaflag()
}

val integer_flags_setf_decode : (bits(4), bits(5), bits(4), bits(1), bits(6), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_setf_decode (mask, Rn, opcode2, sz, imm6, sf) = {
    __unconditional = true;
    if ~(HaveFlagManipulateExt()) | sf != 0b0 then {
        throw(Error_Undefined())
    };
    let 'msb : {'n, 'n in {15, 7}. int('n)} = if sz == 0b1 then 15 else 7;
    let 'n = UInt(Rn);
    __PostDecode();
    integer_flags_setf(msb, n)
}

val integer_flags_rmif_decode : (bits(4), bits(5), bits(6), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_rmif_decode (mask, Rn, imm6, sf) = {
    __unconditional = true;
    if ~(HaveFlagManipulateExt()) | sf != 0b1 then {
        throw(Error_Undefined())
    };
    let 'lsb = UInt(imm6);
    let 'n = UInt(Rn);
    __PostDecode();
    integer_flags_rmif(lsb, mask, n)
}

val integer_flags_cfinv_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_cfinv_decode CRm = {
    __unconditional = true;
    if ~(HaveFlagManipulateExt()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_flags_cfinv()
}

val integer_flags_axflag_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_axflag_decode CRm = {
    __unconditional = true;
    if ~(HaveFlagFormatExt()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_flags_axflag()
}

val integer_crc_decode : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_crc_decode (Rd, Rn, sz, C, opcode2_5_3_, Rm, S, op, sf) = {
    __unconditional = true;
    if ~(HaveCRCExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sf == 0b1 & sz != 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & sz == 0b11 then {
        throw(Error_Undefined())
    };
    let 'size = shl_int(8, UInt(sz));
    assert(constraint('size in {8, 16, 32, 64}));
    let crc32c : bool = C == 0b1;
    __PostDecode();
    integer_crc(crc32c, d, m, n, size)
}

val integer_conditional_select_decode : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_select_decode (Rd, Rn, o2, cond, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let condition : vector(4, dec, bit) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    __PostDecode();
    integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

val integer_conditional_compare_register_decode : (bits(4), bits(1), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_compare_register_decode (nzcv, o3, Rn, o2, cond, Rm, S, op, sf) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : vector(4, dec, bit) = cond;
    let flags : vector(4, dec, bit) = nzcv;
    __PostDecode();
    integer_conditional_compare_register(condition, datasize, flags, m, n, sub_op)
}

val integer_conditional_compare_immediate_decode : (bits(4), bits(1), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_compare_immediate_decode (nzcv, o3, Rn, o2, cond, imm5, S, op, sf) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : vector(4, dec, bit) = cond;
    let flags : vector(4, dec, bit) = nzcv;
    let imm : bits('datasize) = ZeroExtend(imm5, datasize);
    __PostDecode();
    integer_conditional_compare_immediate(condition, datasize, flags, imm, n, sub_op)
}

val integer_bitfield_decode : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_bitfield_decode (Rd, Rn, imms, immr, N, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined : bool;
    extend : bool = undefined : bool;
    R : int = undefined : int;
    S : int = undefined : int;
    wmask : bits('datasize) = undefined : bits('datasize);
    tmask : bits('datasize) = undefined : bits('datasize);
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    };
    let R = UInt(immr);
    let S = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(N, imms, immr, false);
    __PostDecode();
    integer_bitfield(R, S, d, datasize, extend, inzero, n, tmask, wmask)
}

val integer_arithmetic_rev_decode : (bits(5), bits(5), bits(2), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rev_decode (Rd, Rn, opc, opcode2, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    container_size : int = undefined : int;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          };
          container_size = 64
      }
    };
    __PostDecode();
    integer_arithmetic_rev(container_size, d, datasize, n)
}

val integer_arithmetic_rbit_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rbit_decode (Rd, Rn, opcode2, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    __PostDecode();
    integer_arithmetic_rbit(d, datasize, n)
}

val integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    let setflags : bool(true) = true;
    __PostDecode();
    integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags(d, m, n, setflags)
}

val integer_arithmetic_pointer_mcsubtracttaggedaddress_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddress_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    let setflags : bool(false) = false;
    __PostDecode();
    integer_arithmetic_pointer_mcsubtracttaggedaddress(d, m, n, setflags)
}

val integer_arithmetic_mul_widening_64128hi_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_widening_64128hi_decode (Rd, Rn, Ra, o0, Rm, U, op54, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize : {'n, 'n == 64. int('n)} = 64;
    let 'datasize : {'n, 'n == 'destsize. int('n)} = destsize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    integer_arithmetic_mul_widening_64128hi(d, datasize, m, n, unsigned)
}

val integer_arithmetic_mul_widening_3264_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_widening_3264_decode (Rd, Rn, Ra, o0, Rm, U, op54, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize : {'n, 'n == 64. int('n)} = 64;
    let 'datasize : {'n, 'n == 32. int('n)} = 32;
    let sub_op : bool = o0 == 0b1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    integer_arithmetic_mul_widening_3264(a, d, datasize, destsize, m, n, sub_op, unsigned)
}

val integer_arithmetic_mul_uniform_addsub_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_uniform_addsub_decode (Rd, Rn, Ra, o0, Rm, op31, op54, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let 'datasize : {'n, 'n == 'destsize. int('n)} = destsize;
    let sub_op : bool = o0 == 0b1;
    __PostDecode();
    integer_arithmetic_mul_uniform_addsub(a, d, datasize, destsize, m, n, sub_op)
}

val integer_arithmetic_div_decode : (bits(5), bits(5), bits(1), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_div_decode (Rd, Rn, o1, opcode2_5_1_, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let unsigned : bool = o1 == 0b0;
    __PostDecode();
    integer_arithmetic_div(d, datasize, m, n, unsigned)
}

val integer_arithmetic_cnt_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_cnt_decode (Rd, Rn, op, opcode2, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let opcode : CountOp = if op == 0b0 then CountOp_CLZ else CountOp_CLS;
    __PostDecode();
    integer_arithmetic_cnt(d, datasize, n, opcode)
}

val integer_arithmetic_address_pcrel_decode : (bits(5), bits(19), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_address_pcrel_decode (Rd, immhi, immlo, op) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let page : bool = op == 0b1;
    imm : bits(64) = undefined : bits(64);
    if page then {
        imm = SignExtend((immhi @ immlo) @ Zeros(12), 64)
    } else {
        imm = SignExtend(immhi @ immlo, 64)
    };
    __PostDecode();
    integer_arithmetic_address_pcrel(d, imm, page)
}

val integer_arithmetic_addsub_shiftedreg_decode : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_shiftedreg_decode (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    __PostDecode();
    integer_arithmetic_addsub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

val integer_arithmetic_addsub_extendedreg_decode : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_extendedreg_decode (Rd, Rn, imm3, option_name, Rm, opt, S, op, sf) = {
    __unconditional = true;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let datasize : {|64, 32|} = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    };
    assert(shift <= 4);
    __PostDecode();
    integer_arithmetic_addsub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

val integer_arithmetic_addsub_carry_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_carry_decode (Rd, Rn, opcode2, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    __PostDecode();
    integer_arithmetic_addsub_carry(d, datasize, m, n, setflags, sub_op)
}

val branch_unconditional_register_decode : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_register_decode (Rm, Rn, M, A, op2, op, Z) = {
    __unconditional = true;
    n : int = UInt(Rn);
    branch_type : BranchType = undefined : BranchType;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if ~(pac) & m != 0 then {
        throw(Error_Undefined())
    } else {
        if pac & ~(HavePACExt()) then {
            throw(Error_Undefined())
        }
    };
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        }
    };
    __PostDecode();
    let 'n = n;
    assert(constraint((0 <= 'n & 'n <= 31)));
    branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

val branch_unconditional_immediate_decode : (bits(26), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_immediate_decode (imm26, op) = {
    __unconditional = true;
    let branch_type : BranchType = if op == 0b1 then BranchType_DIRCALL else BranchType_DIR;
    let offset : vector(64, dec, bit) = SignExtend(imm26 @ 0b00, 64);
    __PostDecode();
    branch_unconditional_immediate(branch_type, offset)
}

val branch_conditional_test_decode : (bits(5), bits(14), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_test_decode (Rt, imm14, b40, op, b5) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if b5 == 0b1 then 64 else 32;
    let 'bit_pos = UInt(b5 @ b40);
    let bit_val : vector(1, dec, bit) = op;
    let offset : vector(64, dec, bit) = SignExtend(imm14 @ 0b00, 64);
    __PostDecode();
    branch_conditional_test(bit_pos, bit_val, datasize, offset, t)
}

val branch_conditional_cond_decode : (bits(4), bits(1), bits(19), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_cond_decode (cond, o0, imm19, o1) = {
    __unconditional = true;
    let offset : vector(64, dec, bit) = SignExtend(imm19 @ 0b00, 64);
    let condition : vector(4, dec, bit) = cond;
    __PostDecode();
    branch_conditional_cond(condition, offset)
}

val branch_conditional_compare_decode : (bits(5), bits(19), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_compare_decode (Rt, imm19, op, sf) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let iszero : bool = op == 0b0;
    let offset : vector(64, dec, bit) = SignExtend(imm19 @ 0b00, 64);
    __PostDecode();
    branch_conditional_compare(datasize, iszero, offset, t)
}

val AArch64_AdvSIMDFPAccessTrap : bits(2) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AdvSIMDFPAccessTrap target_el = {
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset : int(0) = 0;
    let route_to_el2 : bool = (target_el == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b1;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if route_to_el2 then {
        exception = ExceptionSyndrome(Exception_Uncategorized);
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        exception = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
        __tc1 : bits(25) = exception.syndrome;
        __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
        exception.syndrome = __tc1;
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    };
    return()
}

val AArch64_CheckFPAdvSIMDTrap : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckFPAdvSIMDTrap () = {
    disabled : bool = undefined : bool;
    if EL2Enabled() then {
        if HaveVirtHostExt() & [HCR_EL2[34]] == 0b1 then {
            match slice(CPTR_EL2, 20, 2) {
              _ : bits(1) @ [bitzero] => {
                  disabled = ~(PSTATE.EL == EL1 & [HCR_EL2[27]] == 0b1)
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & [HCR_EL2[27]] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            }
        } else {
            if [CPTR_EL2[10]] == 0b1 then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            }
        }
    };
    if HaveEL(EL3) then {
        if [CPTR_EL3[10]] == 0b1 then {
            AArch64_AdvSIMDFPAccessTrap(EL3)
        }
    };
    return()
}

val AArch64_CheckFPAdvSIMDEnabled : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckFPAdvSIMDEnabled () = {
    disabled : bool = undefined : bool;
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & ~(IsInHost()) then {
        match slice(CPACR(), 20, 2) {
          _ : bits(1) @ [bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            AArch64_AdvSIMDFPAccessTrap(EL1)
        }
    };
    AArch64_CheckFPAdvSIMDTrap()
}

val vector_crypto_sm4_sm4enckey : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm4_sm4enckey (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    intval : bits(32) = undefined : bits(32);
    let sboxout : vector(8, dec, bit) = undefined : bits(8);
    let result : vector(128, dec, bit) = undefined : bits(128);
    const : bits(32) = undefined : bits(32);
    roundresult : bits(128) = undefined : bits(128);
    roundresult = V(n);
    foreach (index from 0 to 3 by 1 in inc) {
        const = aget_Elem(Vm, index, 32);
        intval = ((slice(roundresult, 96, 32) ^ slice(roundresult, 64, 32)) ^ slice(roundresult, 32, 32)) ^ const;
        foreach (i from 0 to 3 by 1 in inc) {
            intval = aset_Elem(intval, i, 8, Sbox(aget_Elem(intval, i, 8)))
        };
        intval = (intval ^ ROL(intval, 13)) ^ ROL(intval, 23);
        intval = intval ^ slice(roundresult, 0, 32);
        roundresult = __SetSlice_bits(128, 32, roundresult, 0, slice(roundresult, 32, 32));
        roundresult = __SetSlice_bits(128, 32, roundresult, 32, slice(roundresult, 64, 32));
        roundresult = __SetSlice_bits(128, 32, roundresult, 64, slice(roundresult, 96, 32));
        roundresult = __SetSlice_bits(128, 32, roundresult, 96, intval)
    };
    V(d) = roundresult
}

val vector_crypto_sm4_sm4enckey_decode__0 : (bits(5), bits(5), bits(2), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm4_sm4enckey_decode__1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm4_sm4enckey_decode = {
  vector_crypto_sm4_sm4enckey_decode__0,
  vector_crypto_sm4_sm4enckey_decode__1
}

function vector_crypto_sm4_sm4enckey_decode__0 (Rd, Rn, opcode, O, Rm) = {
    __unconditional = true;
    if ~(HaveSM4Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sm4_sm4enckey(d, m, n)
}

function vector_crypto_sm4_sm4enckey_decode__1 (Rd, Rn, Rm) = {
    __unconditional = true;
    if ~(HaveSM4Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sm4_sm4enckey(d, m, n)
}

val vector_crypto_sm4_sm4enc : forall 'd 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm4_sm4enc (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vn : bits(128) = V(n);
    intval : bits(32) = undefined : bits(32);
    let sboxout : vector(8, dec, bit) = undefined : bits(8);
    roundresult : bits(128) = undefined : bits(128);
    roundkey : bits(32) = undefined : bits(32);
    roundresult = V(d);
    foreach (index from 0 to 3 by 1 in inc) {
        roundkey = aget_Elem(Vn, index, 32);
        intval = ((slice(roundresult, 96, 32) ^ slice(roundresult, 64, 32)) ^ slice(roundresult, 32, 32)) ^ roundkey;
        foreach (i from 0 to 3 by 1 in inc) {
            intval = aset_Elem(intval, i, 8, Sbox(aget_Elem(intval, i, 8)))
        };
        intval = (((intval ^ ROL(intval, 2)) ^ ROL(intval, 10)) ^ ROL(intval, 18)) ^ ROL(intval, 24);
        intval = intval ^ slice(roundresult, 0, 32);
        roundresult = __SetSlice_bits(128, 32, roundresult, 0, slice(roundresult, 32, 32));
        roundresult = __SetSlice_bits(128, 32, roundresult, 32, slice(roundresult, 64, 32));
        roundresult = __SetSlice_bits(128, 32, roundresult, 64, slice(roundresult, 96, 32));
        roundresult = __SetSlice_bits(128, 32, roundresult, 96, intval)
    };
    V(d) = roundresult
}

val vector_crypto_sm4_sm4enc_decode__0 : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm4_sm4enc_decode__1 : (bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm4_sm4enc_decode = {
  vector_crypto_sm4_sm4enc_decode__0,
  vector_crypto_sm4_sm4enc_decode__1
}

function vector_crypto_sm4_sm4enc_decode__0 (Rd, Rn) = {
    __unconditional = true;
    if ~(HaveSM4Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    __PostDecode();
    vector_crypto_sm4_sm4enc(d, n)
}

function vector_crypto_sm4_sm4enc_decode__1 (Rd, Rn, opcode) = {
    __unconditional = true;
    if ~(HaveSM4Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    __PostDecode();
    vector_crypto_sm4_sm4enc(d, n)
}

val vector_crypto_sm3_sm3tt2b : forall 'd 'i 'm 'n,
  ('m >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31 & 'i >= 0 & ('i + 1) * 32 <= 128).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm3_sm3tt2b (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = aget_V(m);
    let Vn : bits(128) = aget_V(n);
    let Vd : bits(128) = aget_V(d);
    Wj : bits(32) = undefined : bits(32);
    result : bits(128) = undefined : bits(128);
    TT2 : bits(32) = undefined : bits(32);
    let Wj = aget_Elem(Vm, i, 32);
    TT2 = slice(Vd, 96, 32) & slice(Vd, 64, 32) | ~(slice(Vd, 96, 32)) & slice(Vd, 32, 32);
    let TT2 = slice(TT2 + slice(Vd, 0, 32) + slice(Vn, 96, 32) + Wj, 0, 32);
    result = __SetSlice_bits(128, 32, result, 0, slice(Vd, 32, 32));
    result = __SetSlice_bits(128, 32, result, 32, ROL(slice(Vd, 64, 32), 19));
    result = __SetSlice_bits(128, 32, result, 64, slice(Vd, 96, 32));
    let result = __SetSlice_bits(128, 32, result, 96, (TT2 ^ ROL(TT2, 9)) ^ ROL(TT2, 17));
    aset_V(d, result)
}

val vector_crypto_sm3_sm3tt2b_decode__0 : (bits(5), bits(5), bits(2), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm3_sm3tt2b_decode__1 : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm3_sm3tt2b_decode = {
  vector_crypto_sm3_sm3tt2b_decode__0,
  vector_crypto_sm3_sm3tt2b_decode__1
}

function vector_crypto_sm3_sm3tt2b_decode__0 (Rd, Rn, opcode, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt2b(d, i, m, n)
}

function vector_crypto_sm3_sm3tt2b_decode__1 (Rd, Rn, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt2b(d, i, m, n)
}

val vector_crypto_sm3_sm3tt2a : forall 'd 'i 'm 'n,
  ('m >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31 & 'i >= 0 & ('i + 1) * 32 <= 128).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm3_sm3tt2a (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = aget_V(m);
    let Vn : bits(128) = aget_V(n);
    let Vd : bits(128) = aget_V(d);
    Wj : bits(32) = undefined : bits(32);
    result : bits(128) = undefined : bits(128);
    let TT1 : bits(32) = undefined : bits(32);
    let Wj = aget_Elem(Vm, i, 32);
    TT2 : bits(32) = undefined : bits(32);
    TT2 = slice(Vd, 32, 32) ^ slice(Vd, 96, 32) ^ slice(Vd, 64, 32);
    let TT2 = slice(TT2 + slice(Vd, 0, 32) + slice(Vn, 96, 32) + Wj, 0, 32);
    result = __SetSlice_bits(128, 32, result, 0, slice(Vd, 32, 32));
    result = __SetSlice_bits(128, 32, result, 32, ROL(slice(Vd, 64, 32), 19));
    result = __SetSlice_bits(128, 32, result, 64, slice(Vd, 96, 32));
    let result = __SetSlice_bits(128, 32, result, 96, (TT2 ^ ROL(TT2, 9)) ^ ROL(TT2, 17));
    aset_V(d, result)
}

val vector_crypto_sm3_sm3tt2a_decode__0 : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm3_sm3tt2a_decode__1 : (bits(5), bits(5), bits(2), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm3_sm3tt2a_decode = {
  vector_crypto_sm3_sm3tt2a_decode__0,
  vector_crypto_sm3_sm3tt2a_decode__1
}

function vector_crypto_sm3_sm3tt2a_decode__0 (Rd, Rn, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt2a(d, i, m, n)
}

function vector_crypto_sm3_sm3tt2a_decode__1 (Rd, Rn, opcode, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt2a(d, i, m, n)
}

val vector_crypto_sm3_sm3tt1b : forall 'd 'i 'm 'n,
  ('m >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31 & 'i >= 0 & ('i + 1) * 32 <= 128).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm3_sm3tt1b (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = aget_V(m);
    let Vn : bits(128) = aget_V(n);
    let Vd : bits(128) = aget_V(d);
    WjPrime : bits(32) = undefined : bits(32);
    result : bits(128) = undefined : bits(128);
    TT1 : bits(32) = undefined : bits(32);
    SS2 : bits(32) = undefined : bits(32);
    let WjPrime = aget_Elem(Vm, i, 32);
    let SS2 = slice(Vn, 96, 32) ^ ROL(slice(Vd, 96, 32), 12);
    TT1 = (slice(Vd, 96, 32) & slice(Vd, 32, 32) | slice(Vd, 96, 32) & slice(Vd, 64, 32)) | slice(Vd, 32, 32) & slice(Vd, 64, 32);
    let TT1 = slice(TT1 + slice(Vd, 0, 32) + SS2 + WjPrime, 0, 32);
    result = __SetSlice_bits(128, 32, result, 0, slice(Vd, 32, 32));
    result = __SetSlice_bits(128, 32, result, 32, ROL(slice(Vd, 64, 32), 9));
    result = __SetSlice_bits(128, 32, result, 64, slice(Vd, 96, 32));
    let result = __SetSlice_bits(128, 32, result, 96, TT1);
    aset_V(d, result)
}

val vector_crypto_sm3_sm3tt1b_decode__0 : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm3_sm3tt1b_decode__1 : (bits(5), bits(5), bits(2), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm3_sm3tt1b_decode = {
  vector_crypto_sm3_sm3tt1b_decode__0,
  vector_crypto_sm3_sm3tt1b_decode__1
}

function vector_crypto_sm3_sm3tt1b_decode__0 (Rd, Rn, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt1b(d, i, m, n)
}

function vector_crypto_sm3_sm3tt1b_decode__1 (Rd, Rn, opcode, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt1b(d, i, m, n)
}

val vector_crypto_sm3_sm3tt1a : forall 'd 'i 'm 'n,
  ('m >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31 & 'i >= 0 & ('i + 1) * 32 <= 128).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm3_sm3tt1a (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = aget_V(m);
    let Vn : bits(128) = aget_V(n);
    let Vd : bits(128) = aget_V(d);
    WjPrime : bits(32) = undefined : bits(32);
    result : bits(128) = undefined : bits(128);
    TT1 : bits(32) = undefined : bits(32);
    SS2 : bits(32) = undefined : bits(32);
    let WjPrime = aget_Elem(Vm, i, 32);
    let SS2 = slice(Vn, 96, 32) ^ ROL(slice(Vd, 96, 32), 12);
    TT1 = slice(Vd, 32, 32) ^ slice(Vd, 96, 32) ^ slice(Vd, 64, 32);
    let TT1 = slice(TT1 + slice(Vd, 0, 32) + SS2 + WjPrime, 0, 32);
    result = __SetSlice_bits(128, 32, result, 0, slice(Vd, 32, 32));
    result = __SetSlice_bits(128, 32, result, 32, ROL(slice(Vd, 64, 32), 9));
    result = __SetSlice_bits(128, 32, result, 64, slice(Vd, 96, 32));
    let result = __SetSlice_bits(128, 32, result, 96, TT1);
    aset_V(d, result)
}

val vector_crypto_sm3_sm3tt1a_decode__0 : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm3_sm3tt1a_decode__1 : (bits(5), bits(5), bits(2), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm3_sm3tt1a_decode = {
  vector_crypto_sm3_sm3tt1a_decode__0,
  vector_crypto_sm3_sm3tt1a_decode__1
}

function vector_crypto_sm3_sm3tt1a_decode__0 (Rd, Rn, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt1a(d, i, m, n)
}

function vector_crypto_sm3_sm3tt1a_decode__1 (Rd, Rn, opcode, imm2, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    __PostDecode();
    vector_crypto_sm3_sm3tt1a(d, i, m, n)
}

val vector_crypto_sm3_sm3ss1 : forall 'a 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31) & ('a >= 0 & 'a <= 31).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm3_sm3ss1 (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    let Vn : bits(128) = V(n);
    Vd : bits(128) = V(d);
    let Va : bits(128) = V(a);
    Vd = __SetSlice_bits(128, 32, Vd, 96, ROL(ROL(slice(Vn, 96, 32), 12) + slice(Vm, 96, 32) + slice(Va, 96, 32), 7));
    let Vd = __SetSlice_bits(128, 96, Vd, 0, Zeros());
    V(d) = Vd
}

val vector_crypto_sm3_sm3ss1_decode__0 : (bits(5), bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm3_sm3ss1_decode__1 : (bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm3_sm3ss1_decode = {
  vector_crypto_sm3_sm3ss1_decode__0,
  vector_crypto_sm3_sm3ss1_decode__1
}

function vector_crypto_sm3_sm3ss1_decode__0 (Rd, Rn, Ra, Rm, Op0) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    __PostDecode();
    vector_crypto_sm3_sm3ss1(a, d, m, n)
}

function vector_crypto_sm3_sm3ss1_decode__1 (Rd, Rn, Ra, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    __PostDecode();
    vector_crypto_sm3_sm3ss1(a, d, m, n)
}

val vector_crypto_sm3_sm3partw2 : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm3_sm3partw2 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    let Vn : bits(128) = V(n);
    let Vd : bits(128) = V(d);
    result : bits(128) = undefined : bits(128);
    tmp : bits(128) = undefined : bits(128);
    tmp2 : bits(32) = undefined : bits(32);
    let tmp = __SetSlice_bits(128, 128, tmp, 0, Vn ^ (((ROL(slice(Vm, 96, 32), 7) @ ROL(slice(Vm, 64, 32), 7)) @ ROL(slice(Vm, 32, 32), 7)) @ ROL(slice(Vm, 0, 32), 7)));
    result = __SetSlice_bits(128, 128, result, 0, slice(Vd, 0, 128) ^ slice(tmp, 0, 128));
    tmp2 = ROL(slice(tmp, 0, 32), 15);
    let tmp2 = (tmp2 ^ ROL(tmp2, 15)) ^ ROL(tmp2, 23);
    let result = __SetSlice_bits(128, 32, result, 96, slice(result, 96, 32) ^ tmp2);
    V(d) = result
}

val vector_crypto_sm3_sm3partw2_decode__0 : (bits(5), bits(5), bits(2), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm3_sm3partw2_decode__1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm3_sm3partw2_decode = {
  vector_crypto_sm3_sm3partw2_decode__0,
  vector_crypto_sm3_sm3partw2_decode__1
}

function vector_crypto_sm3_sm3partw2_decode__0 (Rd, Rn, opcode, O, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sm3_sm3partw2(d, m, n)
}

function vector_crypto_sm3_sm3partw2_decode__1 (Rd, Rn, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sm3_sm3partw2(d, m, n)
}

val vector_crypto_sm3_sm3partw1 : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sm3_sm3partw1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    let Vn : bits(128) = V(n);
    let Vd : bits(128) = V(d);
    result : bits(128) = undefined : bits(128);
    result = __SetSlice_bits(128, 96, result, 0, slice(Vd ^ Vn, 0, 96) ^ ((ROL(slice(Vm, 96, 32), 15) @ ROL(slice(Vm, 64, 32), 15)) @ ROL(slice(Vm, 32, 32), 15)));
    foreach (i from 0 to 3 by 1 in inc) {
        if i == 3 then {
            result = __SetSlice_bits(128, 32, result, 96, slice(Vd ^ Vn, 96, 32) ^ ROL(slice(result, 0, 32), 15))
        };
        result = __SetSlice_bits(128, 32, result, 32 * i, (slice(result, 32 * i, 32) ^ ROL(slice(result, 32 * i, 32), 15)) ^ ROL(slice(result, 32 * i, 32), 23))
    };
    V(d) = result
}

val vector_crypto_sm3_sm3partw1_decode__0 : (bits(5), bits(5), bits(2), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sm3_sm3partw1_decode__1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sm3_sm3partw1_decode = {
  vector_crypto_sm3_sm3partw1_decode__0,
  vector_crypto_sm3_sm3partw1_decode__1
}

function vector_crypto_sm3_sm3partw1_decode__0 (Rd, Rn, opcode, O, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sm3_sm3partw1(d, m, n)
}

function vector_crypto_sm3_sm3partw1_decode__1 (Rd, Rn, Rm) = {
    __unconditional = true;
    if ~(HaveSM3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sm3_sm3partw1(d, m, n)
}

val vector_crypto_sha512_sha512su1 : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha512_sha512su1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    sig1 : bits(64) = undefined : bits(64);
    Vtmp : bits(128) = undefined : bits(128);
    let X : bits(128) = V(n);
    let Y : bits(128) = V(m);
    let W : bits(128) = V(d);
    sig1 = (ROR(slice(X, 64, 64), 19) ^ ROR(slice(X, 64, 64), 61)) ^ (0b000000 @ slice(X, 70, 58));
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 64, slice(W, 64, 64) + sig1 + slice(Y, 64, 64));
    let sig1 = (ROR(slice(X, 0, 64), 19) ^ ROR(slice(X, 0, 64), 61)) ^ (0b000000 @ slice(X, 6, 58));
    let Vtmp = __SetSlice_bits(128, 64, Vtmp, 0, slice(W, 0, 64) + sig1 + slice(Y, 0, 64));
    V(d) = Vtmp
}

val vector_crypto_sha512_sha512su1_decode__0 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sha512_sha512su1_decode__1 : (bits(5), bits(5), bits(2), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sha512_sha512su1_decode = {
  vector_crypto_sha512_sha512su1_decode__0,
  vector_crypto_sha512_sha512su1_decode__1
}

function vector_crypto_sha512_sha512su1_decode__0 (Rd, Rn, Rm) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha512_sha512su1(d, m, n)
}

function vector_crypto_sha512_sha512su1_decode__1 (Rd, Rn, opcode, O, Rm) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha512_sha512su1(d, m, n)
}

val vector_crypto_sha512_sha512su0 : forall 'd 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha512_sha512su0 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    sig0 : bits(64) = undefined : bits(64);
    Vtmp : bits(128) = undefined : bits(128);
    let X : bits(128) = V(n);
    let W : bits(128) = V(d);
    sig0 = (ROR(slice(W, 64, 64), 1) ^ ROR(slice(W, 64, 64), 8)) ^ (0b0000000 @ slice(W, 71, 57));
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 0, slice(W, 0, 64) + sig0);
    let sig0 = (ROR(slice(X, 0, 64), 1) ^ ROR(slice(X, 0, 64), 8)) ^ (0b0000000 @ slice(X, 7, 57));
    let Vtmp = __SetSlice_bits(128, 64, Vtmp, 64, slice(W, 64, 64) + sig0);
    V(d) = Vtmp
}

val vector_crypto_sha512_sha512su0_decode__0 : (bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sha512_sha512su0_decode__1 : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sha512_sha512su0_decode = {
  vector_crypto_sha512_sha512su0_decode__0,
  vector_crypto_sha512_sha512su0_decode__1
}

function vector_crypto_sha512_sha512su0_decode__0 (Rd, Rn, opcode) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    __PostDecode();
    vector_crypto_sha512_sha512su0(d, n)
}

function vector_crypto_sha512_sha512su0_decode__1 (Rd, Rn) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    __PostDecode();
    vector_crypto_sha512_sha512su0(d, n)
}

val vector_crypto_sha512_sha512h : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha512_sha512h (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined : bits(128);
    MSigma1 : bits(64) = undefined : bits(64);
    tmp : bits(64) = undefined : bits(64);
    let X : bits(128) = V(n);
    let Y : bits(128) = V(m);
    let W : bits(128) = V(d);
    MSigma1 = (ROR(slice(Y, 64, 64), 14) ^ ROR(slice(Y, 64, 64), 18)) ^ ROR(slice(Y, 64, 64), 41);
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 64, (slice(Y, 64, 64) & slice(X, 0, 64)) ^ (~(slice(Y, 64, 64)) & slice(X, 64, 64)));
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 64, slice(Vtmp, 64, 64) + MSigma1 + slice(W, 64, 64));
    let tmp = slice(Vtmp, 64, 64) + slice(Y, 0, 64);
    let MSigma1 = (ROR(tmp, 14) ^ ROR(tmp, 18)) ^ ROR(tmp, 41);
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 0, (tmp & slice(Y, 64, 64)) ^ (~(tmp) & slice(X, 0, 64)));
    let Vtmp = __SetSlice_bits(128, 64, Vtmp, 0, slice(Vtmp, 0, 64) + MSigma1 + slice(W, 0, 64));
    V(d) = Vtmp
}

val vector_crypto_sha512_sha512h_decode__0 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sha512_sha512h_decode__1 : (bits(5), bits(5), bits(2), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sha512_sha512h_decode = {
  vector_crypto_sha512_sha512h_decode__0,
  vector_crypto_sha512_sha512h_decode__1
}

function vector_crypto_sha512_sha512h_decode__0 (Rd, Rn, Rm) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha512_sha512h(d, m, n)
}

function vector_crypto_sha512_sha512h_decode__1 (Rd, Rn, opcode, O, Rm) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha512_sha512h(d, m, n)
}

val vector_crypto_sha512_sha512h2 : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha512_sha512h2 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined : bits(128);
    NSigma0 : bits(64) = undefined : bits(64);
    let tmp : vector(64, dec, bit) = undefined : bits(64);
    let X : bits(128) = V(n);
    let Y : bits(128) = V(m);
    let W : bits(128) = V(d);
    NSigma0 = (ROR(slice(Y, 0, 64), 28) ^ ROR(slice(Y, 0, 64), 34)) ^ ROR(slice(Y, 0, 64), 39);
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 64, ((slice(X, 0, 64) & slice(Y, 64, 64)) ^ (slice(X, 0, 64) & slice(Y, 0, 64))) ^ (slice(Y, 64, 64) & slice(Y, 0, 64)));
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 64, slice(Vtmp, 64, 64) + NSigma0 + slice(W, 64, 64));
    let NSigma0 = (ROR(slice(Vtmp, 64, 64), 28) ^ ROR(slice(Vtmp, 64, 64), 34)) ^ ROR(slice(Vtmp, 64, 64), 39);
    Vtmp = __SetSlice_bits(128, 64, Vtmp, 0, ((slice(Vtmp, 64, 64) & slice(Y, 0, 64)) ^ (slice(Vtmp, 64, 64) & slice(Y, 64, 64))) ^ (slice(Y, 64, 64) & slice(Y, 0, 64)));
    let Vtmp = __SetSlice_bits(128, 64, Vtmp, 0, slice(Vtmp, 0, 64) + NSigma0 + slice(W, 0, 64));
    V(d) = Vtmp
}

val vector_crypto_sha512_sha512h2_decode__0 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sha512_sha512h2_decode__1 : (bits(5), bits(5), bits(2), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sha512_sha512h2_decode = {
  vector_crypto_sha512_sha512h2_decode__0,
  vector_crypto_sha512_sha512h2_decode__1
}

function vector_crypto_sha512_sha512h2_decode__0 (Rd, Rn, Rm) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha512_sha512h2(d, m, n)
}

function vector_crypto_sha512_sha512h2_decode__1 (Rd, Rn, opcode, O, Rm) = {
    __unconditional = true;
    if ~(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha512_sha512h2(d, m, n)
}

val vector_crypto_sha3op_sha256sched1 : forall 'd 'm 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha256sched1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V(d);
    let operand2 : bits(128) = V(n);
    let operand3 : bits(128) = V(m);
    result : bits(128) = undefined : bits(128);
    let T0 : bits(128) = slice(operand3, 0, 32) @ slice(operand2, 32, 96);
    T1 : bits(64) = undefined : bits(64);
    elt : bits(32) = undefined : bits(32);
    T1 = slice(operand3, 64, 64);
    foreach (e from 0 to 1 by 1 in inc) {
        elt = aget_Elem(T1, e, 32);
        elt = (ROR(elt, 17) ^ ROR(elt, 19)) ^ LSR(elt, 10);
        elt = elt + aget_Elem(operand1, e, 32) + aget_Elem(T0, e, 32);
        result = aset_Elem(result, e, 32, elt)
    };
    let T1 = slice(result, 0, 64);
    foreach (e from 2 to 3 by 1 in inc) {
        elt = aget_Elem(T1, e - 2, 32);
        elt = (ROR(elt, 17) ^ ROR(elt, 19)) ^ LSR(elt, 10);
        elt = elt + aget_Elem(operand1, e, 32) + aget_Elem(T0, e, 32);
        result = aset_Elem(result, e, 32, elt)
    };
    V(d) = result
}

val vector_crypto_sha3op_sha256sched1_decode : (bits(5), bits(5), bits(3), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha256sched1_decode (Rd, Rn, opcode, Rm, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha3op_sha256sched1(d, m, n)
}

val vector_crypto_sha3op_sha256hash : forall 'd 'm 'n ('part1 : Bool),
  ('d >= 0 & 'd <= 31 | not('part1)) & ('n >= 0 & 'n <= 31 | not('part1)) & ('m >= 0 & 'm <= 31 | not('part1)) & ('n >= 0 & 'n <= 31 | not(not('part1))) & ('d >= 0 & 'd <= 31 | not(not('part1))) & ('m >= 0 & 'm <= 31 | not(not('part1))).
  (int('d), int('m), int('n), bool('part1)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha256hash (d, m, n, part1) = {
    AArch64_CheckFPAdvSIMDEnabled();
    result : bits(128) = undefined : bits(128);
    if part1 then {
        result = SHA256hash(V(d), V(n), V(m), true)
    } else {
        result = SHA256hash(V(n), V(d), V(m), false)
    };
    V(d) = result
}

val vector_crypto_sha3op_sha256hash_decode : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha256hash_decode (Rd, Rn, P, Rm, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    let part1 : bool = P == 0b0;
    __PostDecode();
    vector_crypto_sha3op_sha256hash(d, m, n, part1)
}

val vector_crypto_sha3op_sha1sched0 : forall 'd 'm 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1sched0 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V(d);
    let operand2 : bits(128) = V(n);
    let operand3 : bits(128) = V(m);
    result : bits(128) = undefined : bits(128);
    result = slice(operand2, 0, 64) @ slice(operand1, 64, 64);
    let result = (result ^ operand1) ^ operand3;
    V(d) = result
}

val vector_crypto_sha3op_sha1sched0_decode : (bits(5), bits(5), bits(3), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1sched0_decode (Rd, Rn, opcode, Rm, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha3op_sha1sched0(d, m, n)
}

val vector_crypto_sha3op_sha1hash_parity : forall 'd 'm 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1hash_parity (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    X : bits(128) = V(d);
    Y : bits(32) = V(n);
    let W : bits(128) = V(m);
    t : bits(32) = undefined : bits(32);
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAparity(slice(X, 32, 32), slice(X, 64, 32), slice(X, 96, 32));
        Y = Y + ROL(slice(X, 0, 32), 5) + t + aget_Elem(W, e, 32);
        X = __SetSlice_bits(128, 32, X, 32, ROL(slice(X, 32, 32), 30));
        let __tc1 : bits(160) = ROL(Y @ X, 32);
        Y = slice(__tc1, 128, 32);
        X = slice(__tc1, 0, 128)
    };
    V(d) = X
}

val vector_crypto_sha3op_sha1hash_parity_decode : (bits(5), bits(5), bits(3), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1hash_parity_decode (Rd, Rn, opcode, Rm, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha3op_sha1hash_parity(d, m, n)
}

val vector_crypto_sha3op_sha1hash_majority : forall 'd 'm 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1hash_majority (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    X : bits(128) = V(d);
    Y : bits(32) = V(n);
    let W : bits(128) = V(m);
    t : bits(32) = undefined : bits(32);
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAmajority(slice(X, 32, 32), slice(X, 64, 32), slice(X, 96, 32));
        Y = Y + ROL(slice(X, 0, 32), 5) + t + aget_Elem(W, e, 32);
        X = __SetSlice_bits(128, 32, X, 32, ROL(slice(X, 32, 32), 30));
        let __tc1 : bits(160) = ROL(Y @ X, 32);
        Y = slice(__tc1, 128, 32);
        X = slice(__tc1, 0, 128)
    };
    V(d) = X
}

val vector_crypto_sha3op_sha1hash_majority_decode : (bits(5), bits(5), bits(3), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1hash_majority_decode (Rd, Rn, opcode, Rm, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha3op_sha1hash_majority(d, m, n)
}

val vector_crypto_sha3op_sha1hash_choose : forall 'd 'm 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1hash_choose (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    X : bits(128) = V(d);
    Y : bits(32) = V(n);
    let W : bits(128) = V(m);
    t : bits(32) = undefined : bits(32);
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAchoose(slice(X, 32, 32), slice(X, 64, 32), slice(X, 96, 32));
        Y = Y + ROL(slice(X, 0, 32), 5) + t + aget_Elem(W, e, 32);
        X = __SetSlice_bits(128, 32, X, 32, ROL(slice(X, 32, 32), 30));
        let __tc1 : bits(160) = ROL(Y @ X, 32);
        Y = slice(__tc1, 128, 32);
        X = slice(__tc1, 0, 128)
    };
    V(d) = X
}

val vector_crypto_sha3op_sha1hash_choose_decode : (bits(5), bits(5), bits(3), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3op_sha1hash_choose_decode (Rd, Rn, opcode, Rm, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha3op_sha1hash_choose(d, m, n)
}

val vector_crypto_sha3_xar : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), bits(6), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3_xar (d, imm6, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    let Vn : bits(128) = V(n);
    let tmp : bits(128) = Vn ^ Vm;
    V(d) = ROR(slice(tmp, 64, 64), UInt(imm6)) @ ROR(slice(tmp, 0, 64), UInt(imm6))
}

val vector_crypto_sha3_xar_decode : (bits(5), bits(5), bits(6), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3_xar_decode (Rd, Rn, imm6, Rm) = {
    __unconditional = true;
    if ~(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha3_xar(d, imm6, m, n)
}

val vector_crypto_sha3_rax1 : forall 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3_rax1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    let Vn : bits(128) = V(n);
    V(d) = Vn ^ (ROL(slice(Vm, 64, 64), 1) @ ROL(slice(Vm, 0, 64), 1))
}

val vector_crypto_sha3_rax1_decode__0 : (bits(5), bits(5), bits(2), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sha3_rax1_decode__1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sha3_rax1_decode = {
  vector_crypto_sha3_rax1_decode__0,
  vector_crypto_sha3_rax1_decode__1
}

function vector_crypto_sha3_rax1_decode__0 (Rd, Rn, opcode, O, Rm) = {
    __unconditional = true;
    if ~(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha3_rax1(d, m, n)
}

function vector_crypto_sha3_rax1_decode__1 (Rd, Rn, Rm) = {
    __unconditional = true;
    if ~(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    __PostDecode();
    vector_crypto_sha3_rax1(d, m, n)
}

val vector_crypto_sha3_eor3 : forall 'a 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('a >= 0 & 'a <= 31) & ('d >= 0 & 'd <= 31).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3_eor3 (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    let Vn : bits(128) = V(n);
    let Va : bits(128) = V(a);
    V(d) = (Vn ^ Vm) ^ Va
}

val vector_crypto_sha3_eor3_decode__0 : (bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sha3_eor3_decode__1 : (bits(5), bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sha3_eor3_decode = {
  vector_crypto_sha3_eor3_decode__0,
  vector_crypto_sha3_eor3_decode__1
}

function vector_crypto_sha3_eor3_decode__0 (Rd, Rn, Ra, Rm) = {
    __unconditional = true;
    if ~(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    __PostDecode();
    vector_crypto_sha3_eor3(a, d, m, n)
}

function vector_crypto_sha3_eor3_decode__1 (Rd, Rn, Ra, Rm, Op0) = {
    __unconditional = true;
    if ~(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    __PostDecode();
    vector_crypto_sha3_eor3(a, d, m, n)
}

val vector_crypto_sha3_bcax : forall 'a 'd 'm 'n,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & ('a >= 0 & 'a <= 31) & ('d >= 0 & 'd <= 31).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha3_bcax (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V(m);
    let Vn : bits(128) = V(n);
    let Va : bits(128) = V(a);
    V(d) = Vn ^ (Vm & ~(Va))
}

val vector_crypto_sha3_bcax_decode__0 : (bits(5), bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

val vector_crypto_sha3_bcax_decode__1 : (bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

overload vector_crypto_sha3_bcax_decode = {
  vector_crypto_sha3_bcax_decode__0,
  vector_crypto_sha3_bcax_decode__1
}

function vector_crypto_sha3_bcax_decode__0 (Rd, Rn, Ra, Rm, Op0) = {
    __unconditional = true;
    if ~(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    __PostDecode();
    vector_crypto_sha3_bcax(a, d, m, n)
}

function vector_crypto_sha3_bcax_decode__1 (Rd, Rn, Ra, Rm) = {
    __unconditional = true;
    if ~(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    __PostDecode();
    vector_crypto_sha3_bcax(a, d, m, n)
}

val vector_crypto_sha2op_sha256sched0 : forall 'd 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha2op_sha256sched0 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V(d);
    let operand2 : bits(128) = V(n);
    result : bits(128) = undefined : bits(128);
    let T : bits(128) = slice(operand2, 0, 32) @ slice(operand1, 32, 96);
    elt : bits(32) = undefined : bits(32);
    foreach (e from 0 to 3 by 1 in inc) {
        elt = aget_Elem(T, e, 32);
        elt = (ROR(elt, 7) ^ ROR(elt, 18)) ^ LSR(elt, 3);
        result = aset_Elem(result, e, 32, elt + aget_Elem(operand1, e, 32))
    };
    V(d) = result
}

val vector_crypto_sha2op_sha256sched0_decode : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha2op_sha256sched0_decode (Rd, Rn, opcode, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha2op_sha256sched0(d, n)
}

val vector_crypto_sha2op_sha1sched1 : forall 'd 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha2op_sha1sched1 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V(d);
    let operand2 : bits(128) = V(n);
    result : bits(128) = undefined : bits(128);
    let T : bits(128) = operand1 ^ LSR(operand2, 32);
    result = __SetSlice_bits(128, 32, result, 0, ROL(slice(T, 0, 32), 1));
    result = __SetSlice_bits(128, 32, result, 32, ROL(slice(T, 32, 32), 1));
    result = __SetSlice_bits(128, 32, result, 64, ROL(slice(T, 64, 32), 1));
    let result = __SetSlice_bits(128, 32, result, 96, ROL(slice(T, 96, 32), 1) ^ ROL(slice(T, 0, 32), 2));
    V(d) = result
}

val vector_crypto_sha2op_sha1sched1_decode : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha2op_sha1sched1_decode (Rd, Rn, opcode, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha2op_sha1sched1(d, n)
}

val vector_crypto_sha2op_sha1hash : forall 'd 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha2op_sha1hash (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand : bits(32) = V(n);
    V(d) = ROL(operand, 30)
}

val vector_crypto_sha2op_sha1hash_decode : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_sha2op_sha1hash_decode (Rd, Rn, opcode, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_crypto_sha2op_sha1hash(d, n)
}

val vector_crypto_aes_round : forall 'd ('decrypt : Bool) 'n,
  ('d >= 0 & 'd <= 31) & ('n >= 0 & 'n <= 31).
  (int('d), bool('decrypt), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_aes_round (d, decrypt, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V(d);
    let operand2 : bits(128) = V(n);
    result : bits(128) = undefined : bits(128);
    result = operand1 ^ operand2;
    if decrypt then {
        result = AESInvSubBytes(AESInvShiftRows(result))
    } else {
        result = AESSubBytes(AESShiftRows(result))
    };
    V(d) = result
}

val vector_crypto_aes_round_decode : (bits(5), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_aes_round_decode (Rd, Rn, D, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    let decrypt : bool = D == 0b1;
    __PostDecode();
    vector_crypto_aes_round(d, decrypt, n)
}

val vector_crypto_aes_mix : forall 'd ('decrypt : Bool) 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), bool('decrypt), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_aes_mix (d, decrypt, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand : bits(128) = V(n);
    result : bits(128) = undefined : bits(128);
    if decrypt then {
        result = AESInvMixColumns(operand)
    } else {
        result = AESMixColumns(operand)
    };
    V(d) = result
}

val vector_crypto_aes_mix_decode : (bits(5), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_crypto_aes_mix_decode (Rd, Rn, D, size) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HaveAESExt()) then {
        throw(Error_Undefined())
    };
    let decrypt : bool = D == 0b1;
    __PostDecode();
    vector_crypto_aes_mix(d, decrypt, n)
}

val CheckFPAdvSIMDEnabled64 : unit -> unit effect {escape, rreg, undef, wreg}

function CheckFPAdvSIMDEnabled64 () = {
    AArch64_CheckFPAdvSIMDEnabled()
}

val vector_transfer_vector_table : forall 'd 'datasize 'elements ('is_tbl : Bool) 'm 'n 'regs,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), bool('is_tbl), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_table (d, datasize, elements, is_tbl, m, n__arg, regs) = {
    n : range(0, 31) = n__arg;
    CheckFPAdvSIMDEnabled64();
    let indices : bits('datasize) = aget_V(m);
    table : bits(128 * 'regs) = Zeros();
    result : bits('datasize) = undefined : bits('datasize);
    index : int = undefined : int;
    foreach (i from 0 to (regs - 1) by 1 in inc) {
        table = __SetSlice_bits(128 * regs, 128, table, 128 * i, aget_V(n));
        n = (n + 1) % 32
    };
    result = if is_tbl then Zeros() else aget_V(d);
    foreach (i from 0 to (elements - 1) by 1 in inc) {
        assert(i >= 0 & (i + 1) * 8 <= datasize);
        let index = UInt(aget_Elem(indices, i, 8));
        if index < 16 * regs then {
            result = aset_Elem(result, i, 8, aget_Elem(table, index, 8))
        }
    };
    aset_V(d, result)
}

val vector_transfer_vector_table_decode : (bits(5), bits(5), bits(1), bits(2), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_table_decode (Rd, Rn, op, len, Rm, op2, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    let 'regs = UInt(len) + 1;
    let is_tbl : bool = op == 0b0;
    __PostDecode();
    vector_transfer_vector_table(d, datasize, elements, is_tbl, m, n, regs)
}

val vector_transfer_vector_permute_zip : forall 'd 'datasize 'esize 'm 'n 'pairs 'part,
  ('n >= 0 & 'n <= 31 & 'm >= 0 & 'm <= 31 & 'd >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('m), int('n), int('pairs), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_permute_zip (d, datasize, esize, m, n, pairs, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = aget_V(n);
    let operand2 : bits('datasize) = aget_V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let 'base : {'n, 'n == 'part * 'pairs. int('n)} = part * pairs;
    foreach (p from 0 to (pairs - 1) by 1 in inc) {
        assert(constraint(('base + 'loop_p >= 0 & 'esize >= 0 & ('base + 'loop_p + 1) * 'esize <= 'datasize)));
        result = aset_Elem(result, 2 * p + 0, esize, aget_Elem(operand1, base + p, esize));
        result = aset_Elem(result, 2 * p + 1, esize, aget_Elem(operand2, base + p, esize))
    };
    aset_V(d, result)
}

val vector_transfer_vector_permute_zip_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_permute_zip_decode (Rd, Rn, op, Rm, size, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'part = UInt(op);
    let 'pairs : {'n, 'n == div('elements, 2). int('n)} = elements / 2;
    __PostDecode();
    vector_transfer_vector_permute_zip(d, datasize, esize, m, n, pairs, part)
}

val vector_transfer_vector_permute_unzip : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('n >= 0 & 'n <= 31 & 'm >= 0 & 'm <= 31 & 'd >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_permute_unzip (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operandl : bits('datasize) = aget_V(n);
    let operandh : bits('datasize) = aget_V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let zipped : bits(2 * 'datasize) = operandh @ operandl;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((2 * 'loop_e + 'part >= 0 & 'esize >= 0 & (2 * 'loop_e + 'part + 1) * 'esize <= 2 * 'datasize)));
        result = aset_Elem(result, e, esize, aget_Elem(zipped, 2 * e + part, esize))
    };
    aset_V(d, result)
}

val vector_transfer_vector_permute_unzip_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_permute_unzip_decode (Rd, Rn, op, Rm, size, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'part = UInt(op);
    __PostDecode();
    vector_transfer_vector_permute_unzip(d, datasize, elements, esize, m, n, part)
}

val vector_transfer_vector_permute_transpose : forall 'd 'datasize 'esize 'm 'n 'pairs 'part,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('m), int('n), int('pairs), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_permute_transpose (d, datasize, esize, m, n, pairs, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    foreach (p from 0 to (pairs - 1) by 1 in inc) {
        assert(constraint((2 * 'loop_p + 'part >= 0 & 'esize >= 0 & (2 * 'loop_p + 'part + 1) * 'esize <= 'datasize)));
        result = aset_Elem(result, 2 * p + 0, esize, aget_Elem(operand1, 2 * p + part, esize));
        result = aset_Elem(result, 2 * p + 1, esize, aget_Elem(operand2, 2 * p + part, esize))
    };
    V(d) = result
}

val vector_transfer_vector_permute_transpose_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_permute_transpose_decode (Rd, Rn, op, Rm, size, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'part = UInt(op);
    let 'pairs : {'n, 'n == div('elements, 2). int('n)} = elements / 2;
    __PostDecode();
    vector_transfer_vector_permute_transpose(d, datasize, esize, m, n, pairs, part)
}

val vector_transfer_vector_insert : forall 'd 'dst_index 'esize 'idxdsize 'n 'src_index,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31) & ('src_index >= 0 & 'esize >= 0 & ('src_index + 1) * 'esize <= 'idxdsize).
  (int('d), int('dst_index), int('esize), int('idxdsize), int('n), int('src_index)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_insert (d, dst_index, esize, idxdsize, n, src_index) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V(n);
    result : bits(128) = undefined : bits(128);
    result = V(d);
    let result = aset_Elem(result, dst_index, esize, aget_Elem(operand, src_index, esize));
    V(d) = result
}

val vector_transfer_vector_insert_decode : (bits(5), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_insert_decode (Rd, Rn, imm4, imm5, op, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    let 'dst_index = UInt(slice(imm5, size + 1, negate(size) + 4));
    let 'src_index = UInt(slice(imm4, size, negate(size) + 4));
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if [imm4[3]] == 0b1 then 128 else 64;
    let 'esize = shl_int(8, size);
    assert(constraint(('_src_index >= 0 & '_esize >= 0 & ('_src_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_transfer_vector_insert(d, dst_index, esize, idxdsize, n, src_index)
}

val vector_transfer_vector_extract : forall 'd 'datasize 'm 'n 'position,
  ('m >= 0 & 'm <= 31) & ('n >= 0 & 'n <= 31) & (2 * 'datasize >= 0 & 'datasize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), int('position)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_extract (d, datasize, m, n, position) = {
    CheckFPAdvSIMDEnabled64();
    let hi : bits('datasize) = V(m);
    let lo : bits('datasize) = V(n);
    let concat : bits(2 * 'datasize) = hi @ lo;
    V(d) = slice(concat, position, datasize)
}

val vector_transfer_vector_extract_decode : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_extract_decode (Rd, Rn, imm4, Rm, op2, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if Q == 0b0 & [imm4[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'position = shl_int(UInt(imm4), 3);
    __PostDecode();
    vector_transfer_vector_extract(d, datasize, m, n, position)
}

val vector_transfer_vector_cpydup_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'n,
  ('n >= 0 & 'n <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & 'datasize >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_cpydup_sisd (d, datasize, elements, esize, idxdsize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let element : bits('esize) = aget_Elem(operand, index, esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = aset_Elem(result, e, esize, element)
    };
    V(d) = result
}

val vector_transfer_vector_cpydup_sisd_decode : (bits(5), bits(5), bits(4), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_cpydup_sisd_decode (Rd, Rn, imm4, imm5, op) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    let 'index = UInt(slice(imm5, size + 1, negate(size) + 4));
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if [imm5[4]] == 0b1 then 128 else 64;
    let 'esize = shl_int(8, size);
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint('_datasize >= 0));
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_transfer_vector_cpydup_sisd(d, datasize, elements, esize, idxdsize, index, n)
}

val vector_transfer_vector_cpydup_simd_decode : (bits(5), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_vector_cpydup_simd_decode (Rd, Rn, imm4, imm5, op, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    let 'index = UInt(slice(imm5, size + 1, negate(size) + 4));
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if [imm5[4]] == 0b1 then 128 else 64;
    if size == 3 & Q == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, size);
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint('_datasize >= 0));
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_transfer_vector_cpydup_sisd(d, datasize, elements, esize, idxdsize, index, n)
}

val vector_transfer_integer_move_unsigned : forall 'd 'datasize 'esize 'idxdsize 'index 'n,
  ('n >= 0 & 'n <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('idxdsize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_move_unsigned (d, datasize, esize, idxdsize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V(n);
    X(d) = ZeroExtend(aget_Elem(operand, index, esize), datasize)
}

val vector_transfer_integer_move_unsigned_decode : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_move_unsigned_decode (Rd, Rn, imm4_0_, imm4_1_, imm4_3_2_, imm5, op, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    size : int = undefined : int;
    match Q @ imm5 {
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ [bitone] => {
          size = 0
      },
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ [bitone] @ [bitzero] => {
          size = 1
      },
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitone] @ [bitzero] @ [bitzero] => {
          size = 2
      },
      [bitone] @ _ : bits(1) @ [bitone] @ [bitzero] @ [bitzero] @ [bitzero] => {
          size = 3
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    assert(constraint('size in {0, 1, 2, 3}));
    let 'idxdsize : {|128, 64|} = if [imm5[4]] == 0b1 then 128 else 64;
    let 'index = UInt(slice(imm5, size + 1, negate(size) + 4));
    let 'esize = shl_int(8, size);
    let 'datasize : {|64, 32|} = if Q == 0b1 then 64 else 32;
    __PostDecode();
    assert((index + 1) * esize <= idxdsize);
    vector_transfer_integer_move_unsigned(d, datasize, esize, idxdsize, index, n)
}

val vector_transfer_integer_move_signed : forall 'd 'datasize 'esize 'idxdsize 'index 'n,
  ('n >= 0 & 'n <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('idxdsize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_move_signed (d, datasize, esize, idxdsize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V(n);
    X(d) = SignExtend(aget_Elem(operand, index, esize), datasize)
}

val vector_transfer_integer_move_signed_decode : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_move_signed_decode (Rd, Rn, imm4_0_, imm4_1_, imm4_3_2_, imm5, op, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    size : int = undefined : int;
    match Q @ imm5 {
      _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ [bitone] => {
          size = 0
      },
      _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) @ [bitone] @ [bitzero] => {
          size = 1
      },
      [bitone] @ _ : bits(1) @ _ : bits(1) @ [bitone] @ [bitzero] @ [bitzero] => {
          size = 2
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    assert(constraint('size in {0, 1, 2}));
    let 'idxdsize : {|128, 64|} = if [imm5[4]] == 0b1 then 128 else 64;
    let 'index = UInt(slice(imm5, size + 1, negate(size) + 4));
    let 'esize = shl_int(8, size);
    let 'datasize : {|64, 32|} = if Q == 0b1 then 64 else 32;
    __PostDecode();
    assert((index + 1) * esize <= idxdsize);
    vector_transfer_integer_move_signed(d, datasize, esize, idxdsize, index, n)
}

val vector_transfer_integer_insert : forall 'd 'datasize 'esize 'index 'n,
  ('n >= 0 & 'n <= 31 & 'esize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31) & 'datasize >= 0.
  (int('d), int('datasize), int('esize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_insert (d, datasize, esize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let element : bits('esize) = X(n);
    result : bits('datasize) = undefined : bits('datasize);
    result = V(d);
    let result = aset_Elem(result, index, esize, element);
    V(d) = result
}

val vector_transfer_integer_insert_decode : (bits(5), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_insert_decode (Rd, Rn, imm4, imm5, op, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    let 'index = UInt(slice(imm5, size + 1, negate(size) + 4));
    let 'esize = shl_int(8, size);
    let 'datasize : {'n, 'n == 128. int('n)} = 128;
    assert(constraint('_datasize >= 0));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_esize in {8, 16, 32, 64})));
    __PostDecode();
    vector_transfer_integer_insert(d, datasize, esize, index, n)
}

val vector_transfer_integer_dup : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31 & 'esize in {8, 16, 32, 64}) & 'datasize >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_dup (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let element : bits('esize) = X(n);
    result : bits('datasize) = undefined : bits('datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = aset_Elem(result, e, esize, element)
    };
    V(d) = result
}

val vector_transfer_integer_dup_decode : (bits(5), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_transfer_integer_dup_decode (Rd, Rn, imm4, imm5, op, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    };
    if size == 3 & Q == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, size);
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint('_datasize >= 0));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_esize in {8, 16, 32, 64})));
    __PostDecode();
    vector_transfer_integer_dup(d, datasize, elements, esize, n)
}

val vector_shift_right_sisd : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize 'n ('round : Bool) 'shift ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('n), bool('round), int('shift), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_right_sisd (accumulate, d, datasize, elements, esize, n, round, shift, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = aget_V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let 'round_const = if round then shl_int(1, shift - 1) else 0;
    element : int = undefined : int;
    let operand2 : bits('datasize) = if accumulate then aget_V(d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = shr_int(asl_Int(aget_Elem(operand, e, esize), unsigned) + round_const, shift);
        result = aset_Elem(result, e, esize, aget_Elem(operand2, e, esize) + __GetSlice_int(esize, element, 0))
    };
    aset_V(d, result)
}

val vector_shift_right_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_right_sisd_decode (Rd, Rn, o0, o1, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, 3);
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    __PostDecode();
    vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, unsigned)
}

val vector_shift_right_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_right_simd_decode (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    __PostDecode();
    vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, unsigned)
}

val vector_shift_rightnarrow_uniform_sisd : forall 'd 'datasize 'elements 'esize 'n 'part ('round : Bool) 'shift ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_uniform_sisd (d, datasize, elements, esize, n, part, round, shift, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let 'round_const = if round then shl_int(1, shift - 1) else 0;
    element : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element = shr_int(asl_Int(aget_Elem(operand, e, 2 * esize), unsigned) + round_const, shift);
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SatQ(element, esize, unsigned);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    Vpart(d, part) = result
}

val vector_shift_rightnarrow_uniform_sisd_decode : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_uniform_sisd_decode (Rd, Rn, op, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_shift_rightnarrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, unsigned)
}

val vector_shift_rightnarrow_uniform_simd_decode : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_uniform_simd_decode (Rd, Rn, op, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_shift_rightnarrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, unsigned)
}

val vector_shift_rightnarrow_nonuniform_sisd : forall 'd 'datasize 'elements 'esize 'n 'part ('round : Bool) 'shift,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_nonuniform_sisd (d, datasize, elements, esize, n, part, round, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let 'round_const = if round then shl_int(1, shift - 1) else 0;
    element : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element = shr_int(SInt(aget_Elem(operand, e, 2 * esize)) + round_const, shift);
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = UnsignedSatQ(element, esize);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    Vpart(d, part) = result
}

val vector_shift_rightnarrow_nonuniform_sisd_decode : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_nonuniform_sisd_decode (Rd, Rn, op, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_Undefined())
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    __PostDecode();
    vector_shift_rightnarrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

val vector_shift_rightnarrow_nonuniform_simd_decode : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_nonuniform_simd_decode (Rd, Rn, op, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    __PostDecode();
    vector_shift_rightnarrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

val vector_shift_rightnarrow_logical : forall 'd 'datasize 'elements 'esize 'n 'part ('round : Bool) 'shift,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_logical (d, datasize, elements, esize, n, part, round, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let 'round_const = if round then shl_int(1, shift - 1) else 0;
    element : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element = shr_int(UInt(aget_Elem(operand, e, 2 * esize)) + round_const, shift);
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, element, 0))
    };
    Vpart(d, part) = result
}

val vector_shift_rightnarrow_logical_decode : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightnarrow_logical_decode (Rd, Rn, op, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    __PostDecode();
    vector_shift_rightnarrow_logical(d, datasize, elements, esize, n, part, round, shift)
}

val vector_shift_rightinsert_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31) & ('shift >= 0 & 'esize >= 0).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightinsert_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    let mask : bits('esize) = LSR(Ones(esize), shift);
    shifted : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        shifted = LSR(aget_Elem(operand, e, esize), shift);
        result = aset_Elem(result, e, esize, aget_Elem(operand2, e, esize) & ~(mask) | shifted)
    };
    V(d) = result
}

val vector_shift_rightinsert_sisd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightinsert_sisd_decode (Rd, Rn, opcode, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, 3);
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    assert(constraint(('_esize * 2 - '_shift >= 0 & '_esize >= 0)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_rightinsert_sisd(d, datasize, elements, esize, n, shift)
}

val vector_shift_rightinsert_simd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_rightinsert_simd_decode (Rd, Rn, opcode, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = esize * 2 - UInt(immh @ immb);
    assert(constraint(('_esize * 2 - '_shift >= 0 & '_esize >= 0)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_rightinsert_sisd(d, datasize, elements, esize, n, shift)
}

val vector_shift_left_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  ('n >= 0 & 'n <= 31) & ('shift >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_left_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        result = aset_Elem(result, e, esize, LSL(aget_Elem(operand, e, esize), shift))
    };
    V(d) = result
}

val vector_shift_left_sisd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_left_sisd_decode (Rd, Rn, opcode, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, 3);
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'shift = UInt(immh @ immb) - esize;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_shift - '_esize >= 0 & '_esize >= 0)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_left_sisd(d, datasize, elements, esize, n, shift)
}

val vector_shift_left_simd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_left_simd_decode (Rd, Rn, opcode, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = UInt(immh @ immb) - esize;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_shift - '_esize >= 0 & '_esize >= 0)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_left_sisd(d, datasize, elements, esize, n, shift)
}

val vector_shift_leftsat_sisd : forall 'd 'datasize ('dst_unsigned : Bool) 'elements 'esize 'n 'shift ('src_unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), bool('dst_unsigned), int('elements), int('esize), int('n), int('shift), bool('src_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftsat_sisd (d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = shl_int(asl_Int(aget_Elem(operand, e, esize), src_unsigned), shift);
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SatQ(element, esize, dst_unsigned);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_shift_leftsat_sisd_decode : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftsat_sisd_decode (Rd, Rn, op, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined : bool;
    dst_unsigned : bool = undefined : bool;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    __PostDecode();
    vector_shift_leftsat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

val vector_shift_leftsat_simd_decode : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftsat_simd_decode (Rd, Rn, op, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined : bool;
    dst_unsigned : bool = undefined : bool;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    __PostDecode();
    vector_shift_leftsat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

val vector_shift_leftlong : forall 'd 'datasize 'elements 'esize 'n 'part 'shift ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), int('shift), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftlong (d, datasize, elements, esize, n, part, shift, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart(n, part);
    result : bits(2 * 'datasize) = undefined : bits('datasize * 2);
    element : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = shl_int(asl_Int(aget_Elem(operand, e, esize), unsigned), shift);
        result = aset_Elem(result, e, 2 * esize, __GetSlice_int(2 * esize, element, 0))
    };
    V(d) = result
}

val vector_shift_leftlong_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftlong_decode (Rd, Rn, opcode, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = UInt(immh @ immb) - esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_shift_leftlong(d, datasize, elements, esize, n, part, shift, unsigned)
}

val vector_shift_leftinsert_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31) & ('shift >= 0 & 'esize >= 0).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftinsert_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    let mask : bits('esize) = LSL(Ones(esize), shift);
    shifted : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        shifted = LSL(aget_Elem(operand, e, esize), shift);
        result = aset_Elem(result, e, esize, aget_Elem(operand2, e, esize) & ~(mask) | shifted)
    };
    V(d) = result
}

val vector_shift_leftinsert_sisd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftinsert_sisd_decode (Rd, Rn, opcode, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, 3);
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'shift = UInt(immh @ immb) - esize;
    assert(constraint(('_shift - '_esize >= 0 & '_esize >= 0)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_leftinsert_sisd(d, datasize, elements, esize, n, shift)
}

val vector_shift_leftinsert_simd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_leftinsert_simd_decode (Rd, Rn, opcode, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, HighestSetBit(immh));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift = UInt(immh @ immb) - esize;
    assert(constraint(('_shift - '_esize >= 0 & '_esize >= 0)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_leftinsert_sisd(d, datasize, elements, esize, n, shift)
}

val vector_shift_conv_int_sisd : forall 'd 'datasize 'elements 'esize 'fracbits 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('fracbits), int('n), FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_conv_int_sisd (d, datasize, elements, esize, fracbits, n, rounding, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FixedToFP(element, fracbits, unsigned, FPCR, rounding))
    };
    V(d) = result
}

val vector_shift_conv_int_sisd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_conv_int_sisd_decode (Rd, Rn, opcode, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (immh & 0xE) == 0x0 | (immh & 0xE) == 0x2 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n in {64, 32, 16}. int('n)} = if (immh & 0x8) == 0x8 then 64 else if (immh & 0xC) == 0x4 then 32 else 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR);
    __PostDecode();
    vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, unsigned)
}

val vector_shift_conv_int_simd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_conv_int_simd_decode (Rd, Rn, opcode, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if (immh & 0xE) == 0x0 | (immh & 0xE) == 0x2 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n in {64, 32, 16}. int('n)} = if (immh & 0x8) == 0x8 then 64 else if (immh & 0xC) == 0x4 then 32 else 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR);
    __PostDecode();
    vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, unsigned)
}

val vector_shift_conv_float_sisd : forall 'd 'datasize 'elements 'esize 'fracbits 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('esize >= 0 & 'fracbits >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('fracbits), int('n), FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_conv_float_sisd (d, datasize, elements, esize, fracbits, n, rounding, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPToFixed(element, fracbits, unsigned, FPCR, rounding))
    };
    V(d) = result
}

val vector_shift_conv_float_sisd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_conv_float_sisd_decode (Rd, Rn, opcode, immb, immh, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (immh & 0xE) == 0x0 | (immh & 0xE) == 0x2 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n in {64, 32, 16}. int('n)} = if (immh & 0x8) == 0x8 then 64 else if (immh & 0xC) == 0x4 then 32 else 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_esize >= 0 & '_esize * 2 - '_fracbits >= 0)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, unsigned)
}

val vector_shift_conv_float_simd_decode : (bits(5), bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_shift_conv_float_simd_decode (Rd, Rn, opcode, immb, immh, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0x0 then {
        throw(Error_See("asimdimm"))
    };
    if (immh & 0xE) == 0x0 | (immh & 0xE) == 0x2 & ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n in {64, 32, 16}. int('n)} = if (immh & 0x8) == 0x8 then 64 else if (immh & 0xC) == 0x4 then 32 else 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_esize >= 0 & '_esize * 2 - '_fracbits >= 0)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, unsigned)
}

val vector_reduce_intmax : forall 'd 'datasize 'elements 'esize ('min : Bool) 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('esize >= 0 & 'esize <= 'datasize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), bool('min), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_intmax (d, datasize, elements, esize, min, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    maxmin : int = undefined : int;
    element : int = undefined : int;
    maxmin = asl_Int(aget_Elem(operand, 0, esize), unsigned);
    foreach (e from 1 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = asl_Int(aget_Elem(operand, e, esize), unsigned);
        maxmin = if min then min(maxmin, element) else max(maxmin, element)
    };
    V(d) = __GetSlice_int(esize, maxmin, 0)
}

val vector_reduce_intmax_decode : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_intmax_decode (Rd, Rn, op, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    __PostDecode();
    vector_reduce_intmax(d, datasize, elements, esize, min, n, unsigned)
}

val vector_reduce_fp16maxnm_sisd : forall 'd 'datasize 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('esize >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16maxnm_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    V(d) = Reduce(op, operand, esize)
}

val vector_reduce_fp16maxnm_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16maxnm_sisd_decode (Rd, Rn, opcode, sz, o1, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize : {'n, 'n == 'esize * 2. int('n)} = esize * 2;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    __PostDecode();
    vector_reduce_fp16maxnm_sisd(d, datasize, esize, n, op)
}

val vector_reduce_fpmaxnm_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fpmaxnm_sisd_decode (Rd, Rn, opcode, sz, o1, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize * 2. int('n)} = esize * 2;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    __PostDecode();
    vector_reduce_fp16maxnm_sisd(d, datasize, esize, n, op)
}

val vector_reduce_fp16maxnm_simd : forall 'd 'datasize 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('esize >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16maxnm_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    V(d) = Reduce(op, operand, esize)
}

val vector_reduce_fp16maxnm_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16maxnm_simd_decode (Rd, Rn, opcode, o1, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    __PostDecode();
    vector_reduce_fp16maxnm_simd(d, datasize, esize, n, op)
}

val vector_reduce_fpmaxnm_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fpmaxnm_simd_decode (Rd, Rn, opcode, sz, o1, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    __PostDecode();
    vector_reduce_fp16maxnm_simd(d, datasize, esize, n, op)
}

val vector_reduce_fp16max_sisd : forall 'd 'datasize 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('esize >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16max_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    V(d) = Reduce(op, operand, esize)
}

val vector_reduce_fp16max_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16max_sisd_decode (Rd, Rn, opcode, sz, o1, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize : {'n, 'n == 'esize * 2. int('n)} = esize * 2;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    __PostDecode();
    vector_reduce_fp16max_sisd(d, datasize, esize, n, op)
}

val vector_reduce_fpmax_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fpmax_sisd_decode (Rd, Rn, opcode, sz, o1, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize * 2. int('n)} = esize * 2;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    __PostDecode();
    vector_reduce_fp16max_sisd(d, datasize, esize, n, op)
}

val vector_reduce_fp16max_simd : forall 'd 'datasize 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('esize >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16max_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    V(d) = Reduce(op, operand, esize)
}

val vector_reduce_fp16max_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16max_simd_decode (Rd, Rn, opcode, o1, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    __PostDecode();
    vector_reduce_fp16max_simd(d, datasize, esize, n, op)
}

val vector_reduce_fpmax_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fpmax_simd_decode (Rd, Rn, opcode, sz, o1, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    __PostDecode();
    vector_reduce_fp16max_simd(d, datasize, esize, n, op)
}

val vector_reduce_fp16add_sisd : forall 'd 'datasize 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('esize >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16add_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    V(d) = Reduce(op, operand, esize)
}

val vector_reduce_fp16add_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fp16add_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'datasize : {'n, 'n == 'esize * 2. int('n)} = esize * 2;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let op : ReduceOp = ReduceOp_FADD;
    __PostDecode();
    vector_reduce_fp16add_sisd(d, datasize, esize, n, op)
}

val vector_reduce_fpadd_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_fpadd_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize * 2. int('n)} = esize * 2;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let op : ReduceOp = ReduceOp_FADD;
    __PostDecode();
    vector_reduce_fp16add_sisd(d, datasize, esize, n, op)
}

val vector_reduce_add_sisd : forall 'd 'datasize 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('esize >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_add_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    V(d) = Reduce(op, operand, esize)
}

val vector_reduce_add_sisd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_add_sisd_decode (Rd, Rn, opcode, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize * 2. int('n)} = esize * 2;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let op : ReduceOp = ReduceOp_ADD;
    __PostDecode();
    vector_reduce_add_sisd(d, datasize, esize, n, op)
}

val vector_reduce_add_simd : forall 'd 'datasize 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('esize >= 0 & 'esize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_add_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    V(d) = Reduce(op, operand, esize)
}

val vector_reduce_add_simd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_add_simd_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let op : ReduceOp = ReduceOp_ADD;
    __PostDecode();
    vector_reduce_add_simd(d, datasize, esize, n, op)
}

val vector_reduce_addlong : forall 'd 'datasize 'elements 'esize 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('esize >= 0 & 'esize <= 'datasize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_addlong (d, datasize, elements, esize, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    sum : int = undefined : int;
    sum = asl_Int(aget_Elem(operand, 0, esize), unsigned);
    foreach (e from 1 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        sum = sum + asl_Int(aget_Elem(operand, e, esize), unsigned)
    };
    V(d) = __GetSlice_int(2 * esize, sum, 0)
}

val vector_reduce_addlong_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_reduce_addlong_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_reduce_addlong(d, datasize, elements, esize, n, unsigned)
}

val vector_logical : forall 'datasize 'rd,
  'datasize >= 0 & ('rd >= 0 & 'rd <= 31).
  (int('datasize), bits('datasize), ImmediateOp, int('rd)) -> unit effect {escape, rreg, undef, wreg}

function vector_logical (datasize, imm, operation, rd) = {
    CheckFPAdvSIMDEnabled64();
    operand : bits('datasize) = undefined : bits('datasize);
    result : bits('datasize) = undefined : bits('datasize);
    match operation {
      ImmediateOp_MOVI => {
          result = imm
      },
      ImmediateOp_MVNI => {
          result = ~(imm)
      },
      ImmediateOp_ORR => {
          operand = V(rd);
          result = operand | imm
      },
      ImmediateOp_BIC => {
          operand = V(rd);
          result = operand & ~(imm)
      }
    };
    let result = result;
    V(rd) = result
}

val vector_logical_decode : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_logical_decode (Rd, h, g, f, e, d, o2, cmode, c, b, a, op, Q) = {
    __unconditional = true;
    let 'rd = UInt(Rd);
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    imm : bits('datasize) = undefined : bits('datasize);
    imm64 : bits(64) = undefined : bits(64);
    operation : ImmediateOp = undefined : ImmediateOp;
    match cmode @ op {
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitzero] @ [bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitone] @ [bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitone] @ [bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone] @ [bitzero] @ _ : bits(1) @ [bitzero] @ [bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone] @ [bitzero] @ _ : bits(1) @ [bitzero] @ [bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone] @ [bitzero] @ _ : bits(1) @ [bitone] @ [bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone] @ [bitzero] @ _ : bits(1) @ [bitone] @ [bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) @ [bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) @ [bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          };
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm = replicate_bits(imm64, datasize / 64);
    __PostDecode();
    vector_logical(datasize, imm, operation, rd)
}

val vector_fp16_movi : forall 'datasize 'rd,
  'datasize >= 0 & ('rd >= 0 & 'rd <= 31).
  (int('datasize), bits('datasize), int('rd)) -> unit effect {escape, rreg, undef, wreg}

function vector_fp16_movi (datasize, imm, rd) = {
    CheckFPAdvSIMDEnabled64();
    V(rd) = imm
}

val vector_fp16_movi_decode : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_fp16_movi_decode (Rd, h, g, f, e, d, o2, cmode, c, b, a, op, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'rd = UInt(Rd);
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    imm : bits('datasize) = undefined : bits('datasize);
    let imm8 : vector(1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, dec, bit) = ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h;
    let imm16 : bits(16) = ((([imm8[7]] @ ~([imm8[6]])) @ replicate_bits([imm8[6]], 2)) @ slice(imm8, 0, 6)) @ Zeros(6);
    let imm = replicate_bits(imm16, datasize / 16);
    __PostDecode();
    vector_fp16_movi(datasize, imm, rd)
}

val vector_arithmetic_unary_special_sqrtfp16 : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtfp16 (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPSqrt(element, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_unary_special_sqrt_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrt_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_sqrtfp16(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_sqrtfp16_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtfp16_decode (Rd, Rn, opcode, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_sqrtfp16(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_sqrtest_int : forall 'd 'datasize 'elements 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtest_int (d, datasize, elements, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits(32) = undefined : bits(32);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 32 <= 'datasize)));
        element = aget_Elem(operand, e, 32);
        result = aset_Elem(result, e, 32, UnsignedRSqrtEstimate(element))
    };
    V(d) = result
}

val vector_arithmetic_unary_special_sqrtest_int_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtest_int_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_sqrtest_int(d, datasize, elements, n)
}

val vector_arithmetic_unary_special_sqrtest_fp16_sisd : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtest_fp16_sisd (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPRSqrtEstimate(element, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_unary_special_sqrtest_fp16_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtest_fp16_sisd_decode (Rd, Rn, opcode, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_unary_special_sqrtest_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_sqrtest_fp16_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtest_fp16_simd_decode (Rd, Rn, opcode, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_sqrtest_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_sqrtest_float_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtest_float_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_unary_special_sqrtest_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_sqrtest_float_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_sqrtest_float_simd_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_sqrtest_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_recip_int : forall 'd 'datasize 'elements 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_recip_int (d, datasize, elements, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits(32) = undefined : bits(32);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 32 <= 'datasize)));
        element = aget_Elem(operand, e, 32);
        result = aset_Elem(result, e, 32, UnsignedRecipEstimate(element))
    };
    V(d) = result
}

val vector_arithmetic_unary_special_recip_int_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_recip_int_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_recip_int(d, datasize, elements, n)
}

val vector_arithmetic_unary_special_recip_fp16_sisd : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_recip_fp16_sisd (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPRecipEstimate(element, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_unary_special_recip_fp16_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_recip_fp16_sisd_decode (Rd, Rn, opcode, size_1_, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_recip_fp16_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_recip_fp16_simd_decode (Rd, Rn, opcode, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_recip_float_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_recip_float_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_recip_float_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_recip_float_simd_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_frecpxfp16 : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_frecpxfp16 (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPRecpX(element, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_unary_special_frecpx_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_frecpx_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_unary_special_frecpxfp16(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_special_frecpxfp16_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_special_frecpxfp16_decode (Rd, Rn, opcode, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_unary_special_frecpxfp16(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_shift : forall 'd 'datasize 'elements 'esize 'n 'part 'shift ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), int('shift), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_shift (d, datasize, elements, esize, n, part, shift, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart(n, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = shl_int(asl_Int(aget_Elem(operand, e, esize), unsigned), shift);
        result = aset_Elem(result, e, 2 * esize, __GetSlice_int(2 * esize, element, 0))
    };
    V(d) = result
}

val vector_arithmetic_unary_shift_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_shift_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'shift : {'n, 'n == 'esize. int('n)} = esize;
    let unsigned : bool(false) = false;
    __PostDecode();
    vector_arithmetic_unary_shift(d, datasize, elements, esize, n, part, shift, unsigned)
}

val vector_arithmetic_unary_rev : forall 'containers 'd 'datasize 'elements_per_container 'esize 'n,
  ('n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31).
  (int('containers), int('d), int('datasize), int('elements_per_container), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_rev (containers, d, datasize, elements_per_container, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = aget_V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : int = 0;
    rev_element : int = undefined : int;
    foreach (c from 0 to (containers - 1) by 1 in inc) {
        rev_element = element + elements_per_container - 1;
        foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
            let 're = rev_element;
            let 'e = element;
            assert(constraint(('e >= 0 & 'esize >= 0 & ('e + 1) * 'esize <= 'datasize)));
            result = aset_Elem(result, re, esize, aget_Elem(operand, e, esize));
            element = element + 1;
            rev_element = rev_element - 1
        }
    };
    aset_V(d, result)
}

val vector_arithmetic_unary_rev_decode : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_rev_decode (Rd, Rn, o0, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {|128, 64|} = if Q == 0b1 then 128 else 64;
    let op : vector(1 + 1, dec, bit) = o0 @ U;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    };
    container_size : int = undefined : int;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      }
    };
    let 'container_size = container_size;
    assert(constraint('container_size in {16, 32, 64}));
    let 'containers : {'n, 'n == div('datasize, 'container_size). int('n)} = datasize / container_size;
    let 'elements_per_container : {'n, 'n == div('container_size, 'esize). int('n)} = container_size / esize;
    __PostDecode();
    vector_arithmetic_unary_rev(containers, d, datasize, elements_per_container, esize, n)
}

val vector_arithmetic_unary_rbit : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_rbit (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    rev : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        foreach (i from 0 to (esize - 1) by 1 in inc) {
            rev = __SetSlice_bits(esize, 1, rev, esize - 1 - i, [element[i]])
        };
        result = aset_Elem(result, e, esize, rev)
    };
    V(d) = result
}

val vector_arithmetic_unary_rbit_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_rbit_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 8. int('n)} = 8;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    __PostDecode();
    vector_arithmetic_unary_rbit(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_not : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_not (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, ~(element))
    };
    V(d) = result
}

val vector_arithmetic_unary_not_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_not_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 8. int('n)} = 8;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    __PostDecode();
    vector_arithmetic_unary_not(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_fp16_round : forall 'd 'datasize 'elements 'esize ('exact : Bool) 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), bool('exact), int('n), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_round (d, datasize, elements, esize, exact, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPRoundInt(element, FPCR, rounding, exact))
    };
    V(d) = result
}

val vector_arithmetic_unary_fp16_round_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_round_decode (Rd, Rn, o1, o2, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    exact : bool = false;
    rounding : FPRounding = undefined : FPRounding;
    match (U @ o1) @ o2 {
      [bitzero] @ _ : bits(1) @ _ : bits(1) => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    __PostDecode();
    vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

val vector_arithmetic_unary_float_round_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_round_decode (Rd, Rn, o1, sz, o2, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    exact : bool = false;
    rounding : FPRounding = undefined : FPRounding;
    match (U @ o1) @ o2 {
      [bitzero] @ _ : bits(1) @ _ : bits(1) => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    __PostDecode();
    vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

val vector_arithmetic_unary_fp16_conv_int_sisd : forall 'd 'datasize 'elements 'esize 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_int_sisd (d, datasize, elements, esize, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let rounding : FPRounding = FPRoundingMode(FPCR);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FixedToFP(element, 0, unsigned, FPCR, rounding))
    };
    V(d) = result
}

val vector_arithmetic_unary_fp16_conv_int_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_int_sisd_decode (Rd, Rn, opcode, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, unsigned)
}

val vector_arithmetic_unary_fp16_conv_int_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_int_simd_decode (Rd, Rn, opcode, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, unsigned)
}

val vector_arithmetic_unary_float_conv_int_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_conv_int_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, unsigned)
}

val vector_arithmetic_unary_float_conv_int_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_conv_int_simd_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, unsigned)
}

val vector_arithmetic_unary_fp16_conv_float_tieaway_sisd : forall 'd 'datasize 'elements 'esize 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (d, datasize, elements, esize, n, rounding, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPToFixed(element, 0, unsigned, FPCR, rounding))
    };
    V(d) = result
}

val vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_decode (Rd, Rn, opcode, size_1_, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_fp16_conv_float_tieaway_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_float_tieaway_simd_decode (Rd, Rn, opcode, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_float_conv_float_tieaway_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_conv_float_tieaway_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_float_conv_float_tieaway_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_conv_float_tieaway_simd_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_fp16_conv_float_bulk_sisd : forall 'd 'datasize 'elements 'esize 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_float_bulk_sisd (d, datasize, elements, esize, n, rounding, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPToFixed(element, 0, unsigned, FPCR, rounding))
    };
    V(d) = result
}

val vector_arithmetic_unary_fp16_conv_float_bulk_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_float_bulk_sisd_decode (Rd, Rn, o1, o2, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_fp16_conv_float_bulk_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_fp16_conv_float_bulk_simd_decode (Rd, Rn, o1, o2, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_float_conv_float_bulk_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_conv_float_bulk_sisd_decode (Rd, Rn, o1, sz, o2, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_float_conv_float_bulk_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_conv_float_bulk_simd_decode (Rd, Rn, o1, sz, o2, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, unsigned)
}

val vector_arithmetic_unary_float_xtn_sisd : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_xtn_sisd (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        result = aset_Elem(result, e, esize, FPConvert(aget_Elem(operand, e, 2 * esize), FPCR, FPRounding_ODD))
    };
    Vpart(d, part) = result
}

val vector_arithmetic_unary_float_xtn_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_xtn_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    __PostDecode();
    vector_arithmetic_unary_float_xtn_sisd(d, datasize, elements, esize, n, part)
}

val vector_arithmetic_unary_float_xtn_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_xtn_simd_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b0 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'elements : {'n, 'n == 2. int('n)} = 2;
    let 'part = UInt(Q);
    __PostDecode();
    vector_arithmetic_unary_float_xtn_sisd(d, datasize, elements, esize, n, part)
}

val vector_arithmetic_unary_float_widen : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_widen (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart(n, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        result = aset_Elem(result, e, 2 * esize, FPConvert(aget_Elem(operand, e, esize), FPCR))
    };
    V(d) = result
}

val vector_arithmetic_unary_float_widen_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_widen_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(16, UInt(sz));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_float_widen(d, datasize, elements, esize, n, part)
}

val vector_arithmetic_unary_float_round_frint_32_64 : forall 'd 'datasize 'elements 'esize 'intsize 'n,
  ('n >= 0 & 'n <= 31) & ('esize >= 0 & 'intsize in {32, 64}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('intsize), int('n), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_round_frint_32_64 (d, datasize, elements, esize, intsize, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        result = aset_Elem(result, e, esize, FPRoundIntN(element, FPCR, rounding, intsize))
    };
    V(d) = result
}

val vector_arithmetic_unary_float_round_frint_32_64_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_round_frint_32_64_decode (Rd, Rn, op, sz, U, Q) = {
    __unconditional = true;
    if ~(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let 'intsize : {'n, 'n in {32, 64}. int('n)} = if op == 0b0 then 32 else 64;
    let rounding : FPRounding = if U == 0b0 then FPRounding_ZERO else FPRoundingMode(FPCR);
    __PostDecode();
    vector_arithmetic_unary_float_round_frint_32_64(d, datasize, elements, esize, intsize, n, rounding)
}

val vector_arithmetic_unary_float_narrow : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_narrow (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        result = aset_Elem(result, e, esize, FPConvert(aget_Elem(operand, e, 2 * esize), FPCR))
    };
    Vpart(d, part) = result
}

val vector_arithmetic_unary_float_narrow_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_float_narrow_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(16, UInt(sz));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_float_narrow(d, datasize, elements, esize, n, part)
}

val vector_arithmetic_unary_extract_sqxtun_sisd : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_sqxtun_sisd (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element = aget_Elem(operand, e, 2 * esize);
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = UnsignedSatQ(SInt(element), esize);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    Vpart(d, part) = result
}

val vector_arithmetic_unary_extract_sqxtun_sisd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_sqxtun_sisd_decode (Rd, Rn, opcode, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_unary_extract_sqxtun_sisd(d, datasize, elements, esize, n, part)
}

val vector_arithmetic_unary_extract_sqxtun_simd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_sqxtun_simd_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_extract_sqxtun_sisd(d, datasize, elements, esize, n, part)
}

val vector_arithmetic_unary_extract_sat_sisd : forall 'd 'datasize 'elements 'esize 'n 'part ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_sat_sisd (d, datasize, elements, esize, n, part, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element = aget_Elem(operand, e, 2 * esize);
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SatQ(asl_Int(element, unsigned), esize, unsigned);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    Vpart(d, part) = result
}

val vector_arithmetic_unary_extract_sat_sisd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_sat_sisd_decode (Rd, Rn, opcode, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, unsigned)
}

val vector_arithmetic_unary_extract_sat_simd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_sat_simd_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, unsigned)
}

val vector_arithmetic_unary_extract_nosat : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_nosat (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element = aget_Elem(operand, e, 2 * esize);
        result = aset_Elem(result, e, esize, slice(element, 0, esize))
    };
    Vpart(d, part) = result
}

val vector_arithmetic_unary_extract_nosat_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_extract_nosat_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_unary_extract_nosat(d, datasize, elements, esize, n, part)
}

val vector_arithmetic_unary_diffneg_sat_sisd : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_sat_sisd (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = SInt(aget_Elem(operand, e, esize));
        if neg then {
            element = negate(element)
        } else {
            element = abs(element)
        };
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SignedSatQ(element, esize);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_unary_diffneg_sat_sisd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_sat_sisd_decode (Rd, Rn, opcode, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let neg : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_diffneg_sat_sisd(d, datasize, elements, esize, n, neg)
}

val vector_arithmetic_unary_diffneg_sat_simd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_sat_simd_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let neg : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_diffneg_sat_sisd(d, datasize, elements, esize, n, neg)
}

val vector_arithmetic_unary_diffneg_int_sisd : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_int_sisd (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = SInt(aget_Elem(operand, e, esize));
        if neg then {
            element = negate(element)
        } else {
            element = abs(element)
        };
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, element, 0))
    };
    V(d) = result
}

val vector_arithmetic_unary_diffneg_int_sisd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_int_sisd_decode (Rd, Rn, opcode, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let neg : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_diffneg_int_sisd(d, datasize, elements, esize, n, neg)
}

val vector_arithmetic_unary_diffneg_int_simd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_int_simd_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let neg : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_diffneg_int_sisd(d, datasize, elements, esize, n, neg)
}

val vector_arithmetic_unary_diffneg_fp16 : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_fp16 (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        if neg then {
            element = FPNeg(element)
        } else {
            element = FPAbs(element)
        };
        result = aset_Elem(result, e, esize, element)
    };
    V(d) = result
}

val vector_arithmetic_unary_diffneg_fp16_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_fp16_decode (Rd, Rn, opcode, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let neg : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_diffneg_fp16(d, datasize, elements, esize, n, neg)
}

val vector_arithmetic_unary_diffneg_float_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_diffneg_float_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let neg : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_diffneg_fp16(d, datasize, elements, esize, n, neg)
}

val vector_arithmetic_unary_cnt : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cnt (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    count : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        count = BitCount(aget_Elem(operand, e, esize));
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, count, 0))
    };
    V(d) = result
}

val vector_arithmetic_unary_cnt_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cnt_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n == 8. int('n)} = 8;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    __PostDecode();
    vector_arithmetic_unary_cnt(d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_int_lessthan_sisd : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_int_lessthan_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : int = undefined : int;
    test_passed : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = SInt(aget_Elem(operand, e, esize));
        match comparison {
          CompareOp_GT => {
              test_passed = element > 0
          },
          CompareOp_GE => {
              test_passed = element >= 0
          },
          CompareOp_EQ => {
              test_passed = element == 0
          },
          CompareOp_LE => {
              test_passed = element <= 0
          },
          CompareOp_LT => {
              test_passed = element < 0
          }
        };
        result = aset_Elem(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V(d) = result
}

val vector_arithmetic_unary_cmp_int_lessthan_sisd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_int_lessthan_sisd_decode (Rd, Rn, opcode, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let comparison : CompareOp = CompareOp_LT;
    __PostDecode();
    vector_arithmetic_unary_cmp_int_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_int_lessthan_simd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_int_lessthan_simd_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let comparison : CompareOp = CompareOp_LT;
    __PostDecode();
    vector_arithmetic_unary_cmp_int_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_int_bulk_sisd : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_int_bulk_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    element : int = undefined : int;
    test_passed : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = SInt(aget_Elem(operand, e, esize));
        match comparison {
          CompareOp_GT => {
              test_passed = element > 0
          },
          CompareOp_GE => {
              test_passed = element >= 0
          },
          CompareOp_EQ => {
              test_passed = element == 0
          },
          CompareOp_LE => {
              test_passed = element <= 0
          },
          CompareOp_LT => {
              test_passed = element < 0
          }
        };
        result = aset_Elem(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V(d) = result
}

val vector_arithmetic_unary_cmp_int_bulk_sisd_decode : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_int_bulk_sisd_decode (Rd, Rn, op, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    comparison : CompareOp = undefined : CompareOp;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    __PostDecode();
    vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_int_bulk_simd_decode : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_int_bulk_simd_decode (Rd, Rn, op, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    comparison : CompareOp = undefined : CompareOp;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    __PostDecode();
    vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_fp16_lessthan_sisd : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_fp16_lessthan_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let zero : bits('esize) = FPZero(0b0);
    element : bits('esize) = undefined : bits('esize);
    test_passed : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        match comparison {
          CompareOp_GT => {
              test_passed = FPCompareGT(element, zero, FPCR)
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element, zero, FPCR)
          },
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element, zero, FPCR)
          },
          CompareOp_LE => {
              test_passed = FPCompareGE(zero, element, FPCR)
          },
          CompareOp_LT => {
              test_passed = FPCompareGT(zero, element, FPCR)
          }
        };
        result = aset_Elem(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V(d) = result
}

val vector_arithmetic_unary_cmp_fp16_lessthan_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_fp16_lessthan_sisd_decode (Rd, Rn, opcode, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let comparison : CompareOp = CompareOp_LT;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_fp16_lessthan_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_fp16_lessthan_simd_decode (Rd, Rn, opcode, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let comparison : CompareOp = CompareOp_LT;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_float_lessthan_sisd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_float_lessthan_sisd_decode (Rd, Rn, opcode, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let comparison : CompareOp = CompareOp_LT;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_float_lessthan_simd_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_float_lessthan_simd_decode (Rd, Rn, opcode, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let comparison : CompareOp = CompareOp_LT;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_fp16_bulk_sisd : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_fp16_bulk_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let zero : bits('esize) = FPZero(0b0);
    element : bits('esize) = undefined : bits('esize);
    test_passed : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element = aget_Elem(operand, e, esize);
        match comparison {
          CompareOp_GT => {
              test_passed = FPCompareGT(element, zero, FPCR)
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element, zero, FPCR)
          },
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element, zero, FPCR)
          },
          CompareOp_LE => {
              test_passed = FPCompareGE(zero, element, FPCR)
          },
          CompareOp_LT => {
              test_passed = FPCompareGT(zero, element, FPCR)
          }
        };
        result = aset_Elem(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V(d) = result
}

val vector_arithmetic_unary_cmp_fp16_bulk_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_fp16_bulk_sisd_decode (Rd, Rn, op, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    comparison : CompareOp = undefined : CompareOp;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_fp16_bulk_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_fp16_bulk_simd_decode (Rd, Rn, op, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    comparison : CompareOp = undefined : CompareOp;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_float_bulk_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_float_bulk_sisd_decode (Rd, Rn, op, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    comparison : CompareOp = undefined : CompareOp;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_cmp_float_bulk_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_cmp_float_bulk_simd_decode (Rd, Rn, op, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    comparison : CompareOp = undefined : CompareOp;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    __PostDecode();
    vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_clsz : forall 'd 'datasize 'elements 'esize 'n,
  ('n >= 0 & 'n <= 31) & 'esize >= 1 & 'datasize >= 0 & ('d >= 0 & 'd <= 31).
  (CountOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_clsz (countop, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    count : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if countop == CountOp_CLS then {
            assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
            count = CountLeadingSignBits(aget_Elem(operand, e, esize))
        } else {
            assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
            count = CountLeadingZeroBits(aget_Elem(operand, e, esize))
        };
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, count, 0))
    };
    V(d) = result
}

val vector_arithmetic_unary_clsz_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_clsz_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let countop : CountOp = if U == 0b1 then CountOp_CLZ else CountOp_CLS;
    __PostDecode();
    vector_arithmetic_unary_clsz(countop, d, datasize, elements, esize, n)
}

val vector_arithmetic_unary_add_saturating_sisd : forall 'd 'datasize 'elements 'esize 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_add_saturating_sisd (d, datasize, elements, esize, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    let operand2 : bits('datasize) = V(d);
    op1 : int = undefined : int;
    op2 : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        op1 = asl_Int(aget_Elem(operand, e, esize), ~(unsigned));
        op2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SatQ(op1 + op2, esize, unsigned);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_unary_add_saturating_sisd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_add_saturating_sisd_decode (Rd, Rn, opcode, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, unsigned)
}

val vector_arithmetic_unary_add_saturating_simd_decode : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_add_saturating_simd_decode (Rd, Rn, opcode, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, unsigned)
}

val vector_arithmetic_unary_add_pairwise : forall ('acc : Bool) 'd 'datasize 'elements 'esize 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('d >= 0 & 'd <= 31 | not('acc)) & ('d >= 0 & 'd <= 31).
  (bool('acc), int('d), int('datasize), int('elements), int('esize), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_add_pairwise (acc, d, datasize, elements, esize, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V(n);
    result : bits('datasize) = undefined : bits('datasize);
    sum : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    op1 : int = undefined : int;
    op2 : int = undefined : int;
    result = if acc then V(d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((2 * 'loop_e + 1 >= 0 & 'esize >= 0 & (2 * 'loop_e + 1 + 1) * 'esize <= 'datasize)));
        assert(constraint((2 * 'loop_e + 0 >= 0 & 'esize >= 0 & (2 * 'loop_e + 0 + 1) * 'esize <= 'datasize)));
        op1 = asl_Int(aget_Elem(operand, 2 * e + 0, esize), unsigned);
        op2 = asl_Int(aget_Elem(operand, 2 * e + 1, esize), unsigned);
        sum = __GetSlice_int(2 * esize, op1 + op2, 0);
        result = aset_Elem(result, e, 2 * esize, aget_Elem(result, e, 2 * esize) + sum)
    };
    V(d) = result
}

val vector_arithmetic_unary_add_pairwise_decode : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_unary_add_pairwise_decode (Rd, Rn, op, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, (2 * 'esize)). int('n)} = datasize / (2 * esize);
    let acc : bool = op == 0b1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, unsigned)
}

val vector_arithmetic_binary_uniform_sub_saturating_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_saturating_sisd (d, datasize, elements, esize, m, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    diff : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        diff = element1 - element2;
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SatQ(diff, esize, unsigned);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_sub_saturating_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_saturating_sisd_decode (Rd, Rn, opcode, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_sub_saturating_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_saturating_simd_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_sub_int : forall 'd 'datasize 'elements 'esize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_int (d, datasize, elements, esize, m, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    diff : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        diff = element1 - element2;
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, diff, 1))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_sub_int_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_int_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_sub_int(d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_sub_fp16_sisd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (bool('abs), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_fp16_sisd (abs, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    diff : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        diff = FPSub(element1, element2, FPCR);
        result = aset_Elem(result, e, esize, if abs then FPAbs(diff) else diff)
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_sub_fp16_sisd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_fp16_sisd_decode (Rd, Rn, opcode, Rm, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let abs : bool(true) = true;
    __PostDecode();
    vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_sub_fp16_simd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_fp16_simd_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let abs : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_sub_fp_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_fp_sisd_decode (Rd, Rn, opcode, Rm, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let abs : bool(true) = true;
    __PostDecode();
    vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_sub_fp_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_sub_fp_simd_decode (Rd, Rn, opcode, Rm, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let abs : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_shift_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('rounding : Bool) ('saturating : Bool) ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding), bool('saturating), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_shift_sisd (d, datasize, elements, esize, m, n, rounding, saturating, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    round_const : int = 0;
    shift : int = undefined : int;
    element : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        shift = SInt(slice(aget_Elem(operand2, e, esize), 0, 8));
        if rounding then {
            round_const = shl_int(1, negate(shift) - 1)
        };
        element = shl_int(asl_Int(aget_Elem(operand1, e, esize), unsigned) + round_const, shift);
        if saturating then {
            __tc1 : bits('esize) = undefined : bits('esize);
            (__tc1, sat) = SatQ(element, esize, unsigned);
            result = aset_Elem(result, e, esize, __tc1);
            if sat then {
                FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
            }
        } else {
            result = aset_Elem(result, e, esize, __GetSlice_int(esize, element, 0))
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_shift_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_shift_sisd_decode (Rd, Rn, S, R, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, unsigned)
}

val vector_arithmetic_binary_uniform_shift_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_shift_simd_decode (Rd, Rn, S, R, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, unsigned)
}

val vector_arithmetic_binary_uniform_rsqrtsfp16_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_rsqrtsfp16_sisd (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        result = aset_Elem(result, e, esize, FPRSqrtStepFused(element1, element2))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_rsqrts_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_rsqrts_sisd_decode (Rd, Rn, opcode, Rm, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_uniform_rsqrtsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_rsqrts_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_rsqrts_simd_decode (Rd, Rn, opcode, Rm, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_rsqrtsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_rsqrtsfp16_sisd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_rsqrtsfp16_sisd_decode (Rd, Rn, opcode, Rm, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_uniform_rsqrtsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_rsqrtsfp16_simd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_rsqrtsfp16_simd_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_rsqrtsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_recpsfp16_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_recpsfp16_sisd (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        result = aset_Elem(result, e, esize, FPRecipStepFused(element1, element2))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_recps_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_recps_sisd_decode (Rd, Rn, opcode, Rm, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_uniform_recpsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_recps_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_recps_simd_decode (Rd, Rn, opcode, Rm, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_recpsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_recpsfp16_sisd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_recpsfp16_sisd_decode (Rd, Rn, opcode, Rm, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_uniform_recpsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_recpsfp16_simd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_recpsfp16_simd_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_recpsfp16_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_mul_int_product : forall 'd 'datasize 'elements 'esize 'm 'n ('poly : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('poly)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_product (d, datasize, elements, esize, m, n, poly) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    product : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        if poly then {
            product = slice(PolynomialMult(element1, element2), 0, esize)
        } else {
            product = __GetSlice_int(esize, UInt(element1) * UInt(element2), 0)
        };
        result = aset_Elem(result, e, esize, product)
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_int_product_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_product_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if U == 0b1 & size != 0b00 then {
        throw(Error_Undefined())
    };
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let poly : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_product(d, datasize, elements, esize, m, n, poly)
}

val vector_arithmetic_binary_uniform_mul_int_doubling_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('rounding : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_doubling_sisd (d, datasize, elements, esize, m, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let 'round_const = if rounding then shl_int(1, esize - 1) else 0;
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        element2 = SInt(aget_Elem(operand2, e, esize));
        product = 2 * element1 * element2 + round_const;
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SignedSatQ(shr_int(product, esize), esize);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_int_doubling_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_doubling_sisd_decode (Rd, Rn, opcode, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let rounding : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

val vector_arithmetic_binary_uniform_mul_int_doubling_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_doubling_simd_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let rounding : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

val vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('rounding : Bool) ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (d, datasize, elements, esize, m, n, rounding, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    let 'rounding_const = if rounding then shl_int(1, esize - 1) else 0;
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    element3 : int = undefined : int;
    let 'product = undefined : int;
    sat : bool = undefined : bool;
    accum : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        element2 = SInt(aget_Elem(operand2, e, esize));
        element3 = SInt(aget_Elem(operand3, e, esize));
        if sub_op then {
            accum = shl_int(element3, esize) - 2 * (element1 * element2) + rounding_const
        } else {
            accum = shl_int(element3, esize) + 2 * (element1 * element2) + rounding_const
        };
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SignedSatQ(shr_int(accum, esize), esize);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_decode (Rd, Rn, S, Rm, size, U) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let rounding : bool(true) = true;
    let sub_op : bool = S == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

val vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_decode (Rd, Rn, S, Rm, size, U, Q) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let rounding : bool(true) = true;
    let sub_op : bool = S == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

val vector_arithmetic_binary_uniform_mul_int_dotp : forall 'd 'datasize 'elements 'esize 'm 'n ('signed : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('signed)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_dotp (d, datasize, elements, esize, m, n, signed) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    result = V(d);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        res : int = 0;
        element1 : int = undefined : int;
        element2 : int = undefined : int;
        foreach (i from 0 to 3 by 1 in inc) {
            if signed then {
                assert(constraint((4 * 'loop_e + 'loop_i >= 0 & div('esize, 4) >= 0 & (4 * 'loop_e + 'loop_i + 1) * div('esize, 4) <= 'datasize | not('signed))));
                element1 = SInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                element2 = SInt(aget_Elem(operand2, 4 * e + i, esize / 4))
            } else {
                assert(constraint((4 * 'loop_e + 'loop_i >= 0 & div('esize, 4) >= 0 & (4 * 'loop_e + 'loop_i + 1) * div('esize, 4) <= 'datasize | not(not('signed)))));
                element1 = UInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                element2 = UInt(aget_Elem(operand2, 4 * e + i, esize / 4))
            };
            res = res + element1 * element2
        };
        result = aset_Elem(result, e, esize, aget_Elem(result, e, esize) + res)
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_int_dotp_decode__0 : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

val vector_arithmetic_binary_uniform_mul_int_dotp_decode__1 : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

overload vector_arithmetic_binary_uniform_mul_int_dotp_decode = {
  vector_arithmetic_binary_uniform_mul_int_dotp_decode__0,
  vector_arithmetic_binary_uniform_mul_int_dotp_decode__1
}

function vector_arithmetic_binary_uniform_mul_int_dotp_decode__0 (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_dotp(d, datasize, elements, esize, m, n, signed)
}

function vector_arithmetic_binary_uniform_mul_int_dotp_decode__1 (Rd, Rn, Rm, size, U, Q) = {
    __unconditional = true;
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_dotp(d, datasize, elements, esize, m, n, signed)
}

val vector_arithmetic_binary_uniform_mul_int_accum : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_accum (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    product : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        product = __GetSlice_int(esize, UInt(element1) * UInt(element2), 0);
        if sub_op then {
            result = aset_Elem(result, e, esize, aget_Elem(operand3, e, esize) - product)
        } else {
            result = aset_Elem(result, e, esize, aget_Elem(operand3, e, esize) + product)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_int_accum_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_int_accum_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_int_accum(d, datasize, elements, esize, m, n, sub_op)
}

val vector_arithmetic_binary_uniform_mul_fp16_product : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp16_product (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        result = aset_Elem(result, e, esize, FPMul(element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_fp16_product_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp16_product_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_product(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_mul_fp_product_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_product_decode (Rd, Rn, opcode, Rm, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_product(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_mul_fp16_fused : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp16_fused (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = aset_Elem(result, e, esize, FPMulAdd(aget_Elem(operand3, e, esize), element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_fp16_fused_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp16_fused_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = a == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

val vector_arithmetic_binary_uniform_mul_fp_fused_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_fused_decode (Rd, Rn, opcode, Rm, sz, op, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = op == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

val vector_arithmetic_binary_uniform_mul_fp16_extended_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp16_extended_sisd (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        result = aset_Elem(result, e, esize, FPMulX(element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_decode (Rd, Rn, opcode, Rm, a, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_mul_fp16_extended_simd_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp16_extended_simd_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_mul_fp_extended_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_extended_sisd_decode (Rd, Rn, opcode, Rm, sz, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_mul_fp_extended_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_extended_simd_decode (Rd, Rn, opcode, Rm, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper (d, datasize, elements, esize, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(div('datasize, 2)) = Vpart(n, part);
    let operand2 : bits(div('datasize, 2)) = Vpart(m, part);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    element2 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        assert(constraint(('loop_e >= 0 & div('esize, 2) >= 0 & ('loop_e + 1) * div('esize, 2) <= div('datasize, 2))));
        element1 = aget_Elem(operand1, e, esize / 2);
        element2 = aget_Elem(operand2, e, esize / 2);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = aset_Elem(result, e, esize, FPMulAddH(aget_Elem(operand3, e, esize), element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_decode (Rd, Rn, Rm, sz, S, Q) = {
    __unconditional = true;
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = S == 0b1;
    let 'part : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper(d, datasize, elements, esize, m, n, part, sub_op)
}

val vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower (d, datasize, elements, esize, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(div('datasize, 2)) = Vpart(n, part);
    let operand2 : bits(div('datasize, 2)) = Vpart(m, part);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    element2 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        assert(constraint(('loop_e >= 0 & div('esize, 2) >= 0 & ('loop_e + 1) * div('esize, 2) <= div('datasize, 2))));
        element1 = aget_Elem(operand1, e, esize / 2);
        element2 = aget_Elem(operand2, e, esize / 2);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = aset_Elem(result, e, esize, FPMulAddH(aget_Elem(operand3, e, esize), element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_decode : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_decode (Rd, Rn, Rm, sz, S, Q) = {
    __unconditional = true;
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = S == 0b1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower(d, datasize, elements, esize, m, n, part, sub_op)
}

val vector_arithmetic_binary_uniform_mul_fp_complex : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_complex (d, datasize, elements, esize, m, n, rot) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    element3 : bits('esize) = undefined : bits('esize);
    element4 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements / 2 - 1) by 1 in inc) {
        assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
        assert(constraint(('loop_e * 2 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1) * 'esize <= 'datasize)));
        match rot {
          0b00 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              assert(constraint(('loop_e * 2 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1) * 'esize <= 'datasize)));
              element1 = aget_Elem(operand2, e * 2, esize);
              element2 = aget_Elem(operand1, e * 2, esize);
              element3 = aget_Elem(operand2, e * 2 + 1, esize);
              element4 = aget_Elem(operand1, e * 2, esize)
          },
          0b01 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              element1 = FPNeg(aget_Elem(operand2, e * 2 + 1, esize));
              element2 = aget_Elem(operand1, e * 2 + 1, esize);
              element3 = aget_Elem(operand2, e * 2, esize);
              element4 = aget_Elem(operand1, e * 2 + 1, esize)
          },
          0b10 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              assert(constraint(('loop_e * 2 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1) * 'esize <= 'datasize)));
              element1 = FPNeg(aget_Elem(operand2, e * 2, esize));
              element2 = aget_Elem(operand1, e * 2, esize);
              element3 = FPNeg(aget_Elem(operand2, e * 2 + 1, esize));
              element4 = aget_Elem(operand1, e * 2, esize)
          },
          0b11 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              element1 = aget_Elem(operand2, e * 2 + 1, esize);
              element2 = aget_Elem(operand1, e * 2 + 1, esize);
              element3 = FPNeg(aget_Elem(operand2, e * 2, esize));
              element4 = aget_Elem(operand1, e * 2 + 1, esize)
          }
        };
        result = aset_Elem(result, e * 2, esize, FPMulAdd(aget_Elem(operand3, e * 2, esize), element2, element1, FPCR));
        result = aset_Elem(result, e * 2 + 1, esize, FPMulAdd(aget_Elem(operand3, e * 2 + 1, esize), element4, element3, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_mul_fp_complex_decode : (bits(5), bits(5), bits(2), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_mul_fp_complex_decode (Rd, Rn, rot, Rm, size, U, Q) = {
    __unconditional = true;
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b0 & size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_mul_fp_complex(d, datasize, elements, esize, m, n, rot)
}

val vector_arithmetic_binary_uniform_maxmin_single : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_single (d, datasize, elements, esize, m, minimum, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    maxmin : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        maxmin = if minimum then min(element1, element2) else max(element1, element2);
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, maxmin, 0))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_maxmin_single_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_single_decode (Rd, Rn, o1, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_maxmin_single(d, datasize, elements, esize, m, minimum, n, unsigned)
}

val vector_arithmetic_binary_uniform_maxmin_pair : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_pair (d, datasize, elements, esize, m, minimum, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    maxmin : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((2 * 'loop_e + 1 >= 0 & 'esize >= 0 & (2 * 'loop_e + 1 + 1) * 'esize <= 2 * 'datasize)));
        assert(constraint((2 * 'loop_e >= 0 & 'esize >= 0 & (2 * 'loop_e + 1) * 'esize <= 2 * 'datasize)));
        element1 = asl_Int(aget_Elem(concat, 2 * e, esize), unsigned);
        element2 = asl_Int(aget_Elem(concat, 2 * e + 1, esize), unsigned);
        maxmin = if minimum then min(element1, element2) else max(element1, element2);
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, maxmin, 0))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_maxmin_pair_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_pair_decode (Rd, Rn, o1, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_maxmin_pair(d, datasize, elements, esize, m, minimum, n, unsigned)
}

val vector_arithmetic_binary_uniform_maxmin_fp16_2008 : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('pair : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('esize >= 0 & 'esize >= 0 | not('minimum)) & ('datasize >= 0 & 'esize >= 0 | not('minimum)) & ('esize >= 0 & 'esize >= 0 | not(not('minimum))) & ('datasize >= 0 | not(not('minimum))) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('pair)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_fp16_2008 (d, datasize, elements, esize, m, minimum, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            assert(constraint((2 * 'loop_e + 1 >= 0 & 'esize >= 0 & (2 * 'loop_e + 1 + 1) * 'esize <= 2 * 'datasize | not('pair))));
            assert(constraint((2 * 'loop_e >= 0 & 'esize >= 0 & (2 * 'loop_e + 1) * 'esize <= 2 * 'datasize | not('pair))));
            element1 = aget_Elem(concat, 2 * e, esize);
            element2 = aget_Elem(concat, 2 * e + 1, esize)
        } else {
            assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize | not(not('pair)))));
            element1 = aget_Elem(operand1, e, esize);
            element2 = aget_Elem(operand2, e, esize)
        };
        if minimum then {
            result = aset_Elem(result, e, esize, FPMinNum(element1, element2, FPCR))
        } else {
            result = aset_Elem(result, e, esize, FPMaxNum(element1, element2, FPCR))
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_maxmin_fp16_2008_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_fp16_2008_decode (Rd, Rn, Op3, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_maxmin_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

val vector_arithmetic_binary_uniform_maxmin_fp_2008_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_fp_2008_decode (Rd, Rn, opcode, Rm, sz, o1, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_maxmin_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

val vector_arithmetic_binary_uniform_maxmin_fp16_1985 : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('pair : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('esize >= 0 & 'esize >= 0 | not('minimum)) & ('datasize >= 0 & 'esize >= 0 | not('minimum)) & ('esize >= 0 & 'esize >= 0 | not(not('minimum))) & ('datasize >= 0 | not(not('minimum))) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('pair)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_fp16_1985 (d, datasize, elements, esize, m, minimum, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            assert(constraint((2 * 'loop_e + 1 >= 0 & 'esize >= 0 & (2 * 'loop_e + 1 + 1) * 'esize <= 2 * 'datasize | not('pair))));
            assert(constraint((2 * 'loop_e >= 0 & 'esize >= 0 & (2 * 'loop_e + 1) * 'esize <= 2 * 'datasize | not('pair))));
            element1 = aget_Elem(concat, 2 * e, esize);
            element2 = aget_Elem(concat, 2 * e + 1, esize)
        } else {
            assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize | not(not('pair)))));
            element1 = aget_Elem(operand1, e, esize);
            element2 = aget_Elem(operand2, e, esize)
        };
        if minimum then {
            result = aset_Elem(result, e, esize, FPMin(element1, element2, FPCR))
        } else {
            result = aset_Elem(result, e, esize, FPMax(element1, element2, FPCR))
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_maxmin_fp16_1985_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_fp16_1985_decode (Rd, Rn, opcode, Rm, o1, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_maxmin_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

val vector_arithmetic_binary_uniform_maxmin_fp_1985_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_maxmin_fp_1985_decode (Rd, Rn, opcode, Rm, sz, o1, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_maxmin_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

val vector_arithmetic_binary_uniform_logical_bsleor : forall 'd 'datasize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), VBitOp) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_logical_bsleor (d, datasize, m, n, op) = {
    CheckFPAdvSIMDEnabled64();
    operand1 : bits('datasize) = undefined : bits('datasize);
    operand2 : bits('datasize) = undefined : bits('datasize);
    operand3 : bits('datasize) = undefined : bits('datasize);
    let operand4 : bits('datasize) = V(n);
    match op {
      VBitOp_VEOR => {
          operand1 = V(m);
          operand2 = Zeros();
          operand3 = Ones()
      },
      VBitOp_VBSL => {
          operand1 = V(m);
          operand2 = operand1;
          operand3 = V(d)
      },
      VBitOp_VBIT => {
          operand1 = V(d);
          operand2 = operand1;
          operand3 = V(m)
      },
      VBitOp_VBIF => {
          operand1 = V(d);
          operand2 = operand1;
          operand3 = ~(V(m))
      }
    };
    let operand3 = operand3;
    let operand2 = operand2;
    let operand1 = operand1;
    V(d) = operand1 ^ (operand2 ^ operand4 & operand3)
}

val vector_arithmetic_binary_uniform_logical_bsleor_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_logical_bsleor_decode (Rd, Rn, opcode, Rm, opc2, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 8. int('n)} = 8;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    op : VBitOp = undefined : VBitOp;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    __PostDecode();
    vector_arithmetic_binary_uniform_logical_bsleor(d, datasize, m, n, op)
}

val vector_arithmetic_binary_uniform_logical_andorr : forall 'd 'datasize ('invert : Bool) 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), bool('invert), int('m), int('n), LogicalOp) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_logical_andorr (d, datasize, invert, m, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    if invert then {
        operand2 = ~(operand2)
    };
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      }
    };
    let result = result;
    V(d) = result
}

val vector_arithmetic_binary_uniform_logical_andorr_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_logical_andorr_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 8. int('n)} = 8;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else LogicalOp_AND;
    __PostDecode();
    vector_arithmetic_binary_uniform_logical_andorr(d, datasize, invert, m, n, op)
}

val vector_arithmetic_binary_uniform_divfp16 : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_divfp16 (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        result = aset_Elem(result, e, esize, FPDiv(element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_div_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_div_decode (Rd, Rn, opcode, Rm, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_divfp16(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_divfp16_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_divfp16_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_divfp16(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_diff : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31 | not('accumulate)) & ('d >= 0 & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_diff (accumulate, d, datasize, elements, esize, m, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    absdiff : bits('esize) = undefined : bits('esize);
    result = if accumulate then V(d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        absdiff = __GetSlice_int(esize, abs(element1 - element2), 0);
        result = aset_Elem(result, e, esize, aget_Elem(result, e, esize) + absdiff)
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_diff_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_diff_decode (Rd, Rn, ac, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_cmp_int_sisd : forall ('cmp_eq : Bool) 'd 'datasize 'elements 'esize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (bool('cmp_eq), int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_int_sisd (cmp_eq, d, datasize, elements, esize, m, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    test_passed : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
        result = aset_Elem(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_cmp_int_sisd_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_int_sisd_decode (Rd, Rn, eq, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_cmp_int_simd_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_int_simd_decode (Rd, Rn, eq, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_cmp_fp16_sisd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (bool('abs), CompareOp, int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_fp16_sisd (abs, cmp, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    test_passed : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        if abs then {
            element1 = FPAbs(element1);
            element2 = FPAbs(element2)
        };
        match cmp {
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element1, element2, FPCR)
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element1, element2, FPCR)
          },
          CompareOp_GT => {
              test_passed = FPCompareGT(element1, element2, FPCR)
          }
        };
        result = aset_Elem(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_cmp_fp16_sisd_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_fp16_sisd_decode (Rd, Rn, ac, Rm, E, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    cmp : CompareOp = undefined : CompareOp;
    abs : bool = undefined : bool;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_cmp_fp16_simd_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_fp16_simd_decode (Rd, Rn, ac, Rm, E, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    cmp : CompareOp = undefined : CompareOp;
    abs : bool = undefined : bool;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_cmp_fp_sisd_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_fp_sisd_decode (Rd, Rn, ac, Rm, sz, E, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    cmp : CompareOp = undefined : CompareOp;
    abs : bool = undefined : bool;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_cmp_fp_simd_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_fp_simd_decode (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    cmp : CompareOp = undefined : CompareOp;
    abs : bool = undefined : bool;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_cmp_bitwise_sisd : forall ('and_test : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (bool('and_test), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_bitwise_sisd (and_test, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    test_passed : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        if and_test then {
            test_passed = ~(IsZero(element1 & element2))
        } else {
            test_passed = element1 == element2
        };
        result = aset_Elem(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_cmp_bitwise_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_bitwise_sisd_decode (Rd, Rn, opcode, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let and_test : bool = U == 0b0;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_cmp_bitwise_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_cmp_bitwise_simd_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let and_test : bool = U == 0b0;
    __PostDecode();
    vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_add_wrapping_single_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_wrapping_single_sisd (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        if sub_op then {
            result = aset_Elem(result, e, esize, element1 - element2)
        } else {
            result = aset_Elem(result, e, esize, element1 + element2)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_add_wrapping_single_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_wrapping_single_sisd_decode (Rd, Rn, opcode, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let sub_op : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

val vector_arithmetic_binary_uniform_add_wrapping_single_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_wrapping_single_simd_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

val vector_arithmetic_binary_uniform_add_wrapping_pair : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_wrapping_pair (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((2 * 'loop_e + 1 >= 0 & 'esize >= 0 & (2 * 'loop_e + 1 + 1) * 'esize <= 2 * 'datasize)));
        assert(constraint((2 * 'loop_e >= 0 & 'esize >= 0 & (2 * 'loop_e + 1) * 'esize <= 2 * 'datasize)));
        element1 = aget_Elem(concat, 2 * e, esize);
        element2 = aget_Elem(concat, 2 * e + 1, esize);
        result = aset_Elem(result, e, esize, element1 + element2)
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_add_wrapping_pair_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_wrapping_pair_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_wrapping_pair(d, datasize, elements, esize, m, n)
}

val vector_arithmetic_binary_uniform_add_saturating_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_saturating_sisd (d, datasize, elements, esize, m, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    sum : int = undefined : int;
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        sum = element1 + element2;
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SatQ(sum, esize, unsigned);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_add_saturating_sisd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_saturating_sisd_decode (Rd, Rn, opcode, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_add_saturating_simd_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_saturating_simd_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_add_halving_truncating : forall 'd 'datasize 'elements 'esize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_halving_truncating (d, datasize, elements, esize, m, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    sum : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        sum = element1 + element2;
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, sum, 1))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_add_halving_truncating_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_halving_truncating_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_halving_truncating(d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_add_halving_rounding : forall 'd 'datasize 'elements 'esize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_halving_rounding (d, datasize, elements, esize, m, n, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        result = aset_Elem(result, e, esize, __GetSlice_int(esize, element1 + element2 + 1, 1))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_add_halving_rounding_decode : (bits(5), bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_halving_rounding_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_halving_rounding(d, datasize, elements, esize, m, n, unsigned)
}

val vector_arithmetic_binary_uniform_add_fp16 : forall 'd 'datasize 'elements 'esize 'm 'n ('pair : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('esize >= 0 & 'esize >= 0) & 'datasize >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('pair)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_fp16 (d, datasize, elements, esize, m, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            assert(constraint((2 * 'loop_e + 1 >= 0 & 'esize >= 0 & (2 * 'loop_e + 1 + 1) * 'esize <= 2 * 'datasize | not('pair))));
            assert(constraint((2 * 'loop_e >= 0 & 'esize >= 0 & (2 * 'loop_e + 1) * 'esize <= 2 * 'datasize | not('pair))));
            element1 = aget_Elem(concat, 2 * e, esize);
            element2 = aget_Elem(concat, 2 * e + 1, esize)
        } else {
            assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize | not(not('pair)))));
            element1 = aget_Elem(operand1, e, esize);
            element2 = aget_Elem(operand2, e, esize)
        };
        result = aset_Elem(result, e, esize, FPAdd(element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_add_fp_decode : (bits(5), bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_fp_decode (Rd, Rn, opcode, Rm, sz, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let pair : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

val vector_arithmetic_binary_uniform_add_fp16_decode : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_fp16_decode (Rd, Rn, opcode, Rm, a, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let pair : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

val vector_arithmetic_binary_uniform_add_fp_complex : forall 'd 'datasize 'elements 'esize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_fp_complex (d, datasize, elements, esize, m, n, rot) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element3 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements / 2 - 1) by 1 in inc) {
        assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
        assert(constraint(('loop_e * 2 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1) * 'esize <= 'datasize)));
        match rot {
          0b0 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              element1 = FPNeg(aget_Elem(operand2, e * 2 + 1, esize));
              element3 = aget_Elem(operand2, e * 2, esize)
          },
          0b1 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & 'esize >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              element1 = aget_Elem(operand2, e * 2 + 1, esize);
              element3 = FPNeg(aget_Elem(operand2, e * 2, esize))
          }
        };
        result = aset_Elem(result, e * 2, esize, FPAdd(aget_Elem(operand1, e * 2, esize), element1, FPCR));
        result = aset_Elem(result, e * 2 + 1, esize, FPAdd(aget_Elem(operand1, e * 2 + 1, esize), element3, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_uniform_add_fp_complex_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_uniform_add_fp_complex_decode (Rd, Rn, rot, Rm, size, U, Q) = {
    __unconditional = true;
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 then {
        throw(Error_Undefined())
    };
    if Q == 0b0 & size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_uniform_add_fp_complex(d, datasize, elements, esize, m, n, rot)
}

val vector_arithmetic_binary_element_mul_long : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_long (d, datasize, elements, esize, idxdsize, index, m, n, part, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('idxdsize) = V(m);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    let element2 = asl_Int(aget_Elem(operand2, index, esize), unsigned);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        product = __GetSlice_int(2 * esize, element1 * element2, 0);
        result = aset_Elem(result, e, 2 * esize, product)
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mul_long_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_long_decode (Rd, Rn, H, opcode, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_long(d, datasize, elements, esize, idxdsize, index, m, n, part, unsigned)
}

val vector_arithmetic_binary_element_mul_int : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_int (d, datasize, elements, esize, idxdsize, index, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('idxdsize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits('esize) = undefined : bits('esize);
    let element2 = UInt(aget_Elem(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = UInt(aget_Elem(operand1, e, esize));
        product = __GetSlice_int(esize, element1 * element2, 0);
        result = aset_Elem(result, e, esize, product)
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mul_int_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_int_decode (Rd, Rn, H, opcode, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {|128, 64|} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_int(d, datasize, elements, esize, idxdsize, index, m, n)
}

val vector_arithmetic_binary_element_mul_high_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('round : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('round)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_high_sisd (d, datasize, elements, esize, idxdsize, index, m, n, round) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('idxdsize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let 'round_const = if round then shl_int(1, esize - 1) else 0;
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : int = undefined : int;
    sat : bool = undefined : bool;
    let element2 = SInt(aget_Elem(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        product = 2 * element1 * element2 + round_const;
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SignedSatQ(shr_int(product, esize), esize);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mul_high_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_high_sisd_decode (Rd, Rn, H, op, Rm, M, L, size, U) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let round : bool = op == 0b1;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

val vector_arithmetic_binary_element_mul_high_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_high_simd_decode (Rd, Rn, H, op, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {|128, 64|} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let round : bool = op == 0b1;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

val vector_arithmetic_binary_element_mul_fp16_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm ('mulx_op : Bool) 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), bool('mulx_op), int('n)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_fp16_sisd (d, datasize, elements, esize, idxdsize, index, m, mulx_op, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('idxdsize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    let element2 : bits('esize) = aget_Elem(operand2, index, esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        if mulx_op then {
            result = aset_Elem(result, e, esize, FPMulX(element1, element2, FPCR))
        } else {
            result = aset_Elem(result, e, esize, FPMul(element1, element2, FPCR))
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mul_fp16_sisd_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_fp16_sisd_decode (Rd, Rn, H, opcode, Rm, M, L, size, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    let index = UInt((H @ L) @ M);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let mulx_op : bool = U == 0b1;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

val vector_arithmetic_binary_element_mul_fp16_simd_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_fp16_simd_decode (Rd, Rn, H, opcode, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    let index = UInt((H @ L) @ M);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let mulx_op : bool = U == 0b1;
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

val vector_arithmetic_binary_element_mul_fp_sisd_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_fp_sisd_decode (Rd, Rn, H, opcode, Rm, M, L, sz, U) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    let Rmhi : vector(1, dec, bit) = M;
    match sz @ L {
      [bitzero] @ _ : bits(1) => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let mulx_op : bool = U == 0b1;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

val vector_arithmetic_binary_element_mul_fp_simd_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_fp_simd_decode (Rd, Rn, H, opcode, Rm, M, L, sz, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    let Rmhi : vector(1, dec, bit) = M;
    match sz @ L {
      [bitzero] @ _ : bits(1) => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {|128, 64|} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let mulx_op : bool = U == 0b1;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

val vector_arithmetic_binary_element_mul_double_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part,
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_double_sisd (d, datasize, elements, esize, idxdsize, index, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('idxdsize) = V(m);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    sat : bool = undefined : bool;
    let element2 = SInt(aget_Elem(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        (product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
        result = aset_Elem(result, e, 2 * esize, product);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mul_double_sisd_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_double_sisd_decode (Rd, Rn, H, opcode, Rm, M, L, size, U) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part)
}

val vector_arithmetic_binary_element_mul_double_simd_decode : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mul_double_simd_decode (Rd, Rn, H, opcode, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mul_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part)
}

val vector_arithmetic_binary_element_mulacc_mul_norounding_i_upper : forall 'd 'datasize 'elements 'esize 'index 'm 'n 'part ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index >= 0 & div('esize, 2) >= 0 & ('index + 1) * div('esize, 2) <= 128).
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_mul_norounding_i_upper (d, datasize, elements, esize, index, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(div('datasize, 2)) = Vpart(n, part);
    let operand2 : bits(128) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    let element2 : bits(div('esize, 2)) = aget_Elem(operand2, index, esize / 2);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * div('esize, 2) <= div('datasize, 2))));
        element1 = aget_Elem(operand1, e, esize / 2);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = aset_Elem(result, e, esize, FPMulAddH(aget_Elem(operand3, e, esize), element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_mul_norounding_i_upper_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_mul_norounding_i_upper_decode (Rd, Rn, H, S, Rm, M, L, sz, Q) = {
    __unconditional = true;
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(0b0 @ Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'index = UInt((H @ L) @ M);
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = S == 0b1;
    let 'part : {'n, 'n == 1. int('n)} = 1;
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_mul_norounding_i_upper(d, datasize, elements, esize, index, m, n, part, sub_op)
}

val vector_arithmetic_binary_element_mulacc_mul_norounding_i_lower : forall 'd 'datasize 'elements 'esize 'index 'm 'n 'part ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index >= 0 & div('esize, 2) >= 0 & ('index + 1) * div('esize, 2) <= 128).
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_mul_norounding_i_lower (d, datasize, elements, esize, index, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(div('datasize, 2)) = Vpart(n, part);
    let operand2 : bits(128) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits(div('esize, 2)) = undefined : bits(div('esize, 2));
    let element2 : bits(div('esize, 2)) = aget_Elem(operand2, index, esize / 2);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * div('esize, 2) <= div('datasize, 2))));
        element1 = aget_Elem(operand1, e, esize / 2);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = aset_Elem(result, e, esize, FPMulAddH(aget_Elem(operand3, e, esize), element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_mul_norounding_i_lower_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_mul_norounding_i_lower_decode (Rd, Rn, H, S, Rm, M, L, sz, Q) = {
    __unconditional = true;
    if ~(HaveFP16MulNoRoundingToFP32Ext()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(0b0 @ Rm);
    if sz == 0b1 then {
        throw(Error_Undefined())
    };
    let 'index = UInt((H @ L) @ M);
    let 'esize : {'n, 'n == 32. int('n)} = 32;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = S == 0b1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_mul_norounding_i_lower(d, datasize, elements, esize, index, m, n, part, sub_op)
}

val vector_arithmetic_binary_element_mulacc_long : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part ('sub_op : Bool) ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('sub_op), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_long (d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('idxdsize) = V(m);
    let operand3 : bits(2 * 'datasize) = V(d);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    let element2 = asl_Int(aget_Elem(operand2, index, esize), unsigned);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        product = __GetSlice_int(2 * esize, element1 * element2, 0);
        if sub_op then {
            result = aset_Elem(result, e, 2 * esize, aget_Elem(operand3, e, 2 * esize) - product)
        } else {
            result = aset_Elem(result, e, 2 * esize, aget_Elem(operand3, e, 2 * esize) + product)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_long_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_long_decode (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {|128, 64|} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    __PostDecode();
    assert(index >= 0 & esize >= 0 & (index + 1) * esize <= idxdsize);
    vector_arithmetic_binary_element_mulacc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, unsigned)
}

val vector_arithmetic_binary_element_mulacc_int : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_int (d, datasize, elements, esize, idxdsize, index, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('idxdsize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits('esize) = undefined : bits('esize);
    let element2 = UInt(aget_Elem(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = UInt(aget_Elem(operand1, e, esize));
        product = __GetSlice_int(esize, element1 * element2, 0);
        if sub_op then {
            result = aset_Elem(result, e, esize, aget_Elem(operand3, e, esize) - product)
        } else {
            result = aset_Elem(result, e, esize, aget_Elem(operand3, e, esize) + product)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_int_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_int_decode (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o2 == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_int(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

val vector_arithmetic_binary_element_mulacc_high_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('rounding : Bool) ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('rounding), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_high_sisd (d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('idxdsize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    let 'rounding_const = if rounding then shl_int(1, esize - 1) else 0;
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    element3 : int = undefined : int;
    let 'product = undefined : int;
    sat : bool = undefined : bool;
    let element2 = SInt(aget_Elem(operand2, index, esize));
    accum : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        element3 = SInt(aget_Elem(operand3, e, esize));
        if sub_op then {
            accum = shl_int(element3, esize) - 2 * (element1 * element2) + rounding_const
        } else {
            accum = shl_int(element3, esize) + 2 * (element1 * element2) + rounding_const
        };
        __tc1 : bits('esize) = undefined : bits('esize);
        (__tc1, sat) = SignedSatQ(shr_int(accum, esize), esize);
        result = aset_Elem(result, e, esize, __tc1);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_high_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_high_sisd_decode (Rd, Rn, H, S, Rm, M, L, size, U) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let rounding : bool(true) = true;
    let sub_op : bool = S == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

val vector_arithmetic_binary_element_mulacc_high_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_high_simd_decode (Rd, Rn, H, S, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    if ~(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let rounding : bool(true) = true;
    let sub_op : bool = S == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

val vector_arithmetic_binary_element_mulacc_fp16_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_fp16_sisd (d, datasize, elements, esize, idxdsize, index, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('idxdsize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    let element2 : bits('esize) = aget_Elem(operand2, index, esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        if sub_op then {
            element1 = FPNeg(element1)
        };
        result = aset_Elem(result, e, esize, FPMulAdd(aget_Elem(operand3, e, esize), element1, element2, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_fp16_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_fp16_sisd_decode (Rd, Rn, H, o2, Rm, M, L, size, U) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    let index = UInt((H @ L) @ M);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let sub_op : bool = o2 == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

val vector_arithmetic_binary_element_mulacc_fp16_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_fp16_simd_decode (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    if ~(HaveFP16Ext()) then {
        throw(Error_Undefined())
    };
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    let index = UInt((H @ L) @ M);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize : {'n, 'n == 16. int('n)} = 16;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o2 == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

val vector_arithmetic_binary_element_mulacc_fp_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_fp_sisd_decode (Rd, Rn, H, o2, Rm, M, L, sz, U) = {
    __unconditional = true;
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    let Rmhi : vector(1, dec, bit) = M;
    match sz @ L {
      [bitzero] @ _ : bits(1) => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let sub_op : bool = o2 == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

val vector_arithmetic_binary_element_mulacc_fp_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_fp_simd_decode (Rd, Rn, H, o2, Rm, M, L, sz, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    let Rmhi : vector(1, dec, bit) = M;
    match sz @ L {
      [bitzero] @ _ : bits(1) => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(32, UInt(sz));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o2 == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31)));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

val vector_arithmetic_binary_element_mulacc_double_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index >= 0 & 'esize >= 0 & ('index + 1) * 'esize <= 'idxdsize).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_double_sisd (d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('idxdsize) = V(m);
    let operand3 : bits(2 * 'datasize) = V(d);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    accum : int = undefined : int;
    sat1 : bool = undefined : bool;
    sat2 : bool = undefined : bool;
    let element2 = SInt(aget_Elem(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
        if sub_op then {
            accum = SInt(aget_Elem(operand3, e, 2 * esize)) - SInt(product)
        } else {
            accum = SInt(aget_Elem(operand3, e, 2 * esize)) + SInt(product)
        };
        __tc1 : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        (__tc1, sat2) = SignedSatQ(accum, 2 * esize);
        result = aset_Elem(result, e, 2 * esize, __tc1);
        if sat1 | sat2 then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_double_sisd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_double_sisd_decode (Rd, Rn, H, o2, Rm, M, L, size, U) = {
    __unconditional = true;
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    let sub_op : bool = o2 == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_part in {0, 1})));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

val vector_arithmetic_binary_element_mulacc_double_simd_decode : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_double_simd_decode (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    let 'idxdsize : {'n, 'n in {128, 64}. int('n)} = if H == 0b1 then 128 else 64;
    index : int = undefined : int;
    Rmhi : bits(1) = undefined : bits(1);
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o2 == 0b1;
    assert(constraint(('_index >= 0 & '_esize >= 0 & ('_index + 1) * '_esize <= '_idxdsize)));
    assert(constraint(('_d >= 0 & '_d <= 31)));
    assert(constraint(('_m >= 0 & '_m <= 31)));
    assert(constraint(('_n >= 0 & '_n <= 31 & '_part in {0, 1})));
    __PostDecode();
    vector_arithmetic_binary_element_mulacc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

val vector_arithmetic_binary_element_mulacc_complex : forall 'd 'datasize 'elements 'esize 'index 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31) & ('index * 2 >= 0 & 'esize >= 0 & ('index * 2 + 1) * 'esize <= 'datasize) & ('index * 2 + 1 + 1) * 'esize <= 'datasize.
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_complex (d, datasize, elements, esize, index, m, n, rot) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    let operand3 : bits('datasize) = V(d);
    result : bits('datasize) = undefined : bits('datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    element3 : bits('esize) = undefined : bits('esize);
    element4 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements / 2 - 1) by 1 in inc) {
        assert(constraint(('loop_e * 2 + 1 >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
        assert(constraint(('loop_e * 2 >= 0 & ('loop_e * 2 + 1) * 'esize <= 'datasize)));
        match rot {
          0b00 => {
              assert(constraint(('loop_e * 2 >= 0 & ('loop_e * 2 + 1) * 'esize <= 'datasize)));
              element1 = aget_Elem(operand2, index * 2, esize);
              element2 = aget_Elem(operand1, e * 2, esize);
              element3 = aget_Elem(operand2, index * 2 + 1, esize);
              element4 = aget_Elem(operand1, e * 2, esize)
          },
          0b01 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              element1 = FPNeg(aget_Elem(operand2, index * 2 + 1, esize));
              element2 = aget_Elem(operand1, e * 2 + 1, esize);
              element3 = aget_Elem(operand2, index * 2, esize);
              element4 = aget_Elem(operand1, e * 2 + 1, esize)
          },
          0b10 => {
              assert(constraint(('loop_e * 2 >= 0 & ('loop_e * 2 + 1) * 'esize <= 'datasize)));
              element1 = FPNeg(aget_Elem(operand2, index * 2, esize));
              element2 = aget_Elem(operand1, e * 2, esize);
              element3 = FPNeg(aget_Elem(operand2, index * 2 + 1, esize));
              element4 = aget_Elem(operand1, e * 2, esize)
          },
          0b11 => {
              assert(constraint(('loop_e * 2 + 1 >= 0 & ('loop_e * 2 + 1 + 1) * 'esize <= 'datasize)));
              element1 = aget_Elem(operand2, index * 2 + 1, esize);
              element2 = aget_Elem(operand1, e * 2 + 1, esize);
              element3 = FPNeg(aget_Elem(operand2, index * 2, esize));
              element4 = aget_Elem(operand1, e * 2 + 1, esize)
          }
        };
        result = aset_Elem(result, e * 2, esize, FPMulAdd(aget_Elem(operand3, e * 2, esize), element2, element1, FPCR));
        result = aset_Elem(result, e * 2 + 1, esize, FPMulAdd(aget_Elem(operand3, e * 2 + 1, esize), element4, element3, FPCR))
    };
    V(d) = result
}

val vector_arithmetic_binary_element_mulacc_complex_decode : (bits(5), bits(5), bits(1), bits(2), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_mulacc_complex_decode (Rd, Rn, H, rot, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    if ~(HaveFCADDExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    index : int = undefined : int;
    if size == 0b01 then {
        index = UInt(H @ L)
    };
    if size == 0b10 then {
        index = UInt(H)
    };
    let 'index = index;
    let 'esize = shl_int(8, UInt(size));
    if ~(HaveFP16Ext()) & esize == 16 then {
        throw(Error_Undefined())
    };
    let 'datasize : {|128, 64|} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    if size == 0b10 & (L == 0b1 | Q == 0b0) then {
        throw(Error_Undefined())
    };
    if (size == 0b01 & H == 0b1) & Q == 0b0 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    assert(index * 2 >= 0 & esize >= 0 & (index * 2 + 2) * esize <= datasize);
    vector_arithmetic_binary_element_mulacc_complex(d, datasize, elements, esize, index, m, n, rot)
}

val vector_arithmetic_binary_element_dotp : forall 'd 'datasize 'elements 'esize 'index 'm 'n ('signed : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), bool('signed)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_element_dotp (d, datasize, elements, esize, index, m, n, signed) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits(128) = V(m);
    result : bits('datasize) = V(d);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        res : int = 0;
        element1 : int = undefined : int;
        element2 : int = undefined : int;
        foreach (i from 0 to 3 by 1 in inc) {
            if signed then {
                assert(constraint((4 * 'index + 'loop_i >= 0 & div('esize, 4) >= 0 & (4 * 'index + 'loop_i + 1) * div('esize, 4) <= 128 | not('signed))));
                assert(constraint((4 * 'loop_e + 'loop_i >= 0 & div('esize, 4) >= 0 & (4 * 'loop_e + 'loop_i + 1) * div('esize, 4) <= 'datasize | not('signed))));
                element1 = SInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                element2 = SInt(aget_Elem(operand2, 4 * index + i, esize / 4))
            } else {
                assert(constraint((4 * 'index + 'loop_i >= 0 & div('esize, 4) >= 0 & (4 * 'index + 'loop_i + 1) * div('esize, 4) <= 128 | not(not('signed)))));
                assert(constraint((4 * 'loop_e + 'loop_i >= 0 & div('esize, 4) >= 0 & (4 * 'loop_e + 'loop_i + 1) * div('esize, 4) <= 'datasize | not(not('signed)))));
                element1 = UInt(aget_Elem(operand1, 4 * e + i, esize / 4));
                element2 = UInt(aget_Elem(operand2, 4 * index + i, esize / 4))
            };
            res = res + element1 * element2
        };
        result = aset_Elem(result, e, esize, aget_Elem(result, e, esize) + res)
    };
    V(d) = result
}

val vector_arithmetic_binary_element_dotp_decode__0 : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

val vector_arithmetic_binary_element_dotp_decode__1 : (bits(5), bits(5), bits(1), bits(4), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

overload vector_arithmetic_binary_element_dotp_decode = {
  vector_arithmetic_binary_element_dotp_decode__0,
  vector_arithmetic_binary_element_dotp_decode__1
}

function vector_arithmetic_binary_element_dotp_decode__0 (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'index = UInt(H @ L);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_element_dotp(d, datasize, elements, esize, index, m, n, signed)
}

function vector_arithmetic_binary_element_dotp_decode__1 (Rd, Rn, H, opcode, Rm, M, L, size, U, Q) = {
    __unconditional = true;
    if ~(HaveDOTPExt()) then {
        throw(Error_Undefined())
    };
    if size != 0b10 then {
        throw(Error_Undefined())
    };
    let signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'index = UInt(H @ L);
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_element_dotp(d, datasize, elements, esize, index, m, n, signed)
}

val vector_arithmetic_binary_disparate_mul_product : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_product (d, datasize, elements, esize, m, n, part, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('datasize) = Vpart(m, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        result = aset_Elem(result, e, 2 * esize, __GetSlice_int(2 * esize, element1 * element2, 0))
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_mul_product_decode : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_product_decode (Rd, Rn, opcode_0_, opcode_1_, opcode_2_, opcode_3_, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_mul_product(d, datasize, elements, esize, m, n, part, unsigned)
}

val vector_arithmetic_binary_disparate_mul_poly : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_poly (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('datasize) = Vpart(m, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : bits('esize) = undefined : bits('esize);
    element2 : bits('esize) = undefined : bits('esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = aget_Elem(operand1, e, esize);
        element2 = aget_Elem(operand2, e, esize);
        result = aset_Elem(result, e, 2 * esize, PolynomialMult(element1, element2))
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_mul_poly_decode : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_poly_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b01 | size == 0b10 then {
        throw(Error_Undefined())
    };
    if size == 0b11 & ~(HaveBit128PMULLExt()) then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_disparate_mul_poly(d, datasize, elements, esize, m, n, part)
}

val vector_arithmetic_binary_disparate_mul_double_sisd : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_double_sisd (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('datasize) = Vpart(m, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    sat : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        element2 = SInt(aget_Elem(operand2, e, esize));
        (product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
        result = aset_Elem(result, e, 2 * esize, product);
        if sat then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_mul_double_sisd_decode : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_double_sisd_decode (Rd, Rn, opcode, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    __PostDecode();
    vector_arithmetic_binary_disparate_mul_double_sisd(d, datasize, elements, esize, m, n, part)
}

val vector_arithmetic_binary_disparate_mul_double_simd_decode : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_double_simd_decode (Rd, Rn, opcode, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    __PostDecode();
    vector_arithmetic_binary_disparate_mul_double_sisd(d, datasize, elements, esize, m, n, part)
}

val vector_arithmetic_binary_disparate_mul_dmacc_sisd : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_dmacc_sisd (d, datasize, elements, esize, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('datasize) = Vpart(m, part);
    let operand3 : bits(2 * 'datasize) = V(d);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    accum : int = undefined : int;
    sat1 : bool = undefined : bool;
    sat2 : bool = undefined : bool;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = SInt(aget_Elem(operand1, e, esize));
        element2 = SInt(aget_Elem(operand2, e, esize));
        (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
        if sub_op then {
            accum = SInt(aget_Elem(operand3, e, 2 * esize)) - SInt(product)
        } else {
            accum = SInt(aget_Elem(operand3, e, 2 * esize)) + SInt(product)
        };
        __tc1 : bits(2 * 'esize) = undefined : bits(2 * 'esize);
        (__tc1, sat2) = SignedSatQ(accum, 2 * esize);
        result = aset_Elem(result, e, 2 * esize, __tc1);
        if sat1 | sat2 then {
            FPSR = __SetSlice_bits(32, 1, FPSR, 27, 0b1)
        }
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_mul_dmacc_sisd_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_dmacc_sisd_decode (Rd, Rn, o1, Rm, size, U) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 'esize. int('n)} = esize;
    let 'elements : {'n, 'n == 1. int('n)} = 1;
    let 'part : {'n, 'n == 0. int('n)} = 0;
    let sub_op : bool = o1 == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

val vector_arithmetic_binary_disparate_mul_dmacc_simd_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_dmacc_simd_decode (Rd, Rn, o1, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o1 == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

val vector_arithmetic_binary_disparate_mul_accum : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool) ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_accum (d, datasize, elements, esize, m, n, part, sub_op, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('datasize) = Vpart(m, part);
    let operand3 : bits(2 * 'datasize) = V(d);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    product : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    accum : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        product = __GetSlice_int(2 * esize, element1 * element2, 0);
        if sub_op then {
            accum = aget_Elem(operand3, e, 2 * esize) - product
        } else {
            accum = aget_Elem(operand3, e, 2 * esize) + product
        };
        result = aset_Elem(result, e, 2 * esize, accum)
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_mul_accum_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_mul_accum_decode (Rd, Rn, o1, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o1 == 0b1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, unsigned)
}

val vector_arithmetic_binary_disparate_diff : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize 'm 'n 'part ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31 | not('accumulate)) & ('d >= 0 & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_diff (accumulate, d, datasize, elements, esize, m, n, part, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('datasize) = Vpart(m, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    absdiff : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    result = if accumulate then V(d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        absdiff = __GetSlice_int(2 * esize, abs(element1 - element2), 0);
        result = aset_Elem(result, e, 2 * esize, aget_Elem(result, e, 2 * esize) + absdiff)
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_diff_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_diff_decode (Rd, Rn, op, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let accumulate : bool = op == 0b0;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, unsigned)
}

val vector_arithmetic_binary_disparate_addsub_wide : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool) ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31 & 'part in {0, 1}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_addsub_wide (d, datasize, elements, esize, m, n, part, sub_op, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(2 * 'datasize) = V(n);
    let operand2 : bits('datasize) = Vpart(m, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    sum : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, 2 * esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        result = aset_Elem(result, e, 2 * esize, __GetSlice_int(2 * esize, sum, 0))
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_addsub_wide_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_addsub_wide_decode (Rd, Rn, o1, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o1 == 0b1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_addsub_wide(d, datasize, elements, esize, m, n, part, sub_op, unsigned)
}

val vector_arithmetic_binary_disparate_addsub_narrow : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('round : Bool) ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31 & 'part in {0, 1}).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('round), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_addsub_narrow (d, datasize, elements, esize, m, n, part, round, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(2 * 'datasize) = V(n);
    let operand2 : bits(2 * 'datasize) = V(m);
    result : bits('datasize) = undefined : bits('datasize);
    let 'round_const = if round then shl_int(1, esize - 1) else 0;
    element1 : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    element2 : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    sum : bits(2 * 'esize) = undefined : bits(2 * 'esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 2 * 'esize >= 0 & ('loop_e + 1) * (2 * 'esize) <= 2 * 'datasize)));
        element1 = aget_Elem(operand1, e, 2 * esize);
        element2 = aget_Elem(operand2, e, 2 * esize);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        sum = sum + round_const;
        result = aset_Elem(result, e, esize, slice(sum, esize, esize))
    };
    Vpart(d, part) = result
}

val vector_arithmetic_binary_disparate_addsub_narrow_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_addsub_narrow_decode (Rd, Rn, o1, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_addsub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

val vector_arithmetic_binary_disparate_addsub_long : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool) ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'part in {0, 1}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_addsub_long (d, datasize, elements, esize, m, n, part, sub_op, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart(n, part);
    let operand2 : bits('datasize) = Vpart(m, part);
    result : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    element1 : int = undefined : int;
    element2 : int = undefined : int;
    sum : int = undefined : int;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint(('loop_e >= 0 & 'esize >= 0 & ('loop_e + 1) * 'esize <= 'datasize)));
        element1 = asl_Int(aget_Elem(operand1, e, esize), unsigned);
        element2 = asl_Int(aget_Elem(operand2, e, esize), unsigned);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        result = aset_Elem(result, e, 2 * esize, __GetSlice_int(2 * esize, sum, 0))
    };
    V(d) = result
}

val vector_arithmetic_binary_disparate_addsub_long_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function vector_arithmetic_binary_disparate_addsub_long_decode (Rd, Rn, o1, Rm, size, U, Q) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    };
    let 'esize = shl_int(8, UInt(size));
    let 'datasize : {'n, 'n == 64. int('n)} = 64;
    let 'part = UInt(Q);
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    let sub_op : bool = o1 == 0b1;
    let unsigned : bool = U == 0b1;
    __PostDecode();
    vector_arithmetic_binary_disparate_addsub_long(d, datasize, elements, esize, m, n, part, sub_op, unsigned)
}

val float_move_fp_select : forall 'd 'datasize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (bits(4), int('d), int('datasize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function float_move_fp_select (condition, d, datasize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let result : bits('datasize) = if ConditionHolds(condition) then V(n) else V(m);
    V(d) = result
}

val float_move_fp_select_decode : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_move_fp_select_decode (Rd, Rn, cond, Rm, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let condition : vector(4, dec, bit) = cond;
    __PostDecode();
    float_move_fp_select(condition, d, datasize, m, n)
}

val float_move_fp_imm : forall 'd 'datasize,
  'datasize >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), bits('datasize)) -> unit effect {escape, rreg, undef, wreg}

function float_move_fp_imm (d, datasize, imm) = {
    CheckFPAdvSIMDEnabled64();
    V(d) = imm
}

val float_move_fp_imm_decode : (bits(5), bits(5), bits(8), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_move_fp_imm_decode (Rd, imm5, imm8, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    let imm : bits('datasize) = VFPExpandImm(imm8);
    __PostDecode();
    float_move_fp_imm(d, datasize, imm)
}

val float_convert_int : forall 'd 'fltsize 'intsize 'n 'part ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & 'fltsize >= 0 & ('d >= 0 & 'd <= 31) & 'intsize in {8, 16, 32, 64} & 'part in {0, 1}.
  (int('d), int('fltsize), int('intsize), int('n), FPConvOp, int('part), FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function float_convert_int (d, fltsize, intsize, n, op, part, rounding, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    fltval : bits('fltsize) = undefined : bits('fltsize);
    intval : bits('intsize) = undefined : bits('intsize);
    match op {
      FPConvOp_CVT_FtoI => {
          fltval = V(n);
          intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
          X(d) = intval
      },
      FPConvOp_CVT_ItoF => {
          intval = X(n);
          fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
          V(d) = fltval
      },
      FPConvOp_MOV_FtoI => {
          fltval = Vpart(n, part);
          intval = ZeroExtend(fltval, intsize);
          X(d) = intval
      },
      FPConvOp_MOV_ItoF => {
          intval = X(n);
          fltval = slice(intval, 0, fltsize);
          Vpart(d, part) = fltval
      },
      FPConvOp_CVT_FtoI_JS => {
          fltval = V(n);
          intval = FPToFixedJS(fltval, FPCR, true);
          X(d) = ZeroExtend(slice(intval, 0, 32), 64)
      }
    };
    let intval = intval;
    let fltval = fltval;
    ()
}

val float_convert_int_decode : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_convert_int_decode (Rd, Rn, opcode, rmode, typ, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize : {|64, 32|} = if sf == 0b1 then 64 else 32;
    fltsize : int = undefined : int;
    op : FPConvOp = undefined : FPConvOp;
    rounding : FPRounding = undefined : FPRounding;
    unsigned : bool = undefined : bool;
    part : int = undefined : int;
    match typ {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (slice(opcode, 1, 2) @ rmode) != 0xD then {
              throw(Error_Undefined())
          };
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match slice(opcode, 1, 2) @ rmode {
      [bitzero] @ [bitzero] @ _ : bits(1) @ _ : bits(1) => {
          rounding = FPDecodeRounding(rmode);
          unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0x4 => {
          rounding = FPRoundingMode(FPCR);
          unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0x8 => {
          rounding = FPRounding_TIEAWAY;
          unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0xC => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0xD => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          };
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      0xF => {
          if ~(HaveFJCVTZSExt()) then {
              throw(Error_Undefined())
          };
          rounding = FPRounding_ZERO;
          unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI_JS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    __PostDecode();
    let 'fltsize = fltsize;
    let 'part = part;
    assert(constraint(('part in {0, 1} & 'fltsize >= 0)));
    float_convert_int(d, fltsize, intsize, n, op, part, rounding, unsigned)
}

val float_convert_fp : forall 'd 'dstsize 'n 'srcsize,
  ('n >= 0 & 'n <= 31 & 'srcsize >= 0 & 'd >= 0 & 'd <= 31).
  (int('d), int('dstsize), int('n), int('srcsize)) -> unit effect {escape, rreg, undef, wreg}

function float_convert_fp (d, dstsize, n, srcsize) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('srcsize) = aget_V(n);
    let result : bits('dstsize) = FPConvert(operand, FPCR);
    aset_V(d, result)
}

val float_convert_fp_decode : (bits(5), bits(5), bits(2), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_convert_fp_decode (Rd, Rn, opc, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if typ == opc then {
        throw(Error_Undefined())
    };
    srcsize : int = undefined : int;
    match typ {
      0b00 => {
          srcsize = 32
      },
      0b01 => {
          srcsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          srcsize = 16
      }
    };
    dstsize : int = undefined : int;
    match opc {
      0b00 => {
          dstsize = 32
      },
      0b01 => {
          dstsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          dstsize = 16
      }
    };
    __PostDecode();
    let 'srcsize = srcsize;
    let 'dstsize = dstsize;
    assert(constraint(('srcsize in {16, 32, 64} & 'dstsize in {16, 32, 64})));
    float_convert_fp(d, dstsize, n, srcsize)
}

val float_convert_fix : forall 'd 'fltsize 'fracbits 'intsize 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31) & ('fltsize >= 0 & 'fracbits >= 0) & ('d >= 0 & 'd <= 31) & 'intsize in {8, 16, 32, 64}.
  (int('d), int('fltsize), int('fracbits), int('intsize), int('n), FPConvOp, FPRounding, bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function float_convert_fix (d, fltsize, fracbits, intsize, n, op, rounding, unsigned) = {
    CheckFPAdvSIMDEnabled64();
    fltval : bits('fltsize) = undefined : bits('fltsize);
    intval : bits('intsize) = undefined : bits('intsize);
    match op {
      FPConvOp_CVT_FtoI => {
          fltval = V(n);
          intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
          X(d) = intval
      },
      FPConvOp_CVT_ItoF => {
          intval = X(n);
          fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
          V(d) = fltval
      }
    };
    let intval = intval;
    let fltval = fltval;
    ()
}

val float_convert_fix_decode : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_convert_fix_decode (Rd, Rn, scale, opcode, rmode, typ, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize : {|64, 32|} = if sf == 0b1 then 64 else 32;
    fltsize : int = undefined : int;
    op : FPConvOp = undefined : FPConvOp;
    rounding : FPRounding = undefined : FPRounding;
    unsigned : bool = undefined : bool;
    match typ {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    };
    let 'fracbits = 64 - UInt(scale);
    match slice(opcode, 1, 2) @ rmode {
      0x3 => {
          rounding = FPRounding_ZERO;
          unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0x4 => {
          rounding = FPRoundingMode(FPCR);
          unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    __PostDecode();
    let 'fltsize = fltsize;
    assert(constraint('fltsize in {16, 32, 64}));
    float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, unsigned)
}

val float_compare_uncond : forall ('cmp_with_zero : Bool) 'datasize 'm 'n ('signal_all_nans : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31 | not(not('cmp_with_zero))) & ('datasize >= 0 & 'datasize >= 0).
  (bool('cmp_with_zero), int('datasize), int('m), int('n), bool('signal_all_nans)) -> unit effect {escape, rreg, undef, wreg}

function float_compare_uncond (cmp_with_zero, datasize, m, n, signal_all_nans) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = if cmp_with_zero then FPZero(0b0) else V(m);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = FPCompare(operand1, operand2, signal_all_nans, FPCR)
}

val float_compare_uncond_decode : (bits(2), bits(5), bits(2), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_compare_uncond_decode (opc, Rn, op, Rm, typ, S, M) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let signal_all_nans : bool = [opc[1]] == 0b1;
    let cmp_with_zero : bool = [opc[0]] == 0b1;
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_compare_uncond(cmp_with_zero, datasize, m, n, signal_all_nans)
}

val float_compare_cond : forall 'datasize 'm 'n ('signal_all_nans : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('datasize >= 0 & 'datasize >= 0).
  (bits(4), int('datasize), bits(4), int('m), int('n), bool('signal_all_nans)) -> unit effect {escape, rreg, undef, wreg}

function float_compare_cond (condition, datasize, flags__arg, m, n, signal_all_nans) = {
    flags = flags__arg;
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    if ConditionHolds(condition) then {
        flags = FPCompare(operand1, operand2, signal_all_nans, FPCR)
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val float_compare_cond_decode : (bits(4), bits(1), bits(5), bits(4), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_compare_cond_decode (nzcv, op, Rn, cond, Rm, typ, S, M) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let signal_all_nans : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_compare_cond(condition, datasize, flags, m, n, signal_all_nans)
}

val float_arithmetic_unary : forall 'd 'datasize 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), FPUnaryOp, int('n)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_unary (d, datasize, fpop, n) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    let operand : bits('datasize) = V(n);
    match fpop {
      FPUnaryOp_MOV => {
          result = operand
      },
      FPUnaryOp_ABS => {
          result = FPAbs(operand)
      },
      FPUnaryOp_NEG => {
          result = FPNeg(operand)
      },
      FPUnaryOp_SQRT => {
          result = FPSqrt(operand, FPCR)
      }
    };
    let result = result;
    V(d) = result
}

val float_arithmetic_unary_decode : (bits(5), bits(5), bits(2), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_unary_decode (Rd, Rn, opc, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    fpop : FPUnaryOp = undefined : FPUnaryOp;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_unary(d, datasize, fpop, n)
}

val float_arithmetic_round_frint_32_64 : forall 'd 'datasize 'intsize 'n,
  ('n >= 0 & 'n <= 31) & ('datasize >= 0 & 'intsize in {32, 64}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('intsize), int('n), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_round_frint_32_64 (d, datasize, intsize, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    let operand : bits('datasize) = V(n);
    let result = FPRoundIntN(operand, FPCR, rounding, intsize);
    V(d) = result
}

val float_arithmetic_round_frint_32_64_decode : (bits(5), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_round_frint_32_64_decode (Rd, Rn, op, typ) = {
    __unconditional = true;
    if ~(HaveFrintExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      [bitone] @ _ : bits(1) => {
          throw(Error_Undefined())
      }
    };
    let 'intsize : {|32, 64|} = if [op[1]] == 0b0 then 32 else 64;
    let rounding : FPRounding = if [op[0]] == 0b0 then FPRounding_ZERO else FPRoundingMode(FPCR);
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_round_frint_32_64(d, datasize, intsize, n, rounding)
}

val float_arithmetic_round_frint : forall 'd 'datasize ('exact : Bool) 'n,
  ('n >= 0 & 'n <= 31) & 'datasize >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), bool('exact), int('n), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_round_frint (d, datasize, exact, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    let operand : bits('datasize) = V(n);
    let result = FPRoundInt(operand, FPCR, rounding, exact);
    V(d) = result
}

val float_arithmetic_round_frint_decode : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_round_frint_decode (Rd, Rn, rmode, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    exact : bool = false;
    rounding : FPRounding = undefined : FPRounding;
    match rmode {
      [bitzero] @ _ : bits(1) @ _ : bits(1) => {
          rounding = FPDecodeRounding(slice(rmode, 0, 2))
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

val float_arithmetic_mul_product : forall 'd 'datasize 'm 'n ('negated : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('datasize >= 0 & 'datasize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('negated)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_mul_product (d, datasize, m, n, negated) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    result = FPMul(operand1, operand2, FPCR);
    if negated then {
        result = FPNeg(result)
    };
    V(d) = result
}

val float_arithmetic_mul_product_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_mul_product_decode (Rd, Rn, op, Rm, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let negated : bool = op == 0b1;
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_mul_product(d, datasize, m, n, negated)
}

val float_arithmetic_mul_addsub : forall 'a 'd 'datasize 'm 'n ('op1_neg : Bool) ('opa_neg : Bool),
  ('a >= 0 & 'a <= 31) & ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('datasize >= 0 | not('opa_neg)) & ('datasize >= 0 | not('op1_neg)) & ('datasize >= 0 & 'datasize >= 0 & 'datasize >= 0) & ('d >= 0 & 'd <= 31).
  (int('a), int('d), int('datasize), int('m), int('n), bool('op1_neg), bool('opa_neg)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_mul_addsub (a, d, datasize, m, n, op1_neg, opa_neg) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    operanda : bits('datasize) = V(a);
    operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    if opa_neg then {
        operanda = FPNeg(operanda)
    };
    if op1_neg then {
        operand1 = FPNeg(operand1)
    };
    let result = FPMulAdd(operanda, operand1, operand2, FPCR);
    V(d) = result
}

val float_arithmetic_mul_addsub_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_mul_addsub_decode (Rd, Rn, Ra, o0, Rm, o1, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_mul_addsub(a, d, datasize, m, n, op1_neg, opa_neg)
}

val float_arithmetic_maxmin : forall 'd 'datasize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('datasize >= 0 & 'datasize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), FPMaxMinOp) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_maxmin (d, datasize, m, n, operation) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    match operation {
      FPMaxMinOp_MAX => {
          result = FPMax(operand1, operand2, FPCR)
      },
      FPMaxMinOp_MIN => {
          result = FPMin(operand1, operand2, FPCR)
      },
      FPMaxMinOp_MAXNUM => {
          result = FPMaxNum(operand1, operand2, FPCR)
      },
      FPMaxMinOp_MINNUM => {
          result = FPMinNum(operand1, operand2, FPCR)
      }
    };
    let result = result;
    V(d) = result
}

val float_arithmetic_maxmin_decode : (bits(5), bits(5), bits(2), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_maxmin_decode (Rd, Rn, op, Rm, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    operation : FPMaxMinOp = undefined : FPMaxMinOp;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_maxmin(d, datasize, m, n, operation)
}

val float_arithmetic_div : forall 'd 'datasize 'm 'n,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('datasize >= 0 & 'datasize >= 0) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_div (d, datasize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    let result = FPDiv(operand1, operand2, FPCR);
    V(d) = result
}

val float_arithmetic_div_decode : (bits(5), bits(5), bits(4), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_div_decode (Rd, Rn, opcode, Rm, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_div(d, datasize, m, n)
}

val float_arithmetic_addsub : forall 'd 'datasize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31) & ('datasize >= 0 & 'datasize >= 0 | not('sub_op)) & ('datasize >= 0 & 'datasize >= 0 | not(not('sub_op))) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_addsub (d, datasize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = V(n);
    let operand2 : bits('datasize) = V(m);
    if sub_op then {
        result = FPSub(operand1, operand2, FPCR)
    } else {
        result = FPAdd(operand1, operand2, FPCR)
    };
    V(d) = result
}

val float_arithmetic_addsub_decode : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function float_arithmetic_addsub_decode (Rd, Rn, op, Rm, typ, S, M) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : int = undefined : int;
    match typ {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let sub_op : bool = op == 0b1;
    __PostDecode();
    let 'datasize = datasize;
    assert(constraint('datasize in {16, 32, 64}));
    float_arithmetic_addsub(d, datasize, m, n, sub_op)
}

val AArch32_TakeReset : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeReset cold_reset = {
    assert(HighestELUsingAArch32());
    if HaveEL(EL3) then {
        AArch32_WriteMode(M32_Svc);
        __tc1 : bits(32) = get_SCR();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b0);
        set_SCR(__tc1)
    } else {
        if HaveEL(EL2) then {
            AArch32_WriteMode(M32_Hyp)
        } else {
            AArch32_WriteMode(M32_Svc)
        }
    };
    AArch32_ResetControlRegisters(cold_reset);
    __tc2 : bits(32) = get_FPEXC();
    let __tc2 = __SetSlice_bits(32, 1, __tc2, 30, 0b0);
    set_FPEXC(__tc2);
    (PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b111;
    PSTATE.IT = 0x00;
    PSTATE.T = [get_SCTLR()[30]];
    PSTATE.E = [get_SCTLR()[25]];
    PSTATE.IL = 0b0;
    AArch32_ResetGeneralRegisters();
    AArch32_ResetSIMDFPRegisters();
    AArch32_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);
    rv : bits(32) = undefined : bits(32);
    if HaveEL(EL3) then {
        if [MVBAR[0]] == 0b1 then {
            rv = slice(MVBAR, 1, 31) @ 0b0
        } else {
            rv = undefined
        }
    } else {
        rv = slice(RVBAR, 1, 31) @ 0b0
    };
    assert([rv[0]] == 0b0 & (PSTATE.T == 0b1 | [rv[1]] == 0b0));
    BranchTo(rv, BranchType_RESET)
}

val TakeReset : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function TakeReset cold = {
    assert(HighestEL() == EL1 | HighestEL() == EL2 | HighestEL() == EL3);
    EDSCR = __SetSlice_bits(32, 6, EDSCR, 0, 0b000010);
    if cold then {
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 12, CFG_ID_AA64PFR0_EL1_EL3);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 8, CFG_ID_AA64PFR0_EL1_EL2);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 4, CFG_ID_AA64PFR0_EL1_EL1);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 0, CFG_ID_AA64PFR0_EL1_EL0);
        RMR_EL3 = __SetSlice_bits(32, 1, RMR_EL3, 0, CFG_RMR_AA64)
    };
    if [RMR_EL3[0]] == 0b1 then {
        __highest_el_aarch32 = false;
        SetResetVector(CFG_RVBAR);
        AArch64_TakeReset(cold)
    } else {
        match HighestEL() {
          ? if ? == EL3 => {
              assert(slice(ID_AA64PFR0_EL1, 12, 4) == 0x2)
          },
          ? if ? == EL2 => {
              assert(slice(ID_AA64PFR0_EL1, 8, 4) == 0x2)
          },
          ? if ? == EL1 => {
              assert(slice(ID_AA64PFR0_EL1, 4, 4) == 0x2)
          }
        };
        __highest_el_aarch32 = true;
        SetResetVector(CFG_RVBAR);
        AArch32_TakeReset(cold)
    }
}

val __TakeColdReset : unit -> unit effect {escape, rreg, undef, wreg}

function __TakeColdReset () = {
    TakeReset(true)
}

val AArch32_EnterMode : forall ('lr_offset : Int) ('vect_offset : Int).
  (bits(5), bits(32), int('lr_offset), int('vect_offset)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_EnterMode (target_mode, preferred_exception_return, lr_offset, vect_offset) = {
    SynchronizeContext();
    assert(ELUsingAArch32(EL1) & PSTATE.EL != EL2);
    let spsr : vector(32, dec, bit) = GetPSRFromPSTATE();
    if PSTATE.M == M32_Monitor then {
        __tc1 : bits(32) = get_SCR();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b0);
        set_SCR(__tc1)
    };
    AArch32_WriteMode(target_mode);
    SPSR() = spsr;
    R(14) = preferred_exception_return + lr_offset;
    PSTATE.T = [get_SCTLR()[30]];
    PSTATE.SS = 0b0;
    if target_mode == M32_FIQ then {
        (PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b111
    } else {
        if target_mode == M32_Abort | target_mode == M32_IRQ then {
            (PSTATE.A @ PSTATE.I) = 0b11
        } else {
            PSTATE.I = 0b1
        }
    };
    PSTATE.E = [get_SCTLR()[25]];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0x00;
    if HavePANExt() & [get_SCTLR()[23]] == 0b0 then {
        PSTATE.PAN = 0b1
    };
    BranchTo(slice(ExcVectorBase(), 5, 27) @ __GetSlice_int(5, vect_offset, 0), BranchType_EXCEPTION);
    EndOfInstruction()
}

val AArch64_AutoGen_SysRegTrapFP : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_AutoGen_SysRegTrapFP (el, op0, op1, CRn, op2, CRm, read) = {
    let ___ELUsingAArch32_EL2_ : bool = ~(ELUsingAArch32(EL2));
    let __HCR_EL2_E2H : bits(1) = [HCR_EL2[34]];
    let ___ELUsingAArch32_EL3_ : bool = ~(ELUsingAArch32(EL3));
    let __HCR_EL2_TGE : bits(1) = [HCR_EL2[27]];
    let __CPTR_EL2_FPEN : bits(2) = slice(CPTR_EL2, 20, 2);
    let __CPTR_EL3_TFP : bits(1) = [CPTR_EL3[10]];
    let __SCR_EL3_EEL2 : bits(1) = [SCR_EL3[18]];
    let __SCR_EL3_NS : bits(1) = [SCR_EL3[0]];
    let __HCR_EL2_TID3 : bits(1) = [HCR_EL2[18]];
    let __CPTR_EL2_TFP : bits(1) = [CPTR_EL2[10]];
    let __CPACR_EL1_FPEN : bits(2) = slice(CPACR_EL1, 20, 2);
    let __HCR_EL2_NV : bits(1) = [HCR_EL2[42]];
    if op0 == 0b11 then {
        if CRm == 0x3 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b010 then {
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                            return((true, EL2))
                        }
                    } else {
                        if op2 == 0b000 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                return((true, EL2))
                            }
                        } else {
                            if op2 == 0b001 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if op1 == 0b100 then {
                        if CRn == 0x5 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TFP == 1) & el == EL2 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0b10) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b10) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TFP == 1) & (el == EL2 | el == EL3) then {
                                return((true, EL3))
                            }
                        }
                    }
                }
            }
        } else {
            if CRm == 0x4 then {
                if CRn == 0x4 then {
                    if op1 == 0b011 then {
                        if op2 == 0b000 then {
                            if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                return((true, EL2))
                            };
                            if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                return((true, EL1))
                            };
                            if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                return((true, EL2))
                            };
                            if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TFP == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b01) & el == EL0 then {
                                return((true, EL1))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b10) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0) & ((el == EL0 | el == EL1) | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0b10) & ((el == EL0 | el == EL1) | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0) & (el == EL0 | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b01) & el == EL0 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b10) & (el == EL0 | el == EL2) then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TFP == 1) & (((el == EL0 | el == EL1) | el == EL2) | el == EL3) then {
                                return((true, EL3))
                            }
                        } else {
                            if op2 == 0b001 then {
                                if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TFP == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b01) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b10) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0) & ((el == EL0 | el == EL1) | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0b10) & ((el == EL0 | el == EL1) | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0) & (el == EL0 | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b01) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b10) & (el == EL0 | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TFP == 1) & (((el == EL0 | el == EL1) | el == EL2) | el == EL3) then {
                                    return((true, EL3))
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    return((false, EL0))
}

val AArch64_CheckAdvSIMDFPSystemRegisterTraps : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_CheckAdvSIMDFPSystemRegisterTraps (op0, op1, crn, crm, op2, read) = {
    target_el : bits(2) = undefined : bits(2);
    trap : bool = undefined : bool;
    (trap, target_el) = AArch64_AutoGen_SysRegTrapFP(PSTATE.EL, op0, op1, crn, op2, crm, read);
    return((trap, target_el))
}

val AArch64_AutoGen_SysRegTrap : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_AutoGen_SysRegTrap (el, op0, op1, CRn, op2, CRm, read) = {
    let __CNTHCTL_EL2_EL0PCTEN : vector(1, dec, bit) = [CNTHCTL_EL2[0]];
    let __HaveEL_EL3_ : bool = HaveEL(EL3);
    let __HCR_EL2_EnSCXT : vector(1, dec, bit) = [HCR_EL2[53]];
    let __SCTLR_EL1_EnRCTX : vector(1, dec, bit) = [SCTLR_EL1[10]];
    let __MDCR_EL2_TPMCR : vector(1, dec, bit) = [MDCR_EL2[5]];
    let __ICC_SRE_EL2_SRE : vector(1, dec, bit) = [ICC_SRE_EL2[0]];
    let __EDSCR_TDA : vector(1, dec, bit) = [EDSCR[21]];
    let __MDCR_EL2_TDOSA : vector(1, dec, bit) = [MDCR_EL2[10]];
    let __CNTKCTL_EL1_EL0VTEN : vector(1, dec, bit) = [CNTKCTL_EL1[8]];
    let __CNTHCTL_EL2_EL0VCTEN : vector(1, dec, bit) = [CNTHCTL_EL2[1]];
    let __HCR_EL2_TACR : vector(1, dec, bit) = [HCR_EL2[21]];
    let __SCR_EL3_EnSCXT : vector(1, dec, bit) = [SCR_EL3[25]];
    let __MDCR_EL2_TTRF : vector(1, dec, bit) = [MDCR_EL2[19]];
    let __CNTKCTL_EL1_EL0PCTEN : vector(1, dec, bit) = [CNTKCTL_EL1[0]];
    let __SCTLR_EL2_EnRCTX : vector(1, dec, bit) = [SCTLR_EL2[10]];
    let __MPAM2_EL2_TRAPMPAM0EL1 : vector(1, dec, bit) = [MPAM2_EL2[49]];
    let __MDCR_EL3_TDA : vector(1, dec, bit) = [MDCR_EL3[9]];
    let __HCR_EL2_TID1 : vector(1, dec, bit) = [HCR_EL2[16]];
    let __HCR_EL2_TID2 : vector(1, dec, bit) = [HCR_EL2[17]];
    let __HCR_EL2_TID3 : vector(1, dec, bit) = [HCR_EL2[18]];
    let __MDCR_EL2_TPM : vector(1, dec, bit) = [MDCR_EL2[6]];
    let __CNTHCTL_EL2_EL1PCTEN : vector(1, dec, bit) = [CNTHCTL_EL2[if [HCR_EL2[34]] == 0 then 0 else 10]];
    let __MPAM2_EL2_TRAPMPAM1EL1 : vector(1, dec, bit) = [MPAM2_EL2[48]];
    let __SCR_EL3_TLOR : vector(1, dec, bit) = [SCR_EL3[14]];
    let __SCTLR___UCT : vector(1, dec, bit) = [SCTLR()[15]];
    let __SCTLR___UCI : vector(1, dec, bit) = [SCTLR()[26]];
    let __HCR_EL2_AT : vector(1, dec, bit) = [HCR_EL2[44]];
    let __SCR_EL3_EEL2 : vector(1, dec, bit) = [SCR_EL3[18]];
    let __MDCR_EL3_TDOSA : vector(1, dec, bit) = [MDCR_EL3[10]];
    let __HCR_EL2_IMO : vector(1, dec, bit) = [HCR_EL2[4]];
    let __HCR_EL2_TRVM : vector(1, dec, bit) = [HCR_EL2[30]];
    let __HCR_EL2_NV : vector(1, dec, bit) = [HCR_EL2[42]];
    let __MDCR_EL2_TDA : vector(1, dec, bit) = [MDCR_EL2[9]];
    let __CNTHCTL_EL2_EL0VTEN : vector(1, dec, bit) = [CNTHCTL_EL2[8]];
    let __HCR_EL2_NV1 : vector(1, dec, bit) = [HCR_EL2[43]];
    let __HCR_EL2_NV2 : vector(1, dec, bit) = [HCR_EL2[45]];
    let __HCR_EL2_E2H : vector(1, dec, bit) = [HCR_EL2[34]];
    let __MDCR_EL3_TPM : vector(1, dec, bit) = [MDCR_EL3[6]];
    let __SCTLR_EL1_UCI : vector(1, dec, bit) = [SCTLR_EL1[26]];
    let __SCR_EL3_NS : vector(1, dec, bit) = [SCR_EL3[0]];
    let __MDCR_EL2_TDRA : vector(1, dec, bit) = [MDCR_EL2[11]];
    let __HCR_EL2_TDZ : vector(1, dec, bit) = [HCR_EL2[28]];
    let __ICH_HCR_EL2_TC : vector(1, dec, bit) = [ICH_HCR_EL2[10]];
    let __ICC_SRE_EL1_SRE : vector(1, dec, bit) = [get_ICC_SRE_EL1()[0]];
    let __HCR_EL2_FMO : vector(1, dec, bit) = [HCR_EL2[3]];
    let __CNTKCTL_EL1_EL0VCTEN : vector(1, dec, bit) = [CNTKCTL_EL1[1]];
    let __SCR_EL3_IRQ : vector(1, dec, bit) = [SCR_EL3[1]];
    let __SCTLR_EL2_UCI : vector(1, dec, bit) = [SCTLR_EL2[26]];
    let __MPAMIDR_EL1_HAS_HCR : vector(1, dec, bit) = [MPAMIDR_EL1[17]];
    let __CNTKCTL_EL1_EL0PTEN : vector(1, dec, bit) = [CNTKCTL_EL1[9]];
    let ___ELUsingAArch32_EL3_ : bool = ~(ELUsingAArch32(EL3));
    let __PMUSERENR_EL0_ER : vector(1, dec, bit) = [PMUSERENR_EL0[3]];
    let __PMUSERENR_EL0_EN : vector(1, dec, bit) = [PMUSERENR_EL0[0]];
    let __SCR_EL3_ST : vector(1, dec, bit) = [SCR_EL3[11]];
    let __CPTR_EL2_TCPAC : vector(1, dec, bit) = [CPTR_EL2[31]];
    let __MPAM3_EL3_TRAPLOWER : vector(1, dec, bit) = [MPAM3_EL3[62]];
    let __ICC_SRE_EL3_Enable : vector(1, dec, bit) = [ICC_SRE_EL3[3]];
    let __CNTHCTL_EL2_EL1PCEN : vector(1, dec, bit) = [CNTHCTL_EL2[1]];
    let __HCR_EL2_TGE : vector(1, dec, bit) = [HCR_EL2[27]];
    let __HCR_EL2_TVM : vector(1, dec, bit) = [HCR_EL2[26]];
    let __ICC_SRE_EL2_Enable : vector(1, dec, bit) = [ICC_SRE_EL2[3]];
    let __MPAMHCR_EL2_TRAP_MPAMIDR_EL1 : vector(1, dec, bit) = [MPAMHCR_EL2[31]];
    let __CNTHCTL_EL2_EL0PTEN : vector(1, dec, bit) = [CNTHCTL_EL2[9]];
    let __SCR_EL3_FIQ : vector(1, dec, bit) = [SCR_EL3[2]];
    let ___ELUsingAArch32_EL2_ : bool = ~(ELUsingAArch32(EL2));
    let __SCTLR___DZE : vector(1, dec, bit) = [SCTLR()[14]];
    let __ICH_HCR_EL2_TDIR : vector(1, dec, bit) = [ICH_HCR_EL2[14]];
    let __HSTR_EL2_T12 : vector(1, dec, bit) = [HSTR_EL2[12]];
    let __CNTHCTL_EL2_EL1PTEN : vector(1, dec, bit) = [CNTHCTL_EL2[11]];
    let __OSLSR_EL1_OSLK : vector(1, dec, bit) = [OSLSR_EL1[1]];
    let __PMUSERENR_EL0_SW : vector(1, dec, bit) = [PMUSERENR_EL0[1]];
    let __HCR_EL2_TLOR : vector(1, dec, bit) = [HCR_EL2[35]];
    let __HCR_EL2_TSW : vector(1, dec, bit) = [HCR_EL2[22]];
    let __HCR_EL2_TTLB : vector(1, dec, bit) = [HCR_EL2[25]];
    let __HCR_EL2_APK : vector(1, dec, bit) = [HCR_EL2[40]];
    let __SCR_EL3_APK : vector(1, dec, bit) = [SCR_EL3[16]];
    let __SCTLR_EL1_UMA : vector(1, dec, bit) = [SCTLR_EL1[9]];
    let __PMUSERENR_EL0_CR : vector(1, dec, bit) = [PMUSERENR_EL0[2]];
    let __HaveEL_EL2_ : bool = HaveEL(EL2);
    let __HCR_EL2_TPC : vector(1, dec, bit) = [HCR_EL2[23]];
    let __CPTR_EL3_TCPAC : vector(1, dec, bit) = [CPTR_EL3[31]];
    let __HCR_EL2_TPU : vector(1, dec, bit) = [HCR_EL2[24]];
    let __SCTLR___TSCXT : vector(1, dec, bit) = [SCTLR()[20]];
    let __ICC_SRE_EL3_SRE : vector(1, dec, bit) = [ICC_SRE_EL3[0]];
    let __MDSCR_EL1_TDCC : vector(1, dec, bit) = [MDSCR_EL1[12]];
    let __ICH_HCR_EL2_TALL0 : vector(1, dec, bit) = [ICH_HCR_EL2[11]];
    let __ICH_HCR_EL2_TALL1 : vector(1, dec, bit) = [ICH_HCR_EL2[12]];
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                            return((true, EL3))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                            return((true, EL3))
                        }
                    } else {
                        if op2 == 0b111 then {
                            if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                                return((true, EL3))
                            };
                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                return((true, EL3))
                            }
                        } else {
                            if op2 == 0b100 then {
                                if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                };
                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    };
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                            return((true, EL1))
                        };
                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                            return((true, EL2))
                        };
                        if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                            return((true, EL1))
                        };
                        if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                            return((true, EL3))
                        }
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                            return((true, EL1))
                        };
                        if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                            return((true, EL2))
                        };
                        if ((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                            return((true, EL3))
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                            return((true, EL1))
                        };
                        if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                            return((true, EL2))
                        };
                        if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                            return((true, EL3))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                            return((true, EL3))
                        };
                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2 then {
                            return((true, EL3))
                        };
                        if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1 then {
                            return((true, EL3))
                        };
                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                            return((true, EL1))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                            return((true, EL2))
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                            return((true, EL2))
                        };
                        if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                            return((true, EL3))
                        };
                        if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                            return((true, EL2))
                        }
                    } else {
                        if CRm == 0x9 then {
                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                return((true, EL2))
                            };
                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                return((true, EL3))
                            };
                            if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                return((true, EL1))
                            };
                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                return((true, EL2))
                            };
                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                return((true, EL3))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                return((true, EL3))
                            };
                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                return((true, EL3))
                            };
                            if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                return((true, EL3))
                            };
                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                return((true, EL1))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                return((true, EL2))
                            }
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op1 == 0b000 then {
            if CRn == 0x0 then {
                if CRm == 0x1 then {
                    if op2 == 0b010 then {
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                            return((true, EL2))
                        }
                    } else {
                        if op2 == 0b011 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                return((true, EL2))
                            }
                        } else {
                            if op2 == 0b000 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b111 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x2 then {
                        if op2 == 0b010 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                return((true, EL2))
                            }
                        } else {
                            if op2 == 0b011 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b101 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b000 then {
                            if CRm == 0x5 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x4 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x6 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x7 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if CRm == 0x5 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x4 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b100 then {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b010 then {
                                        if CRm == 0x7 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if op2 == 0b110 then {
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if op2 == 0b101 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRn == 0x1 then {
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xA then {
                            if CRm == 0x2 then {
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x5 then {
                                    if __MPAM3_EL3_TRAPLOWER == 1 & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    };
                                    if __MPAM2_EL2_TRAPMPAM1EL1 == 1 & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x4 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x1 then {
                                if CRn == 0xE then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xC then {
                                    if CRm == 0x8 then {
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xC then {
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0x5 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x6 then {
                                                if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                    return((true, EL1))
                                                };
                                                if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                    return((true, EL2))
                                                };
                                                if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                    return((true, EL3))
                                                };
                                                if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                    return((true, EL1))
                                                };
                                                if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if CRn == 0x6 then {
                                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if CRm == 0x3 then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0xC then {
                        if CRm == 0xC then {
                            if op2 == 0b010 then {
                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                    return((true, EL1))
                                };
                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                    return((true, EL3))
                                };
                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                    return((true, EL3))
                                };
                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                    return((true, EL3))
                                };
                                if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 1 then {
                                    return((true, EL3))
                                };
                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                    return((true, EL1))
                                };
                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if __ICC_SRE_EL1_SRE == 0 & (el == EL1 | el == EL1) then {
                                        throw(Error_Undefined())
                                    };
                                    if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                        return((true, EL2))
                                    };
                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                        return((true, EL3))
                                    };
                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                        return((true, EL3))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                        return((true, EL3))
                                    };
                                    if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                        return((true, EL3))
                                    };
                                    if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                        return((true, EL1))
                                    };
                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b101 then {
                                        if (__HaveEL_EL3_ & __ICC_SRE_EL3_Enable == 0) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __HaveEL_EL2_) & __ICC_SRE_EL2_Enable == 0) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                return((true, EL2))
                                            };
                                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                return((true, EL3))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                        return((true, EL1))
                                                    };
                                                    if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                        return((true, EL2))
                                                    };
                                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                        return((true, EL3))
                                                    };
                                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                        return((true, EL1))
                                                    };
                                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                            return((true, EL1))
                                                        };
                                                        if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                            return((true, EL2))
                                                        };
                                                        if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                            return((true, EL3))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                                                            return((true, EL3))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2 then {
                                                            return((true, EL3))
                                                        };
                                                        if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                            return((true, EL3))
                                                        };
                                                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                            return((true, EL1))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0xB then {
                                if op2 == 0b101 then {
                                    if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                        return((true, EL1))
                                    };
                                    if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                        return((true, EL3))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                        return((true, EL3))
                                    };
                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                        return((true, EL3))
                                    };
                                    if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                return((true, EL1))
                                            };
                                            if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TDIR == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TDIR == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                        return((true, EL1))
                                                    };
                                                    if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x8 then {
                                    if op2 == 0b010 then {
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                return((true, EL2))
                                            };
                                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                return((true, EL3))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b001 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x5 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            };
                                            if __MPAM2_EL2_TRAPMPAM0EL1 == 1 & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x1 then {
                                                    if (((__HaveEL_EL2_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __MDCR_EL2_TTRF == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__HaveEL_EL2_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __MDCR_EL2_TTRF == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x9 then {
                                                    if CRm == 0xE then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0x1 then {
                                            if ((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if ((true & ___ELUsingAArch32_EL3_) & __CPTR_EL3_TCPAC == 1) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xE then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if CRn == 0x2 then {
                                        if CRm == 0x2 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0xA then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if (__MPAM3_EL3_TRAPLOWER == 1 & (el == EL2 | el == EL1)) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((__MPAMIDR_EL1_HAS_HCR == 1 & __MPAMHCR_EL2_TRAP_MPAMIDR_EL1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if __HCR_EL2_EnSCXT == 0 & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__HCR_EL2_EnSCXT == 1 & __SCR_EL3_EnSCXT == 0) & (el == EL1 | el == EL2) then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if __SCR_EL3_EnSCXT == 0 & el == EL2 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if CRm == 0xE then {
                                                    if op2 == 0b110 then {
                                                        if ((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__HaveEL_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op1 == 0b100 then {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRn == 0x4 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x3 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x6 then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x0 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xA then {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                            return((true, EL3))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xE then {
                                    if CRm == 0x2 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                return((true, EL2))
                                            };
                                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                return((true, EL3))
                                            };
                                            if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if CRm == 0x2 then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0x2 then {
                                                            if (((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0x5 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL2 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                    return((true, EL3))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x1 then {
                                                    if (((__HaveEL_EL2_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __HCR_EL2_NV == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xD then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if CRn == 0xA then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if (((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRn == 0xC then {
                                    if CRm == 0xB then {
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0xE then {
                                            if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x6 then {
                                        if op2 == 0b101 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                            return((true, EL3))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op2 == 0b101 then {
                                            if CRm == 0xB then {
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if CRm == 0x9 then {
                                                    if __ICC_SRE_EL3_Enable == 0 & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xB then {
                                                if op2 == 0b111 then {
                                                    if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                        return((true, EL2))
                                                    };
                                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0xD then {
                                                if op2 == 0b111 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if __SCR_EL3_EnSCXT == 0 & el == EL2 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b101 then {
                                                    if CRn == 0x0 then {
                                                        if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                } else {
                                                    if CRn == 0x6 then {
                                                        if op2 == 0b100 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if op2 == 0b111 then {
                                                    if CRn == 0x1 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b101 then {
                    if op2 == 0b000 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x4 then {
                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x6 then {
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0xE then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if CRn == 0x6 then {
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xA then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                };
                                                if __MPAM2_EL2_TRAPMPAM1EL1 == 1 & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if CRn == 0xE then {
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b001 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0xD then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & __HaveEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __HCR_EL2_NV == 1) & (__HCR_EL2_NV1 == 1 | __HCR_EL2_NV2 == 0)) & true) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x3 then {
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRm == 0x0 then {
                                    if CRn == 0x1 then {
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                            return((true, EL3))
                                        };
                                        if (((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & ___ELUsingAArch32_EL3_) & __CPTR_EL3_TCPAC == 1) & el == EL1 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op2 == 0b111 then {
                                        if CRn == 0xD then {
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if __HCR_EL2_EnSCXT == 0 & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (__HCR_EL2_EnSCXT == 1 & __SCR_EL3_EnSCXT == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0x9 then {
                            if CRm == 0xC then {
                                if op2 == 0b010 then {
                                    if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if op2 == 0b000 then {
                                            if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPMCR == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b101 then {
                                                if ((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                        return((true, EL3))
                                                    }
                                                } else {
                                                    if op2 == 0b100 then {
                                                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_SW == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_SW == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 0 then {
                                                            return((true, EL3))
                                                        }
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                                return((true, EL1))
                                                            };
                                                            if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                                return((true, EL2))
                                                            };
                                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                                return((true, EL3))
                                                            }
                                                        } else {
                                                            if op2 == 0b110 then {
                                                                if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                                    return((true, EL1))
                                                                };
                                                                if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                                    return((true, EL3))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xD then {
                                    if op2 == 0b010 then {
                                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                            return((true, EL1))
                                        };
                                        if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if op2 == 0b000 then {
                                            if (((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                                return((true, EL1))
                                            };
                                            if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0xE then {
                                        if op2 == 0b000 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if op2 == 0b010 then {
                                    if CRm == 0x2 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if ((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x2 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if (((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PCTEN == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PCTEN == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & __CNTHCTL_EL2_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if CRm == 0x2 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x0 then {
                                                    if ((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & __CNTKCTL_EL1_EL0PCTEN == 1) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & __CNTKCTL_EL1_EL0PCTEN == 1) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRm == 0xF then {
                                                    if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op2 == 0b111 then {
                                        if CRn == 0xD then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if __SCTLR___TSCXT == 1 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (__SCTLR___TSCXT == 0 & __HCR_EL2_EnSCXT == 0) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if ((__SCTLR___TSCXT == 0 & __HCR_EL2_EnSCXT == 1) & __SCR_EL3_EnSCXT == 0) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if CRn == 0x0 then {
                                                if ((__SCTLR___UCT == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if (((__SCTLR___UCT == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0x4 then {
                                            if op2 == 0b001 then {
                                                if (__SCR_EL3_NS == 0 & __SCTLR_EL1_UMA == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __SCTLR_EL1_UMA == 0) & ~(__HCR_EL2_E2H == 1 & __HCR_EL2_TGE == 1)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if CRn == 0x0 then {
                                if op1 == 0b001 then {
                                    if op2 == 0b010 then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b000 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b010 then {
                                        if op2 == 0b000 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if op1 == 0b110 then {
                                    if CRm == 0xC then {
                                        if op2 == 0b101 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        if op1 == 0b111 then {
                                            if op2 == 0b010 then {
                                                if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_ST == 0) & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b000 then {
                                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_ST == 0) & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_ST == 0) & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b01 then {
            if CRn == 0x8 then {
                if op1 == 0b100 then {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRm == 0x1 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x7 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b101 then {
                            if CRm == 0x0 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x7 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x4 then {
                                if op2 == 0b010 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if CRm == 0x0 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            if CRm == 0x1 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x7 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b010 then {
                                                if CRm == 0x0 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x1 then {
                            if op2 == 0b010 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x3 then {
                                if op2 == 0b010 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x7 then {
                                    if op2 == 0b010 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b000 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b011 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b111 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if op2 == 0b101 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b011 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b111 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if op2 == 0b101 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b011 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b111 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        } else {
                                                            if op2 == 0b001 then {
                                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0x7 then {
                    if op1 == 0b000 then {
                        if CRm == 0x6 then {
                            if op2 == 0b010 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b000 then {
                                if CRm == 0x8 then {
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x9 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRm == 0x8 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xA then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0xE then {
                                        if op2 == 0b100 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b110 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0xA then {
                                            if op2 == 0b100 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x8 then {
                                                if op2 == 0b011 then {
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if CRm == 0x9 then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b011 then {
                            if op2 == 0b001 then {
                                if CRm == 0xE then {
                                    if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0xA then {
                                        if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xD then {
                                            if __SCTLR___UCI == 0 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0xB then {
                                                    if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x4 then {
                                                        if (__SCTLR___DZE == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((__SCTLR___DZE == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRm == 0xC then {
                                                            if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                                return((true, EL1))
                                                            };
                                                            if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if CRm == 0xA then {
                                        if __SCTLR___UCI == 0 & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if __SCTLR___DZE == 0 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if __SCTLR___UCI == 0 & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0xC then {
                                                    if __SCTLR___UCI == 0 & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b101 then {
                                        if CRm == 0xA then {
                                            if __SCTLR___UCI == 0 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0xE then {
                                                    if __SCTLR___UCI == 0 & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0xC then {
                                                        if __SCTLR___UCI == 0 & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            if CRm == 0x4 then {
                                                if __SCTLR___DZE == 0 & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRm == 0x3 then {
                                                    if ((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b100 then {
                                if CRm == 0x8 then {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b100 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b110 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op0 == 0b10 then {
                if op1 == 0b000 then {
                    if CRn == 0x1 then {
                        if op2 == 0b100 then {
                            if CRm == 0x0 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2)) & read == 0 then {
                                    return((true, EL3))
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x4 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b000 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDRA == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x0 then {
                            if op2 == 0b010 then {
                                if CRm == 0x2 then {
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL2 then {
                                        return((true, EL3))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL1 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if op2 == 0b000 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if op2 == 0b110 then {
                                    if CRm == 0x8 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0xE then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x9 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b000 then {
                        if CRn == 0x0 then {
                            if op1 == 0b011 then {
                                if CRm == 0x5 then {
                                    if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                        return((true, EL1))
                                    };
                                    if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    };
                                    if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                        return((true, EL1))
                                    };
                                    if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 0 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if (__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b100 then {
                                    if CRm == 0x7 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL2 then {
                                            return((true, EL3))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op0 == 0b00 then {
                    if CRn == 0x4 then {
                        if op1 == 0b011 then {
                            if op2 == 0b111 then {
                                if (__SCR_EL3_NS == 0 & __SCTLR_EL1_UMA == 0) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if ((__SCR_EL3_NS == 1 & __SCTLR_EL1_UMA == 0) & ~(__HCR_EL2_E2H == 1 & __HCR_EL2_TGE == 1)) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if ((__SCR_EL3_NS == 1 & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & el == EL0 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if (__SCR_EL3_NS == 0 & __SCTLR_EL1_UMA == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __SCTLR_EL1_UMA == 0) & ~(__HCR_EL2_E2H == 1 & __HCR_EL2_TGE == 1)) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    return((false, EL0))
}

val AArch64_CheckSystemRegisterTraps : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_CheckSystemRegisterTraps (op0, op1, crn, crm, op2, read) = {
    target_el : bits(2) = undefined : bits(2);
    trap : bool = undefined : bool;
    (trap, target_el) = AArch64_AutoGen_SysRegTrap(PSTATE.EL, op0, op1, crn, op2, crm, read);
    return((trap, target_el))
}

val AArch64_CheckSystemAccess : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckSystemAccess (op0, op1, crn, crm, op2, rt, read) = {
    let unallocated : bool(false) = false;
    need_secure : bool = false;
    min_EL : bits(2) = undefined : bits(2);
    if HaveBTIExt() then {
        BranchTargetCheck()
    };
    rcs_el0_trap : bool = undefined : bool;
    if ((((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & [HCR_EL2[20]] == 1) & (op0 & 0b01) == 0b01) & (crn & 0xB) == 0xB then {
        rcs_el0_trap = __IMPDEF_boolean("Reserved Control Space EL0 Trapped");
        if PSTATE.EL == EL1 | rcs_el0_trap then {
            AArch64_SystemRegisterTrap(EL2, op0, op2, op1, crn, rt, crm, read)
        }
    };
    match op1 {
      [bitzero] @ [bitzero] @ _ : bits(1) => {
          min_EL = EL1
      },
      0b010 => {
          min_EL = EL1
      },
      0b011 => {
          min_EL = EL0
      },
      0b100 => {
          min_EL = EL2
      },
      0b101 => {
          if ~(HaveVirtHostExt()) then {
              throw(Error_Undefined())
          };
          min_EL = EL2
      },
      0b110 => {
          min_EL = EL3
      },
      0b111 => {
          min_EL = EL1;
          need_secure = true
      }
    };
    let min_EL = min_EL;
    nv_access : bool = undefined : bool;
    if UInt(PSTATE.EL) < UInt(min_EL) then {
        nv_access = (((HaveNVExt() & min_EL == EL2) & PSTATE.EL == EL1) & EL2Enabled()) & [HCR_EL2[42]] == 0b1;
        if ~(nv_access) then {
            throw(Error_Undefined())
        }
    } else {
        if need_secure & ~(IsSecure()) then {
            throw(Error_Undefined())
        } else {
            if AArch64_CheckUnallocatedSystemAccess(PSTATE.EL, op0, op1, crn, crm, op2, read) then {
                throw(Error_Undefined())
            }
        }
    };
    take_trap : bool = undefined : bool;
    target_el : bits(2) = undefined : bits(2);
    (take_trap, target_el) = AArch64_CheckAdvSIMDFPSystemRegisterTraps(op0, op1, crn, crm, op2, read);
    if take_trap then {
        AArch64_AdvSIMDFPAccessTrap(target_el)
    };
    (take_trap, target_el) = AArch64_CheckSystemRegisterTraps(op0, op1, crn, crm, op2, read);
    if take_trap then {
        AArch64_SystemRegisterTrap(target_el, op0, op2, op1, crn, rt, crm, read)
    }
}

val system_register_cpsr_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_register_cpsr_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    if op1 == 0b000 & op2 == 0b000 then {
        throw(Error_See("CFINV"))
    };
    if op1 == 0b000 & op2 == 0b001 then {
        throw(Error_See("XAFlag"))
    };
    if op1 == 0b000 & op2 == 0b010 then {
        throw(Error_See("AXFlag"))
    };
    AArch64_CheckSystemAccess(0b00, op1, 0x4, CRm, op2, 0b11111, 0b0);
    let operand : vector(4, dec, bit) = CRm;
    field : PSTATEField = undefined : PSTATEField;
    match op1 @ op2 {
      0b000011 => {
          if ~(HaveUAOExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_UAO
      },
      0b000100 => {
          if ~(HavePANExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_PAN
      },
      0b000101 => {
          field = PSTATEField_SP
      },
      0b011010 => {
          if ~(HaveDITExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_DIT
      },
      0b011110 => {
          field = PSTATEField_DAIFSet
      },
      0b011111 => {
          field = PSTATEField_DAIFClr
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let field = field;
    if (op1 == 0b011 & PSTATE.EL == EL0) & (IsInHost() | [SCTLR_EL1[9]] == 0b0) then {
        AArch64_SystemRegisterTrap(EL1, 0b00, op2, op1, 0x4, 0b11111, CRm, 0b0)
    };
    __PostDecode();
    system_register_cpsr(field, operand)
}

val AArch64_AccessIsPrivileged : AccType -> bool effect {escape, rreg, undef}

function AArch64_AccessIsPrivileged acctype = {
    let el : bits(2) = AArch64_AccessUsesEL(acctype);
    ispriv : bool = undefined : bool;
    if el == EL0 then {
        ispriv = false
    } else {
        if el == EL3 then {
            ispriv = true
        } else {
            if el == EL2 & (~(IsInHost()) | [HCR_EL2[27]] == 0b0) then {
                ispriv = true
            } else {
                if HaveUAOExt() & PSTATE.UAO == 0b1 then {
                    ispriv = true
                } else {
                    ispriv = acctype != AccType_UNPRIV
                }
            }
        }
    };
    ispriv
}

val AArch64_CheckWatchpoint : forall ('size : Int).
  (bits(64), AccType, bool, int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch64_CheckWatchpoint (vaddress, acctype, iswrite, size) = {
    assert(~(ELUsingAArch32(S1TranslationRegime())));
    val_match : bool = undefined : bool;
    val_match = false;
    let ispriv : bool = AArch64_AccessIsPrivileged(acctype);
    foreach (i from 0 to UInt(slice(ID_AA64DFR0_EL1, 20, 4)) by 1 in inc) {
        val_match = val_match | AArch64_WatchpointMatch(i, vaddress, size, ispriv, acctype, iswrite)
    };
    reason : bits(6) = undefined : bits(6);
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        reason = DebugHalt_Watchpoint;
        Halt(reason);
        AArch64_NoFault()
    } else {
        if (val_match & [MDSCR_EL1[15]] == 0b1) & AArch64_GenerateDebugExceptions() then {
            return(AArch64_DebugFault(acctype, iswrite))
        } else {
            return(AArch64_NoFault())
        }
    }
}

val AArch64_CheckDebug : forall ('iswrite : Bool) ('size : Int).
  (bits(64), AccType, bool('iswrite), int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch64_CheckDebug (vaddress, acctype, iswrite, size) = {
    fault : FaultRecord = AArch64_NoFault();
    let d_side : bool = acctype != AccType_IFETCH;
    let generate_exception : bool = AArch64_GenerateDebugExceptions() & [MDSCR_EL1[15]] == 0b1;
    let halt : bool = HaltOnBreakpointOrWatchpoint();
    if generate_exception | halt then {
        if d_side then {
            fault = AArch64_CheckWatchpoint(vaddress, acctype, iswrite, size)
        } else {
            fault = AArch64_CheckBreakpoint(vaddress, acctype, size)
        }
    };
    fault
}

val AArch64_CheckPermission : forall ('level : Int) ('iswrite : Bool).
  (Permissions, bits(64), int('level), bits(1), AccType, bool('iswrite)) -> FaultRecord effect {escape, rreg, undef}

function AArch64_CheckPermission (perms, vaddress, level, NS, acctype, iswrite) = {
    assert(~(ELUsingAArch32(S1TranslationRegime())));
    let wxn : bool = [SCTLR()[19]] == 0b1;
    is_ats1xp : bool = undefined : bool;
    is_ldst : bool = undefined : bool;
    ispriv : bool = undefined : bool;
    pan : bits(1) = undefined : bits(1);
    priv_r : bool = undefined : bool;
    priv_w : bool = undefined : bool;
    priv_xn : bool = undefined : bool;
    r : bool = undefined : bool;
    user_r : bool = undefined : bool;
    user_w : bool = undefined : bool;
    user_xn : bool = undefined : bool;
    w : bool = undefined : bool;
    xn : bool = undefined : bool;
    if ((PSTATE.EL == EL0 | IsInHost()) | PSTATE.EL == EL1 & ~(HaveNV2Ext())) | (PSTATE.EL == EL1 & HaveNV2Ext()) & (acctype != AccType_NV2REGISTER | ~(ELIsInHost(EL2))) then {
        priv_r = true;
        priv_w = [perms.ap[2]] == 0b0;
        user_r = [perms.ap[1]] == 0b1;
        user_w = slice(perms.ap, 1, 2) == 0b01;
        ispriv = AArch64_AccessIsPrivileged(acctype);
        pan = if HavePANExt() then PSTATE.PAN else 0b0;
        if EL2Enabled() & ((PSTATE.EL == EL1 & HaveNVExt()) & (HCR_EL2[42 .. 42] @ HCR_EL2[43 .. 43]) == 0b11 | (HaveNV2Ext() & acctype == AccType_NV2REGISTER) & [HCR_EL2[45]] == 0b1) then {
            pan = 0b0
        };
        is_ldst = ~(acctype == AccType_DC | acctype == AccType_DC_UNPRIV | acctype == AccType_AT | acctype == AccType_IFETCH);
        is_ats1xp = acctype == AccType_AT & AArch64_ExecutingATS1xPInstr();
        if ((pan == 0b1 & user_r) & ispriv) & (is_ldst | is_ats1xp) then {
            priv_r = false;
            priv_w = false
        };
        user_xn = perms.xn == 0b1 | user_w & wxn;
        priv_xn = (perms.pxn == 0b1 | priv_w & wxn) | user_w;
        if ispriv then {
            (r, w, xn) = (priv_r, priv_w, priv_xn)
        } else {
            (r, w, xn) = (user_r, user_w, user_xn)
        }
    } else {
        r = true;
        w = [perms.ap[2]] == 0b0;
        xn = perms.xn == 0b1 | w & wxn
    };
    if ((HaveEL(EL3) & IsSecure()) & NS == 0b1) & [SCR_EL3[9]] == 0b1 then {
        xn = true
    };
    fail : bool = undefined : bool;
    failedread : bool = undefined : bool;
    if acctype == AccType_IFETCH then {
        fail = xn;
        failedread = true
    } else {
        if acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW then {
            fail = ~(r) | ~(w);
            failedread = ~(r)
        } else {
            if iswrite then {
                fail = ~(w);
                failedread = false
            } else {
                if acctype == AccType_DC & PSTATE.EL != EL0 then {
                    fail = false
                } else {
                    fail = ~(r);
                    failedread = true
                }
            }
        }
    };
    ipaddress : bits(52) = undefined : bits(52);
    s2fs1walk : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    if fail then {
        secondstage = false;
        s2fs1walk = false;
        ipaddress = undefined : bits(52);
        return(AArch64_PermissionFault(ipaddress, undefined : bits(1), level, acctype, ~(failedread), secondstage, s2fs1walk))
    } else {
        return(AArch64_NoFault())
    }
}

val AArch64_FirstStageTranslate : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_FirstStageTranslate (vaddress, acctype, iswrite, wasaligned, size) = {
    s1_enabled : bool = undefined : bool;
    if HaveNV2Ext() & acctype == AccType_NV2REGISTER then {
        s1_enabled = [SCTLR_EL2[0]] == 0b1
    } else {
        if HasS2Translation() then {
            s1_enabled = ([HCR_EL2[27]] == 0b0 & [HCR_EL2[12]] == 0b0) & [SCTLR_EL1[0]] == 0b1
        } else {
            s1_enabled = [SCTLR()[0]] == 0b1
        }
    };
    let ipaddress : vector(52, dec, bit) = undefined : bits(52);
    let secondstage : bool(false) = false;
    s2fs1walk : bool = undefined : bool;
    s2fs1walk = false;
    S1 : TLBRecord = undefined : TLBRecord;
    nTLSMD : bits(1) = undefined : bits(1);
    permissioncheck : bool = undefined : bool;
    if s1_enabled then {
        S1 = AArch64_TranslationTableWalk(ipaddress, 0b1, vaddress, acctype, iswrite, secondstage, s2fs1walk, size);
        permissioncheck = true;
        if acctype == AccType_IFETCH then {
            InGuardedPage = S1.GP == 0b1
        }
    } else {
        S1 = AArch64_TranslateAddressS1Off(vaddress, acctype, iswrite);
        permissioncheck = false;
        if (UsingAArch32() & HaveTrapLoadStoreMultipleDeviceExt()) & AArch32_ExecutingLSMInstr() then {
            if S1.addrdesc.memattrs.typ == MemType_Device & S1.addrdesc.memattrs.device != DeviceType_GRE then {
                nTLSMD = if S1TranslationRegime() == EL2 then [SCTLR_EL2[28]] else [SCTLR_EL1[28]];
                if nTLSMD == 0b0 then {
                    __tc1 : AddressDescriptor = S1.addrdesc;
                    __tc1.fault = AArch64_AlignmentFault(acctype, iswrite, secondstage);
                    S1.addrdesc = __tc1
                }
            }
        }
    };
    if ((~(wasaligned) & acctype != AccType_IFETCH | acctype == AccType_DCZVA) & S1.addrdesc.memattrs.typ == MemType_Device) & ~(IsFault(S1.addrdesc)) then {
        __tc2 : AddressDescriptor = S1.addrdesc;
        __tc2.fault = AArch64_AlignmentFault(acctype, iswrite, secondstage);
        S1.addrdesc = __tc2
    };
    if ~(IsFault(S1.addrdesc)) & permissioncheck then {
        __tc3 : AddressDescriptor = S1.addrdesc;
        __tc3.fault = AArch64_CheckPermission(S1.perms, vaddress, S1.level, S1.addrdesc.paddress.NS, acctype, iswrite);
        S1.addrdesc = __tc3
    };
    if (~(IsFault(S1.addrdesc)) & S1.addrdesc.memattrs.typ == MemType_Device) & acctype == AccType_IFETCH then {
        S1.addrdesc = AArch64_InstructionDevice(S1.addrdesc, vaddress, ipaddress, S1.level, acctype, iswrite, secondstage, s2fs1walk)
    };
    let hwupdatewalk : bool(false) = false;
    let s2fs1walk = false;
    __tc4 : AddressDescriptor = S1.addrdesc;
    __tc4.fault = AArch64_CheckAndUpdateDescriptor(S1.descupdate, S1.addrdesc.fault, secondstage, vaddress, acctype, iswrite, s2fs1walk, hwupdatewalk);
    S1.addrdesc = __tc4;
    S1.addrdesc
}

val AArch64_FullTranslate : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_FullTranslate (vaddress, acctype, iswrite, wasaligned, size) = {
    let S1 : AddressDescriptor = AArch64_FirstStageTranslate(vaddress, acctype, iswrite, wasaligned, size);
    hwupdatewalk : bool = undefined : bool;
    result : AddressDescriptor = undefined : AddressDescriptor;
    s2fs1walk : bool = undefined : bool;
    if (~(IsFault(S1)) & ~(HaveNV2Ext() & acctype == AccType_NV2REGISTER)) & HasS2Translation() then {
        s2fs1walk = false;
        hwupdatewalk = false;
        result = AArch64_SecondStageTranslate(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size, hwupdatewalk)
    } else {
        result = S1
    };
    result
}

val check_access_z : forall ('iswrite : Bool).
  (bits(64), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function check_access_z (val_name, iswrite) = {
    let 'size = 4 * 2 ^ UInt(slice(DCZID_EL0, 0, 4));
    let vaddress : bits(64) = Align(val_name, size);
    let memaddrdesc : AddressDescriptor = AArch64_FullTranslate(vaddress, AccType_DCZVA, iswrite, true, 1);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(val_name, memaddrdesc.fault)
    }
}

val AArch64_TranslateAddress : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_TranslateAddress (vaddress, acctype, iswrite, wasaligned, size) = {
    result : AddressDescriptor = undefined : AddressDescriptor;
    result = AArch64_FullTranslate(vaddress, acctype, iswrite, wasaligned, size);
    if ~(acctype == AccType_PTW | acctype == AccType_IC | acctype == AccType_AT) & ~(IsFault(result)) then {
        result.fault = AArch64_CheckDebug(vaddress, acctype, iswrite, size)
    };
    result.vaddress = ZeroExtend(vaddress);
    result
}

val aset_MemTag : (bits(64), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_MemTag (address, value_name) = {
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    let iswrite : bool(true) = true;
    if address != Align(address, TAG_GRANULE) then {
        let secondstage : bool(false) = false;
        AArch64_Abort(address, AArch64_AlignmentFault(AccType_NORMAL, iswrite, secondstage))
    };
    let wasaligned : bool(true) = true;
    let memaddrdesc = AArch64_TranslateAddress(address, AccType_NORMAL, iswrite, wasaligned, TAG_GRANULE);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if AllocationTagAccessIsEnabled() then {
        _MemTag(memaddrdesc) = value_name
    }
}

overload MemTag = {aset_MemTag}

val integer_tags_mcsettagarray : forall 'n 't,
  ('t >= 0 & 't <= 31) & ('n >= 0 & 'n <= 31 | not(not('n == 31))).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagarray (n, t) = {
    let data : bits(64) = X(t);
    address : bits(64) = undefined : bits(64);
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    count : int = undefined : int;
    (address, count) = ImpDefTagArrayStartAndCount(address);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        let 'index = UInt(slice(address, LOG2_TAG_GRANULE, 4));
        let tag : bits(4) = slice(data, index * 4, 4);
        MemTag(address) = tag;
        address = address + TAG_GRANULE
    };
    if n == 31 then {
        SP() = address
    } else {
        X(n) = address
    }
}

val integer_tags_mcsettagarray_decode : (bits(5), bits(5)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagarray_decode (Xt, Xn) = {
    __unconditional = true;
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    __PostDecode();
    integer_tags_mcsettagarray(n, t)
}

val aget_MemTag : bits(64) -> bits(4) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_MemTag address = {
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    let value_name : vector(4, dec, bit) = undefined : bits(4);
    let iswrite : bool(false) = false;
    let memaddrdesc = AArch64_TranslateAddress(address, AccType_NORMAL, iswrite, true, TAG_GRANULE);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if AllocationTagAccessIsEnabled() then {
        return(_MemTag(memaddrdesc))
    } else {
        return(0x0)
    }
}

overload MemTag = {aget_MemTag}

val integer_tags_mcgettag : forall 'n 't,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcgettag (n, offset, t) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    address = address + offset;
    address = Align(address, TAG_GRANULE);
    let tag = MemTag(address);
    let address = AddressWithAllocationTag(address, tag);
    X(t) = address
}

val integer_tags_mcgettag_decode : (bits(5), bits(5), bits(9)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function integer_tags_mcgettag_decode (Xt, Xn, imm9) = {
    __unconditional = true;
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    __PostDecode();
    integer_tags_mcgettag(n, offset, t)
}

val CheckTag : forall ('write : Bool).
  (AddressDescriptor, bits(4), bool('write)) -> bool effect {escape, rmem, rreg, undef, wmem, wreg}

function CheckTag (memaddrdesc, ptag, write) = {
    if memaddrdesc.memattrs.tagged then {
        let paddress : bits(64) = ZeroExtend(memaddrdesc.paddress.address);
        return(ptag == MemTag(paddress))
    } else {
        return(true)
    }
}

val AArch64_SetExclusiveMonitors : forall ('size : Int).
  (bits(64), int('size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SetExclusiveMonitors (address, size) = {
    let acctype : AccType = AccType_ATOMIC;
    let iswrite : bool(false) = false;
    let aligned : bool = address == Align(address, size);
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        return()
    };
    if memaddrdesc.memattrs.shareable then {
        MarkExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    };
    MarkExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    AArch64_MarkExclusiveVA(address, ProcessorID(), size)
}

val AArch64_ExclusiveMonitorsPass : forall ('size : Int).
  (bits(64), int('size)) -> bool effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_ExclusiveMonitorsPass (address, size) = {
    let acctype : AccType = AccType_ATOMIC;
    let iswrite : bool(true) = true;
    let aligned : bool = address == Align(address, size);
    secondstage : bool = undefined : bool;
    if ~(aligned) then {
        secondstage = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    };
    passed : bool = undefined : bool;
    passed = AArch64_IsExclusiveVA(address, ProcessorID(), size);
    if ~(passed) then {
        return(false)
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    passed = IsExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    if passed then {
        ClearExclusiveLocal(ProcessorID());
        if memaddrdesc.memattrs.shareable then {
            passed = IsExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
        }
    };
    passed
}

val AArch32_WatchpointByteMatch : forall ('n : Int).
  (int('n), bits(32)) -> bool effect {escape, rreg, undef}

function AArch32_WatchpointByteMatch (n, vaddress) = {
    bottom : int = undefined : int;
    bottom = if [DBGWVR[n][2]] == 0b1 then 2 else 3;
    let bottom_fixed = bottom;
    assert(bottom_fixed == 2 | bottom_fixed == 3);
    byte_select_match : bool = undefined : bool;
    byte_select_match = [slice(DBGWCR[n], 5, 8)[UInt(slice(vaddress, 0, bottom_fixed))]] != 0b0;
    mask : int = undefined : int;
    mask = UInt(slice(DBGWCR[n], 24, 5));
    LSB : bits(8) = undefined : bits(8);
    MSB : bits(8) = undefined : bits(8);
    if mask > 0 & ~(IsOnes(slice(DBGWCR[n], 5, 8))) then {
        byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPMASKANDBAS)
    } else {
        LSB = slice(DBGWCR[n], 5, 8) & ~(slice(DBGWCR[n], 5, 8) - 1);
        MSB = slice(DBGWCR[n], 5, 8) + LSB;
        if ~(IsZero(MSB & MSB - 1)) then {
            byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPBASCONTIGUOUS);
            bottom = 3
        }
    };
    c : Constraint = undefined : Constraint;
    if mask > 0 & mask <= 2 then {
        (c, mask) = ConstrainUnpredictableInteger(3, 31, Unpredictable_RESWPMASK);
        assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
        match c {
          Constraint_DISABLED => {
              return(false)
          },
          Constraint_NONE => {
              mask = 0
          }
        }
    };
    WVR_match : bool = undefined : bool;
    let bottom_fixed = bottom;
    let mask_fixed = mask;
    assert(bottom_fixed == 2 | bottom_fixed == 3);
    assert(negate(mask_fixed) + 32 >= 0 & mask_fixed >= 0);
    if mask_fixed > bottom_fixed then {
        WVR_match = slice(vaddress, mask_fixed, negate(mask_fixed) + 32) == slice(DBGWVR[n], mask_fixed, negate(mask_fixed) + 32);
        if WVR_match & ~(IsZero(slice(DBGWVR[n], bottom_fixed, mask_fixed - bottom_fixed))) then {
            WVR_match = ConstrainUnpredictableBool(Unpredictable_WPMASKEDBITS)
        }
    } else {
        WVR_match = slice(vaddress, bottom_fixed, negate(bottom_fixed) + 32) == slice(DBGWVR[n], bottom_fixed, negate(bottom_fixed) + 32)
    };
    WVR_match & byte_select_match
}

val AArch32_VCRMatch : bits(32) -> bool effect {escape, rreg, undef}

function AArch32_VCRMatch vaddress = {
    mask : bits(32) = undefined : bits(32);
    val_match : bool = undefined : bool;
    match_word : bits(32) = undefined : bits(32);
    if ((UsingAArch32() & ELUsingAArch32(EL1)) & IsZero(slice(vaddress, 0, 2))) & PSTATE.EL != EL2 then {
        match_word = Zeros(32);
        if slice(vaddress, 5, 27) == slice(ExcVectorBase(), 5, 27) then {
            if HaveEL(EL3) & ~(IsSecure()) then {
                match_word = __SetSlice_bits(32, 1, match_word, UInt(slice(vaddress, 2, 3)) + 24, 0b1)
            } else {
                match_word = __SetSlice_bits(32, 1, match_word, UInt(slice(vaddress, 2, 3)) + 0, 0b1)
            }
        };
        if ((HaveEL(EL3) & ELUsingAArch32(EL3)) & IsSecure()) & slice(vaddress, 5, 27) == slice(MVBAR, 5, 27) then {
            match_word = __SetSlice_bits(32, 1, match_word, UInt(slice(vaddress, 2, 3)) + 8, 0b1)
        };
        if ~(HaveEL(EL3)) then {
            mask = ((0x00 @ 0x00) @ 0x00) @ 0xDE
        } else {
            if ~(ELUsingAArch32(EL3)) then {
                mask = ((0xDE @ 0x00) @ 0x00) @ 0xDE
            } else {
                mask = ((0xDE @ 0x00) @ 0xDC) @ 0xDE
            }
        };
        match_word = (match_word & get_DBGVCR()) & mask;
        val_match = ~(IsZero(match_word));
        if ~(IsZero(match_word[27 .. 26] @ (match_word[11 .. 10] @ match_word[3 .. 2]))) & DebugTarget() == PSTATE.EL then {
            val_match = ConstrainUnpredictableBool(Unpredictable_VCMATCHDAPA)
        }
    } else {
        val_match = false
    };
    val_match
}

val AArch32_TakeVirtualIRQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeVirtualIRQException () = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    if ELUsingAArch32(EL2) then {
        assert([get_HCR()[27]] == 0b0 & [get_HCR()[4]] == 0b1)
    } else {
        assert([HCR_EL2[27]] == 0b0 & [HCR_EL2[4]] == 0b1)
    };
    if PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1)) then {
        AArch64_TakeVirtualIRQException()
    };
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(24) = 24;
    let lr_offset : int(4) = 4;
    AArch32_EnterMode(M32_IRQ, preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_TakeVirtualFIQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeVirtualFIQException () = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    if ELUsingAArch32(EL2) then {
        assert([get_HCR()[27]] == 0b0 & [get_HCR()[3]] == 0b1)
    } else {
        assert([HCR_EL2[27]] == 0b0 & [HCR_EL2[3]] == 0b1)
    };
    if PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1)) then {
        AArch64_TakeVirtualFIQException()
    };
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(28) = 28;
    let lr_offset : int(4) = 4;
    AArch32_EnterMode(M32_FIQ, preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled : unit -> bool effect {escape, rreg, undef}

function AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled () = {
    if ~(HaveEL(EL3)) & ~(IsSecure()) then {
        return(false)
    };
    DBGEN == HIGH & SPIDEN == HIGH
}

val AArch32_S1AttrDecode : (bits(2), bits(3), AccType) -> MemoryAttributes effect {escape, rreg, undef}

function AArch32_S1AttrDecode (SH, attr, acctype) = {
    memattrs : MemoryAttributes = undefined : MemoryAttributes;
    mair : bits(64) = undefined : bits(64);
    if PSTATE.EL == EL2 then {
        mair = get_HMAIR1() @ get_HMAIR0()
    } else {
        mair = get_MAIR1() @ get_MAIR0()
    };
    let index : {'ex197397#, (0 <= 'ex197397# & 'ex197397# <= 2 ^ 3 - 1). int(8 * 'ex197397#)} = 8 * UInt(attr);
    attrfield : bits(8) = undefined : bits(8);
    attrfield = slice(mair, index, 8);
    memattrs.tagged = false;
    __anon1 : Constraint = undefined : Constraint;
    if (slice(attrfield, 4, 4) != 0x0 & slice(attrfield, 4, 4) != 0xF) & slice(attrfield, 0, 4) == 0x0 | slice(attrfield, 4, 4) == 0x0 & (slice(attrfield, 0, 4) & 0x3) != 0x0 then {
        (__anon1, attrfield) = ConstrainUnpredictableBits(Unpredictable_RESMAIR)
    };
    __anon2 : Constraint = undefined : Constraint;
    if (~(HaveMTEExt()) & slice(attrfield, 4, 4) == 0xF) & slice(attrfield, 0, 4) == 0x0 then {
        (__anon2, attrfield) = ConstrainUnpredictableBits(Unpredictable_RESMAIR)
    };
    if slice(attrfield, 4, 4) == 0x0 then {
        memattrs.typ = MemType_Device;
        match slice(attrfield, 0, 4) {
          0x0 => {
              memattrs.device = DeviceType_nGnRnE
          },
          0x4 => {
              memattrs.device = DeviceType_nGnRE
          },
          0x8 => {
              memattrs.device = DeviceType_nGRE
          },
          0xC => {
              memattrs.device = DeviceType_GRE
          },
          _ => {
              Unreachable()
          }
        }
    } else {
        if slice(attrfield, 0, 4) != 0x0 then {
            memattrs.typ = MemType_Normal;
            memattrs.outer = LongConvertAttrsHints(slice(attrfield, 4, 4), acctype);
            memattrs.inner = LongConvertAttrsHints(slice(attrfield, 0, 4), acctype);
            memattrs.shareable = [SH[1]] == 0b1;
            memattrs.outershareable = SH == 0b10
        } else {
            if HaveMTEExt() & attrfield == 0xF0 then {
                memattrs.tagged = true;
                memattrs.typ = MemType_Normal;
                __tc1 : MemAttrHints = memattrs.outer;
                __tc1.attrs = MemAttr_WB;
                memattrs.outer = __tc1;
                __tc2 : MemAttrHints = memattrs.inner;
                __tc2.attrs = MemAttr_WB;
                memattrs.inner = __tc2;
                __tc3 : MemAttrHints = memattrs.outer;
                __tc3.hints = MemHint_RWA;
                memattrs.outer = __tc3;
                __tc4 : MemAttrHints = memattrs.inner;
                __tc4.hints = MemHint_RWA;
                memattrs.inner = __tc4;
                memattrs.shareable = [SH[1]] == 0b1;
                memattrs.outershareable = SH == 0b10
            } else {
                Unreachable()
            }
        }
    };
    MemAttrDefaults(memattrs)
}

val AArch32_ReportPrefetchAbort : forall ('route_to_monitor : Bool).
  (bool('route_to_monitor), FaultRecord, bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_ReportPrefetchAbort (route_to_monitor, fault, vaddress) = {
    long_format : bool = undefined : bool;
    long_format = false;
    if route_to_monitor & ~(IsSecure()) then {
        long_format = ([TTBCR_S[31]] == 0b1 | PSTATE.EL == EL2) | [get_TTBCR()[31]] == 0b1
    } else {
        long_format = [get_TTBCR()[31]] == 0b1
    };
    let d_side : bool(false) = false;
    fsr : bits(32) = undefined : bits(32);
    if long_format then {
        fsr = AArch32_FaultStatusLD(d_side, fault)
    } else {
        fsr = AArch32_FaultStatusSD(d_side, fault)
    };
    if route_to_monitor then {
        IFSR_S = fsr;
        set_IFAR_S(vaddress)
    } else {
        set_IFSR(fsr);
        set_IFAR(vaddress)
    };
    return()
}

val AArch32_ReportDataAbort : forall ('route_to_monitor : Bool).
  (bool('route_to_monitor), FaultRecord, bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_ReportDataAbort (route_to_monitor, fault, vaddress) = {
    long_format : bool = undefined : bool;
    long_format = false;
    if route_to_monitor & ~(IsSecure()) then {
        long_format = [TTBCR_S[31]] == 0b1;
        if ~(IsSErrorInterrupt(fault)) & ~(long_format) then {
            long_format = PSTATE.EL == EL2 | [get_TTBCR()[31]] == 0b1
        }
    } else {
        long_format = [get_TTBCR()[31]] == 0b1
    };
    let d_side : bool(true) = true;
    syndrome : bits(32) = undefined : bits(32);
    if long_format then {
        syndrome = AArch32_FaultStatusLD(d_side, fault)
    } else {
        syndrome = AArch32_FaultStatusSD(d_side, fault)
    };
    i_syndrome : bits(32) = undefined : bits(32);
    if fault.acctype == AccType_IC then {
        if ~(long_format) & __IMPDEF_boolean("Report I-cache maintenance fault in IFSR") then {
            i_syndrome = syndrome;
            (syndrome[10 .. 10] @ syndrome[3 .. 0]) = EncodeSDFSC(Fault_ICacheMaint, 1)
        } else {
            i_syndrome = undefined : bits(32)
        };
        if route_to_monitor then {
            IFSR_S = i_syndrome
        } else {
            set_IFSR(i_syndrome)
        }
    };
    if route_to_monitor then {
        DFSR_S = syndrome;
        set_DFAR_S(vaddress)
    } else {
        set_DFSR(syndrome);
        set_DFAR(vaddress)
    };
    return()
}

val AArch32_PendingUnmaskedVirtualInterrupts : unit -> (bool, bool, bool) effect {escape, rreg, undef}

function AArch32_PendingUnmaskedVirtualInterrupts () = {
    if HaveEL(EL2) & ~(ELUsingAArch32(EL2)) | HaveEL(EL3) & ~(ELUsingAArch32(EL3)) then {
        return(AArch64_PendingUnmaskedVirtualInterrupts(PSTATE.A @ (PSTATE.I @ PSTATE.F)))
    };
    let mask : vector(1 + (1 + 1), dec, bit) = PSTATE.A @ (PSTATE.I @ PSTATE.F);
    pending : bits(3) = undefined : bits(3);
    if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & [get_HCR()[27]] == 0b0 then {
        pending = (get_HCR()[8 .. 8] @ (get_HCR()[7 .. 7] @ get_HCR()[6 .. 6])) & (get_HCR()[5 .. 5] @ (get_HCR()[4 .. 4] @ get_HCR()[3 .. 3]))
    } else {
        pending = 0b000
    };
    let unmasked_pending : bits(3) = pending & ~(mask);
    return(([unmasked_pending[2]] == 0b1, [unmasked_pending[1]] == 0b1, [unmasked_pending[0]] == 0b1))
}

val AArch32_PendingUnmaskedPhysicalInterrupts : unit -> (bool, bool, bool) effect {escape, rreg, undef}

function AArch32_PendingUnmaskedPhysicalInterrupts () = {
    if HaveEL(EL3) & ~(ELUsingAArch32(EL3)) then {
        return(AArch64_PendingUnmaskedPhysicalInterrupts(PSTATE.A @ (PSTATE.I @ PSTATE.F)))
    };
    let se_pending : vector(1, dec, bit) = if IsPhysicalSErrorPending() then 0b1 else 0b0;
    let irq_pending : vector(1, dec, bit) = if IRQPending() then 0b1 else 0b0;
    let fiq_pending : vector(1, dec, bit) = if FIQPending() then 0b1 else 0b0;
    let pending : bits(3) = (se_pending @ irq_pending) @ fiq_pending;
    mask : bits(3) = undefined : bits(3);
    mask = PSTATE.A @ (PSTATE.I @ PSTATE.F);
    mask_override : bits(3) = undefined : bits(3);
    if (PSTATE.EL == EL1 | PSTATE.EL == EL0) & EL2Enabled() then {
        mask_override = if [get_HCR()[27]] == 0b1 then 0b111 else get_HCR()[5 .. 5] @ (get_HCR()[4 .. 4] @ get_HCR()[3 .. 3]);
        mask = mask & ~(mask_override)
    };
    if HaveEL(EL3) then {
        if PSTATE.EL != EL3 then {
            if [get_SCR()[2]] == 0b1 & ([get_SCR()[4]] == 0b0 | [get_HCR()[3]] == 0b1) then {
                mask = __SetSlice_bits(3, 1, mask, 0, 0b0)
            };
            if [get_SCR()[1]] == 0b1 & [get_HCR()[4]] == 0b1 then {
                mask = __SetSlice_bits(3, 1, mask, 1, 0b0)
            };
            if [get_SCR()[3]] == 0b1 & ([get_SCR()[5]] == 0b0 | [get_HCR()[5]] == 0b1) then {
                mask = __SetSlice_bits(3, 1, mask, 2, 0b0)
            }
        }
    };
    let unmasked_pending : bits(3) = pending & ~(mask);
    return(([unmasked_pending[2]] == 0b1, [unmasked_pending[1]] == 0b1, [unmasked_pending[0]] == 0b1))
}

val AArch32_GenerateDebugExceptionsFrom : forall ('secure : Bool).
  (bits(2), bool('secure)) -> bool effect {escape, rreg, undef}

function AArch32_GenerateDebugExceptionsFrom (from, secure) = {
    mask : bits(1) = undefined : bits(1);
    if from == EL0 & ~(ELStateUsingAArch32(EL1, secure)) then {
        mask = undefined : bits(1);
        return(AArch64_GenerateDebugExceptionsFrom(from, secure, mask))
    };
    if ([get_DBGOSLSR()[1]] == 0b1 | DoubleLockStatus()) | Halted() then {
        return(false)
    };
    enabled : bool = undefined : bool;
    spd : bits(2) = undefined : bits(2);
    if HaveEL(EL3) & secure then {
        spd = if ELUsingAArch32(EL3) then slice(get_SDCR(), 14, 2) else slice(MDCR_EL3, 14, 2);
        if [spd[1]] == 0b1 then {
            enabled = [spd[0]] == 0b1
        } else {
            enabled = AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled()
        };
        if from == EL0 then {
            enabled = enabled | [get_SDER()[0]] == 0b1
        }
    } else {
        enabled = from != EL2
    };
    enabled
}

val AArch32_GenerateDebugExceptions : unit -> bool effect {escape, rreg, undef}

function AArch32_GenerateDebugExceptions () = {
    AArch32_GenerateDebugExceptionsFrom(PSTATE.EL, IsSecure())
}

val DebugExceptionReturnSS : bits(32) -> bits(1) effect {escape, rreg, undef}

function DebugExceptionReturnSS spsr = {
    assert((Halted() | Restarting()) | PSTATE.EL != EL0);
    SS_bit : bits(1) = undefined : bits(1);
    SS_bit = 0b0;
    ELd : bits(2) = undefined : bits(2);
    dest : bits(2) = undefined : bits(2);
    enabled_at_dest : bool = undefined : bool;
    enabled_at_source : bool = undefined : bool;
    mask : bits(1) = undefined : bits(1);
    secure : bool = undefined : bool;
    valid_name : bool = undefined : bool;
    if [MDSCR_EL1[0]] == 0b1 then {
        if Restarting() then {
            enabled_at_source = false
        } else {
            if UsingAArch32() then {
                enabled_at_source = AArch32_GenerateDebugExceptions()
            } else {
                enabled_at_source = AArch64_GenerateDebugExceptions()
            }
        };
        if IllegalExceptionReturn(spsr) then {
            dest = PSTATE.EL
        } else {
            (valid_name, dest) = ELFromSPSR(spsr);
            assert(valid_name)
        };
        secure = IsSecureBelowEL3() | dest == EL3;
        if ELUsingAArch32(dest) then {
            enabled_at_dest = AArch32_GenerateDebugExceptionsFrom(dest, secure)
        } else {
            mask = [spsr[9]];
            enabled_at_dest = AArch64_GenerateDebugExceptionsFrom(dest, secure, mask)
        };
        ELd = DebugTargetFrom(secure);
        if (~(ELUsingAArch32(ELd)) & ~(enabled_at_source)) & enabled_at_dest then {
            SS_bit = [spsr[21]]
        }
    };
    SS_bit
}

val SetPSTATEFromPSR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function SetPSTATEFromPSR spsr__arg = {
    spsr = spsr__arg;
    PSTATE.SS = DebugExceptionReturnSS(spsr);
    if IllegalExceptionReturn(spsr) then {
        PSTATE.IL = 0b1
    } else {
        PSTATE.IL = [spsr[20]];
        if [spsr[4]] == 0b1 then {
            AArch32_WriteMode(slice(spsr, 0, 5))
        } else {
            PSTATE.nRW = 0b0;
            PSTATE.EL = slice(spsr, 2, 2);
            PSTATE.SP = [spsr[0]]
        }
    };
    if PSTATE.IL == 0b1 & PSTATE.nRW == 0b1 then {
        if ConstrainUnpredictableBool(Unpredictable_ILZEROT) then {
            spsr = __SetSlice_bits(32, 1, spsr, 5, 0b0)
        }
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = slice(spsr, 28, 4);
    if HaveDITExt() then {
        PSTATE.DIT = [spsr[24]]
    };
    if PSTATE.nRW == 0b1 then {
        PSTATE.Q = [spsr[27]];
        PSTATE.IT = RestoredITBits(spsr);
        ShouldAdvanceIT = false;
        PSTATE.GE = slice(spsr, 16, 4);
        PSTATE.E = [spsr[9]];
        (PSTATE.A @ PSTATE.I @ PSTATE.F) = slice(spsr, 6, 3);
        PSTATE.T = [spsr[5]]
    } else {
        if HaveUAOExt() then {
            PSTATE.UAO = [spsr[23]]
        };
        (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = slice(spsr, 6, 4);
        if HaveBTIExt() then {
            PSTATE.BTYPE = slice(spsr, 10, 2)
        }
    };
    if HavePANExt() then {
        PSTATE.PAN = [spsr[22]]
    };
    if HaveMTEExt() then {
        if PSTATE.nRW != 0b1 then {
            PSTATE.TCO = [spsr[25]]
        }
    };
    return()
}

val DRPSInstruction : unit -> unit effect {escape, rreg, undef, wreg}

function DRPSInstruction () = {
    SynchronizeContext();
    sync_errors : bool = undefined : bool;
    sync_errors = HaveIESB() & [SCTLR()[21]] == 0b1;
    if HaveDoubleFaultExt() & ~(UsingAArch32()) then {
        sync_errors = sync_errors | ([SCR_EL3[3]] == 0b1 & [SCR_EL3[20]] == 0b1) & PSTATE.EL == EL3
    };
    if ~(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    };
    if sync_errors then {
        SynchronizeErrors()
    };
    SetPSTATEFromPSR(SPSR());
    if UsingAArch32() then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.Q @ PSTATE.GE @ PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = undefined : bits(13);
        PSTATE.IT = 0x00;
        PSTATE.T = 0b1;
        set_DLR(undefined : bits(32));
        set_DSPSR(undefined : bits(32))
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.SS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = undefined : bits(9);
        DLR_EL0 = undefined : bits(64);
        DSPSR_EL0 = undefined : bits(32)
    };
    UpdateEDSCRFields();
    return()
}

val branch_unconditional_dret : unit -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_dret () = {
    DRPSInstruction()
}

val branch_unconditional_dret_decode : (bits(5), bits(5), bits(6), bits(5), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_dret_decode (op4, Rt, op3, op2, opc) = {
    __unconditional = true;
    if ~(Halted()) | PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    branch_unconditional_dret()
}

val AArch64_ExceptionReturn : (bits(64), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_ExceptionReturn (new_pc__arg, spsr) = {
    new_pc = new_pc__arg;
    SynchronizeContext();
    sync_errors : bool = undefined : bool;
    sync_errors = HaveIESB() & [SCTLR()[21]] == 0b1;
    if HaveDoubleFaultExt() then {
        sync_errors = sync_errors | ([SCR_EL3[3]] == 0b1 & [SCR_EL3[20]] == 0b1) & PSTATE.EL == EL3
    };
    iesb_req : bool = undefined : bool;
    if sync_errors then {
        SynchronizeErrors();
        iesb_req = true;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    };
    SetPSTATEFromPSR(spsr);
    ClearExclusiveLocal(ProcessorID());
    SendEventLocal();
    if (PSTATE.IL == 0b1 & [spsr[4]] == 0b1) & [spsr[20]] == 0b0 then {
        new_pc = __SetSlice_bits(64, 32, new_pc, 32, undefined : bits(32));
        new_pc = __SetSlice_bits(64, 2, new_pc, 0, undefined : bits(2))
    } else {
        if UsingAArch32() then {
            if PSTATE.T == 0b1 then {
                new_pc = __SetSlice_bits(64, 1, new_pc, 0, 0b0)
            } else {
                new_pc = __SetSlice_bits(64, 2, new_pc, 0, 0b00)
            }
        } else {
            new_pc = AArch64_BranchAddr(new_pc)
        }
    };
    if UsingAArch32() then {
        BranchTo(slice(new_pc, 0, 32), BranchType_ERET)
    } else {
        BranchToAddr(new_pc, BranchType_ERET)
    }
}

val branch_unconditional_eret : forall ('pac : Bool) ('use_key_a : Bool).
  (bool('pac), bool('use_key_a)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_eret (pac, use_key_a) = {
    AArch64_CheckForERetTrap(pac, use_key_a);
    target : bits(64) = ELR();
    if pac then {
        if use_key_a then {
            target = AuthIA(ELR(), SP())
        } else {
            target = AuthIB(ELR(), SP())
        }
    };
    AArch64_ExceptionReturn(target, SPSR())
}

val branch_unconditional_eret_decode : (bits(5), bits(5), bits(1), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_eret_decode (op4, Rn, M, A, op2) = {
    __unconditional = true;
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    if ~(pac) & op4 != 0b00000 then {
        throw(Error_Undefined())
    } else {
        if pac & (~(HavePACExt()) | op4 != 0b11111) then {
            throw(Error_Undefined())
        }
    };
    if Rn != 0b11111 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    branch_unconditional_eret(pac, use_key_a)
}

val AArch32_GeneralExceptionsToAArch64 : unit -> bool effect {escape, rreg, undef}

function AArch32_GeneralExceptionsToAArch64 () = {
    PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1)) | (EL2Enabled() & ~(ELUsingAArch32(EL2))) & [HCR_EL2[27]] == 0b1
}

val AArch32_FaultSyndrome : forall ('d_side : Bool).
  (bool('d_side), FaultRecord) -> bits(25) effect {escape, rreg, undef}

function AArch32_FaultSyndrome (d_side, fault) = {
    assert(fault.typ != Fault_None);
    iss : bits(25) = Zeros();
    if HaveRASExt() & IsAsyncAbort(fault) then {
        iss = __SetSlice_bits(25, 2, iss, 10, fault.errortype)
    };
    if d_side then {
        if IsSecondStage(fault) & ~(fault.s2fs1walk) then {
            iss = __SetSlice_bits(25, 11, iss, 14, LSInstructionSyndrome())
        };
        if fault.acctype == AccType_DC | fault.acctype == AccType_DC_UNPRIV | fault.acctype == AccType_IC | fault.acctype == AccType_AT then {
            iss = __SetSlice_bits(25, 1, iss, 8, 0b1);
            iss = __SetSlice_bits(25, 1, iss, 6, 0b1)
        } else {
            iss = __SetSlice_bits(25, 1, iss, 6, if fault.write then 0b1 else 0b0)
        }
    };
    if IsExternalAbort(fault) then {
        iss = __SetSlice_bits(25, 1, iss, 9, fault.extflag)
    };
    iss = __SetSlice_bits(25, 1, iss, 7, if fault.s2fs1walk then 0b1 else 0b0);
    let iss = __SetSlice_bits(25, 6, iss, 0, EncodeLDFSC(fault.typ, fault.level));
    iss
}

val AArch32_AbortSyndrome : (Exception, FaultRecord, bits(32)) -> ExceptionRecord effect {escape, rreg, undef}

function AArch32_AbortSyndrome (typ, fault, vaddress) = {
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(typ);
    let d_side : bool = typ == Exception_DataAbort;
    exception.syndrome = AArch32_FaultSyndrome(d_side, fault);
    exception.vaddress = ZeroExtend(vaddress);
    if IPAValid(fault) then {
        exception.ipavalid = true;
        exception.NS = fault.ipaddress.NS;
        exception.ipaddress = ZeroExtend(fault.ipaddress.address)
    } else {
        exception.ipavalid = false
    };
    exception
}

val AArch32_ExecutingATS1xPInstr : unit -> bool effect {rreg, undef}

function AArch32_ExecutingATS1xPInstr () = {
    if ~(HavePrivATExt()) then {
        return(false)
    };
    let instr : vector(32, dec, bit) = ThisInstr();
    CRm : bits(4) = undefined : bits(4);
    CRn : bits(4) = undefined : bits(4);
    op1 : bits(3) = undefined : bits(3);
    op2 : bits(3) = undefined : bits(3);
    if slice(instr, 24, 4) == 0xE & slice(instr, 8, 4) == 0xE then {
        op1 = slice(instr, 21, 3);
        CRn = slice(instr, 16, 4);
        CRm = slice(instr, 0, 4);
        op2 = slice(instr, 5, 3);
        return(((op1 == 0b000 & CRn == 0x7) & CRm == 0x9) & (op2 == 0b000 | op2 == 0b001))
    } else {
        return(false)
    }
}

val AArch32_EnterMonitorMode : forall ('lr_offset : Int) ('vect_offset : Int).
  (bits(32), int('lr_offset), int('vect_offset)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_EnterMonitorMode (preferred_exception_return, lr_offset, vect_offset) = {
    SynchronizeContext();
    assert(HaveEL(EL3) & ELUsingAArch32(EL3));
    let from_secure : bool = IsSecure();
    let spsr : vector(32, dec, bit) = GetPSRFromPSTATE();
    if PSTATE.M == M32_Monitor then {
        __tc1 : bits(32) = get_SCR();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b0);
        set_SCR(__tc1)
    };
    AArch32_WriteMode(M32_Monitor);
    SPSR() = spsr;
    R(14) = preferred_exception_return + lr_offset;
    PSTATE.T = [get_SCTLR()[30]];
    PSTATE.SS = 0b0;
    (PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b111;
    PSTATE.E = [get_SCTLR()[25]];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0x00;
    if HavePANExt() then {
        if ~(from_secure) then {
            PSTATE.PAN = 0b0
        } else {
            if [get_SCTLR()[23]] == 0b0 then {
                PSTATE.PAN = 0b1
            }
        }
    };
    BranchTo(slice(MVBAR, 5, 27) @ __GetSlice_int(5, vect_offset, 0), BranchType_EXCEPTION);
    EndOfInstruction()
}

val AArch32_EnterHypMode : forall ('vect_offset : Int).
  (ExceptionRecord, bits(32), int('vect_offset)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_EnterHypMode (exception, preferred_exception_return, vect_offset) = {
    SynchronizeContext();
    assert((HaveEL(EL2) & ~(IsSecure())) & ELUsingAArch32(EL2));
    let spsr : vector(32, dec, bit) = GetPSRFromPSTATE();
    if ~(exception.typ == Exception_IRQ | exception.typ == Exception_FIQ) then {
        AArch32_ReportHypEntry(exception)
    };
    AArch32_WriteMode(M32_Hyp);
    SPSR() = spsr;
    set_ELR_hyp(preferred_exception_return);
    PSTATE.T = [get_HSCTLR()[30]];
    PSTATE.SS = 0b0;
    if ~(HaveEL(EL3)) | [SCR_GEN()[3]] == 0b0 then {
        PSTATE.A = 0b1
    };
    if ~(HaveEL(EL3)) | [SCR_GEN()[1]] == 0b0 then {
        PSTATE.I = 0b1
    };
    if ~(HaveEL(EL3)) | [SCR_GEN()[2]] == 0b0 then {
        PSTATE.F = 0b1
    };
    PSTATE.E = [get_HSCTLR()[25]];
    PSTATE.IL = 0b0;
    PSTATE.IT = 0x00;
    BranchTo(slice(get_HVBAR(), 5, 27) @ __GetSlice_int(5, vect_offset, 0), BranchType_EXCEPTION);
    EndOfInstruction()
}

val AArch32_TakeUndefInstrException__0 : unit -> unit effect {escape, rreg, undef, wreg}

val AArch32_TakeUndefInstrException__1 : ExceptionRecord -> unit effect {escape, rreg, undef, wreg}

overload AArch32_TakeUndefInstrException = {
  AArch32_TakeUndefInstrException__0,
  AArch32_TakeUndefInstrException__1
}

function AArch32_TakeUndefInstrException__0 () = {
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
    AArch32_TakeUndefInstrException(exception)
}

function AArch32_TakeUndefInstrException__1 exception = {
    let route_to_hyp : bool = (EL2Enabled() & PSTATE.EL == EL0) & [get_HCR()[27]] == 0b1;
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(4) = 4;
    let lr_offset : {'ex197990#, 'ex197990# in {4, 2}. int('ex197990#)} = if CurrentInstrSet() == InstrSet_A32 then 4 else 2;
    if PSTATE.EL == EL2 then {
        AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_hyp then {
            AArch32_EnterHypMode(exception, preferred_exception_return, 20)
        } else {
            AArch32_EnterMode(M32_Undef, preferred_exception_return, lr_offset, vect_offset)
        }
    }
}

val UnallocatedEncoding : unit -> unit effect {escape, rreg, undef, wreg}

function UnallocatedEncoding () = {
    if UsingAArch32() & AArch32_ExecutingCP10or11Instr() then {
        __tc1 : bits(32) = get_FPEXC();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 29, 0b0);
        set_FPEXC(__tc1)
    };
    if UsingAArch32() & ~(AArch32_GeneralExceptionsToAArch64()) then {
        AArch32_TakeUndefInstrException()
    } else {
        AArch64_UndefinedFault()
    }
}

val integer_tags_mcgettagarray : forall 'n 't ('wb_unknown : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (int('n), int('t), bool('wb_unknown), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcgettagarray (n, t, wb_unknown__arg, wback__arg) = {
    wb_unknown : bool = wb_unknown__arg;
    wback : bool = wback__arg;
    data : bits(64) = Zeros(64);
    address : bits(64) = undefined : bits(64);
    count : int = undefined : int;
    c : Constraint = undefined : Constraint;
    if n == t then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              UnallocatedEncoding()
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    (address, count) = ImpDefTagArrayStartAndCount(address);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        let 'index = UInt(slice(address, LOG2_TAG_GRANULE, 4));
        let tag : bits(4) = aget_MemTag(address);
        data = __SetSlice_bits(64, 4, data, index * 4, tag);
        address = address + TAG_GRANULE
    };
    aset_X(t, data);
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcgettagarray_decode : (bits(5), bits(5)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcgettagarray_decode (Xt, Xn) = {
    __unconditional = true;
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    let wback : bool(true) = true;
    let wb_unknown : bool(false) = false;
    __PostDecode();
    integer_tags_mcgettagarray(n, t, wb_unknown, wback)
}

val ReservedValue : unit -> unit effect {escape, rreg, undef, wreg}

function ReservedValue () = {
    if UsingAArch32() & ~(AArch32_GeneralExceptionsToAArch64()) then {
        AArch32_TakeUndefInstrException()
    } else {
        AArch64_UndefinedFault()
    }
}

val integer_arithmetic_addsub_immediate_decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_immediate_decode (Rd, Rn, imm12, shift, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize : {'n, 'n in {64, 32}. int('n)} = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined : bits('datasize);
    match shift {
      0b00 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b01 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      },
      0b10 => {
          throw(Error_See("ADDG, SUBG"))
      },
      0b11 => {
          ReservedValue()
      }
    };
    __PostDecode();
    integer_arithmetic_addsub_immediate(d, datasize, imm, n, setflags, sub_op)
}

val AArch32_UndefinedFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_UndefinedFault () = {
    if AArch32_GeneralExceptionsToAArch64() then {
        AArch64_UndefinedFault()
    };
    AArch32_TakeUndefInstrException()
}

val UndefinedFault : unit -> unit effect {escape, rreg, undef, wreg}

function UndefinedFault () = {
    if UsingAArch32() then {
        AArch32_UndefinedFault()
    } else {
        AArch64_UndefinedFault()
    }
}

val fault_at_EL0 : unit -> unit effect {escape, rreg, undef, wreg}

function fault_at_EL0 () = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    }
}

val DC_IGSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_IGSW val_name = {
    fault_at_EL0();
    return()
}

val DC_IGDSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_IGDSW val_name = {
    fault_at_EL0();
    return()
}

val DC_GVA : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_GVA val_name = {
    fault_at_EL0();
    check_access_z(val_name, false);
    let 'size = 4 * 2 ^ UInt(slice(DCZID_EL0, 0, 4));
    address : bits(64) = Align(val_name, size);
    let 'count = shr_int(size, LOG2_TAG_GRANULE);
    let tag : bits(4) = AllocationTagFromAddress(address);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        MemTag(address) = tag;
        address = address + TAG_GRANULE
    };
    return()
}

val DC_CIGSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CIGSW val_name = {
    fault_at_EL0();
    return()
}

val DC_CGVADP : unit -> unit effect {escape, rreg, undef, wreg}

function DC_CGVADP () = {
    fault_at_EL0();
    return()
}

val DC_CGDVADP : unit -> unit effect {escape, rreg, undef, wreg}

function DC_CGDVADP () = {
    DC_CGVADP();
    return()
}

val DC_CGSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CGSW val_name = {
    fault_at_EL0();
    return()
}

val default_system_exceptions_debug_halt_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function default_system_exceptions_debug_halt_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    if [EDSCR[14]] == 0b0 | ~(HaltingAllowed()) then {
        UndefinedFault()
    };
    if HaveBTIExt() then {
        BTypeCompatible = true
    };
    __PostDecode();
    system_exceptions_debug_halt()
}

val TLBI_VALE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VALE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VALE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VALE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VALE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VALE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VAE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VAE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VAE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VAE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VAE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VAE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVALE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVALE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVALE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVALE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVALE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVALE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVAE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVAE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVAE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVAE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVAE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVAE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_ALLE2OS : unit -> unit effect {escape, rreg, undef, wreg}

function TLBI_ALLE2OS () = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_ALLE2IS : unit -> unit effect {escape, rreg, undef, wreg}

function TLBI_ALLE2IS () = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_ALLE2 : unit -> unit effect {escape, rreg, undef, wreg}

function TLBI_ALLE2 () = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val IC_IALLUIS : unit -> unit effect {escape, rreg, undef, wreg}

function IC_IALLUIS () = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val IC_IALLU : unit -> unit effect {escape, rreg, undef, wreg}

function IC_IALLU () = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val DC_ISW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_ISW val_name = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    if HasS2Translation() & ([HCR_EL2[0]] == 0b1 | [HCR_EL2[1]] == 0b1) then ();
    return()
}

val DC_CSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CSW val_name = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val DC_CGDSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CGDSW val_name = {
    DC_CSW(val_name);
    DC_CGSW(val_name);
    return()
}

val DC_CISW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CISW val_name = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val DC_CIGDSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CIGDSW val_name = {
    DC_CISW(val_name);
    DC_CIGSW(val_name);
    return()
}

val DCPSInstruction : bits(2) -> unit effect {escape, rreg, undef, wreg}

function DCPSInstruction target_el = {
    SynchronizeContext();
    handle_el : bits(2) = undefined : bits(2);
    match target_el {
      ? if ? == EL1 => {
          if PSTATE.EL == EL2 | PSTATE.EL == EL3 & ~(UsingAArch32()) then {
              handle_el = PSTATE.EL
          } else {
              if EL2Enabled() & [HCR_EL2[27]] == 0b1 then {
                  UndefinedFault()
              } else {
                  handle_el = EL1
              }
          }
      },
      ? if ? == EL2 => {
          if ~(HaveEL(EL2)) then {
              UndefinedFault()
          } else {
              if PSTATE.EL == EL3 & ~(UsingAArch32()) then {
                  handle_el = EL3
              } else {
                  if ~(IsSecureEL2Enabled()) & IsSecure() then {
                      UndefinedFault()
                  } else {
                      handle_el = EL2
                  }
              }
          }
      },
      ? if ? == EL3 => {
          if [EDSCR[16]] == 0b1 | ~(HaveEL(EL3)) then {
              UndefinedFault()
          };
          handle_el = EL3
      },
      _ => {
          Unreachable()
      }
    };
    let from_secure : bool = IsSecure();
    if ELUsingAArch32(handle_el) then {
        if PSTATE.M == M32_Monitor then {
            __tc1 : bits(32) = get_SCR();
            __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b0);
            set_SCR(__tc1)
        };
        assert(UsingAArch32());
        match handle_el {
          ? if ? == EL1 => {
              AArch32_WriteMode(M32_Svc);
              if HavePANExt() & [get_SCTLR()[23]] == 0b0 then {
                  PSTATE.PAN = 0b1
              }
          },
          ? if ? == EL2 => {
              AArch32_WriteMode(M32_Hyp)
          },
          ? if ? == EL3 => {
              AArch32_WriteMode(M32_Monitor);
              if HavePANExt() then {
                  if ~(from_secure) then {
                      PSTATE.PAN = 0b0
                  } else {
                      if [get_SCTLR()[23]] == 0b0 then {
                          PSTATE.PAN = 0b1
                      }
                  }
              }
          }
        };
        if handle_el == EL2 then {
            set_ELR_hyp(undefined : bits(32));
            set_HSR(undefined : bits(32))
        } else {
            set_LR(undefined : bits(32))
        };
        SPSR() = undefined : bits(32);
        PSTATE.E = [SCTLR()[25]];
        set_DLR(undefined : bits(32));
        set_DSPSR(undefined : bits(32))
    } else {
        if UsingAArch32() then {
            AArch64_MaybeZeroRegisterUppers()
        };
        PSTATE.nRW = 0b0;
        PSTATE.SP = 0b1;
        PSTATE.EL = handle_el;
        if HavePANExt() & (handle_el == EL1 & [SCTLR_EL1[23]] == 0b0 | ((handle_el == EL2 & [HCR_EL2[34]] == 0b1) & [HCR_EL2[27]] == 0b1) & [SCTLR_EL2[23]] == 0b0) then {
            PSTATE.PAN = 0b1
        };
        ELR() = undefined : bits(64);
        SPSR() = undefined : bits(32);
        ESR() = undefined : bits(32);
        DLR_EL0 = undefined : bits(64);
        DSPSR_EL0 = undefined : bits(32);
        if HaveUAOExt() then {
            PSTATE.UAO = 0b0
        }
    };
    UpdateEDSCRFields();
    sync_errors : bool = undefined : bool;
    sync_errors = HaveIESB() & [SCTLR()[21]] == 0b1;
    if HaveDoubleFaultExt() & ~(UsingAArch32()) then {
        sync_errors = sync_errors | ([SCR_EL3[3]] == 0b1 & [SCR_EL3[20]] == 0b1) & PSTATE.EL == EL3
    };
    if ~(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    };
    if sync_errors then {
        SynchronizeErrors()
    };
    return()
}

val system_exceptions_debug_exception : bits(2) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_exception target_level = {
    DCPSInstruction(target_level)
}

val system_exceptions_debug_exception_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_exception_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let target_level : vector(2, dec, bit) = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    };
    if ~(Halted()) then {
        AArch64_UndefinedFault()
    };
    __PostDecode();
    system_exceptions_debug_exception(target_level)
}

val AArch64_SysInstrWithResult : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bits(64) effect {escape, rreg, undef, wreg}

function AArch64_SysInstrWithResult (op0, op1, crn, crm, op2) = {
    if (__GetSlice_int(2, op0, 0) == 0b01 | __GetSlice_int(2, op0, 0) == 0b11) & (__GetSlice_int(4, crn, 0) == 0xB | __GetSlice_int(4, crn, 0) == 0xF) then {
        throw(Error_Implementation_Defined(""))
    } else {
        UndefinedFault()
    };
    undefined : bits(64)
}

val AArch32_TakePhysicalIRQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakePhysicalIRQException () = {
    route_to_aarch64 : bool = undefined : bool;
    route_to_aarch64 = PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1));
    if (~(route_to_aarch64) & EL2Enabled()) & ~(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = [HCR_EL2[27]] == 0b1 | [HCR_EL2[4]] == 0b1 & ~(IsInHost())
    };
    if (~(route_to_aarch64) & HaveEL(EL3)) & ~(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = [SCR_EL3[1]] == 0b1
    };
    if route_to_aarch64 then {
        AArch64_TakePhysicalIRQException()
    };
    let route_to_monitor : bool = HaveEL(EL3) & [get_SCR()[1]] == 0b1;
    let route_to_hyp : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([get_HCR()[27]] == 0b1 | [get_HCR()[4]] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(24) = 24;
    let lr_offset : int(4) = 4;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if route_to_monitor then {
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_hyp then {
            exception = ExceptionSyndrome(Exception_IRQ);
            AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
        } else {
            AArch32_EnterMode(M32_IRQ, preferred_exception_return, lr_offset, vect_offset)
        }
    }
}

val AArch32_TakePhysicalFIQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakePhysicalFIQException () = {
    route_to_aarch64 : bool = undefined : bool;
    route_to_aarch64 = PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1));
    if (~(route_to_aarch64) & EL2Enabled()) & ~(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = [HCR_EL2[27]] == 0b1 | [HCR_EL2[3]] == 0b1 & ~(IsInHost())
    };
    if (~(route_to_aarch64) & HaveEL(EL3)) & ~(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = [SCR_EL3[2]] == 0b1
    };
    if route_to_aarch64 then {
        AArch64_TakePhysicalFIQException()
    };
    let route_to_monitor : bool = HaveEL(EL3) & [get_SCR()[2]] == 0b1;
    let route_to_hyp : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([get_HCR()[27]] == 0b1 | [get_HCR()[3]] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(28) = 28;
    let lr_offset : int(4) = 4;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if route_to_monitor then {
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_hyp then {
            exception = ExceptionSyndrome(Exception_FIQ);
            AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
        } else {
            AArch32_EnterMode(M32_FIQ, preferred_exception_return, lr_offset, vect_offset)
        }
    }
}

val AArch32_InstructionAbort : (bits(32), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch32_InstructionAbort (vaddress, fault) = {
    let route_to_monitor : bool = (HaveEL(EL3) & [get_SCR()[3]] == 0b1) & IsExternalAbort(fault);
    let route_to_hyp : bool = ((HaveEL(EL2) & ~(IsSecure())) & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ((([get_HCR()[27]] == 0b1 | IsSecondStage(fault)) | (HaveRASExt() & [get_HCR2()[5]] == 0b1) & IsExternalAbort(fault)) | IsDebugException(fault) & [get_HDCR()[8]] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(12) = 12;
    let lr_offset : int(4) = 4;
    if IsDebugException(fault) then {
        __tc1 : bits(32) = get_DBGDSCRext();
        __tc1 = __SetSlice_bits(32, 4, __tc1, 2, fault.debugmoe);
        set_DBGDSCRext(__tc1)
    };
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if route_to_monitor then {
        AArch32_ReportPrefetchAbort(route_to_monitor, fault, vaddress);
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_hyp then {
            if fault.typ == Fault_Alignment then {
                exception = ExceptionSyndrome(Exception_PCAlignment);
                exception.vaddress = ThisInstrAddr()
            } else {
                exception = AArch32_AbortSyndrome(Exception_InstructionAbort, fault, vaddress)
            };
            if PSTATE.EL == EL2 then {
                AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
            } else {
                AArch32_EnterHypMode(exception, preferred_exception_return, 20)
            }
        } else {
            AArch32_ReportPrefetchAbort(route_to_monitor, fault, vaddress);
            AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
        }
    }
}

val AArch32_CheckIllegalState : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckIllegalState () = {
    exception : ExceptionRecord = undefined : ExceptionRecord;
    route_to_hyp : bool = undefined : bool;
    vect_offset : int = undefined : int;
    if AArch32_GeneralExceptionsToAArch64() then {
        AArch64_CheckIllegalState()
    } else {
        if PSTATE.IL == 0b1 then {
            route_to_hyp = (EL2Enabled() & PSTATE.EL == EL0) & [get_HCR()[27]] == 0b1;
            let preferred_exception_return : bits(32) = ThisInstrAddr();
            vect_offset = 4;
            if PSTATE.EL == EL2 | route_to_hyp then {
                exception = ExceptionSyndrome(Exception_IllegalState);
                if PSTATE.EL == EL2 then {
                    AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
                } else {
                    AArch32_EnterHypMode(exception, preferred_exception_return, 20)
                }
            } else {
                AArch32_TakeUndefInstrException()
            }
        }
    }
}

val AArch32_DataAbort : (bits(32), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch32_DataAbort (vaddress, fault) = {
    let route_to_monitor : bool = (HaveEL(EL3) & [get_SCR()[3]] == 0b1) & IsExternalAbort(fault);
    let route_to_hyp : bool = ((HaveEL(EL2) & ~(IsSecure())) & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ((([get_HCR()[27]] == 0b1 | IsSecondStage(fault)) | (HaveRASExt() & [get_HCR2()[5]] == 0b1) & IsExternalAbort(fault)) | IsDebugException(fault) & [get_HDCR()[8]] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(16) = 16;
    let lr_offset : int(8) = 8;
    if IsDebugException(fault) then {
        __tc1 : bits(32) = get_DBGDSCRext();
        __tc1 = __SetSlice_bits(32, 4, __tc1, 2, fault.debugmoe);
        set_DBGDSCRext(__tc1)
    };
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if route_to_monitor then {
        AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_hyp then {
            exception = AArch32_AbortSyndrome(Exception_DataAbort, fault, vaddress);
            if PSTATE.EL == EL2 then {
                AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
            } else {
                AArch32_EnterHypMode(exception, preferred_exception_return, 20)
            }
        } else {
            AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
            AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
        }
    }
}

val AArch32_CreateFaultRecord : forall 'level ('write : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (Fault, bits(40), bits(4), int('level), AccType, bool('write), bits(1), bits(4), bits(2), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_CreateFaultRecord (typ, ipaddress, domain, level, acctype, write, extflag, debugmoe, errortype, secondstage, s2fs1walk) = {
    fault : FaultRecord = undefined : FaultRecord;
    fault.typ = typ;
    if ((((typ != Fault_None & PSTATE.EL != EL2) & [get_TTBCR()[31]] == 0b0) & ~(secondstage)) & ~(s2fs1walk)) & AArch32_DomainValid(typ, level) then {
        fault.domain = domain
    } else {
        fault.domain = undefined : bits(4)
    };
    fault.debugmoe = debugmoe;
    fault.errortype = errortype;
    __tc1 : FullAddress = fault.ipaddress;
    __tc1.NS = undefined : bits(1);
    fault.ipaddress = __tc1;
    __tc2 : FullAddress = fault.ipaddress;
    __tc2.address = ZeroExtend(ipaddress);
    fault.ipaddress = __tc2;
    fault.level = level;
    fault.acctype = acctype;
    fault.write = write;
    fault.extflag = extflag;
    fault.secondstage = secondstage;
    fault.s2fs1walk = s2fs1walk;
    fault
}

val _SyncExternalFault : (bits(52), AccessDescriptor, bits(1), bits(1)) -> FaultRecord effect {escape, rreg, undef}

function _SyncExternalFault (paddress, accdesc, read, extflag) = {
    let write : bool = read == 0b0;
    let secondstage : bool = accdesc.secondstage;
    let s2fs1walk : bool = accdesc.s2fs1walk;
    let level : int = accdesc.level;
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    debugmoe : bits(4) = undefined : bits(4);
    domain : bits(4) = undefined : bits(4);
    if UsingAArch32() then {
        debugmoe = undefined : bits(4);
        domain = undefined : bits(4);
        assert(slice(paddress, 40, 8) == 0x00);
        assert(slice(paddress, 40, 12) == Zeros(52 - 40));
        return(AArch32_CreateFaultRecord(Fault_SyncExternal, slice(paddress, 0, 40), domain, level, accdesc.acctype, write, extflag, debugmoe, errortype, secondstage, s2fs1walk))
    } else {
        return(AArch64_CreateFaultRecord(Fault_SyncExternal, paddress, undefined : bits(1), level, accdesc.acctype, write, extflag, errortype, secondstage, s2fs1walk))
    }
}

val AArch32_TranslationFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(40), bits(4), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_TranslationFault (ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch32_CreateFaultRecord(Fault_Translation, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_PermissionFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(40), bits(4), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_PermissionFault (ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch32_CreateFaultRecord(Fault_Permission, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_InstructionDevice : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (AddressDescriptor, bits(32), bits(40), int('level), bits(4), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> AddressDescriptor effect {escape, rreg, undef}

function AArch32_InstructionDevice (addrdesc__arg, vaddress, ipaddress, level, domain, acctype, iswrite, secondstage, s2fs1walk) = {
    addrdesc = addrdesc__arg;
    let c : Constraint = ConstrainUnpredictable(Unpredictable_INSTRDEVICE);
    assert(c == Constraint_NONE | c == Constraint_FAULT);
    if c == Constraint_FAULT then {
        addrdesc.fault = AArch32_PermissionFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk)
    } else {
        __tc1 : MemoryAttributes = addrdesc.memattrs;
        __tc1.typ = MemType_Normal;
        addrdesc.memattrs = __tc1;
        __tc2 : MemAttrHints = addrdesc.memattrs.inner;
        __tc2.attrs = MemAttr_NC;
        __tc3 : MemoryAttributes = addrdesc.memattrs;
        __tc3.inner = __tc2;
        addrdesc.memattrs = __tc3;
        __tc4 : MemAttrHints = addrdesc.memattrs.inner;
        __tc4.hints = MemHint_No;
        __tc5 : MemoryAttributes = addrdesc.memattrs;
        __tc5.inner = __tc4;
        addrdesc.memattrs = __tc5;
        __tc6 : MemoryAttributes = addrdesc.memattrs;
        __tc6.outer = addrdesc.memattrs.inner;
        addrdesc.memattrs = __tc6;
        __tc7 : MemoryAttributes = addrdesc.memattrs;
        __tc7.tagged = false;
        addrdesc.memattrs = __tc7;
        addrdesc.memattrs = MemAttrDefaults(addrdesc.memattrs)
    };
    addrdesc
}

val AArch32_NoFault : unit -> FaultRecord effect {escape, rreg, undef}

function AArch32_NoFault () = {
    let ipaddress : vector(40, dec, bit) = undefined : bits(40);
    let domain : vector(4, dec, bit) = undefined : bits(4);
    let level : int = undefined : int;
    let acctype : AccType = AccType_NORMAL;
    let iswrite : bool = undefined : bool;
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    let secondstage : bool(false) = false;
    let s2fs1walk : bool(false) = false;
    AArch32_CreateFaultRecord(Fault_None, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_TranslateAddressS1Off : forall ('iswrite : Bool).
  (bits(32), AccType, bool('iswrite)) -> TLBRecord effect {escape, rreg, undef}

function AArch32_TranslateAddressS1Off (vaddress, acctype, iswrite) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    result : TLBRecord = undefined : TLBRecord;
    let default_cacheable : bool = HasS2Translation() & (if ELUsingAArch32(EL2) then [get_HCR()[12]] else [HCR_EL2[12]]) == 0b1;
    cacheable : bool = undefined : bool;
    if default_cacheable then {
        __tc1 : MemoryAttributes = result.addrdesc.memattrs;
        __tc1.typ = MemType_Normal;
        __tc2 : AddressDescriptor = result.addrdesc;
        __tc2.memattrs = __tc1;
        result.addrdesc = __tc2;
        __tc3 : MemAttrHints = result.addrdesc.memattrs.inner;
        __tc3.attrs = MemAttr_WB;
        __tc4 : MemoryAttributes = result.addrdesc.memattrs;
        __tc4.inner = __tc3;
        __tc5 : AddressDescriptor = result.addrdesc;
        __tc5.memattrs = __tc4;
        result.addrdesc = __tc5;
        __tc6 : MemAttrHints = result.addrdesc.memattrs.inner;
        __tc6.hints = MemHint_RWA;
        __tc7 : MemoryAttributes = result.addrdesc.memattrs;
        __tc7.inner = __tc6;
        __tc8 : AddressDescriptor = result.addrdesc;
        __tc8.memattrs = __tc7;
        result.addrdesc = __tc8;
        __tc9 : MemoryAttributes = result.addrdesc.memattrs;
        __tc9.shareable = false;
        __tc10 : AddressDescriptor = result.addrdesc;
        __tc10.memattrs = __tc9;
        result.addrdesc = __tc10;
        __tc11 : MemoryAttributes = result.addrdesc.memattrs;
        __tc11.outershareable = false;
        __tc12 : AddressDescriptor = result.addrdesc;
        __tc12.memattrs = __tc11;
        result.addrdesc = __tc12;
        __tc13 : MemoryAttributes = result.addrdesc.memattrs;
        __tc13.tagged = [HCR_EL2[57]] == 0b1;
        __tc14 : AddressDescriptor = result.addrdesc;
        __tc14.memattrs = __tc13;
        result.addrdesc = __tc14
    } else {
        if acctype != AccType_IFETCH then {
            __tc15 : MemoryAttributes = result.addrdesc.memattrs;
            __tc15.typ = MemType_Device;
            __tc16 : AddressDescriptor = result.addrdesc;
            __tc16.memattrs = __tc15;
            result.addrdesc = __tc16;
            __tc17 : MemoryAttributes = result.addrdesc.memattrs;
            __tc17.device = DeviceType_nGnRnE;
            __tc18 : AddressDescriptor = result.addrdesc;
            __tc18.memattrs = __tc17;
            result.addrdesc = __tc18;
            __tc19 : MemoryAttributes = result.addrdesc.memattrs;
            __tc19.inner = undefined : MemAttrHints;
            __tc20 : AddressDescriptor = result.addrdesc;
            __tc20.memattrs = __tc19;
            result.addrdesc = __tc20;
            __tc21 : MemoryAttributes = result.addrdesc.memattrs;
            __tc21.tagged = false;
            __tc22 : AddressDescriptor = result.addrdesc;
            __tc22.memattrs = __tc21;
            result.addrdesc = __tc22
        } else {
            if PSTATE.EL == EL2 then {
                cacheable = [get_HSCTLR()[12]] == 0b1
            } else {
                cacheable = [get_SCTLR()[12]] == 0b1
            };
            __tc23 : MemoryAttributes = result.addrdesc.memattrs;
            __tc23.typ = MemType_Normal;
            __tc24 : AddressDescriptor = result.addrdesc;
            __tc24.memattrs = __tc23;
            result.addrdesc = __tc24;
            if cacheable then {
                __tc25 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc25.attrs = MemAttr_WT;
                __tc26 : MemoryAttributes = result.addrdesc.memattrs;
                __tc26.inner = __tc25;
                __tc27 : AddressDescriptor = result.addrdesc;
                __tc27.memattrs = __tc26;
                result.addrdesc = __tc27;
                __tc28 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc28.hints = MemHint_RA;
                __tc29 : MemoryAttributes = result.addrdesc.memattrs;
                __tc29.inner = __tc28;
                __tc30 : AddressDescriptor = result.addrdesc;
                __tc30.memattrs = __tc29;
                result.addrdesc = __tc30
            } else {
                __tc31 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc31.attrs = MemAttr_NC;
                __tc32 : MemoryAttributes = result.addrdesc.memattrs;
                __tc32.inner = __tc31;
                __tc33 : AddressDescriptor = result.addrdesc;
                __tc33.memattrs = __tc32;
                result.addrdesc = __tc33;
                __tc34 : MemAttrHints = result.addrdesc.memattrs.inner;
                __tc34.hints = MemHint_No;
                __tc35 : MemoryAttributes = result.addrdesc.memattrs;
                __tc35.inner = __tc34;
                __tc36 : AddressDescriptor = result.addrdesc;
                __tc36.memattrs = __tc35;
                result.addrdesc = __tc36
            };
            __tc37 : MemoryAttributes = result.addrdesc.memattrs;
            __tc37.shareable = true;
            __tc38 : AddressDescriptor = result.addrdesc;
            __tc38.memattrs = __tc37;
            result.addrdesc = __tc38;
            __tc39 : MemoryAttributes = result.addrdesc.memattrs;
            __tc39.outershareable = true;
            __tc40 : AddressDescriptor = result.addrdesc;
            __tc40.memattrs = __tc39;
            result.addrdesc = __tc40;
            __tc41 : MemoryAttributes = result.addrdesc.memattrs;
            __tc41.tagged = false;
            __tc42 : AddressDescriptor = result.addrdesc;
            __tc42.memattrs = __tc41;
            result.addrdesc = __tc42
        }
    };
    __tc43 : MemoryAttributes = result.addrdesc.memattrs;
    __tc43.outer = result.addrdesc.memattrs.inner;
    __tc44 : AddressDescriptor = result.addrdesc;
    __tc44.memattrs = __tc43;
    result.addrdesc = __tc44;
    __tc45 : AddressDescriptor = result.addrdesc;
    __tc45.memattrs = MemAttrDefaults(result.addrdesc.memattrs);
    result.addrdesc = __tc45;
    __tc46 : Permissions = result.perms;
    __tc46.ap = undefined : bits(3);
    result.perms = __tc46;
    __tc47 : Permissions = result.perms;
    __tc47.xn = 0b0;
    result.perms = __tc47;
    __tc48 : Permissions = result.perms;
    __tc48.pxn = 0b0;
    result.perms = __tc48;
    result.nG = undefined : bits(1);
    result.contiguous = undefined : bool;
    result.domain = undefined : bits(4);
    result.level = undefined : int;
    result.blocksize = undefined : int;
    __tc49 : FullAddress = result.addrdesc.paddress;
    __tc49.address = ZeroExtend(vaddress);
    __tc50 : AddressDescriptor = result.addrdesc;
    __tc50.paddress = __tc49;
    result.addrdesc = __tc50;
    __tc51 : FullAddress = result.addrdesc.paddress;
    __tc51.NS = if IsSecure() then 0b0 else 0b1;
    __tc52 : AddressDescriptor = result.addrdesc;
    __tc52.paddress = __tc51;
    result.addrdesc = __tc52;
    __tc53 : AddressDescriptor = result.addrdesc;
    __tc53.fault = AArch32_NoFault();
    result.addrdesc = __tc53;
    result
}

val AArch32_DomainFault : forall ('level : Int) ('iswrite : Bool).
  (bits(4), int('level), AccType, bool('iswrite)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_DomainFault (domain, level, acctype, iswrite) = {
    let ipaddress : vector(40, dec, bit) = undefined : bits(40);
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    let secondstage : bool(false) = false;
    let s2fs1walk : bool(false) = false;
    AArch32_CreateFaultRecord(Fault_Domain, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_CheckDomain : forall ('level : Int) ('iswrite : Bool).
  (bits(4), bits(32), int('level), AccType, bool('iswrite)) -> (bool, FaultRecord) effect {escape, rreg, undef}

function AArch32_CheckDomain (domain, vaddress, level, acctype, iswrite) = {
    let index : {'ex199142#, (0 <= 'ex199142# & 'ex199142# <= 2 ^ 4 - 1). int(2 * 'ex199142#)} = 2 * UInt(domain);
    attrfield : bits(2) = undefined : bits(2);
    attrfield = slice(get_DACR(), index, 2);
    __anon1 : Constraint = undefined : Constraint;
    if attrfield == 0b10 then {
        (__anon1, attrfield) = ConstrainUnpredictableBits(Unpredictable_RESDACR)
    };
    fault : FaultRecord = undefined : FaultRecord;
    if attrfield == 0b00 then {
        fault = AArch32_DomainFault(domain, level, acctype, iswrite)
    } else {
        fault = AArch32_NoFault()
    };
    let permissioncheck : bool = attrfield == 0b01;
    return((permissioncheck, fault))
}

val AArch32_DebugFault : forall ('iswrite : Bool).
  (AccType, bool('iswrite), bits(4)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_DebugFault (acctype, iswrite, debugmoe) = {
    let ipaddress : vector(40, dec, bit) = undefined : bits(40);
    let domain : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    let level : int = undefined : int;
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let secondstage : bool(false) = false;
    let s2fs1walk : bool(false) = false;
    AArch32_CreateFaultRecord(Fault_Debug, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_AsynchExternalAbort : forall ('parity : Bool).
  (bool('parity), bits(2), bits(1)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_AsynchExternalAbort (parity, errortype, extflag) = {
    let typ : Fault = if parity then Fault_AsyncParity else Fault_AsyncExternal;
    let ipaddress : vector(40, dec, bit) = undefined : bits(40);
    let domain : vector(4, dec, bit) = undefined : bits(4);
    let level : int = undefined : int;
    let acctype : AccType = AccType_NORMAL;
    let iswrite : bool = undefined : bool;
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let secondstage : bool(false) = false;
    let s2fs1walk : bool(false) = false;
    AArch32_CreateFaultRecord(typ, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_TakeVirtualSErrorException : forall ('impdef_syndrome : Bool).
  (bits(1), bits(2), bool('impdef_syndrome), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeVirtualSErrorException (extflag, errortype, impdef_syndrome, full_syndrome) = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    if ELUsingAArch32(EL2) then {
        assert([get_HCR()[27]] == 0b0 & [get_HCR()[5]] == 0b1)
    } else {
        assert([HCR_EL2[27]] == 0b0 & [HCR_EL2[5]] == 0b1)
    };
    if PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1)) then {
        AArch64_TakeVirtualSErrorException(impdef_syndrome, full_syndrome)
    };
    let route_to_monitor : bool(false) = false;
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(16) = 16;
    let lr_offset : int(8) = 8;
    let vaddress : vector(32, dec, bit) = undefined : bits(32);
    let parity : bool(false) = false;
    fault : FaultRecord = undefined : FaultRecord;
    if HaveRASExt() then {
        if ELUsingAArch32(EL2) then {
            fault = AArch32_AsynchExternalAbort(false, slice(get_VDFSR(), 14, 2), [get_VDFSR()[12]])
        } else {
            fault = AArch32_AsynchExternalAbort(false, slice(VSESR_EL2, 14, 2), [VSESR_EL2[12]])
        }
    } else {
        fault = AArch32_AsynchExternalAbort(parity, errortype, extflag)
    };
    ClearPendingVirtualSError();
    AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
    AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
}

val AArch32_TakePhysicalSErrorException : forall ('parity : Bool) ('impdef_syndrome : Bool).
  (bool('parity), bits(1), bits(2), bool('impdef_syndrome), bits(24)) -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakePhysicalSErrorException (parity, extflag, errortype, impdef_syndrome, full_syndrome) = {
    ClearPendingPhysicalSError();
    route_to_aarch64 : bool = undefined : bool;
    route_to_aarch64 = PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1));
    if (~(route_to_aarch64) & EL2Enabled()) & ~(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = [HCR_EL2[27]] == 0b1 | ~(IsInHost()) & [HCR_EL2[5]] == 0b1
    };
    if (~(route_to_aarch64) & HaveEL(EL3)) & ~(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = [SCR_EL3[3]] == 0b1
    };
    if route_to_aarch64 then {
        AArch64_TakePhysicalSErrorException(impdef_syndrome, full_syndrome)
    };
    let route_to_monitor : bool = HaveEL(EL3) & [get_SCR()[3]] == 0b1;
    let route_to_hyp : bool = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([get_HCR()[27]] == 0b1 | [get_HCR()[5]] == 0b1);
    let preferred_exception_return : bits(32) = ThisInstrAddr();
    let vect_offset : int(16) = 16;
    let lr_offset : int(8) = 8;
    let fault : FaultRecord = AArch32_AsynchExternalAbort(parity, errortype, extflag);
    let vaddress : vector(32, dec, bit) = undefined : bits(32);
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if route_to_monitor then {
        AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset)
    } else {
        if PSTATE.EL == EL2 | route_to_hyp then {
            exception = AArch32_AbortSyndrome(Exception_DataAbort, fault, vaddress);
            if PSTATE.EL == EL2 then {
                AArch32_EnterHypMode(exception, preferred_exception_return, vect_offset)
            } else {
                AArch32_EnterHypMode(exception, preferred_exception_return, 20)
            }
        } else {
            AArch32_ReportDataAbort(route_to_monitor, fault, vaddress);
            AArch32_EnterMode(M32_Abort, preferred_exception_return, lr_offset, vect_offset)
        }
    }
}

function TakePendingInterrupts interrupt_req = {
    AA : bool = undefined : bool;
    FIQ : bool = undefined : bool;
    IRQ : bool = undefined : bool;
    SE : bool = undefined : bool;
    interrupt_taken : bool = undefined : bool;
    syndrome : bits(25) = undefined : bits(25);
    syndrome32 : AArch32_SErrorSyndrome = undefined : AArch32_SErrorSyndrome;
    syndrome64 : bits(25) = undefined : bits(25);
    vAA : bool = undefined : bool;
    vFIQ : bool = undefined : bool;
    vIRQ : bool = undefined : bool;
    vSE : bool = undefined : bool;
    if UsingAArch32() then {
        (vAA, vIRQ, vFIQ) = AArch32_PendingUnmaskedVirtualInterrupts();
        (AA, IRQ, FIQ) = AArch32_PendingUnmaskedPhysicalInterrupts();
        if ~(interrupt_req.take_SE) then {
            AA = false
        };
        if ~(interrupt_req.take_vSE) then {
            vAA = false
        };
        if ~(interrupt_req.take_IRQ) then {
            IRQ = false
        };
        if ~(interrupt_req.take_vIRQ) then {
            vIRQ = false
        };
        if ~(interrupt_req.take_FIQ) then {
            FIQ = false
        };
        if ~(interrupt_req.take_vFIQ) then {
            vFIQ = false
        };
        if ((((AA | FIQ) | IRQ) | vAA) | vFIQ) | vIRQ then {
            interrupt_taken = true
        } else {
            interrupt_taken = false
        };
        if vFIQ then {
            AArch32_TakeVirtualFIQException()
        } else {
            if vIRQ then {
                AArch32_TakeVirtualIRQException()
            } else {
                if vAA then {
                    AArch32_TakeVirtualSErrorException([get_VDFSR()[12]], slice(get_VDFSR(), 14, 2), [get_VDFSR()[24]] == 0b1, slice(get_VDFSR(), 0, 24))
                } else {
                    if FIQ then {
                        AArch32_TakePhysicalFIQException()
                    } else {
                        if IRQ then {
                            AArch32_TakePhysicalIRQException()
                        } else {
                            if AA then {
                                syndrome32 = AArch32_PhysicalSErrorSyndrome();
                                syndrome64 = AArch64_PhysicalSErrorSyndrome(interrupt_req.iesb_req);
                                AArch32_TakePhysicalSErrorException(false, syndrome32.ExT, syndrome32.AET, [syndrome64[24]] == 0b1, slice(syndrome64, 0, 24))
                            }
                        }
                    }
                }
            }
        }
    } else {
        (vSE, vIRQ, vFIQ) = AArch64_PendingUnmaskedVirtualInterrupts(PSTATE.A @ (PSTATE.I @ PSTATE.F));
        (SE, IRQ, FIQ) = AArch64_PendingUnmaskedPhysicalInterrupts(PSTATE.A @ (PSTATE.I @ PSTATE.F));
        if ~(interrupt_req.take_SE) then {
            SE = false
        };
        if ~(interrupt_req.take_vSE) then {
            vSE = false
        };
        if ~(interrupt_req.take_IRQ) then {
            IRQ = false
        };
        if ~(interrupt_req.take_vIRQ) then {
            vIRQ = false
        };
        if ~(interrupt_req.take_FIQ) then {
            FIQ = false
        };
        if ~(interrupt_req.take_vFIQ) then {
            vFIQ = false
        };
        if ((((SE | FIQ) | IRQ) | vSE) | vFIQ) | vIRQ then {
            interrupt_taken = true
        } else {
            interrupt_taken = false
        };
        if vFIQ then {
            AArch64_TakeVirtualFIQException()
        } else {
            if vIRQ then {
                AArch64_TakeVirtualIRQException()
            } else {
                if vSE then {
                    AArch64_TakeVirtualSErrorException([VSESR_EL2[24]] == 0b1, slice(VSESR_EL2, 0, 24))
                } else {
                    if FIQ then {
                        AArch64_TakePhysicalFIQException()
                    } else {
                        if IRQ then {
                            AArch64_TakePhysicalIRQException()
                        } else {
                            if SE then {
                                syndrome = AArch64_PhysicalSErrorSyndrome(interrupt_req.iesb_req);
                                AArch64_TakePhysicalSErrorException([syndrome[24]] == 0b1, slice(syndrome, 0, 24))
                            }
                        }
                    }
                }
            }
        }
    };
    interrupt_taken
}

val AArch32_AlignmentFault : forall ('iswrite : Bool) ('secondstage : Bool).
  (AccType, bool('iswrite), bool('secondstage)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_AlignmentFault (acctype, iswrite, secondstage) = {
    let ipaddress : vector(40, dec, bit) = undefined : bits(40);
    let domain : vector(4, dec, bit) = undefined : bits(4);
    let level : int = undefined : int;
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    let s2fs1walk : bool = undefined : bool;
    AArch32_CreateFaultRecord(Fault_Alignment, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_AddressSizeFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(40), bits(4), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_AddressSizeFault (ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch32_CreateFaultRecord(Fault_AddressSize, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_AccessFlagFault : forall 'level ('iswrite : Bool) ('secondstage : Bool) ('s2fs1walk : Bool).
  (bits(40), bits(4), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_AccessFlagFault (ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : vector(1, dec, bit) = undefined : bits(1);
    let debugmoe : vector(4, dec, bit) = undefined : bits(4);
    let errortype : vector(2, dec, bit) = undefined : bits(2);
    AArch32_CreateFaultRecord(Fault_AccessFlag, ipaddress, domain, level, acctype, iswrite, extflag, debugmoe, errortype, secondstage, s2fs1walk)
}

val AArch32_CheckVectorCatch : forall ('size : Int).
  (bits(32), int('size)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_CheckVectorCatch (vaddress, size) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    val_match : bool = undefined : bool;
    val_match = AArch32_VCRMatch(vaddress);
    if (size == 4 & ~(val_match)) & AArch32_VCRMatch(vaddress + 2) then {
        val_match = ConstrainUnpredictableBool(Unpredictable_VCMATCHHALF)
    };
    acctype : AccType = undefined : AccType;
    debugmoe : bits(4) = undefined : bits(4);
    iswrite : bool = undefined : bool;
    if (val_match & [get_DBGDSCRext()[15]] == 0b1) & AArch32_GenerateDebugExceptions() then {
        acctype = AccType_IFETCH;
        iswrite = false;
        debugmoe = DebugException_VectorCatch;
        return(AArch32_DebugFault(acctype, iswrite, debugmoe))
    } else {
        return(AArch32_NoFault())
    }
}

val AArch32_CheckS2Permission : forall 'level ('iswrite : Bool) ('s2fs1walk : Bool).
  (Permissions, bits(32), bits(40), int('level), AccType, bool('iswrite), bool('s2fs1walk)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_CheckS2Permission (perms, vaddress, ipaddress, level, acctype, iswrite, s2fs1walk) = {
    assert(((HaveEL(EL2) & ~(IsSecure())) & ELUsingAArch32(EL2)) & HasS2Translation());
    let r : bool = [perms.ap[1]] == 0b1;
    let w : bool = [perms.ap[2]] == 0b1;
    xn : bool = undefined : bool;
    if HaveExtendedExecuteNeverExt() then {
        match perms.xn @ perms.xxn {
          0b00 => {
              xn = ~(r)
          },
          0b01 => {
              xn = ~(r) | PSTATE.EL == EL1
          },
          0b10 => {
              xn = true
          },
          0b11 => {
              xn = ~(r) | PSTATE.EL == EL0
          }
        }
    } else {
        xn = ~(r) | perms.xn == 0b1
    };
    fail : bool = undefined : bool;
    failedread : bool = undefined : bool;
    if acctype == AccType_IFETCH & ~(s2fs1walk) then {
        fail = xn;
        failedread = true
    } else {
        if (acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW) & ~(s2fs1walk) then {
            fail = ~(r) | ~(w);
            failedread = ~(r)
        } else {
            if acctype == AccType_DC & ~(s2fs1walk) then {
                fail = false
            } else {
                if iswrite & ~(s2fs1walk) then {
                    fail = ~(w);
                    failedread = false
                } else {
                    fail = ~(r);
                    failedread = ~(iswrite)
                }
            }
        }
    };
    domain : bits(4) = undefined : bits(4);
    secondstage : bool = undefined : bool;
    if fail then {
        domain = undefined : bits(4);
        secondstage = true;
        return(AArch32_PermissionFault(ipaddress, domain, level, acctype, ~(failedread), secondstage, s2fs1walk))
    } else {
        return(AArch32_NoFault())
    }
}

val AArch32_SecondStageTranslate : forall ('iswrite : Bool) ('wasaligned : Bool) ('s2fs1walk : Bool) 'size.
  (AddressDescriptor, bits(32), AccType, bool('iswrite), bool('wasaligned), bool('s2fs1walk), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_SecondStageTranslate (S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size) = {
    assert(HasS2Translation());
    assert(IsZero(slice(S1.paddress.address, 40, 8)));
    let hwupdatewalk : bool(false) = false;
    if ~(ELUsingAArch32(EL2)) then {
        return(AArch64_SecondStageTranslate(S1, ZeroExtend(vaddress, 64), acctype, iswrite, wasaligned, s2fs1walk, size, hwupdatewalk))
    };
    let s2_enabled : bool = [get_HCR()[0]] == 0b1 | [get_HCR()[12]] == 0b1;
    let secondstage : bool(true) = true;
    S2 : TLBRecord = undefined : TLBRecord;
    domain : bits(4) = undefined : bits(4);
    ipaddress : bits(40) = undefined : bits(40);
    result : AddressDescriptor = undefined : AddressDescriptor;
    if s2_enabled then {
        ipaddress = slice(S1.paddress.address, 0, 40);
        S2 = AArch32_TranslationTableWalk(ipaddress, vaddress, acctype, iswrite, secondstage, s2fs1walk, size);
        if ((~(wasaligned) & acctype != AccType_IFETCH | acctype == AccType_DCZVA) & S2.addrdesc.memattrs.typ == MemType_Device) & ~(IsFault(S2.addrdesc)) then {
            __tc1 : AddressDescriptor = S2.addrdesc;
            __tc1.fault = AArch32_AlignmentFault(acctype, iswrite, secondstage);
            S2.addrdesc = __tc1
        };
        if ~(IsFault(S2.addrdesc)) then {
            __tc2 : AddressDescriptor = S2.addrdesc;
            __tc2.fault = AArch32_CheckS2Permission(S2.perms, vaddress, ipaddress, S2.level, acctype, iswrite, s2fs1walk);
            S2.addrdesc = __tc2
        };
        if ((~(s2fs1walk) & ~(IsFault(S2.addrdesc))) & S2.addrdesc.memattrs.typ == MemType_Device) & acctype == AccType_IFETCH then {
            domain = undefined : bits(4);
            S2.addrdesc = AArch32_InstructionDevice(S2.addrdesc, vaddress, ipaddress, S2.level, domain, acctype, iswrite, secondstage, s2fs1walk)
        };
        if ((s2fs1walk & ~(IsFault(S2.addrdesc))) & [get_HCR()[2]] == 0b1) & S2.addrdesc.memattrs.typ == MemType_Device then {
            domain = undefined : bits(4);
            __tc3 : AddressDescriptor = S2.addrdesc;
            __tc3.fault = AArch32_PermissionFault(ipaddress, domain, S2.level, acctype, iswrite, secondstage, s2fs1walk);
            S2.addrdesc = __tc3
        };
        result = CombineS1S2Desc(S1, S2.addrdesc)
    } else {
        result = S1
    };
    result
}

val AArch32_SecondStageWalk : forall ('iswrite : Bool) ('size : Int).
  (AddressDescriptor, bits(32), AccType, bool('iswrite), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_SecondStageWalk (S1, vaddress, acctype, iswrite, size) = {
    assert(HasS2Translation());
    let s2fs1walk : bool(true) = true;
    let wasaligned : bool(true) = true;
    AArch32_SecondStageTranslate(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size)
}

val AArch32_CheckPermission : forall ('level : Int) ('iswrite : Bool).
  (Permissions, bits(32), int('level), bits(4), bits(1), AccType, bool('iswrite)) -> FaultRecord effect {escape, rreg, undef}

function AArch32_CheckPermission (perms, vaddress, level, domain, NS, acctype, iswrite) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    is_ats1xp : bool = undefined : bool;
    is_ldst : bool = undefined : bool;
    ispriv : bool = undefined : bool;
    pan : bits(1) = undefined : bits(1);
    priv_r : bool = undefined : bool;
    priv_w : bool = undefined : bool;
    priv_xn : bool = undefined : bool;
    r : bool = undefined : bool;
    user_r : bool = undefined : bool;
    user_w : bool = undefined : bool;
    user_xn : bool = undefined : bool;
    uwxn : bool = undefined : bool;
    w : bool = undefined : bool;
    wxn : bool = undefined : bool;
    xn : bool = undefined : bool;
    if PSTATE.EL != EL2 then {
        wxn = [get_SCTLR()[19]] == 0b1;
        if ([get_TTBCR()[31]] == 0b1 | [get_SCTLR()[29]] == 0b1) | [perms.ap[0]] == 0b1 then {
            priv_r = true;
            priv_w = [perms.ap[2]] == 0b0;
            user_r = [perms.ap[1]] == 0b1;
            user_w = slice(perms.ap, 1, 2) == 0b01
        } else {
            priv_r = slice(perms.ap, 1, 2) != 0b00;
            priv_w = slice(perms.ap, 1, 2) == 0b01;
            user_r = [perms.ap[1]] == 0b1;
            user_w = false
        };
        uwxn = [get_SCTLR()[20]] == 0b1;
        ispriv = AArch32_AccessIsPrivileged(acctype);
        pan = if HavePANExt() then PSTATE.PAN else 0b0;
        is_ldst = ~(acctype == AccType_DC | acctype == AccType_DC_UNPRIV | acctype == AccType_AT | acctype == AccType_IFETCH);
        is_ats1xp = acctype == AccType_AT & AArch32_ExecutingATS1xPInstr();
        if ((pan == 0b1 & user_r) & ispriv) & (is_ldst | is_ats1xp) then {
            priv_r = false;
            priv_w = false
        };
        user_xn = (~(user_r) | perms.xn == 0b1) | user_w & wxn;
        priv_xn = (((~(priv_r) | perms.xn == 0b1) | perms.pxn == 0b1) | priv_w & wxn) | user_w & uwxn;
        if ispriv then {
            (r, w, xn) = (priv_r, priv_w, priv_xn)
        } else {
            (r, w, xn) = (user_r, user_w, user_xn)
        }
    } else {
        wxn = [get_HSCTLR()[19]] == 0b1;
        r = true;
        w = [perms.ap[2]] == 0b0;
        xn = perms.xn == 0b1 | w & wxn
    };
    secure_instr_fetch : bits(1) = undefined : bits(1);
    if (HaveEL(EL3) & IsSecure()) & NS == 0b1 then {
        secure_instr_fetch = if ELUsingAArch32(EL3) then [get_SCR()[9]] else [SCR_EL3[9]];
        if secure_instr_fetch == 0b1 then {
            xn = true
        }
    };
    fail : bool = undefined : bool;
    failedread : bool = undefined : bool;
    if acctype == AccType_IFETCH then {
        fail = xn;
        failedread = true
    } else {
        if acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW then {
            fail = ~(r) | ~(w);
            failedread = ~(r)
        } else {
            if acctype == AccType_DC then {
                fail = false
            } else {
                if iswrite then {
                    fail = ~(w);
                    failedread = false
                } else {
                    fail = ~(r);
                    failedread = true
                }
            }
        }
    };
    ipaddress : bits(40) = undefined : bits(40);
    s2fs1walk : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    if fail then {
        secondstage = false;
        s2fs1walk = false;
        ipaddress = undefined : bits(40);
        return(AArch32_PermissionFault(ipaddress, domain, level, acctype, ~(failedread), secondstage, s2fs1walk))
    } else {
        return(AArch32_NoFault())
    }
}

val AArch32_BreakpointValueMatch : forall ('n : Int).
  (int('n), bits(32), bool) -> (bool, bool) effect {escape, rreg, undef}

function AArch32_BreakpointValueMatch (n__arg, vaddress, linked_to) = {
    n : int = n__arg;
    c : Constraint = undefined : Constraint;
    if n > UInt(slice(DBGDIDR, 24, 4)) then {
        (c, n) = ConstrainUnpredictableInteger(0, UInt(slice(DBGDIDR, 24, 4)), Unpredictable_BPNOTIMPL);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((false, false))
        }
    };
    if [DBGBCR[n][0]] == 0b0 then {
        return((false, false))
    };
    let context_aware : bool = n >= UInt(slice(DBGDIDR, 24, 4)) - UInt(slice(DBGDIDR, 20, 4));
    typ : bits(4) = undefined : bits(4);
    typ = slice(DBGBCR[n], 20, 4);
    if ((((typ & 0xE) == 0x6 | (typ & 0xC) == 0xC) & ~(HaveVirtHostExt()) | (typ & 0xE) == 0x4 & HaltOnBreakpointOrWatchpoint()) | (typ & 0xA) != 0x0 & ~(context_aware)) | (typ & 0x8) == 0x8 & ~(HaveEL(EL2)) then {
        (c, typ) = ConstrainUnpredictableBits(Unpredictable_RESBPTYPE);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((false, false))
        }
    };
    let match_addr : bool = (typ & 0xA) == 0x0;
    let mismatch : bool = (typ & 0xE) == 0x4;
    let match_vmid : bool = (typ & 0xC) == 0x8;
    let match_cid1 : bool = (typ & 0x2) == 0x2;
    let match_cid2 : bool = (typ & 0xC) == 0xC;
    let linked : bool = (typ & 0x1) == 0x1;
    if linked_to & (~(linked) | match_addr) then {
        return((false, false))
    };
    if (~(linked_to) & linked) & ~(match_addr) then {
        return((false, false))
    };
    BVR_match : bool = undefined : bool;
    byte : int = undefined : int;
    byte_select_match : bool = undefined : bool;
    if match_addr then {
        byte = UInt(slice(vaddress, 0, 2));
        assert(byte == 0 | byte == 2);
        byte_select_match = [slice(DBGBCR[n], 5, 4)[byte]] == 0b1;
        BVR_match = slice(vaddress, 2, 30) == slice(DBGBVR[n], 2, 30) & byte_select_match
    } else {
        if match_cid1 then {
            BVR_match = PSTATE.EL != EL2 & get_CONTEXTIDR() == slice(DBGBVR[n], 0, 32)
        }
    };
    BXVR_match : bool = undefined : bool;
    bvr_vmid : bits(16) = undefined : bits(16);
    vmid : bits(16) = undefined : bits(16);
    if match_vmid then {
        if ELUsingAArch32(EL2) then {
            vmid = ZeroExtend(slice(get_VTTBR(), 48, 8), 16);
            bvr_vmid = ZeroExtend(slice(DBGBXVR[n], 0, 8), 16)
        } else {
            if ~(Have16bitVMID()) | [VTCR_EL2[19]] == 0b0 then {
                vmid = ZeroExtend(slice(VTTBR_EL2[56 .. 49] @ VTTBR_EL2[48 .. 41], 0, 8), 16);
                bvr_vmid = ZeroExtend(slice(DBGBXVR[n], 0, 8), 16)
            } else {
                vmid = VTTBR_EL2[56 .. 49] @ VTTBR_EL2[48 .. 41];
                bvr_vmid = slice(DBGBXVR[n], 0, 16)
            }
        };
        BXVR_match = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & vmid == bvr_vmid
    } else {
        if match_cid2 then {
            BXVR_match = ((~(IsSecure()) & HaveVirtHostExt()) & ~(ELUsingAArch32(EL2))) & slice(DBGBXVR[n], 0, 32) == CONTEXTIDR_EL2
        }
    };
    let bvr_match_valid : bool = match_addr | match_cid1;
    let bxvr_match_valid : bool = match_vmid | match_cid2;
    let val_match : bool = (~(bxvr_match_valid) | BXVR_match) & (~(bvr_match_valid) | BVR_match);
    return((val_match & ~(mismatch), ~(val_match) & mismatch))
}

val AArch32_StateMatch : forall ('linked : Bool) ('isbreakpnt : Bool) ('ispriv : Bool).
  (bits(2), bits(1), bits(2), bool('linked), bits(4), bool('isbreakpnt), bool('ispriv)) -> bool effect {escape, rreg, undef}

function AArch32_StateMatch (SSC__arg, HMC__arg, PxC__arg, linked__arg, LBN, isbreakpnt, ispriv) = {
    HMC = HMC__arg;
    PxC = PxC__arg;
    SSC = SSC__arg;
    linked : bool = linked__arg;
    c : Constraint = undefined : Constraint;
    if ((((((((HMC @ SSC) @ PxC) & 0b11100) == 0b01100 | (((HMC @ SSC) @ PxC) & 0b11101) == 0b10000 | (((HMC @ SSC) @ PxC) & 0b11101) == 0b10100 | ((HMC @ SSC) @ PxC) == 0b11010 | ((HMC @ SSC) @ PxC) == 0b11101 | (((HMC @ SSC) @ PxC) & 0b11110) == 0b11110) | (HMC == 0b0 & PxC == 0b00) & ~(isbreakpnt)) | (SSC == 0b01 | SSC == 0b10) & ~(HaveEL(EL3))) | ((HMC @ SSC) @ PxC) == 0b11000 & ELUsingAArch32(EL3)) | (((HMC @ SSC) != 0b000 & (HMC @ SSC) != 0b111) & ~(HaveEL(EL3))) & ~(HaveEL(EL2))) | ((HMC @ SSC) @ PxC) == 0b11100 & ~(HaveEL(EL2)) then {
        __tc1 : bits(5) = undefined : bits(5);
        (c, __tc1) = ConstrainUnpredictableBits(Unpredictable_RESBPWPCTRL);
        let __tc2 : bits(5) = __tc1;
        HMC = [__tc2[4]];
        let __tc3 : bits(4) = slice(__tc2, 0, 4);
        SSC = slice(__tc3, 2, 2);
        PxC = slice(__tc3, 0, 2);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return(false)
        }
    };
    let PL2_match : bool = HaveEL(EL2) & HMC == 0b1;
    let PL1_match : bool = [PxC[0]] == 0b1;
    let PL0_match : bool = [PxC[1]] == 0b1;
    let SSU_match : bool = ((isbreakpnt & HMC == 0b0) & PxC == 0b00) & SSC != 0b11;
    let el : vector(2, dec, bit) = PSTATE.EL;
    priv_match : bool = undefined : bool;
    if ~(ispriv) & ~(isbreakpnt) then {
        priv_match = PL0_match
    } else {
        if SSU_match then {
            priv_match = PSTATE.M == M32_User | PSTATE.M == M32_Svc | PSTATE.M == M32_System
        } else {
            match el {
              ? if ? == EL3 => {
                  priv_match = PL1_match
              },
              ? if ? == EL2 => {
                  priv_match = PL2_match
              },
              ? if ? == EL1 => {
                  priv_match = PL1_match
              },
              ? if ? == EL0 => {
                  priv_match = PL0_match
              }
            }
        }
    };
    security_state_match : bool = undefined : bool;
    match SSC {
      0b00 => {
          security_state_match = true
      },
      0b01 => {
          security_state_match = ~(IsSecure())
      },
      0b10 => {
          security_state_match = IsSecure()
      },
      0b11 => {
          security_state_match = true
      }
    };
    first_ctx_cmp : int = undefined : int;
    last_ctx_cmp : int = undefined : int;
    lbn : int = undefined : int;
    if linked then {
        lbn = UInt(LBN);
        first_ctx_cmp = UInt(slice(DBGDIDR, 24, 4)) - UInt(slice(DBGDIDR, 20, 4));
        last_ctx_cmp = UInt(slice(DBGDIDR, 24, 4));
        if lbn < first_ctx_cmp | lbn > last_ctx_cmp then {
            (c, lbn) = ConstrainUnpredictableInteger(first_ctx_cmp, last_ctx_cmp, Unpredictable_BPNOTCTXCMP);
            assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
            match c {
              Constraint_DISABLED => {
                  return(false)
              },
              Constraint_NONE => {
                  linked = false
              }
            }
        }
    };
    __anon1 : bool = undefined : bool;
    linked_match : bool = undefined : bool;
    linked_to : bool = undefined : bool;
    vaddress : bits(32) = undefined : bits(32);
    if linked then {
        vaddress = undefined : bits(32);
        linked_to = true;
        (linked_match, __anon1) = AArch32_BreakpointValueMatch(lbn, vaddress, linked_to)
    };
    (priv_match & security_state_match) & (~(linked) | linked_match)
}

val AArch32_WatchpointMatch : forall 'n 'size ('ispriv : Bool) ('iswrite : Bool).
  (int('n), bits(32), int('size), bool('ispriv), bool('iswrite)) -> bool effect {escape, rreg, undef}

function AArch32_WatchpointMatch (n, vaddress, size, ispriv, iswrite) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    assert(n <= UInt(slice(DBGDIDR, 28, 4)));
    let enabled : bool = [DBGWCR[n][0]] == 0b1;
    let linked : bool = [DBGWCR[n][20]] == 0b1;
    let isbreakpnt : bool(false) = false;
    let state_match : bool = AArch32_StateMatch(slice(DBGWCR[n], 14, 2), [DBGWCR[n][13]], slice(DBGWCR[n], 1, 2), linked, slice(DBGWCR[n], 16, 4), isbreakpnt, ispriv);
    let ls_match : bool = [slice(DBGWCR[n], 3, 2)[if iswrite then 1 else 0]] == 0b1;
    value_match_name : bool = undefined : bool;
    value_match_name = false;
    foreach (byte from 0 to (size - 1) by 1 in inc) {
        value_match_name = value_match_name | AArch32_WatchpointByteMatch(n, vaddress + byte)
    };
    ((value_match_name & state_match) & ls_match) & enabled
}

val AArch32_CheckWatchpoint : forall ('size : Int).
  (bits(32), AccType, bool, int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch32_CheckWatchpoint (vaddress, acctype, iswrite, size) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    val_match : bool = undefined : bool;
    val_match = false;
    let ispriv : bool = AArch32_AccessIsPrivileged(acctype);
    foreach (i from 0 to UInt(slice(DBGDIDR, 28, 4)) by 1 in inc) {
        val_match = val_match | AArch32_WatchpointMatch(i, vaddress, size, ispriv, iswrite)
    };
    debugmoe : bits(4) = undefined : bits(4);
    reason : bits(6) = undefined : bits(6);
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        reason = DebugHalt_Watchpoint;
        Halt(reason);
        AArch32_NoFault()
    } else {
        if (val_match & [get_DBGDSCRext()[15]] == 0b1) & AArch32_GenerateDebugExceptions() then {
            debugmoe = DebugException_Watchpoint;
            return(AArch32_DebugFault(acctype, iswrite, debugmoe))
        } else {
            return(AArch32_NoFault())
        }
    }
}

val AArch32_BreakpointMatch : forall ('n : Int) ('size : Int).
  (int('n), bits(32), int('size)) -> (bool, bool) effect {escape, rreg, undef}

function AArch32_BreakpointMatch (n, vaddress, size) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    assert(n <= UInt(slice(DBGDIDR, 24, 4)));
    let enabled : bool = [DBGBCR[n][0]] == 0b1;
    let ispriv : bool = PSTATE.EL != EL0;
    let linked : bool = (slice(DBGBCR[n], 20, 4) & 0xB) == 0x1;
    let isbreakpnt : bool(true) = true;
    let linked_to : bool(false) = false;
    let state_match : bool = AArch32_StateMatch(slice(DBGBCR[n], 14, 2), [DBGBCR[n][13]], slice(DBGBCR[n], 1, 2), linked, slice(DBGBCR[n], 16, 4), isbreakpnt, ispriv);
    value_match_name : bool = undefined : bool;
    value_mismatch_name : bool = undefined : bool;
    (value_match_name, value_mismatch_name) = AArch32_BreakpointValueMatch(n, vaddress, linked_to);
    match_i : bool = undefined : bool;
    mismatch_i : bool = undefined : bool;
    if size == 4 then {
        (match_i, mismatch_i) = AArch32_BreakpointValueMatch(n, vaddress + 2, linked_to);
        if ~(value_match_name) & match_i then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        };
        if value_mismatch_name & ~(mismatch_i) then {
            value_mismatch_name = ConstrainUnpredictableBool(Unpredictable_BPMISMATCHHALF)
        }
    };
    if [vaddress[1]] == 0b1 & slice(DBGBCR[n], 5, 4) == 0xF then {
        if value_match_name then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        };
        if ~(value_mismatch_name) then {
            value_mismatch_name = ConstrainUnpredictableBool(Unpredictable_BPMISMATCHHALF)
        }
    };
    let val_match : bool = (value_match_name & state_match) & enabled;
    let mismatch : bool = (value_mismatch_name & state_match) & enabled;
    return((val_match, mismatch))
}

val AArch32_CheckBreakpoint : forall ('size : Int).
  (bits(32), int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch32_CheckBreakpoint (vaddress, size) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    assert(size == 2 | size == 4);
    val_match : bool = undefined : bool;
    val_match = false;
    mismatch : bool = undefined : bool;
    mismatch = false;
    match_i : bool = undefined : bool;
    mismatch_i : bool = undefined : bool;
    foreach (i from 0 to UInt(slice(DBGDIDR, 24, 4)) by 1 in inc) {
        (match_i, mismatch_i) = AArch32_BreakpointMatch(i, vaddress, size);
        val_match = val_match | match_i;
        mismatch = mismatch | mismatch_i
    };
    acctype : AccType = undefined : AccType;
    debugmoe : bits(4) = undefined : bits(4);
    iswrite : bool = undefined : bool;
    reason : bits(6) = undefined : bits(6);
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        reason = DebugHalt_Breakpoint;
        Halt(reason);
        AArch32_NoFault()
    } else {
        if ((val_match | mismatch) & [get_DBGDSCRext()[15]] == 0b1) & AArch32_GenerateDebugExceptions() then {
            acctype = AccType_IFETCH;
            iswrite = false;
            debugmoe = DebugException_Breakpoint;
            return(AArch32_DebugFault(acctype, iswrite, debugmoe))
        } else {
            return(AArch32_NoFault())
        }
    }
}

val AArch32_CheckDebug : forall ('iswrite : Bool) ('size : Int).
  (bits(32), AccType, bool('iswrite), int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch32_CheckDebug (vaddress, acctype, iswrite, size) = {
    fault : FaultRecord = AArch32_NoFault();
    let d_side : bool = acctype != AccType_IFETCH;
    let generate_exception : bool = AArch32_GenerateDebugExceptions() & [get_DBGDSCRext()[15]] == 0b1;
    let halt : bool = HaltOnBreakpointOrWatchpoint();
    let vector_catch_first_name : bool = ConstrainUnpredictableBool(Unpredictable_BPVECTORCATCHPRI);
    if (~(d_side) & vector_catch_first_name) & generate_exception then {
        fault = AArch32_CheckVectorCatch(vaddress, size)
    };
    if fault.typ == Fault_None & (generate_exception | halt) then {
        if d_side then {
            fault = AArch32_CheckWatchpoint(vaddress, acctype, iswrite, size)
        } else {
            fault = AArch32_CheckBreakpoint(vaddress, size)
        }
    };
    if ((fault.typ == Fault_None & ~(d_side)) & ~(vector_catch_first_name)) & generate_exception then {
        return(AArch32_CheckVectorCatch(vaddress, size))
    };
    fault
}

val AArch32_Abort : (bits(32), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch32_Abort (vaddress, fault) = {
    route_to_aarch64 : bool = undefined : bool;
    route_to_aarch64 = PSTATE.EL == EL0 & ~(ELUsingAArch32(EL1));
    if (~(route_to_aarch64) & EL2Enabled()) & ~(ELUsingAArch32(EL2)) then {
        route_to_aarch64 = (([HCR_EL2[27]] == 0b1 | IsSecondStage(fault)) | (HaveRASExt() & [get_HCR2()[5]] == 0b1) & IsExternalAbort(fault)) | IsDebugException(fault) & [MDCR_EL2[8]] == 0b1
    };
    if (~(route_to_aarch64) & HaveEL(EL3)) & ~(ELUsingAArch32(EL3)) then {
        route_to_aarch64 = [SCR_EL3[3]] == 0b1 & IsExternalAbort(fault)
    };
    if route_to_aarch64 then {
        AArch64_Abort(ZeroExtend(vaddress), fault)
    } else {
        if fault.acctype == AccType_IFETCH then {
            AArch32_InstructionAbort(vaddress, fault)
        } else {
            AArch32_DataAbort(vaddress, fault)
        }
    }
}

val _CheckAbortRegions : forall ('size : Int).
  (AddressDescriptor, int('size), AccessDescriptor, bits(1)) -> unit effect {escape, rreg, undef, wreg}

function _CheckAbortRegions (desc, size, accdesc, read) = {
    let address : vector(52, dec, bit) = desc.paddress.address;
    let extflag : vector(1, dec, bit) = desc.paddress.NS;
    let AbortRgnBase1 : vector(32 + 32, dec, bit) = AbortRgn64Lo1_Hi @ AbortRgn64Lo1;
    let AbortRgnTop1 : vector(32 + 32, dec, bit) = AbortRgn64Hi1_Hi @ AbortRgn64Hi1;
    let AbortRgnBase2 : vector(32 + 32, dec, bit) = AbortRgn64Lo2_Hi @ AbortRgn64Lo2;
    let AbortRgnTop2 : vector(32 + 32, dec, bit) = AbortRgn64Hi2_Hi @ AbortRgn64Hi2;
    let AbortLo1 : bool = UInt(address) >= UInt(slice(AbortRgnBase1, 0, 52));
    let AbortHi1 : bool = UInt(address) < UInt(slice(AbortRgnTop1, 0, 52));
    let AbortLo2 : bool = UInt(address) >= UInt(slice(AbortRgnBase2, 0, 52));
    let AbortHi2 : bool = UInt(address) < UInt(slice(AbortRgnTop2, 0, 52));
    fault : FaultRecord = undefined : FaultRecord;
    sync : bool = undefined : bool;
    if AbortLo1 & AbortHi1 | AbortLo2 & AbortHi2 then {
        let cacheable : bool = desc.memattrs.inner.attrs != MemAttr_NC;
        let normal_access : bool = desc.memattrs.typ == MemType_Normal;
        let device : bool = desc.memattrs.typ == MemType_Device;
        let strongly_ordered : bool = desc.memattrs.device == DeviceType_nGnRnE;
        if accdesc.page_table_walk then {
            sync = cacheable & __syncAbortOnTTWCache | ~(cacheable) & __syncAbortOnTTWNonCache
        } else {
            if accdesc.acctype == AccType_IFETCH then {
                sync = __syncAbortOnPrefetch
            } else {
                if read == 0b1 then {
                    sync = (((normal_access & cacheable) & __syncAbortOnReadNormCache | (normal_access & ~(cacheable)) & __syncAbortOnReadNormNonCache) | device & __syncAbortOnDeviceRead) | strongly_ordered & __syncAbortOnSoRead
                } else {
                    sync = ((device & __syncAbortOnDeviceWrite | (normal_access & cacheable) & __syncAbortOnWriteNormCache) | (normal_access & ~(cacheable)) & __syncAbortOnWriteNormNonCache) | strongly_ordered & __syncAbortOnSoWrite
                }
            }
        };
        if sync then {
            fault = _SyncExternalFault(address, accdesc, read, extflag);
            if UsingAArch32() then {
                AArch32_Abort(slice(desc.vaddress, 0, 32), fault)
            } else {
                AArch64_Abort(desc.vaddress, fault)
            }
        } else {
            SetPendingPhysicalSE(true)
        }
    };
    return()
}

val aset__Mem : forall ('size : Int), 'size >= 0.
  (AddressDescriptor, int('size), AccessDescriptor, bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset__Mem (desc, size, accdesc, value_name) = {
    let read : bits(1) = 0b0;
    paddress : bits(52) = desc.paddress.address;
    let extflag : bits(1) = desc.paddress.NS;
    if __trickbox_enabled then {
        _CheckAbortRegions(desc, size, accdesc, read)
    };
    fault : FaultRecord = undefined : FaultRecord;
    if __trickbox_enabled & IsGTEPPUMatch(desc.paddress, read) then {
        fault = _SyncExternalFault(paddress, accdesc, read, extflag);
        AArch64_Abort(desc.vaddress, fault)
    };
    lsb : int = undefined : int;
    readValue : unit = undefined : unit;
    regs : int = undefined : int;
    if __trickbox_enabled & (paddress & __trickbox_mask_v8) == __trickbox_base_v8 then {
        if slice(paddress, 0, 16) != Zeros(16) then {
            prerr("Trickbox write " ++ HexStr(UInt(paddress)) ++ " = " ++ HexStr(UInt(value_name)) ++ " (" ++ DecStr(size) ++ ")\n")
        };
        if size == 8 | size == 16 then {
            regs = size / 4;
            foreach (i from 1 to regs by 1 in inc) {
                lsb = (i - 1) * 32;
                let writeValue : bits(32) = slice(value_name, lsb, 32);
                prerr("Multiple trickbox write part:" ++ DecStr(i) ++ " " ++ HexStr(UInt(paddress)) ++ " = " ++ HexStr(UInt(writeValue)) ++ "\n");
                _WriteTrickbox(UInt(slice(paddress, 0, 16)), true, true, true, true, writeValue);
                paddress = paddress + 4
            }
        } else {
            let width = size * 8;
            let writeval : bits(32) = ZeroExtend(slice(value_name, 0, width));
            _WriteTrickbox(UInt(slice(paddress, 0, 16)), true, true, true, true, slice(writeval, 0, 32))
        }
    } else {
        if UInt(__CNTControlBase) != 0 & (paddress & __CNTControlMask) == __CNTControlBase then {
            readValue = __WriteMemoryMappedCounterRegister(UInt(slice(paddress, 0, 12)), ZeroExtend(slice(value_name, 0, 32)))
        } else {
            if __trickbox_enabled then {
                GTECheckAccessSensitiveAccess(paddress, size, value_name, false)
            };
            if size == 16 then {
                __WriteMemory(8, ZeroExtend(paddress), slice(value_name, 0, 64));
                __WriteMemory(8, ZeroExtend(paddress + 8), slice(value_name, 64, 64))
            } else {
                __WriteMemory(size, ZeroExtend(paddress), value_name)
            }
        }
    };
    return()
}

overload _Mem = {aset__Mem}

val DC_ZVA : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_ZVA val_name = {
    let iswrite : bool(true) = true;
    let 'size = 4 * 2 ^ UInt(slice(DCZID_EL0, 0, 4));
    let vaddress : bits(64) = Align(val_name, size);
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    memaddrdesc = AArch64_FullTranslate(vaddress, AccType_DCZVA, iswrite, true, 1);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(val_name, memaddrdesc.fault)
    };
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    foreach (i from 0 to (size - 1) by 1 in inc) {
        accdesc = CreateAccessDescriptor(AccType_DCZVA);
        if HaveMTEExt() then {
            if AccessIsTagChecked(vaddress, AccType_DCZVA) then {
                let ptag : bits(4) = TransformTag(vaddress);
                if ~(CheckTag(memaddrdesc, ptag, iswrite)) then {
                    TagCheckFail(vaddress, iswrite)
                }
            }
        };
        _Mem(memaddrdesc, 1, accdesc) = Zeros();
        __tc1 : FullAddress = memaddrdesc.paddress;
        __tc1.address = memaddrdesc.paddress.address + 1;
        memaddrdesc.paddress = __tc1
    };
    return()
}

val DC_GZVA : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_GZVA val_name = {
    DC_GVA(val_name);
    DC_ZVA(val_name);
    return()
}

val AArch64_aset_MemSingle : forall 'size ('wasaligned : Bool),
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType, bool('wasaligned), bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_aset_MemSingle (address, size, acctype, wasaligned, value_name) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    assert(address == Align(address, size));
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    let iswrite : bool(true) = true;
    let memaddrdesc = AArch64_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareable then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    };
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    if HaveMTEExt() then {
        if AccessIsTagChecked(ZeroExtend(address, 64), acctype) then {
            let ptag : vector(4, dec, bit) = TransformTag(ZeroExtend(address, 64));
            if ~(CheckTag(memaddrdesc, ptag, iswrite)) then {
                TagCheckFail(ZeroExtend(address, 64), iswrite)
            }
        }
    };
    _Mem(memaddrdesc, size, accdesc) = value_name;
    return()
}

overload MemSingle = {AArch64_aset_MemSingle}

val aset_Mem : forall 'size,
  8 * 'size >= 0 & 'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType, bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_Mem (address, size, acctype, value_name__arg) = {
    value_name = value_name__arg;
    let iswrite : bool(true) = true;
    if (HaveNV2Ext() & acctype == AccType_NV2REGISTER) & [SCTLR_EL2[25]] == 0b1 | BigEndian() then {
        value_name = BigEndianReverse(value_name)
    };
    aligned : bool = undefined : bool;
    aligned = AArch64_CheckAlignment(address, size, acctype, iswrite);
    atomic : bool = undefined : bool;
    if size != 16 | ~(acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        atomic = aligned
    } else {
        atomic = address == Align(address, 8)
    };
    c : Constraint = undefined : Constraint;
    if ~(atomic) then {
        assert(size > 1);
        MemSingle(address, 1, acctype, aligned) = slice(value_name, 0, 8);
        if ~(aligned) then {
            c = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            }
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            MemSingle(address + i, 1, acctype, aligned) = slice(value_name, 8 * i, 8)
        }
    } else {
        if size == 16 & (acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
            MemSingle(address, 8, acctype, aligned) = slice(value_name, 0, 64);
            MemSingle(address + 8, 8, acctype, aligned) = slice(value_name, 64, 64)
        } else {
            MemSingle(address, size, acctype, aligned) = value_name
        }
    };
    return()
}

overload Mem = {aset_Mem}

val semihost_writeparam : forall ('index : Int).
  (int('index), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function semihost_writeparam (index, value_name) = {
    let base : vector(64, dec, bit) = semihost_arg(1);
    Mem(base + index * 8, 8, AccType_NORMAL) = value_name
}

val aset_NVMem : forall ('offset : Int).
  (int('offset), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_NVMem (offset, val_name) = {
    base : bits(52) = undefined : bits(52);
    if [VNCR_EL2[52]] == 0b1 then {
        base = Ones(11) @ slice(VNCR_EL2, 12, 41)
    } else {
        base = Zeros(11) @ slice(VNCR_EL2, 12, 41)
    };
    let address : bits(64) = base @ __GetSlice_int(12, offset, 0);
    Mem(address, 8, AccType_NV2REGISTER) = val_name
}

overload NVMem = {aset_NVMem}

val AArch64_AutoGen_SysRegWrite : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AutoGen_SysRegWrite (el, op0, op1, CRn, op2, CRm, read, val_name) = {
    let __HCR_EL2_NV1 : vector(1, dec, bit) = [HCR_EL2[43]];
    let __HCR_EL2_FMO : vector(1, dec, bit) = [HCR_EL2[3]];
    let __HCR_EL2_NV2 : vector(1, dec, bit) = [HCR_EL2[45]];
    let __HCR_EL2_E2H : vector(1, dec, bit) = [HCR_EL2[34]];
    let __HCR_EL2_TGE : vector(1, dec, bit) = [HCR_EL2[27]];
    let __SCR_EL3_EEL2 : vector(1, dec, bit) = [SCR_EL3[18]];
    let __SCR_EL3_NS : vector(1, dec, bit) = [SCR_EL3[0]];
    let __HCR_EL2_IMO : vector(1, dec, bit) = [HCR_EL2[4]];
    let __HCR_EL2_NV : vector(1, dec, bit) = [HCR_EL2[42]];
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        DBGBCR_EL1[UInt(slice(CRm, 0, 4))] = slice(val_name, 0, 32)
                    } else {
                        if op2 == 0b111 then {
                            DBGWCR_EL1[UInt(slice(CRm, 0, 4))] = slice(val_name, 0, 32)
                        } else {
                            if op2 == 0b100 then {
                                DBGBVR_EL1[UInt(slice(CRm, 0, 4))] = val_name
                            } else {
                                if op2 == 0b110 then {
                                    DBGWVR_EL1[UInt(slice(CRm, 0, 4))] = val_name
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        PMEVCNTR_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))] = slice(val_name, 0, 32)
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        PMEVTYPER_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))] = slice(val_name, 0, 32)
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            ICV_AP0R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                        } else {
                            ICC_AP0R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            NVMem(1152 + 8 * UInt(slice(op2, 0, 2))) = ZeroExtend(slice(val_name, 0, 32))
                        } else {
                            ICH_AP0R_EL2[UInt(slice(op2, 0, 2))] = ZeroExtend(slice(val_name, 0, 32))
                        }
                    } else {
                        if CRm == 0x9 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                NVMem(1184 + 8 * UInt(slice(op2, 0, 2))) = ZeroExtend(slice(val_name, 0, 32))
                            } else {
                                ICH_AP1R_EL2[UInt(slice(op2, 0, 2))] = ZeroExtend(slice(val_name, 0, 32))
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                ICV_AP1R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                            } else {
                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                    ICC_AP1R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                                } else {
                                    ICC_AP1R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op2 == 0b000 then {
            if op1 == 0b100 then {
                if CRm == 0x0 then {
                    if CRn == 0xC then {
                        VBAR_EL2 = val_name
                    } else {
                        if CRn == 0x4 then {
                            SPSR_EL2 = slice(val_name, 0, 32)
                        } else {
                            if CRn == 0x3 then {
                                DACR32_EL2 = slice(val_name, 0, 32)
                            } else {
                                if CRn == 0x6 then {
                                    FAR_EL2 = val_name
                                } else {
                                    if CRn == 0x1 then {
                                        SCTLR_EL2 = val_name
                                    } else {
                                        if CRn == 0x0 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(136) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                VPIDR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                TTBR0_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x1 then {
                        if CRn == 0xE then {
                            CNTHCTL_EL2 = slice(val_name, 0, 32)
                        } else {
                            if CRn == 0x1 then {
                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    NVMem(120) = val_name
                                } else {
                                    HCR_EL2 = val_name
                                }
                            } else {
                                if CRn == 0x4 then {
                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(576) = val_name
                                    } else {
                                        SP_EL1 = val_name
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        AFSR0_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(32) = val_name
                                            } else {
                                                VTTBR_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xA then {
                            if CRm == 0x2 then {
                                MAIR_EL2 = val_name
                            } else {
                                if CRm == 0x5 then {
                                    MPAM2_EL2 = val_name
                                } else {
                                    if CRm == 0x4 then {
                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(2352) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            MPAMHCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2368) = val_name
                                            } else {
                                                MPAMVPM0_EL2 = val_name
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                AMAIR_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    CNTHP_TVAL_EL2 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x5 then {
                                        CNTHPS_TVAL_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x4 then {
                                            CNTHVS_TVAL_EL2 = slice(val_name, 0, 32)
                                        } else {
                                            if CRm == 0x3 then {
                                                CNTHV_TVAL_EL2 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x5 then {
                                    if CRm == 0x2 then {
                                        ESR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x3 then {
                                            FPEXC32_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                } else {
                                    if CRn == 0x2 then {
                                        if CRm == 0x2 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(176) = val_name
                                            } else {
                                                VNCR_EL2 = val_name
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                    NVMem(48) = val_name
                                                } else {
                                                    VSTTBR_EL2 = val_name
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(1216) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    ICH_HCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if CRn == 0x6 then {
                                                    TFSR_EL2 = slice(val_name, 0, 32)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        SPSR_irq = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                VBAR_EL2 = val_name
                            } else {
                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    NVMem(592) = val_name
                                } else {
                                    VBAR_EL1 = val_name
                                }
                            }
                        } else {
                            if CRn == 0x1 then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    SCTLR_EL2 = val_name
                                } else {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(272) = val_name
                                    } else {
                                        SCTLR_EL1 = val_name
                                    }
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        FAR_EL2 = val_name
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(544) = val_name
                                        } else {
                                            FAR_EL1 = val_name
                                        }
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            SPSR_EL2 = slice(val_name, 0, 32)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(352) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                SPSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                TTBR0_EL2 = val_name
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(512) = val_name
                                                } else {
                                                    TTBR0_EL1 = val_name
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    CNTHCTL_EL2 = slice(val_name, 0, 32)
                                } else {
                                    CNTKCTL_EL1 = slice(val_name, 0, 32)
                                }
                            } else {
                                if CRn == 0x4 then {
                                    SP_EL0 = val_name
                                } else {
                                    if CRn == 0x5 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            AFSR0_EL2 = slice(val_name, 0, 32)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(296) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                AFSR0_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            APIAKeyLo_EL1 = val_name
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0x4 then {
                                    set_SPSel(slice(val_name, 0, 32))
                                } else {
                                    if CRn == 0xA then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            MAIR_EL2 = val_name
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(320) = val_name
                                            } else {
                                                MAIR_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ESR_EL2 = slice(val_name, 0, 32)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(312) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    ESR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                APDAKeyLo_EL1 = val_name
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            MPAM2_EL2 = val_name
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2304) = val_name
                                            } else {
                                                MPAM1_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            LORSA_EL1 = val_name
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    AMAIR_EL2 = val_name
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(328) = val_name
                                                    } else {
                                                        AMAIR_EL1 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x7 then {
                                        if CRm == 0x4 then {
                                            PAR_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x6 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    ICV_PMR_EL1 = slice(val_name, 0, 32)
                                                } else {
                                                    ICC_PMR_EL1 = slice(val_name, 0, 32)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if CRn == 0x6 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(400) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        TFSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if CRm == 0x3 then {
                                                        APGAKeyLo_EL1 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0xF then {
                            if CRm == 0x0 then {
                                ESP_EL0 = val_name
                            } else {
                                if CRm == 0x2 then {
                                    SPSR_EL0 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x5 then {
                                        VBAR_EL0 = val_name
                                    } else {
                                        if CRm == 0x1 then {
                                            ELR_EL0 = val_name
                                        } else {
                                            if CRm == 0x4 then {
                                                FAR_EL0 = val_name
                                            } else {
                                                if CRm == 0x3 then {
                                                    ESR_EL0 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x4 then {
                                if CRm == 0x2 then {
                                    set_NZCV(slice(val_name, 0, 32))
                                } else {
                                    if CRm == 0x5 then {
                                        DSPSR_EL0 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x4 then {
                                            FPCR = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x9 then {
                                    if CRm == 0xD then {
                                        PMCCNTR_EL0 = val_name
                                    } else {
                                        if CRm == 0xE then {
                                            PMUSERENR_EL0 = slice(val_name, 0, 32)
                                        } else {
                                            if CRm == 0xC then {
                                                PMCR_EL0 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                CNTHP_TVAL_EL2 = slice(val_name, 0, 32)
                                            } else {
                                                CNTP_TVAL_EL0 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                CNTFRQ_EL0 = slice(val_name, 0, 32)
                                            } else {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        CNTHV_TVAL_EL2 = slice(val_name, 0, 32)
                                                    } else {
                                                        CNTV_TVAL_EL0 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0xC then {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(592) = val_name
                                    } else {
                                        VBAR_EL1 = val_name
                                    }
                                } else {
                                    if CRn == 0x2 then {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(512) = val_name
                                        } else {
                                            TTBR0_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0x6 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(544) = val_name
                                            } else {
                                                FAR_EL1 = val_name
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(272) = val_name
                                                } else {
                                                    SCTLR_EL1 = val_name
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(352) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        SPSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        CNTP_TVAL_EL0 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0xA then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(320) = val_name
                                            } else {
                                                MAIR_EL1 = val_name
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(312) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    ESR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0xE then {
                                            CNTKCTL_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(296) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    AFSR0_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if CRn == 0x6 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(400) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    TFSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(2304) = val_name
                                                    } else {
                                                        MPAM1_EL1 = val_name
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    CNTV_TVAL_EL0 = slice(val_name, 0, 32)
                                                } else {
                                                    if CRn == 0xA then {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            NVMem(328) = val_name
                                                        } else {
                                                            AMAIR_EL1 = val_name
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b110 then {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        VBAR_EL3 = val_name
                                    } else {
                                        if CRn == 0x2 then {
                                            TTBR0_EL3 = val_name
                                        } else {
                                            if CRn == 0x6 then {
                                                FAR_EL3 = val_name
                                            } else {
                                                if CRn == 0x1 then {
                                                    SCTLR_EL3 = val_name
                                                } else {
                                                    if CRn == 0x4 then {
                                                        SPSR_EL3 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            SCR_EL3 = slice(val_name, 0, 32)
                                        } else {
                                            if CRn == 0x4 then {
                                                SP_EL2 = val_name
                                            } else {
                                                if CRn == 0x5 then {
                                                    AFSR0_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x2 then {
                                                MAIR_EL3 = val_name
                                            } else {
                                                if CRm == 0x5 then {
                                                    MPAM3_EL3 = val_name
                                                } else {
                                                    if CRm == 0x3 then {
                                                        AMAIR_EL3 = val_name
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x5 then {
                                                    ESR_EL3 = slice(val_name, 0, 32)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        TFSR_EL3 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op1 == 0b010 then {
                                        if CRn == 0x0 then {
                                            CSSELR_EL1 = slice(val_name, 0, 32)
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                CNTPS_TVAL_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op2 == 0b001 then {
                if op1 == 0b100 then {
                    if CRm == 0x0 then {
                        if CRn == 0x4 then {
                            ELR_EL2 = val_name
                        } else {
                            if CRn == 0xD then {
                                CONTEXTIDR_EL2 = slice(val_name, 0, 32)
                            } else {
                                if CRn == 0x1 then {
                                    ACTLR_EL2 = val_name
                                } else {
                                    if CRn == 0x5 then {
                                        IFSR32_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0x2 then {
                                            TTBR1_EL2 = val_name
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xE then {
                            if CRm == 0x2 then {
                                CNTHP_CTL_EL2 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x5 then {
                                    CNTHPS_CTL_EL2 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x4 then {
                                        CNTHVS_CTL_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x3 then {
                                            CNTHV_CTL_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x1 then {
                                if CRm == 0x2 then {
                                    TRFCR_EL2 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x1 then {
                                        MDCR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x3 then {
                                            SDER32_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x4 then {
                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(2360) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            MPAMVPMV_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2376) = val_name
                                            } else {
                                                MPAMVPM1_EL2 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x5 then {
                                            AFSR1_EL2 = slice(val_name, 0, 32)
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x3 then {
                                                SPSR_abt = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x0 then {
                            if CRn == 0x4 then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    ELR_EL2 = val_name
                                } else {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(560) = val_name
                                    } else {
                                        ELR_EL1 = val_name
                                    }
                                }
                            } else {
                                if CRn == 0xD then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        CONTEXTIDR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(264) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            CONTEXTIDR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(280) = val_name
                                        } else {
                                            ACTLR_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                TTBR1_EL2 = val_name
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(528) = val_name
                                                } else {
                                                    TTBR1_EL1 = val_name
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if CRm == 0x8 then {
                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        ICV_EOIR0_EL1 = slice(val_name, 0, 32)
                                    } else {
                                        ICC_EOIR0_EL1 = slice(val_name, 0, 32)
                                    }
                                } else {
                                    if CRm == 0xB then {
                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            ICV_DIR_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            ICC_DIR_EL1 = slice(val_name, 0, 32)
                                        }
                                    } else {
                                        if CRm == 0xC then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ICV_EOIR1_EL1 = slice(val_name, 0, 32)
                                            } else {
                                                ICC_EOIR1_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        APDAKeyHi_EL1 = val_name
                                    } else {
                                        if CRm == 0x1 then {
                                            APIAKeyHi_EL1 = val_name
                                        } else {
                                            if CRm == 0x3 then {
                                                APGAKeyHi_EL1 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x5 then {
                                            MPAM0_EL1 = val_name
                                        } else {
                                            if CRm == 0x4 then {
                                                LOREA_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    AFSR1_EL2 = slice(val_name, 0, 32)
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(304) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        AFSR1_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if CRn == 0x9 then {
                                                    PMINTENSET_EL1 = slice(val_name, 0, 32)
                                                }
                                            } else {
                                                if CRm == 0x2 then {
                                                    if CRn == 0x1 then {
                                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            TRFCR_EL2 = slice(val_name, 0, 32)
                                                        } else {
                                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                                NVMem(2176) = ZeroExtend(slice(val_name, 0, 32))
                                                            } else {
                                                                TRFCR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0x6 then {
                                                            TFSRE0_EL1 = slice(val_name, 0, 32)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(528) = val_name
                                    } else {
                                        TTBR1_EL1 = val_name
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(560) = val_name
                                        } else {
                                            ELR_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0xD then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(264) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                CONTEXTIDR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(384) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            CNTP_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2176) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                TRFCR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x3 then {
                                            if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(368) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                CNTV_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(304) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    AFSR1_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b011 then {
                                if CRn == 0x4 then {
                                    if CRm == 0x2 then {
                                        set_DAIF(slice(val_name, 0, 32))
                                    } else {
                                        if CRm == 0x5 then {
                                            DLR_EL0 = val_name
                                        } else {
                                            if CRm == 0x4 then {
                                                FPSR = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            PMXEVTYPER_EL0 = slice(val_name, 0, 32)
                                        } else {
                                            if CRm == 0xC then {
                                                PMCNTENSET_EL0 = slice(val_name, 0, 32)
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if CRm == 0x2 then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    CNTHP_CTL_EL2 = slice(val_name, 0, 32)
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        NVMem(384) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        CNTP_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        CNTHV_CTL_EL2 = slice(val_name, 0, 32)
                                                    } else {
                                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            NVMem(368) = ZeroExtend(slice(val_name, 0, 32))
                                                        } else {
                                                            CNTV_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b110 then {
                                    if CRn == 0x1 then {
                                        if CRm == 0x0 then {
                                            ACTLR_EL3 = val_name
                                        } else {
                                            if CRm == 0x1 then {
                                                SDER32_EL3 = slice(val_name, 0, 32)
                                            } else {
                                                if CRm == 0x3 then {
                                                    MDCR_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0x4 then {
                                                ELR_EL3 = val_name
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    AFSR1_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                CNTPS_CTL_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b010 then {
                    if CRm == 0x0 then {
                        if CRn == 0x2 then {
                            if op1 == 0b101 then {
                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    NVMem(288) = val_name
                                } else {
                                    TCR_EL1 = val_name
                                }
                            } else {
                                if op1 == 0b000 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        TCR_EL2 = val_name
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(288) = val_name
                                        } else {
                                            TCR_EL1 = val_name
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        TCR_EL3 = slice(val_name, 0, 32)
                                    } else {
                                        if op1 == 0b100 then {
                                            TCR_EL2 = val_name
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if op1 == 0b000 then {
                                    RMR_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if op1 == 0b110 then {
                                        RMR_EL3 = slice(val_name, 0, 32)
                                    } else {
                                        if op1 == 0b100 then {
                                            RMR_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xD then {
                                    if op1 == 0b110 then {
                                        TPIDR_EL3 = val_name
                                    } else {
                                        if op1 == 0b100 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(144) = val_name
                                            } else {
                                                TPIDR_EL2 = val_name
                                            }
                                        } else {
                                            if op1 == 0b011 then {
                                                TPIDR_EL0 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if op1 == 0b000 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                CPTR_EL2 = slice(val_name, 0, 32)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(256) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    CPACR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        } else {
                                            if op1 == 0b101 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(256) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    CPACR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xF then {
                                            if op1 == 0b011 then {
                                                RD_EL0 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b100 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    CNTHP_CVAL_EL2 = val_name
                                } else {
                                    if CRm == 0x5 then {
                                        CNTHPS_CVAL_EL2 = val_name
                                    } else {
                                        if CRm == 0x4 then {
                                            CNTHVS_CVAL_EL2 = val_name
                                        } else {
                                            if CRm == 0x3 then {
                                                CNTHV_CVAL_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        CPTR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(64) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                VTCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x6 then {
                                        if CRn == 0xA then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2384) = val_name
                                            } else {
                                                MPAMVPM2_EL2 = val_name
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                    NVMem(72) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    VSTCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x3 then {
                                                SPSR_und = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    if op1 == 0b101 then {
                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(376) = val_name
                                        } else {
                                            CNTP_CVAL_EL0 = val_name
                                        }
                                    } else {
                                        if op1 == 0b111 then {
                                            CNTPS_CVAL_EL1 = val_name
                                        } else {
                                            if op1 == 0b011 then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    CNTHP_CVAL_EL2 = val_name
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        NVMem(376) = val_name
                                                    } else {
                                                        CNTP_CVAL_EL0 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x3 then {
                                        if op1 == 0b101 then {
                                            if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(360) = val_name
                                            } else {
                                                CNTV_CVAL_EL0 = val_name
                                            }
                                        } else {
                                            if op1 == 0b011 then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    CNTHV_CVAL_EL2 = val_name
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        NVMem(360) = val_name
                                                    } else {
                                                        CNTV_CVAL_EL0 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b000 then {
                                    if CRn == 0x2 then {
                                        if CRm == 0x2 then {
                                            APDBKeyLo_EL1 = val_name
                                        } else {
                                            if CRm == 0x1 then {
                                                APIBKeyLo_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xE then {
                                                PMINTENCLR_EL1 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    LORN_EL1 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if op1 == 0b011 then {
                                            if CRm == 0xD then {
                                                PMXEVCNTR_EL0 = slice(val_name, 0, 32)
                                            } else {
                                                if CRm == 0xC then {
                                                    PMCNTENCLR_EL0 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if op1 == 0b110 then {
                                                if CRn == 0x1 then {
                                                    CPTR_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRn == 0xC then {
                            if CRm == 0xC then {
                                if op2 == 0b101 then {
                                    if (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1 then {
                                        ICC_SRE_EL1_NS = slice(val_name, 0, 32)
                                    } else {
                                        ICC_SRE_EL1_S = slice(val_name, 0, 32)
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            ICV_BPR1_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                ICC_BPR1_EL1_NS = slice(val_name, 0, 32)
                                            } else {
                                                ICC_BPR1_EL1_S = slice(val_name, 0, 32)
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ICV_IGRPEN1_EL1 = slice(val_name, 0, 32)
                                            } else {
                                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                    ICC_IGRPEN1_EL1_NS = slice(val_name, 0, 32)
                                                } else {
                                                    ICC_IGRPEN1_EL1_S = slice(val_name, 0, 32)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    ICV_CTLR_EL1 = slice(val_name, 0, 32)
                                                } else {
                                                    if ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                        ICC_CTLR_EL1_NS = slice(val_name, 0, 32)
                                                    } else {
                                                        ICC_CTLR_EL1_S = slice(val_name, 0, 32)
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        ICV_IGRPEN0_EL1 = slice(val_name, 0, 32)
                                                    } else {
                                                        ICC_IGRPEN0_EL1 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xB then {
                                    if op2 == 0b101 then {
                                        ICC_SGI1R_EL1 = val_name
                                    } else {
                                        if op2 == 0b111 then {
                                            ICC_SGI0R_EL1 = val_name
                                        } else {
                                            if op2 == 0b110 then {
                                                ICC_ASGI1R_EL1 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x8 then {
                                        if op2 == 0b011 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ICV_BPR0_EL1 = slice(val_name, 0, 32)
                                            } else {
                                                ICC_BPR0_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if CRn == 0xD then {
                                    if op2 == 0b111 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            SCXTNUM_EL2 = val_name
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(392) = val_name
                                            } else {
                                                SCXTNUM_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            TPIDR_EL1 = val_name
                                        }
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if op2 == 0b101 then {
                                            RGSR_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            if op2 == 0b110 then {
                                                GCR_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if CRm == 0x2 then {
                                        if CRn == 0x4 then {
                                            set_PAN(slice(val_name, 0, 32))
                                        } else {
                                            if CRn == 0x2 then {
                                                APDBKeyHi_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0xA then {
                                                LORC_EL1 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x2 then {
                                                    APIBKeyHi_EL1 = val_name
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0x4 then {
                                            if op2 == 0b100 then {
                                                set_UAO(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b100 then {
                            if CRm == 0x6 then {
                                if CRn == 0xA then {
                                    if op2 == 0b101 then {
                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(2408) = val_name
                                        } else {
                                            MPAMVPM5_EL2 = val_name
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2392) = val_name
                                            } else {
                                                MPAMVPM3_EL2 = val_name
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(2424) = val_name
                                                } else {
                                                    MPAMVPM7_EL2 = val_name
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(2400) = val_name
                                                    } else {
                                                        MPAMVPM4_EL2 = val_name
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            NVMem(2416) = val_name
                                                        } else {
                                                            MPAMVPM6_EL2 = val_name
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op2 == 0b011 then {
                                        if CRn == 0xE then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(96) = val_name
                                            } else {
                                                CNTVOFF_EL2 = val_name
                                            }
                                        }
                                    } else {
                                        if CRn == 0xD then {
                                            if op2 == 0b111 then {
                                                SCXTNUM_EL2 = val_name
                                            }
                                        } else {
                                            if op2 == 0b101 then {
                                                if CRn == 0x0 then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(80) = val_name
                                                    } else {
                                                        VMPIDR_EL2 = val_name
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x6 then {
                                                    if op2 == 0b100 then {
                                                        HPFAR_EL2 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op2 == 0b101 then {
                                            if CRm == 0x9 then {
                                                ICC_SRE_EL2 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0xB then {
                                                if op2 == 0b111 then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(1224) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        ICH_VMCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                if op2 == 0b011 then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(128) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        HSTR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                } else {
                                                    if op2 == 0b111 then {
                                                        HACR_EL2 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        SPSR_fiq = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b011 then {
                                if CRn == 0x9 then {
                                    if CRm == 0xC then {
                                        if op2 == 0b101 then {
                                            PMSELR_EL0 = slice(val_name, 0, 32)
                                        } else {
                                            if op2 == 0b011 then {
                                                PMOVSCLR_EL0 = slice(val_name, 0, 32)
                                            } else {
                                                if op2 == 0b100 then {
                                                    PMSWINC_EL0 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if CRm == 0xE then {
                                                PMOVSSET_EL0 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if CRm == 0x2 then {
                                            if op2 == 0b101 then {
                                                set_DIT(slice(val_name, 0, 32))
                                            } else {
                                                if op2 == 0b111 then {
                                                    set_TCO(slice(val_name, 0, 32))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        set_SSBS(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0xD then {
                                                if op2 == 0b011 then {
                                                    TPIDRRO_EL0 = val_name
                                                } else {
                                                    if op2 == 0b111 then {
                                                        SCXTNUM_EL0 = val_name
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b111 then {
                                                    if CRm == 0xF then {
                                                        PMCCFILTR_EL0 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b110 then {
                                    if CRn == 0xC then {
                                        if CRm == 0xC then {
                                            if op2 == 0b101 then {
                                                ICC_SRE_EL3 = slice(val_name, 0, 32)
                                            } else {
                                                if op2 == 0b111 then {
                                                    ICC_IGRPEN1_EL3 = slice(val_name, 0, 32)
                                                } else {
                                                    if op2 == 0b100 then {
                                                        ICC_CTLR_EL3 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    SCXTNUM_EL3 = val_name
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b101 then {
                                        if CRm == 0x0 then {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(392) = val_name
                                                    } else {
                                                        SCXTNUM_EL1 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b010 then {
                        if CRm == 0x2 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                NVMem(344) = ZeroExtend(slice(val_name, 0, 32))
                            } else {
                                MDSCR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                            }
                        } else {
                            if CRm == 0x0 then {
                                OSDTRRX_EL1 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x6 then {
                                    OSECCR_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x3 then {
                                        OSDTRTX_EL1 = slice(val_name, 0, 32)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if op2 == 0b000 then {
                                MDCCINT_EL1 = slice(val_name, 0, 32)
                            }
                        }
                    }
                } else {
                    if op2 == 0b100 then {
                        if CRn == 0x1 then {
                            if CRm == 0x0 then {
                                OSLAR_EL1 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x4 then {
                                    DBGPRCR_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x3 then {
                                        OSDLR_EL1 = slice(val_name, 0, 32)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x7 then {
                            if op2 == 0b110 then {
                                if CRm == 0x8 then {
                                    DBGCLAIMSET_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x9 then {
                                        DBGCLAIMCLR_EL1 = slice(val_name, 0, 32)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRn == 0x0 then {
                        if op1 == 0b011 then {
                            if CRm == 0x5 then {
                                DBGDTRTX_EL0 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x4 then {
                                    DBGDTR_EL0 = val_name
                                }
                            }
                        } else {
                            if op1 == 0b100 then {
                                if CRm == 0x7 then {
                                    DBGVCR32_EL2 = slice(val_name, 0, 32)
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRn == 0x4 then {
                if op0 == 0b00 then {
                    if op1 == 0b011 then {
                        if op2 == 0b010 then {
                            set_DIT(slice(val_name, 0, 32))
                        } else {
                            if op2 == 0b111 then {
                                set_DAIF(slice(val_name, 0, 32))
                            } else {
                                if op2 == 0b001 then {
                                    set_SSBS(slice(val_name, 0, 32))
                                } else {
                                    if op2 == 0b100 then {
                                        set_TCO(slice(val_name, 0, 32))
                                    } else {
                                        if op2 == 0b110 then {
                                            set_DAIF(slice(val_name, 0, 32))
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b000 then {
                            if op2 == 0b101 then {
                                set_SPSel(slice(val_name, 0, 32))
                            } else {
                                if op2 == 0b011 then {
                                    set_UAO(slice(val_name, 0, 32))
                                } else {
                                    if op2 == 0b100 then {
                                        set_PAN(slice(val_name, 0, 32))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

val AArch64_SysRegWrite : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SysRegWrite (op0, op1, crn, crm, op2, val_name) = {
    AArch64_AutoGen_SysRegWrite(PSTATE.EL, __GetSlice_int(2, op0, 0), __GetSlice_int(3, op1, 0), __GetSlice_int(4, crn, 0), __GetSlice_int(3, op2, 0), __GetSlice_int(4, crm, 0), 0b0, val_name);
    if ((((op0 == 3 & crn == 12) & ((op1 == 6 | op1 == 4) | op1 == 0)) & op2 == 2) & crm == 0) & [val_name[1]] == 0b1 then {
        TakeReset(false)
    };
    return()
}

val integer_tags_mcsettagpre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairpre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairpre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpairpre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairpost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairpost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpairpost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairandzerodatapre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairandzerodatapre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagpairandzerodatapre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairandzerodatapost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairandzerodatapost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagpairandzerodatapost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairandzerodata : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodata (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairandzerodata_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodata_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagpairandzerodata(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpair : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpair (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpair_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpair_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpair(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagandzerodatapre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagandzerodatapre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagandzerodatapre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagandzerodatapost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagandzerodatapost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagandzerodatapost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagandzerodata : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodata (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagandzerodata_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodata_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagandzerodata(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettaganddatapairpre : forall 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31).
  (int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpre (n, offset, postindex, t, t2, writeback) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data1 : bits(64) = aget_X(t);
    let data2 : bits(64) = aget_X(t2);
    if ~(postindex) then {
        address = address + offset
    };
    aset_Mem(address, 8, AccType_NORMAL, data1);
    aset_Mem(address + 8, 8, AccType_NORMAL, data2);
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettaganddatapairpre_decode : (bits(5), bits(5), bits(5), bits(7)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpre_decode (Xt, Xn, Xt2, simm7) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    __PostDecode();
    integer_tags_mcsettaganddatapairpre(n, offset, postindex, t, t2, writeback)
}

val integer_tags_mcsettaganddatapairpost : forall 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31).
  (int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpost (n, offset, postindex, t, t2, writeback) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data1 : bits(64) = aget_X(t);
    let data2 : bits(64) = aget_X(t2);
    if ~(postindex) then {
        address = address + offset
    };
    aset_Mem(address, 8, AccType_NORMAL, data1);
    aset_Mem(address + 8, 8, AccType_NORMAL, data2);
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettaganddatapairpost_decode : (bits(5), bits(5), bits(5), bits(7)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpost_decode (Xt, Xn, Xt2, simm7) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    __PostDecode();
    integer_tags_mcsettaganddatapairpost(n, offset, postindex, t, t2, writeback)
}

val integer_tags_mcsettaganddatapair : forall 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31).
  (int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapair (n, offset, postindex, t, t2, writeback) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data1 : bits(64) = aget_X(t);
    let data2 : bits(64) = aget_X(t2);
    if ~(postindex) then {
        address = address + offset
    };
    aset_Mem(address, 8, AccType_NORMAL, data1);
    aset_Mem(address + 8, 8, AccType_NORMAL, data2);
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettaganddatapair_decode : (bits(5), bits(5), bits(5), bits(7)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapair_decode (Xt, Xn, Xt2, simm7) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    __PostDecode();
    integer_tags_mcsettaganddatapair(n, offset, postindex, t, t2, writeback)
}

val integer_tags_mcsettag : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettag (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettag_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettag_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettag(n, offset, postindex, writeback, zero_data)
}

val aget__Mem : forall 'size,
  (8 * 'size >= 0 | not(not('size in {8, 16}))).
  (AddressDescriptor, int('size), AccessDescriptor) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wreg}

function aget__Mem (desc, size, accdesc) = {
    let read : vector(1, dec, bit) = 0b1;
    paddress : bits(52) = desc.paddress.address;
    let extflag : vector(1, dec, bit) = desc.paddress.NS;
    if __trickbox_enabled then {
        _CheckAbortRegions(desc, size, accdesc, read)
    };
    fault : FaultRecord = undefined : FaultRecord;
    if __trickbox_enabled & IsGTEPPUMatch(desc.paddress, read) then {
        fault = _SyncExternalFault(paddress, accdesc, read, extflag);
        AArch64_Abort(desc.vaddress, fault)
    };
    lsb : int = undefined : int;
    readValue : bits(32) = undefined : bits(32);
    regs : int = undefined : int;
    if __trickbox_enabled & (paddress & __trickbox_mask_v8) == __trickbox_base_v8 then {
        if size == 8 | size == 16 then {
            regs = size / 4;
            result : bits(8 * 'size) = undefined : bits(8 * 'size);
            foreach (i from 1 to regs by 1 in inc) {
                lsb = (i - 1) * 32;
                readValue = _ReadTrickbox(UInt(slice(paddress, 0, 16)), true, true, true, true);
                prerr("Multiple trickbox read part:" ++ DecStr(i) ++ " " ++ HexStr(UInt(paddress)) ++ " = " ++ HexStr(UInt(readValue)) ++ "\n");
                result = __SetSlice_bits(8 * size, 32, result, lsb, slice(readValue, 0, 32));
                paddress = paddress + 4
            };
            prerr("Multiple trickbox read result: " ++ " = " ++ HexStr(UInt(result)) ++ "\n");
            return(result)
        } else {
            prerr("Trickbox read " ++ HexStr(UInt(paddress)) ++ " = " ++ HexStr(UInt(readValue)) ++ "\n");
            readValue = _ReadTrickbox(UInt(slice(paddress, 0, 16)), true, true, true, true);
            return(slice(readValue, 0, 8 * size))
        }
    } else {
        if UInt(__CNTControlBase) != 0 & (paddress & __CNTControlMask) == __CNTControlBase then {
            readValue = __ReadMemoryMappedCounterRegister(UInt(slice(paddress, 0, 12)));
            return(slice(readValue, 0, 8 * size))
        } else {
            result : bits(8 * 'size) = undefined : bits(8 * 'size);
            if size == 16 then {
                result = __SetSlice_bits(8 * size, 64, result, 0, __ReadMemory(8, ZeroExtend(paddress)));
                result = __SetSlice_bits(8 * size, 64, result, 64, __ReadMemory(8, ZeroExtend(paddress + 8)))
            } else {
                result = __ReadMemory(size, ZeroExtend(paddress))
            };
            if __trickbox_enabled then {
                GTECheckAccessSensitiveAccess(paddress, size, result, true)
            };
            return(result)
        }
    }
}

overload _Mem = {aget__Mem}

val AArch64_aget_MemSingle : forall 'size ('wasaligned : Bool),
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType, bool('wasaligned)) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_aget_MemSingle (address, size, acctype, wasaligned) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    assert(address == Align(address, size));
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    value_name : bits(8 * 'size) = undefined : bits('size * 8);
    let iswrite : bool(false) = false;
    let memaddrdesc = AArch64_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    if HaveMTEExt() then {
        if AccessIsTagChecked(ZeroExtend(address, 64), acctype) then {
            let ptag : vector(4, dec, bit) = TransformTag(ZeroExtend(address, 64));
            if ~(CheckTag(memaddrdesc, ptag, iswrite)) then {
                TagCheckFail(ZeroExtend(address, 64), iswrite)
            }
        }
    };
    let value_name = _Mem(memaddrdesc, size, accdesc);
    value_name
}

overload MemSingle = {AArch64_aget_MemSingle}

val aget_Mem : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_Mem (address, size, acctype) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    value_name : bits(8 * 'size) = undefined : bits('size * 8);
    let iswrite : bool(false) = false;
    aligned : bool = undefined : bool;
    aligned = AArch64_CheckAlignment(address, size, acctype, iswrite);
    atomic : bool = undefined : bool;
    if size != 16 | ~(acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        atomic = aligned
    } else {
        atomic = address == Align(address, 8)
    };
    c : Constraint = undefined : Constraint;
    if ~(atomic) then {
        assert(size > 1);
        value_name = __SetSlice_bits(8 * size, 8, value_name, 0, MemSingle(address, 1, acctype, aligned));
        if ~(aligned) then {
            c = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            }
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            value_name = __SetSlice_bits(8 * size, 8, value_name, 8 * i, MemSingle(address + i, 1, acctype, aligned))
        }
    } else {
        if size == 16 & (acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
            value_name = __SetSlice_bits(8 * size, 64, value_name, 0, MemSingle(address, 8, acctype, aligned));
            value_name = __SetSlice_bits(8 * size, 64, value_name, 64, MemSingle(address + 8, 8, acctype, aligned))
        } else {
            value_name = MemSingle(address, size, acctype, aligned)
        }
    };
    if (HaveNV2Ext() & acctype == AccType_NV2REGISTER) & [SCTLR_EL2[25]] == 0b1 | BigEndian() then {
        value_name = BigEndianReverse(value_name)
    };
    value_name
}

overload Mem = {aget_Mem}

val semihost_readparam : forall ('index : Int).
  int('index) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function semihost_readparam index = {
    let base : vector(64, dec, bit) = semihost_arg(1);
    let data : bits(64) = Mem(base + index * 8, 8, AccType_NORMAL);
    data
}

val semihost : unit -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function semihost () = {
    let 'op = UInt(semihost_arg(0));
    ret : int = undefined : int;
    match op {
      1 => {
          let namep : vector(64, dec, bit) = semihost_readparam(0);
          let mode : vector(64, dec, bit) = semihost_readparam(1);
          let 'len = UInt(semihost_readparam(2));
          handle : int = undefined : int;
          let acc : bits(2) = slice(mode, 2, 2);
          if acc == MODE_R then {
              handle = STDIN_HANDLE
          } else {
              if acc == MODE_A then {
                  handle = STDERR_HANDLE
              } else {
                  if acc == MODE_W then {
                      handle = STDOUT_HANDLE
                  } else {
                      handle = 0
                  }
              }
          };
          semihost_ret(__GetSlice_int(64, handle, 0))
      },
      2 => {
          let 'handle = UInt(semihost_readparam(0));
          let 'ret : {'n, 'n == 0. int('n)} = 0;
          semihost_ret(__GetSlice_int(64, ret, 0))
      },
      3 => {
          let buffer : vector(64, dec, bit) = semihost_arg(1);
          let data : bits(8) = Mem(buffer, 1, AccType_NORMAL);
          putchar(UInt(data))
      },
      4 => {
          buffer : bits(64) = semihost_arg(1);
          data : bits(8) = Mem(buffer, 1, AccType_NORMAL);
          while UInt(data) != 0 do {
              buffer = buffer + 1;
              putchar(UInt(data));
              data = Mem(buffer, 1, AccType_NORMAL)
          }
      },
      5 => {
          let 'handle = UInt(semihost_readparam(0));
          let buffer : vector(64, dec, bit) = semihost_readparam(1);
          let 'len = UInt(semihost_readparam(2));
          ret : int = 0;
          if handle == STDOUT_HANDLE | handle == STDERR_HANDLE then {
              foreach (i from 0 to (len - 1) by 1 in inc) {
                  let data : bits(8) = Mem(buffer + i, 1, AccType_NORMAL);
                  putchar(UInt(data))
              };
              ret = 0
          } else {
              ret = negate(1)
          };
          semihost_ret(__GetSlice_int(64, ret, 0))
      },
      9 => {
          let 'handle = UInt(semihost_readparam(0));
          let 'istty : {'n, 'n == 1. int('n)} = 1;
          semihost_ret(__GetSlice_int(64, istty, 0))
      },
      16 => {
          semihost_ret(__GetSlice_int(64, RoundTowardsZero(Real(UInt(semihost_clock)) / 10.0), 0))
      },
      19 => {
          let 'errnum : {'n, 'n == 0. int('n)} = 0;
          semihost_ret(__GetSlice_int(64, errnum, 0))
      },
      21 => {
          let buffer : vector(64, dec, bit) = semihost_readparam(0);
          let 'length = UInt(semihost_readparam(1));
          if length >= 7 then {
              Mem(buffer + 0, 1, AccType_NORMAL) = __GetSlice_int(8, 97, 0);
              Mem(buffer + 1, 1, AccType_NORMAL) = __GetSlice_int(8, 114, 0);
              Mem(buffer + 2, 1, AccType_NORMAL) = __GetSlice_int(8, 99, 0);
              Mem(buffer + 3, 1, AccType_NORMAL) = __GetSlice_int(8, 104, 0);
              Mem(buffer + 4, 1, AccType_NORMAL) = __GetSlice_int(8, 101, 0);
              Mem(buffer + 5, 1, AccType_NORMAL) = __GetSlice_int(8, 120, 0);
              Mem(buffer + 6, 1, AccType_NORMAL) = __GetSlice_int(8, 32, 0);
              Mem(buffer + 7, 1, AccType_NORMAL) = __GetSlice_int(8, 0, 0);
              semihost_writeparam(1, __GetSlice_int(64, 7, 0));
              ret = 0
          } else {
              ret = negate(1)
          };
          semihost_ret(__GetSlice_int(64, ret, 0))
      },
      22 => {
          let buffer : vector(64, dec, bit) = semihost_readparam(0);
          Mem(buffer + 0, 8, AccType_NORMAL) = HEAP_BASE;
          Mem(buffer + 8, 8, AccType_NORMAL) = HEAP_LIMIT;
          Mem(buffer + 16, 8, AccType_NORMAL) = STACK_BASE;
          Mem(buffer + 24, 8, AccType_NORMAL) = STACK_LIMIT;
          semihost_ret(__GetSlice_int(64, 0, 0))
      },
      24 => {
          let 'excep = UInt(semihost_readparam(0));
          let 'ecode = UInt(semihost_readparam(1));
          match excep {
            131110 => {
                exit(())
            },
            _ => {
                prerr("unhandled semihost exception " ++ HexStr(op) ++ "\n")
            }
          }
      },
      48 => {
          semihost_ret(slice(semihost_clock, 0, 64))
      },
      49 => {
          semihost_ret(__GetSlice_int(64, 1000, 0))
      },
      _ => {
          prerr("semihosting: unknown opcode " ++ DecStr(op) ++ "\n");
          assert(false)
      }
    }
}

val system_exceptions_debug_halt_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_exceptions_debug_halt_decode (LL, op2, imm16, opc) = {
    if imm16 == 0xF000 then {
        semihost()
    } else {
        default_system_exceptions_debug_halt_decode(LL, op2, imm16, opc)
    };
    return()
}

val aget_NVMem : forall ('offset : Int).
  int('offset) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_NVMem offset = {
    base : bits(52) = undefined : bits(52);
    if [VNCR_EL2[52]] == 0b1 then {
        base = Ones(11) @ slice(VNCR_EL2, 12, 41)
    } else {
        base = Zeros(11) @ slice(VNCR_EL2, 12, 41)
    };
    let address : bits(64) = base @ __GetSlice_int(12, offset, 0);
    Mem(address, 8, AccType_NV2REGISTER)
}

overload NVMem = {aget_NVMem}

val AArch64_AutoGen_SysRegRead : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AutoGen_SysRegRead (el, op0, op1, CRn, op2, CRm, read) = {
    let __HCR_EL2_NV1 : vector(1, dec, bit) = [HCR_EL2[43]];
    let __HCR_EL2_FMO : vector(1, dec, bit) = [HCR_EL2[3]];
    let __HCR_EL2_NV2 : vector(1, dec, bit) = [HCR_EL2[45]];
    let __HCR_EL2_E2H : vector(1, dec, bit) = [HCR_EL2[34]];
    let __HCR_EL2_TGE : vector(1, dec, bit) = [HCR_EL2[27]];
    let __SCR_EL3_EEL2 : vector(1, dec, bit) = [SCR_EL3[18]];
    let __SCR_EL3_NS : vector(1, dec, bit) = [SCR_EL3[0]];
    let __HCR_EL2_IMO : vector(1, dec, bit) = [HCR_EL2[4]];
    let __HCR_EL2_NV : vector(1, dec, bit) = [HCR_EL2[42]];
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        return(ZeroExtend(DBGBCR_EL1[UInt(slice(CRm, 0, 4))]))
                    } else {
                        if op2 == 0b111 then {
                            return(ZeroExtend(DBGWCR_EL1[UInt(slice(CRm, 0, 4))]))
                        } else {
                            if op2 == 0b100 then {
                                return(DBGBVR_EL1[UInt(slice(CRm, 0, 4))])
                            } else {
                                if op2 == 0b110 then {
                                    return(DBGWVR_EL1[UInt(slice(CRm, 0, 4))])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        return(ZeroExtend(PMEVCNTR_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))]))
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        return(ZeroExtend(PMEVTYPER_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))]))
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            return(ZeroExtend(ICV_AP0R_EL1[UInt(slice(op2, 0, 2))]))
                        } else {
                            return(ZeroExtend(ICC_AP0R_EL1[UInt(slice(op2, 0, 2))]))
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            return(ZeroExtend(NVMem(1152 + 8 * UInt(slice(op2, 0, 2)))))
                        } else {
                            return(ZeroExtend(ICH_AP0R_EL2[UInt(slice(op2, 0, 2))]))
                        }
                    } else {
                        if CRm == 0x9 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(ZeroExtend(NVMem(1184 + 8 * UInt(slice(op2, 0, 2)))))
                            } else {
                                return(ZeroExtend(ICH_AP1R_EL2[UInt(slice(op2, 0, 2))]))
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(ZeroExtend(ICV_AP1R_EL1[UInt(slice(op2, 0, 2))]))
                            } else {
                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                    return(ZeroExtend(ICC_AP1R_EL1[UInt(slice(op2, 0, 2))]))
                                } else {
                                    return(ZeroExtend(ICC_AP1R_EL1[UInt(slice(op2, 0, 2))]))
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op2 == 0b000 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if CRm == 0x0 then {
                        return(ZeroExtend(MIDR_EL1))
                    } else {
                        if CRm == 0x1 then {
                            return(ZeroExtend(ID_PFR0_EL1))
                        } else {
                            if CRm == 0x2 then {
                                return(ZeroExtend(ID_ISAR0_EL1))
                            } else {
                                if CRm == 0x5 then {
                                    return(ID_AA64DFR0_EL1)
                                } else {
                                    if CRm == 0x4 then {
                                        return(ID_AA64PFR0_EL1)
                                    } else {
                                        if CRm == 0x6 then {
                                            return(ID_AA64ISAR0_EL1)
                                        } else {
                                            if CRm == 0x7 then {
                                                return(ID_AA64MMFR0_EL1)
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(MVFR0_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(VBAR_EL2)
                            } else {
                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    return(NVMem(592))
                                } else {
                                    return(VBAR_EL1)
                                }
                            }
                        } else {
                            if CRn == 0x1 then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    return(SCTLR_EL2)
                                } else {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(NVMem(272))
                                    } else {
                                        return(SCTLR_EL1)
                                    }
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(FAR_EL2)
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(544))
                                        } else {
                                            return(FAR_EL1)
                                        }
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(ZeroExtend(SPSR_EL2))
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(352)))
                                            } else {
                                                return(ZeroExtend(SPSR_EL1))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(TTBR0_EL2)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(512))
                                                } else {
                                                    return(TTBR0_EL1)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xC then {
                                return(ZeroExtend(ISR_EL1))
                            } else {
                                if CRn == 0xE then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(ZeroExtend(CNTHCTL_EL2))
                                    } else {
                                        return(ZeroExtend(CNTKCTL_EL1))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        return(SP_EL0)
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(AFSR0_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(296)))
                                                } else {
                                                    return(ZeroExtend(AFSR0_EL1))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                return(APIAKeyLo_EL1)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0x4 then {
                                    return(ZeroExtend(get_SPSel()))
                                } else {
                                    if CRn == 0xA then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(MAIR_EL2)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(320))
                                            } else {
                                                return(MAIR_EL1)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ESR_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(312)))
                                                } else {
                                                    return(ZeroExtend(ESR_EL1))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                return(APDAKeyLo_EL1)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(MPAM2_EL2)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(2304))
                                            } else {
                                                return(MPAM1_EL1)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            return(LORSA_EL1)
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(AMAIR_EL2)
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(328))
                                                    } else {
                                                        return(AMAIR_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0x8 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_IAR0_EL1))
                                            } else {
                                                return(ZeroExtend(ICC_IAR0_EL1))
                                            }
                                        } else {
                                            if CRm == 0xC then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(ICV_IAR1_EL1))
                                                } else {
                                                    return(ZeroExtend(ICC_IAR1_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x7 then {
                                            if CRm == 0x4 then {
                                                return(PAR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x6 then {
                                                    if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(ICV_PMR_EL1))
                                                    } else {
                                                        return(ZeroExtend(ICC_PMR_EL1))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(ZeroExtend(NVMem(400)))
                                                        } else {
                                                            return(ZeroExtend(TFSR_EL1))
                                                        }
                                                    }
                                                } else {
                                                    if CRn == 0x2 then {
                                                        if CRm == 0x3 then {
                                                            return(APGAKeyLo_EL1)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b100 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            return(VBAR_EL2)
                        } else {
                            if CRn == 0x4 then {
                                return(ZeroExtend(SPSR_EL2))
                            } else {
                                if CRn == 0x3 then {
                                    return(ZeroExtend(DACR32_EL2))
                                } else {
                                    if CRn == 0x6 then {
                                        return(FAR_EL2)
                                    } else {
                                        if CRn == 0x1 then {
                                            return(SCTLR_EL2)
                                        } else {
                                            if CRn == 0x0 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(136)))
                                                } else {
                                                    return(ZeroExtend(VPIDR_EL2))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    return(TTBR0_EL2)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                return(ZeroExtend(CNTHCTL_EL2))
                            } else {
                                if CRn == 0x1 then {
                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(NVMem(120))
                                    } else {
                                        return(HCR_EL2)
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(576))
                                        } else {
                                            return(SP_EL1)
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            return(ZeroExtend(AFSR0_EL2))
                                        } else {
                                            if CRn == 0x2 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(32))
                                                } else {
                                                    return(VTTBR_EL2)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xA then {
                                if CRm == 0x2 then {
                                    return(MAIR_EL2)
                                } else {
                                    if CRm == 0x5 then {
                                        return(MPAM2_EL2)
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(2352)))
                                            } else {
                                                return(ZeroExtend(MPAMHCR_EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(2368))
                                                } else {
                                                    return(MPAMVPM0_EL2)
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(AMAIR_EL2)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xE then {
                                    if CRm == 0x2 then {
                                        return(ZeroExtend(CNTHP_TVAL_EL2))
                                    } else {
                                        if CRm == 0x5 then {
                                            return(ZeroExtend(CNTHPS_TVAL_EL2))
                                        } else {
                                            if CRm == 0x4 then {
                                                return(ZeroExtend(CNTHVS_TVAL_EL2))
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(CNTHV_TVAL_EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if CRm == 0x2 then {
                                            return(ZeroExtend(ESR_EL2))
                                        } else {
                                            if CRm == 0x3 then {
                                                return(ZeroExtend(FPEXC32_EL2))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if CRm == 0x2 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(176))
                                                } else {
                                                    return(VNCR_EL2)
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                        return(NVMem(48))
                                                    } else {
                                                        return(VSTTBR_EL2)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(1216)))
                                                    } else {
                                                        return(ZeroExtend(ICH_HCR_EL2))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        return(ZeroExtend(TFSR_EL2))
                                                    }
                                                } else {
                                                    if CRn == 0x4 then {
                                                        if CRm == 0x3 then {
                                                            return(ZeroExtend(SPSR_irq))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0xF then {
                            if CRm == 0x0 then {
                                return(ESP_EL0)
                            } else {
                                if CRm == 0x2 then {
                                    return(ZeroExtend(SPSR_EL0))
                                } else {
                                    if CRm == 0x5 then {
                                        return(VBAR_EL0)
                                    } else {
                                        if CRm == 0x1 then {
                                            return(ELR_EL0)
                                        } else {
                                            if CRm == 0x4 then {
                                                return(FAR_EL0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(ESR_EL0))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x4 then {
                                if CRm == 0x2 then {
                                    return(ZeroExtend(get_NZCV()))
                                } else {
                                    if CRm == 0x5 then {
                                        return(ZeroExtend(DSPSR_EL0))
                                    } else {
                                        if CRm == 0x4 then {
                                            return(ZeroExtend(FPCR))
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x9 then {
                                    if CRm == 0xD then {
                                        return(PMCCNTR_EL0)
                                    } else {
                                        if CRm == 0xE then {
                                            return(ZeroExtend(PMUSERENR_EL0))
                                        } else {
                                            if CRm == 0xC then {
                                                return(ZeroExtend(PMCR_EL0))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(CNTHP_TVAL_EL2))
                                            } else {
                                                return(ZeroExtend(CNTP_TVAL_EL0))
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                return(ZeroExtend(CNTFRQ_EL0))
                                            } else {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(CNTHV_TVAL_EL2))
                                                    } else {
                                                        return(ZeroExtend(CNTV_TVAL_EL0))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0x2 then {
                                                return(RNDR);
                                                return(RNDRRS)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0xC then {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(NVMem(592))
                                    } else {
                                        return(VBAR_EL1)
                                    }
                                } else {
                                    if CRn == 0x2 then {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(512))
                                        } else {
                                            return(TTBR0_EL1)
                                        }
                                    } else {
                                        if CRn == 0x6 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(544))
                                            } else {
                                                return(FAR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(272))
                                                } else {
                                                    return(SCTLR_EL1)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(352)))
                                                    } else {
                                                        return(ZeroExtend(SPSR_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        return(ZeroExtend(CNTP_TVAL_EL0))
                                    } else {
                                        if CRn == 0xA then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(320))
                                            } else {
                                                return(MAIR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(312)))
                                                } else {
                                                    return(ZeroExtend(ESR_EL1))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0xE then {
                                            return(ZeroExtend(CNTKCTL_EL1))
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(296)))
                                                } else {
                                                    return(ZeroExtend(AFSR0_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if CRn == 0x6 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(400)))
                                                } else {
                                                    return(ZeroExtend(TFSR_EL1))
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2304))
                                                    } else {
                                                        return(MPAM1_EL1)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    return(ZeroExtend(CNTV_TVAL_EL0))
                                                } else {
                                                    if CRn == 0xA then {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(NVMem(328))
                                                        } else {
                                                            return(AMAIR_EL1)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b110 then {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        return(VBAR_EL3)
                                    } else {
                                        if CRn == 0x4 then {
                                            return(ZeroExtend(SPSR_EL3))
                                        } else {
                                            if CRn == 0x6 then {
                                                return(FAR_EL3)
                                            } else {
                                                if CRn == 0x1 then {
                                                    return(SCTLR_EL3)
                                                } else {
                                                    if CRn == 0x2 then {
                                                        return(TTBR0_EL3)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            return(ZeroExtend(SCR_EL3))
                                        } else {
                                            if CRn == 0x4 then {
                                                return(SP_EL2)
                                            } else {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(AFSR0_EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x2 then {
                                                return(MAIR_EL3)
                                            } else {
                                                if CRm == 0x5 then {
                                                    return(MPAM3_EL3)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        return(AMAIR_EL3)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(ESR_EL3))
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        return(ZeroExtend(TFSR_EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0x0 then {
                                        if op1 == 0b010 then {
                                            return(ZeroExtend(CSSELR_EL1))
                                        } else {
                                            if op1 == 0b001 then {
                                                return(CCSIDR_EL1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                return(ZeroExtend(CNTPS_TVAL_EL1))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if CRm == 0x1 then {
                        if op2 == 0b010 then {
                            return(ZeroExtend(ID_DFR0_EL1))
                        } else {
                            if op2 == 0b011 then {
                                return(ZeroExtend(ID_AFR0_EL1))
                            } else {
                                if op2 == 0b101 then {
                                    return(ZeroExtend(ID_MMFR1_EL1))
                                } else {
                                    if op2 == 0b111 then {
                                        return(ZeroExtend(ID_MMFR3_EL1))
                                    } else {
                                        if op2 == 0b001 then {
                                            return(ZeroExtend(ID_PFR1_EL1))
                                        } else {
                                            if op2 == 0b100 then {
                                                return(ZeroExtend(ID_MMFR0_EL1))
                                            } else {
                                                if op2 == 0b110 then {
                                                    return(ZeroExtend(ID_MMFR2_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if op2 == 0b010 then {
                                return(ZeroExtend(ID_ISAR2_EL1))
                            } else {
                                if op2 == 0b011 then {
                                    return(ZeroExtend(ID_ISAR3_EL1))
                                } else {
                                    if op2 == 0b101 then {
                                        return(ZeroExtend(ID_ISAR5_EL1))
                                    } else {
                                        if op2 == 0b111 then {
                                            return(ZeroExtend(ID_ISAR6_EL1))
                                        } else {
                                            if op2 == 0b001 then {
                                                return(ZeroExtend(ID_ISAR1_EL1))
                                            } else {
                                                if op2 == 0b100 then {
                                                    return(ZeroExtend(ID_ISAR4_EL1))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        return(ZeroExtend(ID_MMFR4_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if CRm == 0x5 then {
                                    return(ZeroExtend(ID_AA64DFR1_EL1))
                                } else {
                                    if CRm == 0x4 then {
                                        return(ZeroExtend(ID_AA64PFR1_EL1))
                                    } else {
                                        if CRm == 0x6 then {
                                            return(ID_AA64ISAR1_EL1)
                                        } else {
                                            if CRm == 0x7 then {
                                                return(ZeroExtend(ID_AA64MMFR1_EL1))
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(MVFR1_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRm == 0x7 then {
                                        return(ID_AA64MMFR2_EL1)
                                    } else {
                                        if CRm == 0x3 then {
                                            return(ZeroExtend(MVFR2_EL1))
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if op2 == 0b101 then {
                                            return(MPIDR_EL1)
                                        } else {
                                            if op2 == 0b110 then {
                                                return(ZeroExtend(REVIDR_EL1))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if op2 == 0b101 then {
                                                return(ZeroExtend(ID_AA64AFR1_EL1))
                                            } else {
                                                if op2 == 0b100 then {
                                                    return(ZeroExtend(ID_AA64AFR0_EL1))
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(ID_PFR2_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                return(RVBAR_EL1)
                            } else {
                                if CRn == 0x4 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(ELR_EL2)
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(560))
                                        } else {
                                            return(ELR_EL1)
                                        }
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(ZeroExtend(CONTEXTIDR_EL2))
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(264)))
                                            } else {
                                                return(ZeroExtend(CONTEXTIDR_EL1))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(280))
                                            } else {
                                                return(ACTLR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(TTBR1_EL2)
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(528))
                                                    } else {
                                                        return(TTBR1_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x2 then {
                                if CRm == 0x2 then {
                                    return(APDAKeyHi_EL1)
                                } else {
                                    if CRm == 0x1 then {
                                        return(APIAKeyHi_EL1)
                                    } else {
                                        if CRm == 0x3 then {
                                            return(APGAKeyHi_EL1)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        return(MPAM0_EL1)
                                    } else {
                                        if CRm == 0x4 then {
                                            return(LOREA_EL1)
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(AFSR1_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(304)))
                                                } else {
                                                    return(ZeroExtend(AFSR1_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0xE then {
                                            if CRn == 0x9 then {
                                                return(ZeroExtend(PMINTENSET_EL1))
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x1 then {
                                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(TRFCR_EL2))
                                                    } else {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(ZeroExtend(NVMem(2176)))
                                                        } else {
                                                            return(ZeroExtend(TRFCR_EL1))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if CRn == 0x6 then {
                                                        return(ZeroExtend(TFSRE0_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xC then {
                                if CRm == 0x8 then {
                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(ZeroExtend(ICV_HPPIR0_EL1))
                                    } else {
                                        return(ZeroExtend(ICC_HPPIR0_EL1))
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        return(ZeroExtend(RMR_EL1))
                                    } else {
                                        if CRm == 0xC then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_HPPIR1_EL1))
                                            } else {
                                                return(ZeroExtend(ICC_HPPIR1_EL1))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        return(APDBKeyLo_EL1)
                                    } else {
                                        if CRm == 0x0 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(TCR_EL2)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(288))
                                                } else {
                                                    return(TCR_EL1)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                return(APIBKeyLo_EL1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0x1 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(CPTR_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(256)))
                                                } else {
                                                    return(ZeroExtend(CPACR_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x2 then {
                                                return(ZeroExtend(get_CurrentEL()))
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if CRm == 0xE then {
                                                    return(ZeroExtend(PMINTENCLR_EL1))
                                                }
                                            } else {
                                                if CRm == 0x4 then {
                                                    if CRn == 0xA then {
                                                        return(ZeroExtend(LORN_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if CRm == 0xC then {
                                    if op2 == 0b101 then {
                                        if (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1 then {
                                            return(ZeroExtend(ICC_SRE_EL1_NS))
                                        } else {
                                            return(ZeroExtend(ICC_SRE_EL1_S))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_BPR1_EL1))
                                            } else {
                                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                    return(ZeroExtend(ICC_BPR1_EL1_NS))
                                                } else {
                                                    return(ZeroExtend(ICC_BPR1_EL1_S))
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(ICV_IGRPEN1_EL1))
                                                } else {
                                                    if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                        return(ZeroExtend(ICC_IGRPEN1_EL1_NS))
                                                    } else {
                                                        return(ZeroExtend(ICC_IGRPEN1_EL1_S))
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(ICV_CTLR_EL1))
                                                    } else {
                                                        if ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                            return(ZeroExtend(ICC_CTLR_EL1_NS))
                                                        } else {
                                                            return(ZeroExtend(ICC_CTLR_EL1_S))
                                                        }
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(ZeroExtend(ICV_IGRPEN0_EL1))
                                                        } else {
                                                            return(ZeroExtend(ICC_IGRPEN0_EL1))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0x8 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_BPR0_EL1))
                                            } else {
                                                return(ZeroExtend(ICC_BPR0_EL1))
                                            }
                                        } else {
                                            if CRm == 0xB then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(ICV_RPR_EL1))
                                                } else {
                                                    return(ZeroExtend(ICC_RPR_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xD then {
                                        if op2 == 0b111 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(SCXTNUM_EL2)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(392))
                                                } else {
                                                    return(SCXTNUM_EL1)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                return(TPIDR_EL1)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if op2 == 0b101 then {
                                                return(ZeroExtend(RGSR_EL1))
                                            } else {
                                                if op2 == 0b110 then {
                                                    return(ZeroExtend(GCR_EL1))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0x2 then {
                                            if CRn == 0x4 then {
                                                return(ZeroExtend(get_PAN()))
                                            } else {
                                                if CRn == 0x2 then {
                                                    return(APDBKeyHi_EL1)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    return(ZeroExtend(LORC_EL1))
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x2 then {
                                                        return(APIBKeyHi_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x4 then {
                                                if op2 == 0b111 then {
                                                    return(ZeroExtend(LORID_EL1))
                                                } else {
                                                    if op2 == 0b100 then {
                                                        return(MPAMIDR_EL1)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x2 then {
                                                    if op2 == 0b100 then {
                                                        return(ZeroExtend(get_UAO()))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x9 then {
                                                    if CRm == 0xE then {
                                                        if op2 == 0b110 then {
                                                            return(ZeroExtend(PMMIR_EL1))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b100 then {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                return(RVBAR_EL2)
                            } else {
                                if CRn == 0x4 then {
                                    return(ELR_EL2)
                                } else {
                                    if CRn == 0x2 then {
                                        return(TTBR1_EL2)
                                    } else {
                                        if CRn == 0x1 then {
                                            return(ACTLR_EL2)
                                        } else {
                                            if CRn == 0x5 then {
                                                return(ZeroExtend(IFSR32_EL2))
                                            } else {
                                                if CRn == 0xD then {
                                                    return(ZeroExtend(CONTEXTIDR_EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    return(ZeroExtend(CNTHP_CTL_EL2))
                                } else {
                                    if CRm == 0x5 then {
                                        return(ZeroExtend(CNTHPS_CTL_EL2))
                                    } else {
                                        if CRm == 0x4 then {
                                            return(ZeroExtend(CNTHVS_CTL_EL2))
                                        } else {
                                            if CRm == 0x3 then {
                                                return(ZeroExtend(CNTHV_CTL_EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if CRm == 0x2 then {
                                        return(ZeroExtend(TRFCR_EL2))
                                    } else {
                                        if CRm == 0x1 then {
                                            return(ZeroExtend(MDCR_EL2))
                                        } else {
                                            if CRm == 0x3 then {
                                                return(ZeroExtend(SDER32_EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(2360)))
                                            } else {
                                                return(ZeroExtend(MPAMVPMV_EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(2376))
                                                } else {
                                                    return(MPAMVPM1_EL2)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                return(ZeroExtend(ICH_VTR_EL2))
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(AFSR1_EL2))
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        return(ZeroExtend(SPSR_abt))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    return(CNTHP_CVAL_EL2)
                                } else {
                                    if CRm == 0x5 then {
                                        return(CNTHPS_CVAL_EL2)
                                    } else {
                                        if CRm == 0x4 then {
                                            return(CNTHVS_CVAL_EL2)
                                        } else {
                                            if CRm == 0x3 then {
                                                return(CNTHV_CVAL_EL2)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        return(ZeroExtend(RMR_EL2))
                                    } else {
                                        if CRn == 0xD then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(144))
                                            } else {
                                                return(TPIDR_EL2)
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                return(TCR_EL2)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            return(ZeroExtend(CPTR_EL2))
                                        } else {
                                            if CRn == 0x2 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(64)))
                                                } else {
                                                    return(ZeroExtend(VTCR_EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if CRn == 0xA then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(2384))
                                                } else {
                                                    return(MPAMVPM2_EL2)
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                        return(ZeroExtend(NVMem(72)))
                                                    } else {
                                                        return(ZeroExtend(VSTCR_EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    return(ZeroExtend(ICH_MISR_EL2))
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        return(ZeroExtend(SPSR_und))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRn == 0xC then {
                                    if CRm == 0xB then {
                                        return(ZeroExtend(ICH_EISR_EL2))
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0xE then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(96))
                                            } else {
                                                return(CNTVOFF_EL2)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(128)))
                                                } else {
                                                    return(ZeroExtend(HSTR_EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2392))
                                                    } else {
                                                        return(MPAMVPM3_EL2)
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        return(ZeroExtend(SPSR_fiq))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            return(ZeroExtend(ICH_ELRSR_EL2))
                                        } else {
                                            if CRm == 0x9 then {
                                                return(ZeroExtend(ICC_SRE_EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0x0 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(80))
                                                } else {
                                                    return(VMPIDR_EL2)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2408))
                                                    } else {
                                                        return(MPAMVPM5_EL2)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b111 then {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(1224)))
                                                } else {
                                                    return(ZeroExtend(ICH_VMCR_EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0xD then {
                                                    return(SCXTNUM_EL2)
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x1 then {
                                                        return(ZeroExtend(HACR_EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0xA then {
                                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                                return(NVMem(2424))
                                                            } else {
                                                                return(MPAMVPM7_EL2)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x6 then {
                                                if op2 == 0b100 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2400))
                                                    } else {
                                                        return(MPAMVPM4_EL2)
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(NVMem(2416))
                                                        } else {
                                                            return(MPAMVPM6_EL2)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0x6 then {
                                                    if op2 == 0b100 then {
                                                        return(HPFAR_EL2)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0x9 then {
                            if CRm == 0xC then {
                                if op2 == 0b010 then {
                                    return(ZeroExtend(PMCNTENCLR_EL0))
                                } else {
                                    if op2 == 0b101 then {
                                        return(ZeroExtend(PMSELR_EL0))
                                    } else {
                                        if op2 == 0b011 then {
                                            return(ZeroExtend(PMOVSCLR_EL0))
                                        } else {
                                            if op2 == 0b111 then {
                                                return(PMCEID1_EL0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    return(ZeroExtend(PMCNTENSET_EL0))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        return(PMCEID0_EL0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xD then {
                                    if op2 == 0b010 then {
                                        return(ZeroExtend(PMXEVCNTR_EL0))
                                    } else {
                                        if op2 == 0b001 then {
                                            return(ZeroExtend(PMXEVTYPER_EL0))
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0xE then {
                                            return(ZeroExtend(PMOVSSET_EL0))
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        return(CNTVCT_EL0)
                                    } else {
                                        if CRn == 0xF then {
                                            return(RD_EL0)
                                        } else {
                                            if CRn == 0xD then {
                                                return(TPIDR_EL0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if op2 == 0b011 then {
                                            return(TPIDRRO_EL0)
                                        } else {
                                            if op2 == 0b111 then {
                                                return(SCXTNUM_EL0)
                                            }
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if CRn == 0xE then {
                                                return(CNTPCT_EL0)
                                            } else {
                                                if CRn == 0x0 then {
                                                    return(CTR_EL0)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRn == 0x0 then {
                                                    return(ZeroExtend(DCZID_EL0))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0x4 then {
                                        if op2 == 0b101 then {
                                            return(ZeroExtend(get_DIT()))
                                        } else {
                                            if op2 == 0b111 then {
                                                return(ZeroExtend(get_TCO()))
                                            } else {
                                                if op2 == 0b001 then {
                                                    return(ZeroExtend(get_DAIF()))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        return(ZeroExtend(get_SSBS()))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0xE then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(CNTHP_CVAL_EL2)
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        return(NVMem(376))
                                                    } else {
                                                        return(CNTP_CVAL_EL0)
                                                    }
                                                }
                                            } else {
                                                if CRn == 0xF then {
                                                    return(ZeroExtend(RMUID_EL0))
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b001 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(CNTHP_CTL_EL2))
                                                    } else {
                                                        if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            return(ZeroExtend(NVMem(384)))
                                                        } else {
                                                            return(ZeroExtend(CNTP_CTL_EL0))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0x4 then {
                                            if CRm == 0x5 then {
                                                return(DLR_EL0)
                                            } else {
                                                if CRm == 0x4 then {
                                                    return(ZeroExtend(FPSR))
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(CNTHV_CTL_EL2))
                                                    } else {
                                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            return(ZeroExtend(NVMem(368)))
                                                        } else {
                                                            return(ZeroExtend(CNTV_CTL_EL0))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if op2 == 0b010 then {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(CNTHV_CVAL_EL2)
                                                    } else {
                                                        if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            return(NVMem(360))
                                                        } else {
                                                            return(CNTV_CVAL_EL0)
                                                        }
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if CRm == 0xF then {
                                                        return(ZeroExtend(PMCCFILTR_EL0))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if op1 == 0b110 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xC then {
                                        return(ZeroExtend(RMR_EL3))
                                    } else {
                                        if CRn == 0x2 then {
                                            return(ZeroExtend(TCR_EL3))
                                        } else {
                                            if CRn == 0xD then {
                                                return(TPIDR_EL3)
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0xC then {
                                            return(RVBAR_EL3)
                                        } else {
                                            if CRn == 0x4 then {
                                                return(ELR_EL3)
                                            } else {
                                                if CRn == 0x1 then {
                                                    return(ACTLR_EL3)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRn == 0xD then {
                                                return(SCXTNUM_EL3)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b101 then {
                                    if op2 == 0b001 then {
                                        if CRn == 0x2 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(528))
                                            } else {
                                                return(TTBR1_EL1)
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(560))
                                                } else {
                                                    return(ELR_EL1)
                                                }
                                            } else {
                                                if CRn == 0xD then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(264)))
                                                    } else {
                                                        return(ZeroExtend(CONTEXTIDR_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(256)))
                                                } else {
                                                    return(ZeroExtend(CPACR_EL1))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(288))
                                                    } else {
                                                        return(TCR_EL1)
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(392))
                                                    } else {
                                                        return(SCXTNUM_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b001 then {
                                        if CRn == 0x0 then {
                                            if op2 == 0b010 then {
                                                return(ZeroExtend(CCSIDR2_EL1))
                                            } else {
                                                if op2 == 0b111 then {
                                                    return(ZeroExtend(AIDR_EL1))
                                                } else {
                                                    if op2 == 0b001 then {
                                                        return(CLIDR_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if op1 == 0b101 then {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(384)))
                                            } else {
                                                return(ZeroExtend(CNTP_CTL_EL0))
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(2176)))
                                                } else {
                                                    return(ZeroExtend(TRFCR_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if CRm == 0x3 then {
                                                if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(368)))
                                                } else {
                                                    return(ZeroExtend(CNTV_CTL_EL0))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(304)))
                                                    } else {
                                                        return(ZeroExtend(AFSR1_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                return(ZeroExtend(SDER32_EL3))
                                            } else {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(AFSR1_EL3))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(MDCR_EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x2 then {
                                            if CRn == 0xE then {
                                                if op1 == 0b111 then {
                                                    return(ZeroExtend(CNTPS_CTL_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if op1 == 0b101 then {
                                                if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(376))
                                                } else {
                                                    return(CNTP_CVAL_EL0)
                                                }
                                            } else {
                                                if op1 == 0b111 then {
                                                    return(CNTPS_CVAL_EL1)
                                                }
                                            }
                                        } else {
                                            if op1 == 0b101 then {
                                                if CRm == 0x3 then {
                                                    if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(360))
                                                    } else {
                                                        return(CNTV_CVAL_EL0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if op1 == 0b110 then {
                                                if CRn == 0x1 then {
                                                    return(ZeroExtend(CPTR_EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op1 == 0b110 then {
                                            if CRm == 0xC then {
                                                if op2 == 0b101 then {
                                                    return(ZeroExtend(ICC_SRE_EL3))
                                                } else {
                                                    if op2 == 0b111 then {
                                                        return(ZeroExtend(ICC_IGRPEN1_EL3))
                                                    } else {
                                                        if op2 == 0b100 then {
                                                            return(ZeroExtend(ICC_CTLR_EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b010 then {
                        if CRm == 0x2 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(ZeroExtend(NVMem(344)))
                            } else {
                                return(ZeroExtend(MDSCR_EL1))
                            }
                        } else {
                            if CRm == 0x0 then {
                                return(ZeroExtend(OSDTRRX_EL1))
                            } else {
                                if CRm == 0x6 then {
                                    return(ZeroExtend(OSECCR_EL1))
                                } else {
                                    if CRm == 0x3 then {
                                        return(ZeroExtend(OSDTRTX_EL1))
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if op2 == 0b000 then {
                                return(ZeroExtend(MDCCINT_EL1))
                            }
                        }
                    }
                } else {
                    if CRn == 0x1 then {
                        if op2 == 0b100 then {
                            if CRm == 0x1 then {
                                return(ZeroExtend(OSLSR_EL1))
                            } else {
                                if CRm == 0x4 then {
                                    return(ZeroExtend(DBGPRCR_EL1))
                                } else {
                                    if CRm == 0x3 then {
                                        return(ZeroExtend(OSDLR_EL1))
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b000 then {
                                    return(MDRAR_EL1)
                                }
                            }
                        }
                    } else {
                        if CRn == 0x7 then {
                            if op2 == 0b110 then {
                                if CRm == 0x8 then {
                                    return(ZeroExtend(DBGCLAIMSET_EL1))
                                } else {
                                    if CRm == 0xE then {
                                        return(ZeroExtend(DBGAUTHSTATUS_EL1))
                                    } else {
                                        if CRm == 0x9 then {
                                            return(ZeroExtend(DBGCLAIMCLR_EL1))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRn == 0x0 then {
                        if op1 == 0b011 then {
                            if CRm == 0x5 then {
                                return(ZeroExtend(DBGDTRRX_EL0))
                            } else {
                                if CRm == 0x4 then {
                                    return(DBGDTR_EL0)
                                } else {
                                    if CRm == 0x1 then {
                                        return(ZeroExtend(MDCCSR_EL0))
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b100 then {
                                if CRm == 0x7 then {
                                    return(ZeroExtend(DBGVCR32_EL2))
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    undefined : bits(64)
}

val AArch64_SysRegRead : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SysRegRead (op0, op1, crn, crm, op2) = {
    if (((op0 == 3 & crn == 12) & op1 == 0) & op2 == 0) & crm == 1 then {
        return(ZeroExtend(getISR()))
    };
    if (((op0 == 3 & crn == 0) & op1 == 0) & op2 == 5) & crm == 0 then {
        if PSTATE.EL == EL1 & EL2Enabled() then {
            return(VMPIDR_EL2)
        }
    };
    if (((op0 == 3 & crn == 0) & op1 == 0) & op2 == 0) & crm == 0 then {
        if PSTATE.EL == EL1 & EL2Enabled() then {
            return(ZeroExtend(VPIDR_EL2))
        }
    };
    if (((op0 == 3 & crn == 5) & op1 == 4) & op2 == 0) & crm == 2 then {
        if PSTATE.EL == EL1 then {
            return(ZeroExtend(ESR_EL1))
        }
    };
    if (((op0 == 3 & crn == 6) & op1 == 4) & op2 == 0) & crm == 0 then {
        if PSTATE.EL == EL1 then {
            return(FAR_EL1)
        }
    };
    if (((op0 == 3 & crn == 0) & op1 == 3) & op2 == 7) & crm == 0 then {
        if PSTATE.EL == EL0 & ([SCTLR_EL1[14]] == 0b0 | [HCR_EL2[28]] == 0b1) | PSTATE.EL == EL1 & [HCR_EL2[28]] == 0b1 then {
            value_name : bits(64) = ZeroExtend(slice(DCZID_EL0, 0, 32));
            value_name = __SetSlice_bits(64, 1, value_name, 4, 0b1);
            return(value_name)
        }
    };
    value_name : bits(64) = AArch64_AutoGen_SysRegRead(PSTATE.EL, __GetSlice_int(2, op0, 0), __GetSlice_int(3, op1, 0), __GetSlice_int(4, crn, 0), __GetSlice_int(3, op2, 0), __GetSlice_int(4, crm, 0), 0b1);
    if AArch64_CheckNVCondsIfCurrentEL(op0, op1, crn, crm, op2) then {
        value_name = __SetSlice_bits(64, 2, value_name, 2, 0b10)
    };
    value_name
}

val system_register_system : forall ('read : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  ('t >= 0 & 't <= 31 | not('read)) & ('t >= 0 & 't <= 31 | not(not('read))).
  (bool('read), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_register_system (read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if read then {
        X(t) = AArch64_SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2)
    } else {
        AArch64_SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X(t))
    }
}

val system_register_system_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_register_system_decode (Rt, op2, CRm, CRn, op1, o0, L) = {
    __unconditional = true;
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read : bool = L == 0b1;
    __PostDecode();
    system_register_system(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

val memory_vector_single_nowb : forall 'datasize 'esize 'index 'm 'n 'selem 't,
  ('n >= 0 & 'n <= 31).
  (int('datasize), int('esize), int('index), int('m), MemOp, int('n), bool, int('selem), int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_single_nowb (datasize, esize, index, m, memop, n, replicate, selem, t__arg, wback) = {
    t : int = t__arg;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(~(wback) & n == 31)
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    offs : bits(64) = undefined : bits(64);
    rval : bits(128) = undefined : bits(128);
    element : bits('esize) = undefined : bits('esize);
    let 'ebytes : {'n, 'n == div('esize, 8). int('n)} = esize / 8;
    assert(constraint(('ebytes in {1, 2, 4, 8, 16} & 'ebytes == 8 * 'esize)));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    offs = Zeros();
    if replicate then {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            element = aget_Mem(address + offs, ebytes, AccType_VEC);
            aset_V(t, replicate_bits(element, datasize / esize));
            offs = offs + ebytes;
            t = (t + 1) % 32
        }
    } else {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            rval = aget_V(t);
            if memop == MemOp_LOAD then {
                rval = aset_Elem(rval, index, esize, aget_Mem(address + offs, ebytes, AccType_VEC));
                aset_V(t, rval)
            } else {
                aset_Mem(address + offs, ebytes, AccType_VEC, aget_Elem(rval, index, esize))
            };
            offs = offs + ebytes;
            t = (t + 1) % 32
        }
    };
    if wback then {
        if m != 31 then {
            offs = aget_X(m)
        };
        if n == 31 then {
            aset_SP(address + offs)
        } else {
            aset_X(n, address + offs)
        }
    }
}

val memory_vector_single_postinc_memory_vector_single_nowb__decode : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_single_postinc_memory_vector_single_nowb__decode (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool(true) = true;
    scale : int = UInt(slice(opcode, 1, 2));
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined : int;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      }
    };
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, scale);
    __PostDecode();
    memory_vector_single_nowb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

val memory_vector_single_nowb_memory_vector_single_nowb__decode : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_single_nowb_memory_vector_single_nowb__decode (Rt, Rn, size, S, opcode, R, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = undefined : int;
    let wback : bool(false) = false;
    scale : int = UInt(slice(opcode, 1, 2));
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined : int;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      }
    };
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, scale);
    __PostDecode();
    memory_vector_single_nowb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

val memory_vector_multiple_nowb : forall 'datasize 'elements 'esize 'm 'n 'rpt 'selem 't,
  ('n >= 0 & 'n <= 31).
  (int('datasize), int('elements), int('esize), int('m), MemOp, int('n), int('rpt), int('selem), int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_multiple_nowb (datasize, elements, esize, m, memop, n, rpt, selem, t, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    offs : bits(64) = undefined : bits(64);
    rval : bits('datasize) = undefined : bits('datasize);
    tt : int = undefined : int;
    let 'ebytes : {'n, 'n == div('esize, 8). int('n)} = esize / 8;
    assert(constraint(('ebytes in {1, 2, 4, 8, 16} & 'ebytes == 'esize * 8)));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(~(wback) & n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    offs = Zeros();
    foreach (r from 0 to (rpt - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            tt = (t + r) % 32;
            foreach (s from 0 to (selem - 1) by 1 in inc) {
                let tt_fixed = tt;
                assert(0 <= tt_fixed & tt_fixed <= 31);
                rval = aget_V(tt_fixed);
                if memop == MemOp_LOAD then {
                    rval = aset_Elem(rval, e, esize, aget_Mem(address + offs, ebytes, AccType_VEC));
                    aset_V(tt_fixed, rval)
                } else {
                    aset_Mem(address + offs, ebytes, AccType_VEC, aget_Elem(rval, e, esize))
                };
                offs = offs + ebytes;
                tt = (tt + 1) % 32
            }
        }
    };
    if wback then {
        if m != 31 then {
            offs = aget_X(m)
        };
        if n == 31 then {
            aset_SP(address + offs)
        } else {
            aset_X(n, address + offs)
        }
    }
}

val memory_vector_multiple_postinc_memory_vector_multiple_nowb__decode : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_multiple_postinc_memory_vector_multiple_nowb__decode (Rt, Rn, size, opcode, Rm, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool(true) = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, UInt(size));
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    rpt : int = undefined : int;
    selem : int = undefined : int;
    match opcode {
      0x0 => {
          rpt = 1;
          selem = 4
      },
      0x2 => {
          rpt = 4;
          selem = 1
      },
      0x4 => {
          rpt = 1;
          selem = 3
      },
      0x6 => {
          rpt = 3;
          selem = 1
      },
      0x7 => {
          rpt = 1;
          selem = 1
      },
      0x8 => {
          rpt = 1;
          selem = 2
      },
      0xA => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let selem = selem;
    let rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    memory_vector_multiple_nowb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

val memory_vector_multiple_nowb_memory_vector_multiple_nowb__decode : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_multiple_nowb_memory_vector_multiple_nowb__decode (Rt, Rn, size, opcode, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = undefined : int;
    let wback : bool(false) = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize : {'n, 'n in {128, 64}. int('n)} = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, UInt(size));
    let 'elements : {'n, 'n == div('datasize, 'esize). int('n)} = datasize / esize;
    rpt : int = undefined : int;
    selem : int = undefined : int;
    match opcode {
      0x0 => {
          rpt = 1;
          selem = 4
      },
      0x2 => {
          rpt = 4;
          selem = 1
      },
      0x4 => {
          rpt = 1;
          selem = 3
      },
      0x6 => {
          rpt = 3;
          selem = 1
      },
      0x7 => {
          rpt = 1;
          selem = 1
      },
      0x8 => {
          rpt = 1;
          selem = 2
      },
      0xA => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let selem = selem;
    let rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    memory_vector_multiple_nowb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

val memory_single_simdfp_register : forall 'datasize 'm 'n 'shift 't,
  ('shift >= 0 & 'shift <= 4 & 'm >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (AccType, int('datasize), ExtendType, int('m), MemOp, int('n), bool, int('shift), int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_register (acctype, datasize, extend_type, m, memop, n, postindex, shift, t, wback) = {
    let offset : bits(64) = ExtendReg(m, extend_type, shift);
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    let 'd = datasize / 8;
    assert(constraint(('d * 8 == 'datasize & 'd in {1, 2, 4, 8, 16})));
    match memop {
      MemOp_STORE => {
          data = aget_V(t);
          aset_Mem(address, d, acctype, data)
      },
      MemOp_LOAD => {
          data = aget_Mem(address, d, acctype);
          aset_V(t, data)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_simdfp_register_memory_single_simdfp_register__decode : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_register_memory_single_simdfp_register__decode (Rt, Rn, S, option_name, Rm, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift : {'n, ('n == 'scale | 'n == 0). int('n)} = if S == 0b1 then scale else 0;
    assert(constraint('shift <= 4));
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_register(acctype, datasize, extend_type, m, memop, n, postindex, shift, t, wback)
}

val memory_single_simdfp_immediate_signed_postidx : forall 'datasize 'n 't,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_postidx (acctype, datasize, memop, n, offset, postindex, t, wback) = {
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    let 'd = datasize / 8;
    assert(constraint(('d * 8 == 'datasize & 'd in {1, 2, 4, 8, 16})));
    match memop {
      MemOp_STORE => {
          data = aget_V(t);
          aset_Mem(address, d, acctype, data)
      },
      MemOp_LOAD => {
          data = aget_Mem(address, d, acctype);
          aset_V(t, data)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_simdfp_immediate_unsigned_memory_single_simdfp_immediate_signed_postidx__decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_unsigned_memory_single_simdfp_immediate_signed_postidx__decode (Rt, Rn, imm12, opc, V, size) = {
    __unconditional = true;
    let wback : bool(false) = false;
    let postindex : bool(false) = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_simdfp_immediate_signed_preidx_memory_single_simdfp_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_preidx_memory_single_simdfp_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool(true) = true;
    let postindex : bool(false) = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : vector(64, dec, bit) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_simdfp_immediate_signed_postidx_memory_single_simdfp_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_postidx_memory_single_simdfp_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool(true) = true;
    let postindex : bool(true) = true;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : vector(64, dec, bit) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_simdfp_immediate_signed_offset_normal : forall 'datasize 'n 't,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_offset_normal (acctype, datasize, memop, n, offset, postindex, t, wback) = {
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    let 'd = datasize / 8;
    assert(constraint(('d * 8 == 'datasize & 'd in {1, 2, 4, 8, 16})));
    match memop {
      MemOp_STORE => {
          data = aget_V(t);
          aset_Mem(address, datasize / 8, acctype, data)
      },
      MemOp_LOAD => {
          data = aget_Mem(address, datasize / 8, acctype);
          aset_V(t, data)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_simdfp_immediate_signed_offset_normal_memory_single_simdfp_immediate_signed_offset_normal__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_offset_normal_memory_single_simdfp_immediate_signed_offset_normal__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool(false) = false;
    let postindex : bool(false) = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : vector(64, dec, bit) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_general_register : forall 'datasize 'm 'n ('postindex : Bool) 'regsize 'shift ('signed : Bool) 't ('wback : Bool),
  ('shift >= 0 & 'shift <= 4 & 'm >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 'shift >= 0 & 'shift <= 4 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), ExtendType, int('m), MemOp, int('n), bool('postindex), int('regsize), int('shift), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_register (acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    let offset : bits(64) = ExtendReg(m, extend_type, shift);
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = aget_X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          aset_Mem(address, datasize / 8, acctype, data)
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = aget_Mem(address, datasize / 8, acctype);
          if signed then {
              aset_X(t, SignExtend(data, regsize))
          } else {
              aset_X(t, ZeroExtend(data, regsize))
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_general_register_memory_single_general_register__decode : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_register_memory_single_general_register__decode (Rt, Rn, S, option_name, Rm, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift : {'n, ('n == 'scale | 'n == 0). int('n)} = if S == 0b1 then scale else 0;
    assert(shift <= 4);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, signed, t, wback)
}

val memory_single_general_immediate_unsigned : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 't & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_unsigned (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = aget_X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          aset_Mem(address, datasize / 8, acctype, data)
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = aget_Mem(address, datasize / 8, acctype);
          if signed then {
              aset_X(t, SignExtend(data, regsize))
          } else {
              aset_X(t, ZeroExtend(data, regsize))
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_general_immediate_unsigned_memory_single_general_immediate_unsigned__decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_unsigned_memory_single_general_immediate_unsigned__decode (Rt, Rn, imm12, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_unsigned(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_postidx : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_postidx (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_unsigned_memory_single_general_immediate_signed_postidx__decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_unsigned_memory_single_general_immediate_signed_postidx__decode (Rt, Rn, imm12, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_preidx_memory_single_general_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_preidx_memory_single_general_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_postidx_memory_single_general_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_postidx_memory_single_general_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_pac : forall 'n 't ('use_key_a : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31).
  (int('n), bits(64), int('t), bool('use_key_a), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_pac (n, offset, t, use_key_a, wback__arg) = {
    wback : bool = wback__arg;
    address : bits(64) = undefined : bits(64);
    data : bits(64) = undefined : bits(64);
    wb_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if (wback & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    if use_key_a then {
        address = AuthDA(address, X(31))
    } else {
        address = AuthDB(address, X(31))
    };
    address = address + offset;
    let data = Mem(address, 8, AccType_NORMAL);
    X(t) = data;
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_pac_decode : (bits(5), bits(5), bits(1), bits(9), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_pac_decode (Rt, Rn, W, imm9, S, M, V, size) = {
    __unconditional = true;
    if ~(HavePACExt()) | size != 0b11 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let wback : bool = W == 0b1;
    let use_key_a : bool = M == 0b0;
    let S10 : vector(1 + 9, dec, bit) = S @ imm9;
    let 'scale : {'n, 'n == 3. int('n)} = 3;
    let offset : bits(64) = LSL(SignExtend(S10, 64), scale);
    __PostDecode();
    memory_single_general_immediate_signed_pac(n, offset, t, use_key_a, wback)
}

val memory_single_general_immediate_signed_offset_unpriv : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_unpriv (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_offset_unpriv_memory_single_general_immediate_signed_offset_unpriv__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_unpriv_memory_single_general_immediate_signed_offset_unpriv__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1 & ~((EL2Enabled() & HaveNVExt()) & (HCR_EL2[42 .. 42] @ HCR_EL2[43 .. 43]) == 0b11);
    let unpriv_at_el2 : bool = ((HaveEL(EL2) & HaveVirtHostExt()) & PSTATE.EL == EL2) & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    acctype : AccType = undefined : AccType;
    if ~(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_offset_normal : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_normal (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_offset_normal_memory_single_general_immediate_signed_offset_normal__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_normal_memory_single_general_immediate_signed_offset_normal__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_offset_lda_stl : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_lda_stl (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_offset_lda_stl_memory_single_general_immediate_signed_offset_lda_stl__decode : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_lda_stl_memory_single_general_immediate_signed_offset_lda_stl__decode (Rt, Rn, imm9, opc, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_ORDERED;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = undefined : int;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_offset_lda_stl(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_pair_simdfp_postidx : forall 'datasize 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_postidx (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          data1 = aget_V(t);
          data2 = aget_V(t2);
          aset_Mem(address + 0, dbytes, acctype, data1);
          aset_Mem(address + dbytes, dbytes, acctype, data2)
      },
      MemOp_LOAD => {
          data1 = aget_Mem(address + 0, dbytes, acctype);
          data2 = aget_Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          aset_V(t, data1);
          aset_V(t2, data2)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_pair_simdfp_preidx_memory_pair_simdfp_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_preidx_memory_pair_simdfp_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_postidx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_simdfp_postidx_memory_pair_simdfp_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_postidx_memory_pair_simdfp_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_postidx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_simdfp_offset_memory_pair_simdfp_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_offset_memory_pair_simdfp_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_postidx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_simdfp_noalloc : forall 'datasize 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_noalloc (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          data1 = aget_V(t);
          data2 = aget_V(t2);
          aset_Mem(address + 0, dbytes, acctype, data1);
          aset_Mem(address + dbytes, dbytes, acctype, data2)
      },
      MemOp_LOAD => {
          data1 = aget_Mem(address + 0, dbytes, acctype);
          data2 = aget_Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          aset_V(t, data1);
          aset_V(t2, data2)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_pair_simdfp_noalloc_memory_pair_simdfp_noalloc__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_noalloc_memory_pair_simdfp_noalloc__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VECSTREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_noalloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_general_postidx : forall 'datasize 'n ('postindex : Bool) ('signed : Bool) 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}) & ('t2 >= 0 & 't2 <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), bool('signed), int('t), int('t2), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_postidx (acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback__arg) = {
    wback : bool = wback__arg;
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = undefined : bits('datasize)
          } else {
              data1 = X(t)
          };
          if rt_unknown & t2 == n then {
              data2 = undefined : bits('datasize)
          } else {
              data2 = X(t2)
          };
          Mem(address + 0, dbytes, acctype) = data1;
          Mem(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          data1 = Mem(address + 0, dbytes, acctype);
          data2 = Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          if signed then {
              X(t) = SignExtend(data1, 64);
              X(t2) = SignExtend(data2, 64)
          } else {
              X(t) = data1;
              X(t2) = data2
          }
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_pair_general_preidx_memory_pair_general_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_preidx_memory_pair_general_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_postidx(acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback)
}

val memory_pair_general_postidx_memory_pair_general_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_postidx_memory_pair_general_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_postidx(acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback)
}

val memory_pair_general_offset_memory_pair_general_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_offset_memory_pair_general_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_postidx(acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback)
}

val memory_pair_general_noalloc : forall 'datasize 'n ('postindex : Bool) 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}) & ('t2 >= 0 & 't2 <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), int('t2), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_noalloc (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = undefined : bits('datasize)
          } else {
              data1 = X(t)
          };
          if rt_unknown & t2 == n then {
              data2 = undefined : bits('datasize)
          } else {
              data2 = X(t2)
          };
          Mem(address + 0, dbytes, acctype) = data1;
          Mem(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          data1 = Mem(address + 0, dbytes, acctype);
          data2 = Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          X(t) = data1;
          X(t2) = data2
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_pair_general_noalloc_memory_pair_general_noalloc__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_noalloc_memory_pair_general_noalloc__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_STREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if [opc[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_noalloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_ordered : forall 'datasize 'n 'regsize 't,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), int('regsize), int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_ordered (acctype, datasize, memop, n, regsize, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    match memop {
      MemOp_STORE => {
          data = X(t);
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          Mem(address, dbytes, acctype) = data
      },
      MemOp_LOAD => {
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          data = Mem(address, dbytes, acctype);
          X(t) = ZeroExtend(data, regsize)
      }
    };
    let data = data;
    ()
}

val memory_ordered_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_ordered_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, size) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = shl_int(8, UInt(size));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if elsize == 64 then 64 else 32;
    let 'datasize : {'n, 'n == 'elsize. int('n)} = elsize;
    __PostDecode();
    memory_ordered(acctype, datasize, memop, n, regsize, t)
}

val memory_orderedrcpc : forall 'datasize 'n 'regsize 't,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64, 128} & 't >= 0 & 't <= 31).
  (AccType, int('datasize), int('n), int('regsize), int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wreg, wmem}

function memory_orderedrcpc (acctype, datasize, n, regsize, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, acctype);
    aset_X(t, ZeroExtend(data, regsize))
}

val memory_orderedrcpc_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_orderedrcpc_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ORDERED;
    let 'elsize = shl_int(8, UInt(size));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if elsize == 64 then 64 else 32;
    let 'datasize : {'n, 'n == 'elsize. int('n)} = elsize;
    __PostDecode();
    memory_orderedrcpc(acctype, datasize, n, regsize, t)
}

val memory_literal_simdfp : forall 'size 't,
  'size in {1, 2, 4, 8, 16} & ('t >= 0 & 't <= 31).
  (bits(64), int('size), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function memory_literal_simdfp (offset, size, t) = {
    let address : vector(64, dec, bit) = PC() + offset;
    data : bits(8 * 'size) = undefined : bits('size * 8);
    CheckFPAdvSIMDEnabled64();
    let data = Mem(address, size, AccType_VEC);
    V(t) = data
}

val memory_literal_simdfp_decode : (bits(5), bits(19), bits(1), bits(2)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function memory_literal_simdfp_decode (Rt, imm19, V, opc) = {
    __unconditional = true;
    let 't = UInt(Rt);
    size : int = undefined : int;
    offset : bits(64) = undefined : bits(64);
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 16
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let offset = SignExtend(imm19 @ 0b00, 64);
    __PostDecode();
    let size_fixed = size;
    assert(size_fixed == 4 | size_fixed == 8 | size_fixed == 16);
    memory_literal_simdfp(offset, size_fixed, t)
}

val memory_literal_general : forall ('size : Int) ('t : Int), (0 <= 't & 't <= 31).
  (MemOp, bits(64), bool, int('size), int('t)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function memory_literal_general (memop, offset, signed, size, t) = {
    let address : bits(64) = aget_PC() + offset;
    data : bits(8 * 'size) = undefined : bits('size * 8);
    match memop {
      MemOp_LOAD => {
          assert(constraint('size in {1, 2, 4, 8, 16}));
          data = aget_Mem(address, size, AccType_NORMAL);
          if signed then {
              aset_X(t, SignExtend(data, 64))
          } else {
              aset_X(t, data)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    }
}

val memory_literal_general_decode : (bits(5), bits(19), bits(1), bits(2)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function memory_literal_general_decode (Rt, imm19, V, opc) = {
    __unconditional = true;
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    signed : bool = false;
    size : int = undefined : int;
    offset : bits(64) = undefined : bits(64);
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let offset = SignExtend(imm19 @ 0b00, 64);
    __PostDecode();
    memory_literal_general(memop, offset, signed, size, t)
}

val memory_exclusive_single : forall 'datasize 'elsize 'n 'regsize 's 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 's >= 0 & 's <= 31).
  (AccType, int('datasize), int('elsize), MemOp, int('n), bool, int('regsize), int('s), int('t), int('t2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_single (acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction(is_load_store & n == 31)
    };
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_NONE => {
                  rt_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_NONE => {
                  rn_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        if rn_unknown then {
            address = undefined : bits(64)
        } else {
            address = aget_X(n)
        }
    };
    iswrite : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              if pair then {
                  let 'd2 = 'datasize / 2;
                  assert(constraint('datasize in {16, 32, 64, 128}));
                  assert(constraint('d2 * 2 == 'datasize));
                  let el1 : bits('d2) = aget_X(t);
                  let el2 : bits('d2) = aget_X(t2);
                  data = if BigEndian() then el1 @ el2 else el2 @ el1
              } else {
                  assert(constraint('datasize in {8, 16, 32, 64}));
                  data = aget_X(t)
              }
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              aset_Mem(address, dbytes, acctype, data);
              status = ExclusiveMonitorsStatus()
          };
          aset_X(s, ZeroExtend(status, 32))
      },
      MemOp_LOAD => {
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  aset_X(t, undefined : bits('datasize))
              } else {
                  if elsize == 32 then {
                      assert(constraint('dbytes in {1, 2, 4, 8, 16}));
                      assert(constraint(- 'elsize + 'datasize >= 0));
                      data = aget_Mem(address, dbytes, acctype);
                      if BigEndian() then {
                          aset_X(t, slice(data, elsize, negate(elsize) + datasize));
                          aset_X(t2, slice(data, 0, elsize))
                      } else {
                          aset_X(t, slice(data, 0, elsize));
                          aset_X(t2, slice(data, elsize, negate(elsize) + datasize))
                      }
                  } else {
                      if address != Align(address, dbytes) then {
                          iswrite = false;
                          secondstage = false;
                          AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
                      };
                      aset_X(t, aget_Mem(address + 0, 8, acctype));
                      aset_X(t2, aget_Mem(address + 8, 8, acctype))
                  }
              }
          } else {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              data = aget_Mem(address, dbytes, acctype);
              aset_X(t, ZeroExtend(data, regsize))
          }
      }
    }
}

val memory_exclusive_single_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_single_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, size) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool(false) = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = shl_int(8, UInt(size));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if elsize == 64 then 64 else 32;
    let 'datasize : {'n, ('n == 'elsize * 2 | 'n == 'elsize). int('n)} = if pair then elsize * 2 else elsize;
    __PostDecode();
    memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

val memory_exclusive_pair : forall 'datasize 'elsize 'n 'regsize 's 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 's >= 0 & 's <= 31).
  (AccType, int('datasize), int('elsize), MemOp, int('n), bool, int('regsize), int('s), int('t), int('t2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_pair (acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction(is_load_store & n == 31)
    };
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_NONE => {
                  rt_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_NONE => {
                  rn_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        if rn_unknown then {
            address = undefined : bits(64)
        } else {
            address = aget_X(n)
        }
    };
    iswrite : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              if pair then {
                  let 'd2 = 'datasize / 2;
                  assert(constraint('datasize in {16, 32, 64, 128}));
                  assert(constraint('d2 * 2 == 'datasize));
                  let el1 : bits('d2) = aget_X(t);
                  let el2 : bits('d2) = aget_X(t2);
                  data = if BigEndian() then el1 @ el2 else el2 @ el1
              } else {
                  assert(constraint('datasize in {8, 16, 32, 64}));
                  data = aget_X(t)
              }
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              aset_Mem(address, dbytes, acctype, data);
              status = ExclusiveMonitorsStatus()
          };
          aset_X(s, ZeroExtend(status, 32))
      },
      MemOp_LOAD => {
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  aset_X(t, undefined : bits('datasize))
              } else {
                  if elsize == 32 then {
                      assert(constraint('dbytes in {1, 2, 4, 8, 16}));
                      assert(constraint(- 'elsize + 'datasize >= 0));
                      data = aget_Mem(address, dbytes, acctype);
                      if BigEndian() then {
                          aset_X(t, slice(data, elsize, negate(elsize) + datasize));
                          aset_X(t2, slice(data, 0, elsize))
                      } else {
                          aset_X(t, slice(data, 0, elsize));
                          aset_X(t2, slice(data, elsize, negate(elsize) + datasize))
                      }
                  } else {
                      if address != Align(address, dbytes) then {
                          iswrite = false;
                          secondstage = false;
                          AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
                      };
                      aset_X(t, aget_Mem(address + 0, 8, acctype));
                      aset_X(t2, aget_Mem(address + 8, 8, acctype))
                  }
              }
          } else {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              data = aget_Mem(address, dbytes, acctype);
              aset_X(t, ZeroExtend(data, regsize))
          }
      }
    }
}

val memory_exclusive_pair_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_pair_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, sz) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool(true) = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = shl_int(32, UInt(sz));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if elsize == 64 then 64 else 32;
    let 'datasize : {'n, ('n == 'elsize * 2 | 'n == 'elsize). int('n)} = if pair then elsize * 2 else elsize;
    __PostDecode();
    memory_exclusive_pair(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

val memory_atomicops_swp : forall 'datasize 'n 'regsize 's 't,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64} & 's >= 0 & 's <= 31 & 't >= 0 & 't <= 31).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_swp (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    let data = aget_Mem(address, dbytes, ldacctype);
    aset_Mem(address, dbytes, stacctype, aget_X(s));
    aset_X(t, ZeroExtend(data, regsize))
}

val memory_atomicops_swp_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_swp_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    __PostDecode();
    memory_atomicops_swp(datasize, ldacctype, n, regsize, s, stacctype, t)
}

val memory_atomicops_st : forall 'datasize 'n 's,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31).
  (int('datasize), AccType, int('n), MemAtomicOp, int('s), AccType) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_st (datasize, ldacctype, n, op, s, stacctype) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    result : bits('datasize) = undefined : bits('datasize);
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    let value_name : bits('datasize) = aget_X(s);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, ldacctype);
    match op {
      MemAtomicOp_ADD => {
          result = data + value_name
      },
      MemAtomicOp_BIC => {
          result = data & ~(value_name)
      },
      MemAtomicOp_EOR => {
          result = data ^ value_name
      },
      MemAtomicOp_ORR => {
          result = data | value_name
      },
      MemAtomicOp_SMAX => {
          result = if SInt(data) > SInt(value_name) then data else value_name
      },
      MemAtomicOp_SMIN => {
          result = if SInt(data) > SInt(value_name) then value_name else data
      },
      MemAtomicOp_UMAX => {
          result = if UInt(data) > UInt(value_name) then data else value_name
      },
      MemAtomicOp_UMIN => {
          result = if UInt(data) > UInt(value_name) then value_name else data
      }
    };
    aset_Mem(address, dbytes, stacctype, result)
}

val memory_atomicops_st_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_st_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined : MemAtomicOp;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    __PostDecode();
    memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

val memory_atomicops_ld : forall 'datasize 'n 'regsize 's 't,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (int('datasize), AccType, int('n), MemAtomicOp, int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_ld (datasize, ldacctype, n, op, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    result : bits('datasize) = undefined : bits('datasize);
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    let value_name : bits('datasize) = aget_X(s);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, ldacctype);
    match op {
      MemAtomicOp_ADD => {
          result = data + value_name
      },
      MemAtomicOp_BIC => {
          result = data & ~(value_name)
      },
      MemAtomicOp_EOR => {
          result = data ^ value_name
      },
      MemAtomicOp_ORR => {
          result = data | value_name
      },
      MemAtomicOp_SMAX => {
          result = if SInt(data) > SInt(value_name) then data else value_name
      },
      MemAtomicOp_SMIN => {
          result = if SInt(data) > SInt(value_name) then value_name else data
      },
      MemAtomicOp_UMAX => {
          result = if UInt(data) > UInt(value_name) then data else value_name
      },
      MemAtomicOp_UMIN => {
          result = if UInt(data) > UInt(value_name) then value_name else data
      }
    };
    aset_Mem(address, dbytes, stacctype, result);
    if t != 31 then {
        aset_X(t, ZeroExtend(data, regsize))
    }
}

val memory_atomicops_ld_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_ld_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined : MemAtomicOp;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    __PostDecode();
    memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

val memory_atomicops_cas_single : forall 'datasize 'n 'regsize 's 't,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_single (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    let comparevalue : bits('datasize) = aget_X(s);
    let newvalue : bits('datasize) = aget_X(t);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, ldacctype);
    if data == comparevalue then {
        aset_Mem(address, dbytes, stacctype, newvalue)
    };
    aset_X(s, ZeroExtend(data, regsize))
}

val memory_atomicops_cas_single_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_single_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize : {'n, 'n in {64, 32}. int('n)} = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    __PostDecode();
    memory_atomicops_cas_single(datasize, ldacctype, n, regsize, s, stacctype, t)
}

val memory_atomicops_cas_pair : forall 'datasize 'n 'regsize 's 't,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64}) & 's + 1 <= 31 & ('t >= 0 & 't <= 31) & 't + 1 <= 31 & ('n >= 0 & 'n <= 31 | not(not('n == 31))).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_pair (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    comparevalue : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    newvalue : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    data : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    let s1 : bits('datasize) = X(s);
    let s2 : bits('datasize) = X(s + 1);
    let t1 : bits('datasize) = X(t);
    let t2 : bits('datasize) = X(t + 1);
    let comparevalue = if BigEndian() then s1 @ s2 else s2 @ s1;
    let newvalue = if BigEndian() then t1 @ t2 else t2 @ t1;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    let data = Mem(address, 2 * datasize / 8, ldacctype);
    if data == comparevalue then {
        Mem(address, 2 * datasize / 8, stacctype) = newvalue
    };
    if BigEndian() then {
        X(s) = ZeroExtend(slice(data, datasize, datasize), regsize);
        X(s + 1) = ZeroExtend(slice(data, 0, datasize), regsize)
    } else {
        X(s) = ZeroExtend(slice(data, 0, datasize), regsize);
        X(s + 1) = ZeroExtend(slice(data, datasize, datasize), regsize)
    }
}

val memory_atomicops_cas_pair_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_pair_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, sz) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    if [Rs[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    assert(t <= 30);
    let 's = UInt(Rs);
    assert(s <= 30);
    let 'datasize = shl_int(32, UInt(sz));
    let 'regsize : {'n, 'n == 'datasize. int('n)} = datasize;
    let ldacctype : AccType = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    __PostDecode();
    memory_atomicops_cas_pair(datasize, ldacctype, n, regsize, s, stacctype, t)
}

val __fetchA64 : unit -> bits(32) effect {escape, rmem, rreg, undef, wmem, wreg}

function __fetchA64 () = {
    CheckSoftwareStep();
    AArch64_CheckPCAlignment();
    let a64 : vector(8 * 4, dec, bit) = MemSingle(PC(), 4, AccType_IFETCH, true);
    AArch64_CheckIllegalState();
    a64
}

function IsZero_slice (xs, i, 'l) = {
    assert(constraint('l >= 0));
    IsZero(slice(xs, i, l))
}

function IsOnes_slice (xs, i, 'l) = {
    assert(constraint('l >= 0));
    IsOnes(slice(xs, i, l))
}

function ZeroExtend_slice_append (xs, i, 'l, ys) = {
    assert(constraint(('l >= 0 & 'm >= 0)));
    ZeroExtend(slice(xs, i, l) @ ys)
}

function AArch64_TranslationTableWalk (ipaddress, s1_nonsecure, vaddress, acctype, iswrite, secondstage, s2fs1walk, size) = {
    if ~(secondstage) then {
        assert(~(ELUsingAArch32(S1TranslationRegime())))
    } else {
        assert((IsSecureEL2Enabled() | (HaveEL(EL2) & ~(IsSecure())) & ~(ELUsingAArch32(EL2))) & HasS2Translation())
    };
    result : TLBRecord = undefined : TLBRecord;
    descaddr : AddressDescriptor = undefined : AddressDescriptor;
    baseregister : bits(64) = undefined : bits(64);
    inputaddr : bits(64) = undefined : bits(64);
    if __tlb_enabled then {
        if ~(secondstage) then {
            inputaddr = ZeroExtend(vaddress)
        } else {
            inputaddr = ZeroExtend(ipaddress)
        };
        let cacheline : TLBLine = TLBLookup(ZeroExtend(inputaddr, 64), secondstage, s1_nonsecure, acctype);
        if cacheline.valid_name then {
            return(cacheline.data)
        }
    };
    __tc1 : MemoryAttributes = descaddr.memattrs;
    __tc1.typ = MemType_Normal;
    descaddr.memattrs = __tc1;
    basefound : bool = undefined : bool;
    c : Constraint = undefined : Constraint;
    disabled : bool = undefined : bool;
    el : bits(2) = undefined : bits(2);
    firstblocklevel : int = undefined : int;
    grainsize : int = undefined : int;
    hierattrsdisabled : bool = undefined : bool;
    inputsize : int = undefined : int;
    inputsize_max : int = undefined : int;
    inputsize_min : int = undefined : int;
    inputsizecheck : int = undefined : int;
    largegrain : bool = undefined : bool;
    level : int = undefined : int;
    lookupsecure : bool = undefined : bool;
    midgrain : bool = undefined : bool;
    nsaccess : bits(1) = undefined : bits(1);
    nswalk : bits(1) = undefined : bits(1);
    ps : bits(3) = undefined : bits(3);
    reversedescriptors : bool = undefined : bool;
    singlepriv : bool = undefined : bool;
    startlevel : int = undefined : int;
    startsizecheck : int = undefined : int;
    stride : int = undefined : int;
    t0size : bits(6) = undefined : bits(6);
    tg0 : bits(2) = undefined : bits(2);
    top : int = undefined : int;
    update_AF : bool = undefined : bool;
    update_AP : bool = undefined : bool;
    if ~(secondstage) then {
        inputaddr = ZeroExtend(vaddress);
        el = AArch64_AccessUsesEL(acctype);
        top = AddrTop(inputaddr, acctype == AccType_IFETCH, el);
        if el == EL3 then {
            largegrain = slice(TCR_EL3, 14, 2) == 0b01;
            midgrain = slice(TCR_EL3, 14, 2) == 0b10;
            inputsize = 64 - UInt(slice(TCR_EL3, 0, 6));
            inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
            inputsize_min = 64 - (if ~(HaveSmallPageTblExt()) then 39 else if largegrain then 47 else 48);
            if inputsize < inputsize_min then {
                c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                assert(c == Constraint_FORCE | c == Constraint_FAULT);
                if c == Constraint_FORCE then {
                    inputsize = inputsize_min
                }
            };
            ps = slice(TCR_EL3, 16, 3);
            basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & IsZero_slice(inputaddr, inputsize, top - inputsize + 1);
            disabled = false;
            baseregister = TTBR0_EL3;
            descaddr.memattrs = WalkAttrDecode(slice(TCR_EL3, 12, 2), slice(TCR_EL3, 10, 2), slice(TCR_EL3, 8, 2), secondstage);
            reversedescriptors = [SCTLR_EL3[25]] == 0b1;
            lookupsecure = true;
            singlepriv = true;
            update_AF = HaveAccessFlagUpdateExt() & [TCR_EL3[21]] == 0b1;
            update_AP = (HaveDirtyBitModifierExt() & update_AF) & [TCR_EL3[22]] == 0b1;
            hierattrsdisabled = AArch64_HaveHPDExt() & [TCR_EL3[24]] == 0b1
        } else {
            if ELIsInHost(el) then {
                if [inputaddr[top]] == 0b0 then {
                    largegrain = slice(TCR_EL2, 14, 2) == 0b01;
                    midgrain = slice(TCR_EL2, 14, 2) == 0b10;
                    inputsize = 64 - UInt(slice(TCR_EL2, 0, 6));
                    inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                    inputsize_min = 64 - (if ~(HaveSmallPageTblExt()) then 39 else if largegrain then 47 else 48);
                    if inputsize < inputsize_min then {
                        c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                        assert(c == Constraint_FORCE | c == Constraint_FAULT);
                        if c == Constraint_FORCE then {
                            inputsize = inputsize_min
                        }
                    };
                    basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & IsZero_slice(inputaddr, inputsize, top - inputsize + 1);
                    disabled = [TCR_EL2[7]] == 0b1 | (PSTATE.EL == EL0 & HaveE0PDExt()) & [TCR_EL2[55]] == 0b1;
                    baseregister = TTBR0_EL2;
                    descaddr.memattrs = WalkAttrDecode(slice(TCR_EL2, 12, 2), slice(TCR_EL2, 10, 2), slice(TCR_EL2, 8, 2), secondstage);
                    hierattrsdisabled = AArch64_HaveHPDExt() & [TCR_EL2[41]] == 0b1
                } else {
                    inputsize = 64 - UInt(slice(TCR_EL2, 16, 6));
                    largegrain = slice(TCR_EL2, 30, 2) == 0b11;
                    midgrain = slice(TCR_EL2, 30, 2) == 0b01;
                    inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                    inputsize_min = 64 - (if ~(HaveSmallPageTblExt()) then 39 else if largegrain then 47 else 48);
                    if inputsize < inputsize_min then {
                        c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                        assert(c == Constraint_FORCE | c == Constraint_FAULT);
                        if c == Constraint_FORCE then {
                            inputsize = inputsize_min
                        }
                    };
                    basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & IsOnes_slice(inputaddr, inputsize, top - inputsize + 1);
                    disabled = [TCR_EL2[23]] == 0b1 | (PSTATE.EL == EL0 & HaveE0PDExt()) & [TCR_EL2[56]] == 0b1;
                    baseregister = TTBR1_EL2;
                    descaddr.memattrs = WalkAttrDecode(slice(TCR_EL2, 28, 2), slice(TCR_EL2, 26, 2), slice(TCR_EL2, 24, 2), secondstage);
                    hierattrsdisabled = AArch64_HaveHPDExt() & [TCR_EL2[42]] == 0b1
                };
                ps = slice(TCR_EL2, 32, 3);
                reversedescriptors = [SCTLR_EL2[25]] == 0b1;
                lookupsecure = if IsSecureEL2Enabled() then IsSecure() else false;
                singlepriv = false;
                update_AF = HaveAccessFlagUpdateExt() & [TCR_EL2[if [HCR_EL2[34]] == 0 then 21 else 39]] == 0b1;
                update_AP = (HaveDirtyBitModifierExt() & update_AF) & [TCR_EL2[if [HCR_EL2[34]] == 0 then 22 else 40]] == 0b1
            } else {
                if el == EL2 then {
                    inputsize = 64 - UInt(slice(TCR_EL2, 0, 6));
                    largegrain = slice(TCR_EL2, 14, 2) == 0b01;
                    midgrain = slice(TCR_EL2, 14, 2) == 0b10;
                    inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                    inputsize_min = 64 - (if ~(HaveSmallPageTblExt()) then 39 else if largegrain then 47 else 48);
                    if inputsize < inputsize_min then {
                        c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                        assert(c == Constraint_FORCE | c == Constraint_FAULT);
                        if c == Constraint_FORCE then {
                            inputsize = inputsize_min
                        }
                    };
                    ps = slice(TCR_EL2, 16, 3);
                    basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & IsZero_slice(inputaddr, inputsize, top - inputsize + 1);
                    disabled = false;
                    baseregister = TTBR0_EL2;
                    descaddr.memattrs = WalkAttrDecode(slice(TCR_EL2, 12, 2), slice(TCR_EL2, 10, 2), slice(TCR_EL2, 8, 2), secondstage);
                    reversedescriptors = [SCTLR_EL2[25]] == 0b1;
                    lookupsecure = if IsSecureEL2Enabled() then IsSecure() else false;
                    singlepriv = true;
                    update_AF = HaveAccessFlagUpdateExt() & [TCR_EL2[if [HCR_EL2[34]] == 0 then 21 else 39]] == 0b1;
                    update_AP = (HaveDirtyBitModifierExt() & update_AF) & [TCR_EL2[if [HCR_EL2[34]] == 0 then 22 else 40]] == 0b1;
                    hierattrsdisabled = AArch64_HaveHPDExt() & [TCR_EL2[24]] == 0b1
                } else {
                    if [inputaddr[top]] == 0b0 then {
                        inputsize = 64 - UInt(slice(TCR_EL1, 0, 6));
                        largegrain = slice(TCR_EL1, 14, 2) == 0b01;
                        midgrain = slice(TCR_EL1, 14, 2) == 0b10;
                        inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                        inputsize_min = 64 - (if ~(HaveSmallPageTblExt()) then 39 else if largegrain then 47 else 48);
                        if inputsize < inputsize_min then {
                            c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                            assert(c == Constraint_FORCE | c == Constraint_FAULT);
                            if c == Constraint_FORCE then {
                                inputsize = inputsize_min
                            }
                        };
                        basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & IsZero_slice(inputaddr, inputsize, top - inputsize + 1);
                        disabled = [TCR_EL1[7]] == 0b1 | (PSTATE.EL == EL0 & HaveE0PDExt()) & [TCR_EL1[55]] == 0b1;
                        baseregister = TTBR0_EL1;
                        descaddr.memattrs = WalkAttrDecode(slice(TCR_EL1, 12, 2), slice(TCR_EL1, 10, 2), slice(TCR_EL1, 8, 2), secondstage);
                        hierattrsdisabled = AArch64_HaveHPDExt() & [TCR_EL1[41]] == 0b1
                    } else {
                        inputsize = 64 - UInt(slice(TCR_EL1, 16, 6));
                        largegrain = slice(TCR_EL1, 30, 2) == 0b11;
                        midgrain = slice(TCR_EL1, 30, 2) == 0b01;
                        inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                        inputsize_min = 64 - (if ~(HaveSmallPageTblExt()) then 39 else if largegrain then 47 else 48);
                        if inputsize < inputsize_min then {
                            c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                            assert(c == Constraint_FORCE | c == Constraint_FAULT);
                            if c == Constraint_FORCE then {
                                inputsize = inputsize_min
                            }
                        };
                        basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & IsOnes_slice(inputaddr, inputsize, top - inputsize + 1);
                        disabled = [TCR_EL1[23]] == 0b1 | (PSTATE.EL == EL0 & HaveE0PDExt()) & [TCR_EL1[56]] == 0b1;
                        baseregister = TTBR1_EL1;
                        descaddr.memattrs = WalkAttrDecode(slice(TCR_EL1, 28, 2), slice(TCR_EL1, 26, 2), slice(TCR_EL1, 24, 2), secondstage);
                        hierattrsdisabled = AArch64_HaveHPDExt() & [TCR_EL1[42]] == 0b1
                    };
                    ps = slice(TCR_EL1, 32, 3);
                    reversedescriptors = [SCTLR_EL1[25]] == 0b1;
                    lookupsecure = IsSecure();
                    singlepriv = false;
                    update_AF = HaveAccessFlagUpdateExt() & [TCR_EL1[39]] == 0b1;
                    update_AP = (HaveDirtyBitModifierExt() & update_AF) & [TCR_EL1[40]] == 0b1
                }
            }
        };
        if largegrain then {
            grainsize = 16;
            firstblocklevel = if Have52BitPAExt() then 1 else 2
        } else {
            if midgrain then {
                grainsize = 14;
                firstblocklevel = 2
            } else {
                grainsize = 12;
                firstblocklevel = 1
            }
        };
        stride = grainsize - 3;
        level = 4 - RoundUp(Real(inputsize - grainsize) / Real(stride))
    } else {
        inputaddr = ZeroExtend(ipaddress);
        if IsSecureEL2Enabled() & IsSecure() then {
            t0size = if s1_nonsecure == 0b1 then slice(VTCR_EL2, 0, 6) else slice(VSTCR_EL2, 0, 6);
            tg0 = if s1_nonsecure == 0b1 then slice(VTCR_EL2, 14, 2) else slice(VSTCR_EL2, 14, 2);
            nswalk = if s1_nonsecure == 0b1 then [VTCR_EL2[29]] else [VSTCR_EL2[29]];
            if nswalk == 0b1 then {
                nsaccess = 0b1
            } else {
                if s1_nonsecure == 0b0 then {
                    nsaccess = [VSTCR_EL2[30]]
                } else {
                    if [VSTCR_EL2[29]] == 0b1 | [VSTCR_EL2[30]] == 0b1 then {
                        nsaccess = 0b1
                    } else {
                        nsaccess = [VTCR_EL2[30]]
                    }
                }
            }
        } else {
            t0size = slice(VTCR_EL2, 0, 6);
            tg0 = slice(VTCR_EL2, 14, 2);
            nsaccess = 0b1
        };
        inputsize = 64 - UInt(t0size);
        largegrain = tg0 == 0b01;
        midgrain = tg0 == 0b10;
        inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
        inputsize_min = 64 - (if ~(HaveSmallPageTblExt()) then 39 else if largegrain then 47 else 48);
        if inputsize < inputsize_min then {
            c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
            assert(c == Constraint_FORCE | c == Constraint_FAULT);
            if c == Constraint_FORCE then {
                inputsize = inputsize_min
            }
        };
        ps = slice(VTCR_EL2, 16, 3);
        basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & IsZero_slice(inputaddr, inputsize, negate(inputsize) + 64);
        disabled = false;
        descaddr.memattrs = WalkAttrDecode(slice(VTCR_EL2, 8, 2), slice(VTCR_EL2, 10, 2), slice(VTCR_EL2, 12, 2), secondstage);
        reversedescriptors = [SCTLR_EL2[25]] == 0b1;
        singlepriv = true;
        update_AF = HaveAccessFlagUpdateExt() & [VTCR_EL2[21]] == 0b1;
        update_AP = (HaveDirtyBitModifierExt() & update_AF) & [VTCR_EL2[22]] == 0b1;
        lookupsecure = if IsSecureEL2Enabled() then s1_nonsecure == 0b0 else false;
        baseregister = if lookupsecure then VSTTBR_EL2 else VTTBR_EL2;
        startlevel = if lookupsecure then UInt(slice(VSTCR_EL2, 6, 2)) else UInt(slice(VTCR_EL2, 6, 2));
        if largegrain then {
            grainsize = 16;
            level = 3 - startlevel;
            firstblocklevel = if Have52BitPAExt() then 1 else 2
        } else {
            if midgrain then {
                grainsize = 14;
                level = 3 - startlevel;
                firstblocklevel = 2
            } else {
                grainsize = 12;
                if HaveSmallPageTblExt() & startlevel == 3 then {
                    level = startlevel
                } else {
                    level = 2 - startlevel
                };
                firstblocklevel = 1
            }
        };
        stride = grainsize - 3;
        if largegrain then {
            if level == 0 | level == 1 & PAMax() <= 42 then {
                basefound = false
            }
        } else {
            if midgrain then {
                if level == 0 | level == 1 & PAMax() <= 40 then {
                    basefound = false
                }
            } else {
                if level < 0 | level == 0 & PAMax() <= 42 then {
                    basefound = false
                }
            }
        };
        inputsizecheck = inputsize;
        if inputsize > PAMax() & (~(ELUsingAArch32(EL1)) | inputsize > 40) then {
            match ConstrainUnpredictable(Unpredictable_LARGEIPA) {
              Constraint_FORCE => {
                  inputsize = PAMax();
                  inputsizecheck = PAMax()
              },
              Constraint_FORCENOSLCHECK => {
                  inputsize = PAMax()
              },
              Constraint_FAULT => {
                  basefound = false
              },
              _ => {
                  Unreachable()
              }
            }
        };
        startsizecheck = inputsizecheck - ((3 - level) * stride + grainsize);
        if startsizecheck < 1 | startsizecheck > stride + 4 then {
            basefound = false
        }
    };
    if ~(basefound) | disabled then {
        level = 0;
        __tc2 : AddressDescriptor = result.addrdesc;
        __tc2.fault = AArch64_TranslationFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc2;
        return(result)
    };
    outputsize : int = undefined : int;
    match ps {
      0b000 => {
          outputsize = 32
      },
      0b001 => {
          outputsize = 36
      },
      0b010 => {
          outputsize = 40
      },
      0b011 => {
          outputsize = 42
      },
      0b100 => {
          outputsize = 44
      },
      0b101 => {
          outputsize = 48
      },
      0b110 => {
          outputsize = if Have52BitPAExt() & largegrain then 52 else 48
      },
      _ => {
          outputsize = __IMPDEF_integer("Reserved Intermediate Physical Address size value")
      }
    };
    if outputsize > PAMax() then {
        outputsize = PAMax()
    };
    if outputsize < 48 & ~(IsZero_slice(baseregister, outputsize, negate(outputsize) + 48)) then {
        level = 0;
        __tc3 : AddressDescriptor = result.addrdesc;
        __tc3.fault = AArch64_AddressSizeFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc3;
        return(result)
    };
    let baselowerbound : int = 3 + inputsize - ((3 - level) * stride + grainsize);
    baseaddress : bits(52) = undefined : bits(52);
    if outputsize == 52 then {
        let 'z : int = if baselowerbound < 6 then 6 else baselowerbound;
        assert(constraint(- 'z + 48 >= 0));
        baseaddress = (slice(baseregister, 2, 4) @ slice(baseregister, z, negate(z) + 48)) @ Zeros(z)
    } else {
        baseaddress = ZeroExtend_slice_append(baseregister, baselowerbound, negate(baselowerbound) + 48, Zeros(baselowerbound))
    };
    ns_table : bits(1) = undefined : bits(1);
    ns_table = if lookupsecure then 0b0 else 0b1;
    ap_table : bits(2) = undefined : bits(2);
    ap_table = 0b00;
    xn_table : bits(1) = undefined : bits(1);
    xn_table = 0b0;
    pxn_table : bits(1) = undefined : bits(1);
    pxn_table = 0b0;
    addrselecttop : int = undefined : int;
    addrselecttop = inputsize - 1;
    let apply_nvnv1_effect : bool = (((HaveNVExt() & EL2Enabled()) & (HCR_EL2[42 .. 42] @ HCR_EL2[43 .. 43]) == 0b11) & S1TranslationRegime() == EL1) & ~(secondstage);
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    addrselectbottom : int = undefined : int;
    blocktranslate : bool = undefined : bool;
    desc : bits(64) = undefined : bits(64);
    descaddr2 : AddressDescriptor = undefined : AddressDescriptor;
    hwupdatewalk : bool = undefined : bool;
    repeat {
        addrselectbottom = (3 - level) * stride + grainsize;
        let index : bits(52) = ZeroExtend_slice_append(inputaddr, addrselectbottom, addrselecttop - addrselectbottom + 1, 0b000);
        __tc4 : FullAddress = descaddr.paddress;
        __tc4.address = baseaddress | index;
        descaddr.paddress = __tc4;
        __tc5 : FullAddress = descaddr.paddress;
        __tc5.NS = ns_table;
        descaddr.paddress = __tc5;
        if (secondstage | ~(HasS2Translation())) | HaveNV2Ext() & acctype == AccType_NV2REGISTER then {
            descaddr2 = descaddr
        } else {
            hwupdatewalk = false;
            descaddr2 = AArch64_SecondStageWalk(descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            if IsFault(descaddr2) then {
                __tc6 : AddressDescriptor = result.addrdesc;
                __tc6.fault = descaddr2.fault;
                result.addrdesc = __tc6;
                return(result)
            }
        };
        descaddr2.vaddress = ZeroExtend(vaddress);
        accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
        desc = aget__Mem(descaddr2, 8, accdesc);
        if reversedescriptors then {
            desc = BigEndianReverse(desc)
        };
        if [desc[0]] == 0b0 | slice(desc, 0, 2) == 0b01 & (level == 3 | (HaveBlockBBM() & IsBlockDescriptorNTBitValid()) & [desc[16]] == 0b1) then {
            __tc7 : AddressDescriptor = result.addrdesc;
            __tc7.fault = AArch64_TranslationFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
            result.addrdesc = __tc7;
            return(result)
        };
        if slice(desc, 0, 2) == 0b01 | level == 3 then {
            blocktranslate = true
        } else {
            if (outputsize < 52 & largegrain) & ~(IsZero_slice(desc, 12, 4)) | outputsize < 48 & ~(IsZero_slice(desc, outputsize, negate(outputsize) + 48)) then {
                __tc8 : AddressDescriptor = result.addrdesc;
                __tc8.fault = AArch64_AddressSizeFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
                result.addrdesc = __tc8;
                return(result)
            };
            if outputsize == 52 then {
                let 'g = grainsize;
                assert(constraint(- 'g + 48 >= 0));
                baseaddress = (slice(desc, 12, 4) @ slice(desc, g, negate(g) + 48)) @ Zeros(g)
            } else {
                baseaddress = ZeroExtend_slice_append(desc, grainsize, negate(grainsize) + 48, Zeros(grainsize))
            };
            if ~(secondstage) then {
                ns_table = ns_table | [desc[63]]
            };
            if ~(secondstage) & ~(hierattrsdisabled) then {
                ap_table = __SetSlice_bits(2, 1, ap_table, 1, [ap_table[1]] | [desc[62]]);
                if apply_nvnv1_effect then {
                    pxn_table = pxn_table | [desc[60]]
                } else {
                    xn_table = xn_table | [desc[60]]
                };
                if ~(singlepriv) then {
                    if ~(apply_nvnv1_effect) then {
                        pxn_table = pxn_table | [desc[59]];
                        ap_table = __SetSlice_bits(2, 1, ap_table, 0, [ap_table[0]] | [desc[61]])
                    }
                }
            };
            level = level + 1;
            addrselecttop = addrselectbottom - 1;
            blocktranslate = false
        }
    } until blocktranslate;
    if level < firstblocklevel then {
        __tc9 : AddressDescriptor = result.addrdesc;
        __tc9.fault = AArch64_TranslationFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc9;
        return(result)
    };
    contiguousbitcheck : bool = undefined : bool;
    if largegrain then {
        contiguousbitcheck = level == 2 & inputsize < 34
    } else {
        if midgrain then {
            contiguousbitcheck = level == 2 & inputsize < 30
        } else {
            contiguousbitcheck = level == 1 & inputsize < 34
        }
    };
    if contiguousbitcheck & [desc[52]] == 0b1 then {
        if __IMPDEF_boolean("Translation fault on misprogrammed contiguous bit") then {
            __tc10 : AddressDescriptor = result.addrdesc;
            __tc10.fault = AArch64_TranslationFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
            result.addrdesc = __tc10;
            return(result)
        }
    };
    if (outputsize < 52 & largegrain) & ~(IsZero_slice(desc, 12, 4)) | outputsize < 48 & ~(IsZero_slice(desc, outputsize, negate(outputsize) + 48)) then {
        __tc11 : AddressDescriptor = result.addrdesc;
        __tc11.fault = AArch64_AddressSizeFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc11;
        return(result)
    };
    outputaddress : bits(52) = undefined : bits(52);
    if outputsize == 52 then {
        let 'asb = addrselectbottom;
        assert(constraint((- 'asb + 48 >= 0 & 'asb >= 0)));
        outputaddress = (slice(desc, 12, 4) @ slice(desc, asb, negate(asb) + 48)) @ slice(inputaddr, 0, asb)
    } else {
        let 'asb = addrselectbottom;
        assert(constraint((- 'asb + 48 >= 0 & 'asb >= 0)));
        outputaddress = ZeroExtend_slice_append(desc, asb, negate(asb) + 48, slice(inputaddr, 0, asb))
    };
    if [desc[10]] == 0b0 then {
        if ~(update_AF) then {
            __tc12 : AddressDescriptor = result.addrdesc;
            __tc12.fault = AArch64_AccessFlagFault(ipaddress, s1_nonsecure, level, acctype, iswrite, secondstage, s2fs1walk);
            result.addrdesc = __tc12;
            return(result)
        } else {
            __tc13 : DescriptorUpdate = result.descupdate;
            __tc13.AF = true;
            result.descupdate = __tc13
        }
    };
    if update_AP & [desc[51]] == 0b1 then {
        if ~(secondstage) & [desc[7]] == 0b1 then {
            desc = __SetSlice_bits(64, 1, desc, 7, 0b0);
            __tc14 : DescriptorUpdate = result.descupdate;
            __tc14.AP = true;
            result.descupdate = __tc14
        } else {
            if secondstage & [desc[7]] == 0b0 then {
                desc = __SetSlice_bits(64, 1, desc, 7, 0b1);
                __tc15 : DescriptorUpdate = result.descupdate;
                __tc15.AP = true;
                result.descupdate = __tc15
            }
        }
    };
    __tc16 : DescriptorUpdate = result.descupdate;
    __tc16.descaddr = descaddr;
    result.descupdate = __tc16;
    ap : bits(3) = undefined : bits(3);
    pxn : bits(1) = undefined : bits(1);
    xn : bits(1) = undefined : bits(1);
    if apply_nvnv1_effect then {
        pxn = [desc[54]];
        xn = 0b0;
        ap = [desc[7]] @ 0b01
    } else {
        xn = [desc[54]];
        pxn = [desc[53]];
        ap = slice(desc, 6, 2) @ 0b1
    };
    let contiguousbit : bits(1) = [desc[52]];
    let nG : bits(1) = [desc[11]];
    let sh : bits(2) = slice(desc, 8, 2);
    let memattr : bits(4) = slice(desc, 2, 4);
    result.domain = undefined : bits(4);
    result.level = level;
    result.blocksize = 2 ^ ((3 - level) * stride + grainsize);
    if ~(secondstage) then {
        __tc17 : Permissions = result.perms;
        __tc17.xn = xn | xn_table;
        result.perms = __tc17;
        __tc18 : bits(3) = result.perms.ap;
        __tc18 = __SetSlice_bits(3, 1, __tc18, 2, [ap[2]] | [ap_table[1]]);
        __tc19 : Permissions = result.perms;
        __tc19.ap = __tc18;
        result.perms = __tc19;
        if ~(singlepriv) then {
            __tc20 : bits(3) = result.perms.ap;
            __tc20 = __SetSlice_bits(3, 1, __tc20, 1, [ap[1]] & ~([ap_table[0]]));
            __tc21 : Permissions = result.perms;
            __tc21.ap = __tc20;
            result.perms = __tc21;
            __tc22 : Permissions = result.perms;
            __tc22.pxn = pxn | pxn_table;
            result.perms = __tc22;
            if IsSecure() then {
                result.nG = nG | ns_table
            } else {
                result.nG = nG
            }
        } else {
            __tc23 : bits(3) = result.perms.ap;
            __tc23 = __SetSlice_bits(3, 1, __tc23, 1, 0b1);
            __tc24 : Permissions = result.perms;
            __tc24.ap = __tc23;
            result.perms = __tc24;
            __tc25 : Permissions = result.perms;
            __tc25.pxn = 0b0;
            result.perms = __tc25;
            result.nG = 0b0
        };
        result.GP = [desc[50]];
        __tc26 : bits(3) = result.perms.ap;
        __tc26 = __SetSlice_bits(3, 1, __tc26, 0, 0b1);
        __tc27 : Permissions = result.perms;
        __tc27.ap = __tc26;
        result.perms = __tc27;
        __tc28 : AddressDescriptor = result.addrdesc;
        __tc28.memattrs = AArch64_S1AttrDecode(sh, slice(memattr, 0, 3), acctype);
        result.addrdesc = __tc28;
        __tc29 : FullAddress = result.addrdesc.paddress;
        __tc29.NS = [memattr[3]] | ns_table;
        __tc30 : AddressDescriptor = result.addrdesc;
        __tc30.paddress = __tc29;
        result.addrdesc = __tc30
    } else {
        __tc31 : bits(3) = result.perms.ap;
        __tc31 = __SetSlice_bits(3, 2, __tc31, 1, slice(ap, 1, 2));
        __tc32 : Permissions = result.perms;
        __tc32.ap = __tc31;
        result.perms = __tc32;
        __tc33 : bits(3) = result.perms.ap;
        __tc33 = __SetSlice_bits(3, 1, __tc33, 0, 0b1);
        __tc34 : Permissions = result.perms;
        __tc34.ap = __tc33;
        result.perms = __tc34;
        __tc35 : Permissions = result.perms;
        __tc35.xn = xn;
        result.perms = __tc35;
        if HaveExtendedExecuteNeverExt() then {
            __tc36 : Permissions = result.perms;
            __tc36.xxn = [desc[53]];
            result.perms = __tc36
        };
        __tc37 : Permissions = result.perms;
        __tc37.pxn = 0b0;
        result.perms = __tc37;
        result.nG = 0b0;
        if s2fs1walk then {
            __tc38 : AddressDescriptor = result.addrdesc;
            __tc38.memattrs = S2AttrDecode(sh, memattr, AccType_PTW);
            result.addrdesc = __tc38
        } else {
            __tc39 : AddressDescriptor = result.addrdesc;
            __tc39.memattrs = S2AttrDecode(sh, memattr, acctype);
            result.addrdesc = __tc39
        };
        __tc40 : FullAddress = result.addrdesc.paddress;
        __tc40.NS = nsaccess;
        __tc41 : AddressDescriptor = result.addrdesc;
        __tc41.paddress = __tc40;
        result.addrdesc = __tc41
    };
    __tc42 : FullAddress = result.addrdesc.paddress;
    __tc42.address = outputaddress;
    __tc43 : AddressDescriptor = result.addrdesc;
    __tc43.paddress = __tc42;
    result.addrdesc = __tc43;
    __tc44 : AddressDescriptor = result.addrdesc;
    __tc44.fault = AArch64_NoFault();
    result.addrdesc = __tc44;
    result.contiguous = contiguousbit == 0b1;
    if HaveCommonNotPrivateTransExt() then {
        result.CnP = [baseregister[0]]
    };
    if __tlb_enabled then {
        TLBCache(ZeroExtend(inputaddr, 64), secondstage, s1_nonsecure, acctype, result)
    };
    result
}

function AArch64_CheckAndUpdateDescriptor (result, fault, secondstage, vaddress, acctype, iswrite, s2fs1walk, hwupdatewalk__arg) = {
    hwupdatewalk : bool = hwupdatewalk__arg;
    hw_update_AF : bool = undefined : bool;
    if result.AF then {
        if fault.typ == Fault_None then {
            hw_update_AF = true
        } else {
            if ConstrainUnpredictable(Unpredictable_AFUPDATE) == Constraint_TRUE then {
                hw_update_AF = true
            } else {
                hw_update_AF = false
            }
        }
    };
    hw_update_AP : bool = undefined : bool;
    write_perm_req : bool = undefined : bool;
    if result.AP & fault.typ == Fault_None then {
        write_perm_req = (iswrite | acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW) & ~(s2fs1walk);
        hw_update_AP = write_perm_req & ~(acctype == AccType_AT | acctype == AccType_DC | acctype == AccType_DC_UNPRIV) | hwupdatewalk
    } else {
        hw_update_AP = false
    };
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    desc : bits(64) = undefined : bits(64);
    descaddr2 : AddressDescriptor = undefined : AddressDescriptor;
    el : bits(2) = undefined : bits(2);
    reversedescriptors : bool = undefined : bool;
    if hw_update_AF | hw_update_AP then {
        if secondstage | ~(HasS2Translation()) then {
            descaddr2 = result.descaddr
        } else {
            hwupdatewalk = true;
            descaddr2 = AArch64_SecondStageWalk(result.descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            if IsFault(descaddr2) then {
                return(descaddr2.fault)
            }
        };
        accdesc = CreateAccessDescriptor(AccType_ATOMICRW);
        desc = _Mem(descaddr2, 8, accdesc);
        el = AArch64_AccessUsesEL(acctype);
        match el {
          ? if ? == EL3 => {
              reversedescriptors = [SCTLR_EL3[25]] == 0b1
          },
          ? if ? == EL2 => {
              reversedescriptors = [SCTLR_EL2[25]] == 0b1
          },
          _ => {
              reversedescriptors = [SCTLR_EL1[25]] == 0b1
          }
        };
        if reversedescriptors then {
            desc = BigEndianReverse(desc)
        };
        if hw_update_AF then {
            desc = __SetSlice_bits(64, 1, desc, 10, 0b1)
        };
        if hw_update_AP then {
            desc = __SetSlice_bits(64, 1, desc, 7, if secondstage then 0b1 else 0b0)
        };
        _Mem(descaddr2, 8, accdesc) = if reversedescriptors then BigEndianReverse(desc) else desc
    };
    fault
}

val AArch32_TranslationTableWalkSD : forall ('size : Int).
  (bits(32), AccType, bool, int('size)) -> TLBRecord effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_TranslationTableWalkSD (vaddress, acctype, iswrite, size) = {
    assert(ELUsingAArch32(S1TranslationRegime()));
    if __tlb_enabled then {
        let cacheline : TLBLine = TLBLookup(ZeroExtend(vaddress, 64), false, 0b1, acctype);
        if cacheline.valid_name then {
            return(cacheline.data)
        }
    };
    result : TLBRecord = undefined : TLBRecord;
    l1descaddr : AddressDescriptor = undefined : AddressDescriptor;
    l2descaddr : AddressDescriptor = undefined : AddressDescriptor;
    outputaddress : bits(40) = undefined : bits(40);
    let ipaddress : bits(40) = undefined : bits(40);
    let secondstage : bool = false;
    let s2fs1walk : bool = false;
    NS : bits(1) = undefined : bits(1);
    NS = undefined : bits(1);
    domain : bits(4) = undefined : bits(4);
    domain = undefined : bits(4);
    ttbr : bits(64) = undefined : bits(64);
    n : int = undefined : int;
    n = UInt(slice(get_TTBCR(), 0, 3));
    disabled : bool = undefined : bool;
    if n == 0 | IsZero_slice(vaddress, 32 - n, n) then {
        ttbr = get_TTBR0();
        disabled = [get_TTBCR()[4]] == 0b1
    } else {
        ttbr = get_TTBR1();
        disabled = [get_TTBCR()[5]] == 0b1;
        n = 0
    };
    level : int = undefined : int;
    if disabled then {
        level = 1;
        __tc1 : AddressDescriptor = result.addrdesc;
        __tc1.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc1;
        return(result)
    };
    __tc2 : FullAddress = l1descaddr.paddress;
    __tc2.address = {
        let 'n = n;
        assert(constraint(('n + 18 >= 0 & - 'n + 12 >= 0)));
        ZeroExtend((slice(ttbr, 14 - n, n + 18) @ slice(vaddress, 20, negate(n) + 12)) @ 0b00)
    };
    l1descaddr.paddress = __tc2;
    __tc3 : FullAddress = l1descaddr.paddress;
    __tc3.NS = if IsSecure() then 0b0 else 0b1;
    l1descaddr.paddress = __tc3;
    let IRGN : bits(2) = [ttbr[0]] @ [ttbr[6]];
    let RGN : bits(2) = slice(ttbr, 3, 2);
    let SH : bits(2) = [ttbr[1]] @ [ttbr[5]];
    l1descaddr.memattrs = WalkAttrDecode(SH, RGN, IRGN, secondstage);
    l1descaddr2 : AddressDescriptor = undefined : AddressDescriptor;
    if ~(HaveEL(EL2)) | IsSecure() & ~(IsSecureEL2Enabled()) then {
        l1descaddr2 = l1descaddr
    } else {
        l1descaddr2 = AArch32_SecondStageWalk(l1descaddr, vaddress, acctype, iswrite, 4);
        if IsFault(l1descaddr2) then {
            __tc4 : AddressDescriptor = result.addrdesc;
            __tc4.fault = l1descaddr2.fault;
            result.addrdesc = __tc4;
            return(result)
        }
    };
    l1descaddr2.vaddress = ZeroExtend(vaddress);
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
    l1desc : bits(32) = undefined : bits(32);
    l1desc = aget__Mem(l1descaddr2, 4, accdesc);
    if [get_SCTLR()[25]] == 0b1 then {
        l1desc = BigEndianReverse(l1desc)
    };
    S : bits(1) = undefined : bits(1);
    ap : bits(3) = undefined : bits(3);
    b : bits(1) = undefined : bits(1);
    blocksize : int = undefined : int;
    c : bits(1) = undefined : bits(1);
    l2desc : bits(32) = undefined : bits(32);
    l2descaddr2 : AddressDescriptor = undefined : AddressDescriptor;
    nG : bits(1) = undefined : bits(1);
    pxn : bits(1) = undefined : bits(1);
    tex : bits(3) = undefined : bits(3);
    xn : bits(1) = undefined : bits(1);
    match slice(l1desc, 0, 2) {
      0b00 => {
          level = 1;
          __tc5 : AddressDescriptor = result.addrdesc;
          __tc5.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
          result.addrdesc = __tc5;
          return(result)
      },
      0b01 => {
          domain = slice(l1desc, 5, 4);
          level = 2;
          pxn = [l1desc[2]];
          NS = [l1desc[3]];
          __tc6 : FullAddress = l2descaddr.paddress;
          __tc6.address = ZeroExtend((slice(l1desc, 10, 22) @ slice(vaddress, 12, 8)) @ 0b00);
          l2descaddr.paddress = __tc6;
          __tc7 : FullAddress = l2descaddr.paddress;
          __tc7.NS = if IsSecure() then 0b0 else 0b1;
          l2descaddr.paddress = __tc7;
          l2descaddr.memattrs = l1descaddr.memattrs;
          if ~(HaveEL(EL2)) | IsSecure() & ~(IsSecureEL2Enabled()) then {
              l2descaddr2 = l2descaddr
          } else {
              l2descaddr2 = AArch32_SecondStageWalk(l2descaddr, vaddress, acctype, iswrite, 4);
              if IsFault(l2descaddr2) then {
                  __tc8 : AddressDescriptor = result.addrdesc;
                  __tc8.fault = l2descaddr2.fault;
                  result.addrdesc = __tc8;
                  return(result)
              }
          };
          l2descaddr2.vaddress = ZeroExtend(vaddress);
          accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
          l2desc = aget__Mem(l2descaddr2, 4, accdesc);
          if [get_SCTLR()[25]] == 0b1 then {
              l2desc = BigEndianReverse(l2desc)
          };
          if slice(l2desc, 0, 2) == 0b00 then {
              __tc9 : AddressDescriptor = result.addrdesc;
              __tc9.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
              result.addrdesc = __tc9;
              return(result)
          };
          nG = [l2desc[11]];
          S = [l2desc[10]];
          ap = l2desc[9 .. 9] @ l2desc[4 .. 3];
          if [get_SCTLR()[29]] == 0b1 & [l2desc[4]] == 0b0 then {
              __tc10 : AddressDescriptor = result.addrdesc;
              __tc10.fault = AArch32_AccessFlagFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
              result.addrdesc = __tc10;
              return(result)
          };
          if [l2desc[1]] == 0b0 then {
              xn = [l2desc[15]];
              tex = slice(l2desc, 12, 3);
              c = [l2desc[3]];
              b = [l2desc[2]];
              blocksize = 64;
              outputaddress = ZeroExtend(slice(l2desc, 16, 16) @ slice(vaddress, 0, 16))
          } else {
              tex = slice(l2desc, 6, 3);
              c = [l2desc[3]];
              b = [l2desc[2]];
              xn = [l2desc[0]];
              blocksize = 4;
              outputaddress = ZeroExtend(slice(l2desc, 12, 20) @ slice(vaddress, 0, 12))
          }
      },
      [bitone] @ _ : bits(1) => {
          NS = [l1desc[19]];
          nG = [l1desc[17]];
          S = [l1desc[16]];
          ap = l1desc[15 .. 15] @ l1desc[10 .. 9];
          tex = slice(l1desc, 12, 3);
          xn = [l1desc[4]];
          c = [l1desc[3]];
          b = [l1desc[2]];
          pxn = [l1desc[0]];
          level = 1;
          if [get_SCTLR()[29]] == 0b1 & [l1desc[10]] == 0b0 then {
              __tc11 : AddressDescriptor = result.addrdesc;
              __tc11.fault = AArch32_AccessFlagFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
              result.addrdesc = __tc11;
              return(result)
          };
          if [l1desc[18]] == 0b0 then {
              domain = slice(l1desc, 5, 4);
              blocksize = 1024;
              outputaddress = ZeroExtend(slice(l1desc, 20, 12) @ slice(vaddress, 0, 20))
          } else {
              domain = 0x0;
              blocksize = 16384;
              outputaddress = ((slice(l1desc, 5, 4) @ slice(l1desc, 20, 4)) @ slice(l1desc, 24, 8)) @ slice(vaddress, 0, 24)
          }
      }
    };
    if [get_SCTLR()[28]] == 0b0 then {
        if RemapRegsHaveResetValues() then {
            __tc12 : AddressDescriptor = result.addrdesc;
            __tc12.memattrs = AArch32_DefaultTEXDecode(tex, c, b, S, acctype);
            result.addrdesc = __tc12
        } else {
            __tc13 : AddressDescriptor = result.addrdesc;
            __tc13.memattrs = undefined;
            result.addrdesc = __tc13
        }
    } else {
        __tc14 : AddressDescriptor = result.addrdesc;
        __tc14.memattrs = AArch32_RemappedTEXDecode(tex, c, b, S, acctype);
        result.addrdesc = __tc14
    };
    __tc15 : Permissions = result.perms;
    __tc15.ap = ap;
    result.perms = __tc15;
    __tc16 : Permissions = result.perms;
    __tc16.xn = xn;
    result.perms = __tc16;
    __tc17 : Permissions = result.perms;
    __tc17.pxn = pxn;
    result.perms = __tc17;
    result.nG = nG;
    result.domain = domain;
    result.level = level;
    result.blocksize = blocksize;
    __tc18 : FullAddress = result.addrdesc.paddress;
    __tc18.address = ZeroExtend(outputaddress);
    __tc19 : AddressDescriptor = result.addrdesc;
    __tc19.paddress = __tc18;
    result.addrdesc = __tc19;
    __tc20 : FullAddress = result.addrdesc.paddress;
    __tc20.NS = if IsSecure() then NS else 0b1;
    __tc21 : AddressDescriptor = result.addrdesc;
    __tc21.paddress = __tc20;
    result.addrdesc = __tc21;
    __tc22 : AddressDescriptor = result.addrdesc;
    __tc22.fault = AArch32_NoFault();
    result.addrdesc = __tc22;
    if __tlb_enabled then {
        TLBCache(ZeroExtend(vaddress, 64), false, 0b1, acctype, result)
    };
    result
}

val AArch32_FirstStageTranslate : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(32), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_FirstStageTranslate (vaddress, acctype, iswrite, wasaligned, size) = {
    dc : bits(1) = undefined : bits(1);
    s1_enabled : bool = undefined : bool;
    tge : bits(1) = undefined : bits(1);
    if PSTATE.EL == EL2 then {
        s1_enabled = [get_HSCTLR()[0]] == 0b1
    } else {
        if EL2Enabled() then {
            tge = if ELUsingAArch32(EL2) then [get_HCR()[27]] else [HCR_EL2[27]];
            dc = if ELUsingAArch32(EL2) then [get_HCR()[12]] else [HCR_EL2[12]];
            s1_enabled = (tge == 0b0 & dc == 0b0) & [get_SCTLR()[0]] == 0b1
        } else {
            s1_enabled = [get_SCTLR()[0]] == 0b1
        }
    };
    let ipaddress : vector(40, dec, bit) = undefined : bits(40);
    let secondstage : bool(false) = false;
    let s2fs1walk : bool(false) = false;
    S1 : TLBRecord = undefined : TLBRecord;
    domaincheck : bool = undefined : bool;
    nTLSMD : bits(1) = undefined : bits(1);
    permissioncheck : bool = undefined : bool;
    use_long_descriptor_format : bool = undefined : bool;
    if s1_enabled then {
        use_long_descriptor_format = PSTATE.EL == EL2 | [get_TTBCR()[31]] == 0b1;
        if use_long_descriptor_format then {
            S1 = AArch32_TranslationTableWalk(ipaddress, vaddress, acctype, iswrite, secondstage, s2fs1walk, size);
            permissioncheck = true;
            domaincheck = false
        } else {
            S1 = AArch32_TranslationTableWalkSD(vaddress, acctype, iswrite, size);
            permissioncheck = true;
            domaincheck = true
        }
    } else {
        S1 = AArch32_TranslateAddressS1Off(vaddress, acctype, iswrite);
        permissioncheck = false;
        domaincheck = false;
        if (UsingAArch32() & HaveTrapLoadStoreMultipleDeviceExt()) & AArch32_ExecutingLSMInstr() then {
            if S1.addrdesc.memattrs.typ == MemType_Device & S1.addrdesc.memattrs.device != DeviceType_GRE then {
                nTLSMD = if S1TranslationRegime() == EL2 then [get_HSCTLR()[3]] else [get_SCTLR()[3]];
                if nTLSMD == 0b0 then {
                    __tc1 : AddressDescriptor = S1.addrdesc;
                    __tc1.fault = AArch32_AlignmentFault(acctype, iswrite, secondstage);
                    S1.addrdesc = __tc1
                }
            }
        }
    };
    if ((~(wasaligned) & acctype != AccType_IFETCH | acctype == AccType_DCZVA) & S1.addrdesc.memattrs.typ == MemType_Device) & ~(IsFault(S1.addrdesc)) then {
        __tc2 : AddressDescriptor = S1.addrdesc;
        __tc2.fault = AArch32_AlignmentFault(acctype, iswrite, secondstage);
        S1.addrdesc = __tc2
    };
    abort : FaultRecord = undefined : FaultRecord;
    if ~(IsFault(S1.addrdesc)) & domaincheck then {
        (permissioncheck, abort) = AArch32_CheckDomain(S1.domain, vaddress, S1.level, acctype, iswrite);
        __tc3 : AddressDescriptor = S1.addrdesc;
        __tc3.fault = abort;
        S1.addrdesc = __tc3
    };
    if ~(IsFault(S1.addrdesc)) & permissioncheck then {
        __tc4 : AddressDescriptor = S1.addrdesc;
        __tc4.fault = AArch32_CheckPermission(S1.perms, vaddress, S1.level, S1.domain, S1.addrdesc.paddress.NS, acctype, iswrite);
        S1.addrdesc = __tc4
    };
    if (~(IsFault(S1.addrdesc)) & S1.addrdesc.memattrs.typ == MemType_Device) & acctype == AccType_IFETCH then {
        S1.addrdesc = AArch32_InstructionDevice(S1.addrdesc, vaddress, ipaddress, S1.level, S1.domain, acctype, iswrite, secondstage, s2fs1walk)
    };
    S1.addrdesc
}

val AArch64_AT_S1Ex : forall ('iswrite : Bool).
  (bits(64), bits(2), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AT_S1Ex (val_name, el, iswrite) = {
    __SAVE_EL(el);
    addrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if el == EL0 & ELUsingAArch32(EL1) | el != EL0 & ELUsingAArch32(el) then {
        addrdesc = AArch32_FirstStageTranslate(slice(val_name, 0, 32), AccType_AT, iswrite, true, 1)
    } else {
        addrdesc = AArch64_FirstStageTranslate(val_name, AccType_AT, iswrite, true, 1)
    };
    __RESTORE_EL();
    if IsFault(addrdesc) then {
        if IsExternalAbort(addrdesc.fault) | (PSTATE.EL == EL1 & EL2Enabled()) & addrdesc.fault.s2fs1walk then {
            PAR_EL1 = undefined : bits(64);
            AArch64_Abort(val_name, addrdesc.fault)
        }
    };
    AArch64_EncodePAR(addrdesc)
}

val AT_S1E3W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E3W val_name = {
    AArch64_AT_S1Ex(val_name, EL3, true)
}

val AT_S1E3R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E3R val_name = {
    AArch64_AT_S1Ex(val_name, EL3, false)
}

val AT_S1E2W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E2W val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        AArch64_AT_S1Ex(val_name, EL2, true)
    } else {
        UndefinedFault()
    }
}

val AT_S1E2R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E2R val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        AArch64_AT_S1Ex(val_name, EL2, false)
    } else {
        UndefinedFault()
    }
}

val AT_S1E1WP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1WP val_name = {
    AArch64_AT_S1Ex(val_name, EL1, true)
}

val AT_S1E1W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1W val_name = {
    AArch64_AT_S1Ex(val_name, EL1, true)
}

val AT_S1E1RP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1RP val_name = {
    AArch64_AT_S1Ex(val_name, EL1, false)
}

val AT_S1E1R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1R val_name = {
    AArch64_AT_S1Ex(val_name, EL1, false)
}

val AT_S1E0W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E0W val_name = {
    AArch64_AT_S1Ex(val_name, EL0, true)
}

val AT_S1E0R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E0R val_name = {
    AArch64_AT_S1Ex(val_name, EL0, false)
}

val AArch32_FullTranslate : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(32), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_FullTranslate (vaddress, acctype, iswrite, wasaligned, size) = {
    let S1 : AddressDescriptor = AArch32_FirstStageTranslate(vaddress, acctype, iswrite, wasaligned, size);
    result : AddressDescriptor = undefined : AddressDescriptor;
    s2fs1walk : bool = undefined : bool;
    if (~(IsFault(S1)) & ~(HaveNV2Ext() & acctype == AccType_NV2REGISTER)) & HasS2Translation() then {
        s2fs1walk = false;
        result = AArch32_SecondStageTranslate(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size)
    } else {
        result = S1
    };
    result
}

val AArch64_AT_S12Ex : forall ('iswrite : Bool).
  (bits(64), bits(2), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AT_S12Ex (val_name, el, iswrite) = {
    has_s2_translation : bool = undefined : bool;
    if HaveEL(EL3) then {
        has_s2_translation = HaveEL(EL2) & ([SCR_EL3[0]] == 0b1 | [SCR_EL3[18]] == 0b1)
    } else {
        has_s2_translation = HaveEL(EL2)
    };
    let has_s2_enabled : bool = has_s2_translation & ([HCR_EL2[0]] == 0b1 | [HCR_EL2[12]] == 0b1);
    if ~(has_s2_enabled) then {
        AArch64_AT_S1Ex(val_name, el, iswrite);
        return()
    };
    __SAVE_EL(el);
    addrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ELUsingAArch32(EL1) then {
        addrdesc = AArch32_FullTranslate(slice(val_name, 0, 32), AccType_AT, iswrite, true, 1)
    } else {
        addrdesc = AArch64_FullTranslate(val_name, AccType_AT, iswrite, true, 1)
    };
    __RESTORE_EL();
    if IsFault(addrdesc) then {
        if IsExternalAbort(addrdesc.fault) | (PSTATE.EL == EL1 & EL2Enabled()) & addrdesc.fault.s2fs1walk then {
            PAR_EL1 = undefined : bits(64);
            AArch64_Abort(val_name, addrdesc.fault)
        }
    };
    AArch64_EncodePAR(addrdesc)
}

val AT_S12E1W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E1W val_name = {
    AArch64_AT_S12Ex(val_name, EL1, true)
}

val AT_S12E1R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E1R val_name = {
    AArch64_AT_S12Ex(val_name, EL1, false)
}

val AT_S12E0W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E0W val_name = {
    AArch64_AT_S12Ex(val_name, EL0, true)
}

val AT_S12E0R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E0R val_name = {
    AArch64_AT_S12Ex(val_name, EL0, false)
}

val AArch32_TranslateAddress : forall ('iswrite : Bool) ('wasaligned : Bool) 'size.
  (bits(32), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_TranslateAddress (vaddress, acctype, iswrite, wasaligned, size) = {
    if ~(ELUsingAArch32(S1TranslationRegime())) then {
        return(AArch64_TranslateAddress(ZeroExtend(vaddress, 64), acctype, iswrite, wasaligned, size))
    };
    result : AddressDescriptor = undefined : AddressDescriptor;
    result = AArch32_FullTranslate(vaddress, acctype, iswrite, wasaligned, size);
    if ~(acctype == AccType_PTW | acctype == AccType_IC | acctype == AccType_AT) & ~(IsFault(result)) then {
        result.fault = AArch32_CheckDebug(vaddress, acctype, iswrite, size)
    };
    result.vaddress = ZeroExtend(vaddress);
    result
}

val check_access : forall ('iswrite : Bool) ('a64nb : Int).
  (bits(64), bool('iswrite), int('a64nb)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function check_access (val_name, iswrite, a64nb) = {
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, AccType_DC, iswrite, true, a64nb);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), AccType_DC, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    }
}

val DC_IGVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_IGVAC val_name = {
    fault_at_EL0();
    check_access(val_name, true, 4);
    return()
}

val DC_CIGVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CIGVAC val_name = {
    fault_at_EL0();
    check_access(val_name, false, 8);
    return()
}

val DC_CGVAP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGVAP val_name = {
    fault_at_EL0();
    check_access(val_name, false, 4);
    return()
}

val DC_CGVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGVAC val_name = {
    fault_at_EL0();
    check_access(val_name, false, 4);
    return()
}

function AArch32_TranslationTableWalk (ipaddress, vaddress, acctype, iswrite, secondstage, s2fs1walk, size) = {
    if ~(secondstage) then {
        assert(ELUsingAArch32(S1TranslationRegime()))
    } else {
        assert(((HaveEL(EL2) & ~(IsSecure())) & ELUsingAArch32(EL2)) & HasS2Translation())
    };
    result : TLBRecord = undefined : TLBRecord;
    descaddr : AddressDescriptor = undefined : AddressDescriptor;
    baseregister : bits(64) = undefined : bits(64);
    inputaddr : bits(40) = undefined : bits(40);
    if __tlb_enabled then {
        if ~(secondstage) then {
            inputaddr = ZeroExtend(vaddress)
        } else {
            inputaddr = ZeroExtend(ipaddress)
        };
        let cacheline : TLBLine = TLBLookup(ZeroExtend(inputaddr, 64), secondstage, 0b1, acctype);
        if cacheline.valid_name then {
            return(cacheline.data)
        }
    };
    let domain : bits(4) = undefined : bits(4);
    __tc1 : MemoryAttributes = descaddr.memattrs;
    __tc1.typ = MemType_Normal;
    descaddr.memattrs = __tc1;
    let 'grainsize : {'n, 'n == 12. int('n)} = 12;
    let 'stride : {'n, 'n == 'grainsize - 3. int('n)} = grainsize - 3;
    __anon1 : Constraint = undefined : Constraint;
    basefound : bool = undefined : bool;
    disabled : bool = undefined : bool;
    el : bits(2) = undefined : bits(2);
    hierattrsdisabled : bool = undefined : bool;
    inputsize : int = undefined : int;
    level : int = undefined : int;
    lookupsecure : bool = undefined : bool;
    reversedescriptors : bool = undefined : bool;
    singlepriv : bool = undefined : bool;
    startlevel : int = undefined : int;
    startsizecheck : int = undefined : int;
    t0size : int = undefined : int;
    t1size : int = undefined : int;
    if ~(secondstage) then {
        inputaddr = ZeroExtend(vaddress);
        el = AArch32_AccessUsesEL(acctype);
        if el == EL2 then {
            inputsize = 32 - UInt(slice(get_HTCR(), 0, 3));
            basefound = inputsize == 32 | IsZero_slice(inputaddr, inputsize, negate(inputsize) + 32);
            disabled = false;
            baseregister = get_HTTBR();
            descaddr.memattrs = WalkAttrDecode(slice(get_HTCR(), 12, 2), slice(get_HTCR(), 10, 2), slice(get_HTCR(), 8, 2), secondstage);
            reversedescriptors = [get_HSCTLR()[25]] == 0b1;
            lookupsecure = false;
            singlepriv = true;
            hierattrsdisabled = AArch32_HaveHPDExt() & [get_HTCR()[24]] == 0b1
        } else {
            basefound = false;
            disabled = false;
            t0size = UInt(slice(get_TTBCR(), 0, 3));
            if t0size == 0 | IsZero_slice(inputaddr, 32 - t0size, t0size) then {
                inputsize = 32 - t0size;
                basefound = true;
                baseregister = get_TTBR0();
                descaddr.memattrs = WalkAttrDecode(slice(get_TTBCR(), 12, 2), slice(get_TTBCR(), 10, 2), slice(get_TTBCR(), 8, 2), secondstage);
                hierattrsdisabled = (AArch32_HaveHPDExt() & [get_TTBCR()[6]] == 0b1) & [get_TTBCR2()[9]] == 0b1
            };
            t1size = UInt(slice(get_TTBCR(), 16, 3));
            if t1size == 0 & ~(basefound) | t1size > 0 & IsOnes_slice(inputaddr, 32 - t1size, t1size) then {
                inputsize = 32 - t1size;
                basefound = true;
                baseregister = get_TTBR1();
                descaddr.memattrs = WalkAttrDecode(slice(get_TTBCR(), 28, 2), slice(get_TTBCR(), 26, 2), slice(get_TTBCR(), 24, 2), secondstage);
                hierattrsdisabled = (AArch32_HaveHPDExt() & [get_TTBCR()[6]] == 0b1) & [get_TTBCR2()[10]] == 0b1
            };
            reversedescriptors = [get_SCTLR()[25]] == 0b1;
            lookupsecure = IsSecure();
            singlepriv = false
        };
        level = 4 - RoundUp(Real(inputsize - grainsize) / Real(stride))
    } else {
        inputaddr = ipaddress;
        inputsize = 32 - SInt(slice(get_VTCR(), 0, 4));
        if [get_VTCR()[4]] != [slice(get_VTCR(), 0, 4)[3]] then {
            (__anon1, inputsize) = ConstrainUnpredictableInteger(32 - 7, 32 + 8, Unpredictable_RESVTCRS)
        };
        basefound = inputsize == 40 | IsZero_slice(inputaddr, inputsize, negate(inputsize) + 40);
        disabled = false;
        descaddr.memattrs = WalkAttrDecode(slice(get_VTCR(), 8, 2), slice(get_VTCR(), 10, 2), slice(get_VTCR(), 12, 2), secondstage);
        reversedescriptors = [get_HSCTLR()[25]] == 0b1;
        singlepriv = true;
        lookupsecure = false;
        baseregister = get_VTTBR();
        startlevel = UInt(slice(get_VTCR(), 6, 2));
        level = 2 - startlevel;
        if level <= 0 then {
            basefound = false
        };
        startsizecheck = inputsize - ((3 - level) * stride + grainsize);
        if startsizecheck < 1 | startsizecheck > stride + 4 then {
            basefound = false
        }
    };
    if ~(basefound) | disabled then {
        level = 1;
        __tc2 : AddressDescriptor = result.addrdesc;
        __tc2.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc2;
        return(result)
    };
    if ~(IsZero(slice(baseregister, 40, 8))) then {
        level = 0;
        __tc3 : AddressDescriptor = result.addrdesc;
        __tc3.fault = AArch32_AddressSizeFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc3;
        return(result)
    };
    let baselowerbound : int = 3 + inputsize - ((3 - level) * stride + grainsize);
    baseaddress : bits(40) = undefined : bits(40);
    baseaddress = {
        let 'baselowerbound = baselowerbound;
        assert(constraint(- 'baselowerbound + 40 >= 0));
        slice(baseregister, baselowerbound, negate(baselowerbound) + 40) @ Zeros(baselowerbound)
    };
    ns_table : bits(1) = undefined : bits(1);
    ns_table = if lookupsecure then 0b0 else 0b1;
    ap_table : bits(2) = undefined : bits(2);
    ap_table = 0b00;
    xn_table : bits(1) = undefined : bits(1);
    xn_table = 0b0;
    pxn_table : bits(1) = undefined : bits(1);
    pxn_table = 0b0;
    addrselecttop : int = undefined : int;
    addrselecttop = inputsize - 1;
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    addrselectbottom : int = undefined : int;
    blocktranslate : bool = undefined : bool;
    desc : bits(64) = undefined : bits(64);
    descaddr2 : AddressDescriptor = undefined : AddressDescriptor;
    repeat {
        addrselectbottom = (3 - level) * stride + grainsize;
        let index : bits(40) = ZeroExtend_slice_append(inputaddr, addrselectbottom, addrselecttop - addrselectbottom + 1, 0b000);
        __tc4 : FullAddress = descaddr.paddress;
        __tc4.address = ZeroExtend(baseaddress | index);
        descaddr.paddress = __tc4;
        __tc5 : FullAddress = descaddr.paddress;
        __tc5.NS = ns_table;
        descaddr.paddress = __tc5;
        if (secondstage | ~(HasS2Translation())) | HaveNV2Ext() & acctype == AccType_NV2REGISTER then {
            descaddr2 = descaddr
        } else {
            descaddr2 = AArch32_SecondStageWalk(descaddr, vaddress, acctype, iswrite, 8);
            if IsFault(descaddr2) then {
                __tc6 : AddressDescriptor = result.addrdesc;
                __tc6.fault = descaddr2.fault;
                result.addrdesc = __tc6;
                return(result)
            }
        };
        descaddr2.vaddress = ZeroExtend(vaddress);
        accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
        desc = aget__Mem(descaddr2, 8, accdesc);
        if reversedescriptors then {
            desc = BigEndianReverse(desc)
        };
        if [desc[0]] == 0b0 | slice(desc, 0, 2) == 0b01 & level == 3 then {
            __tc7 : AddressDescriptor = result.addrdesc;
            __tc7.fault = AArch32_TranslationFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
            result.addrdesc = __tc7;
            return(result)
        };
        if slice(desc, 0, 2) == 0b01 | level == 3 then {
            blocktranslate = true
        } else {
            if ~(IsZero(slice(desc, 40, 8))) then {
                __tc8 : AddressDescriptor = result.addrdesc;
                __tc8.fault = AArch32_AddressSizeFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
                result.addrdesc = __tc8;
                return(result)
            };
            baseaddress = slice(desc, grainsize, negate(grainsize) + 40) @ Zeros(grainsize);
            if ~(secondstage) then {
                ns_table = ns_table | [desc[63]]
            };
            if ~(secondstage) & ~(hierattrsdisabled) then {
                ap_table = __SetSlice_bits(2, 1, ap_table, 1, [ap_table[1]] | [desc[62]]);
                xn_table = xn_table | [desc[60]];
                if ~(singlepriv) then {
                    pxn_table = pxn_table | [desc[59]];
                    ap_table = __SetSlice_bits(2, 1, ap_table, 0, [ap_table[0]] | [desc[61]])
                }
            };
            level = level + 1;
            addrselecttop = addrselectbottom - 1;
            blocktranslate = false
        }
    } until blocktranslate;
    if ~(IsZero(slice(desc, 40, 8))) then {
        __tc9 : AddressDescriptor = result.addrdesc;
        __tc9.fault = AArch32_AddressSizeFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc9;
        return(result)
    };
    let outputaddress : bits(40) = {
        let 'addrselectbottom = addrselectbottom;
        assert(constraint((- 'addrselectbottom + 40 >= 0 & 'addrselectbottom >= 0)));
        slice(desc, addrselectbottom, negate(addrselectbottom) + 40) @ slice(inputaddr, 0, addrselectbottom)
    };
    if [desc[10]] == 0b0 then {
        __tc10 : AddressDescriptor = result.addrdesc;
        __tc10.fault = AArch32_AccessFlagFault(ipaddress, domain, level, acctype, iswrite, secondstage, s2fs1walk);
        result.addrdesc = __tc10;
        return(result)
    };
    let xn : bits(1) = [desc[54]];
    let pxn : bits(1) = [desc[53]];
    let ap : bits(3) = slice(desc, 6, 2) @ 0b1;
    let contiguousbit : bits(1) = [desc[52]];
    let nG : bits(1) = [desc[11]];
    let sh : bits(2) = slice(desc, 8, 2);
    let memattr : bits(4) = slice(desc, 2, 4);
    result.domain = undefined : bits(4);
    result.level = level;
    result.blocksize = 2 ^ ((3 - level) * stride + grainsize);
    if ~(secondstage) then {
        __tc11 : Permissions = result.perms;
        __tc11.xn = xn | xn_table;
        result.perms = __tc11;
        __tc12 : bits(3) = result.perms.ap;
        __tc12 = __SetSlice_bits(3, 1, __tc12, 2, [ap[2]] | [ap_table[1]]);
        __tc13 : Permissions = result.perms;
        __tc13.ap = __tc12;
        result.perms = __tc13;
        if ~(singlepriv) then {
            __tc14 : bits(3) = result.perms.ap;
            __tc14 = __SetSlice_bits(3, 1, __tc14, 1, [ap[1]] & ~([ap_table[0]]));
            __tc15 : Permissions = result.perms;
            __tc15.ap = __tc14;
            result.perms = __tc15;
            __tc16 : Permissions = result.perms;
            __tc16.pxn = pxn | pxn_table;
            result.perms = __tc16;
            if IsSecure() then {
                result.nG = nG | ns_table
            } else {
                result.nG = nG
            }
        } else {
            __tc17 : bits(3) = result.perms.ap;
            __tc17 = __SetSlice_bits(3, 1, __tc17, 1, 0b1);
            __tc18 : Permissions = result.perms;
            __tc18.ap = __tc17;
            result.perms = __tc18;
            __tc19 : Permissions = result.perms;
            __tc19.pxn = 0b0;
            result.perms = __tc19;
            result.nG = 0b0
        };
        result.GP = [desc[50]];
        __tc20 : bits(3) = result.perms.ap;
        __tc20 = __SetSlice_bits(3, 1, __tc20, 0, 0b1);
        __tc21 : Permissions = result.perms;
        __tc21.ap = __tc20;
        result.perms = __tc21;
        __tc22 : AddressDescriptor = result.addrdesc;
        __tc22.memattrs = AArch32_S1AttrDecode(sh, slice(memattr, 0, 3), acctype);
        result.addrdesc = __tc22;
        __tc23 : FullAddress = result.addrdesc.paddress;
        __tc23.NS = [memattr[3]] | ns_table;
        __tc24 : AddressDescriptor = result.addrdesc;
        __tc24.paddress = __tc23;
        result.addrdesc = __tc24
    } else {
        __tc25 : bits(3) = result.perms.ap;
        __tc25 = __SetSlice_bits(3, 2, __tc25, 1, slice(ap, 1, 2));
        __tc26 : Permissions = result.perms;
        __tc26.ap = __tc25;
        result.perms = __tc26;
        __tc27 : bits(3) = result.perms.ap;
        __tc27 = __SetSlice_bits(3, 1, __tc27, 0, 0b1);
        __tc28 : Permissions = result.perms;
        __tc28.ap = __tc27;
        result.perms = __tc28;
        __tc29 : Permissions = result.perms;
        __tc29.xn = xn;
        result.perms = __tc29;
        if HaveExtendedExecuteNeverExt() then {
            __tc30 : Permissions = result.perms;
            __tc30.xxn = [desc[53]];
            result.perms = __tc30
        };
        __tc31 : Permissions = result.perms;
        __tc31.pxn = 0b0;
        result.perms = __tc31;
        result.nG = 0b0;
        if s2fs1walk then {
            __tc32 : AddressDescriptor = result.addrdesc;
            __tc32.memattrs = S2AttrDecode(sh, memattr, AccType_PTW);
            result.addrdesc = __tc32
        } else {
            __tc33 : AddressDescriptor = result.addrdesc;
            __tc33.memattrs = S2AttrDecode(sh, memattr, acctype);
            result.addrdesc = __tc33
        };
        __tc34 : FullAddress = result.addrdesc.paddress;
        __tc34.NS = 0b1;
        __tc35 : AddressDescriptor = result.addrdesc;
        __tc35.paddress = __tc34;
        result.addrdesc = __tc35
    };
    __tc36 : FullAddress = result.addrdesc.paddress;
    __tc36.address = ZeroExtend(outputaddress);
    __tc37 : AddressDescriptor = result.addrdesc;
    __tc37.paddress = __tc36;
    result.addrdesc = __tc37;
    __tc38 : AddressDescriptor = result.addrdesc;
    __tc38.fault = AArch32_NoFault();
    result.addrdesc = __tc38;
    result.contiguous = contiguousbit == 0b1;
    if HaveCommonNotPrivateTransExt() then {
        result.CnP = [baseregister[0]]
    };
    if __tlb_enabled then {
        TLBCache(ZeroExtend(inputaddr, 64), secondstage, 0b1, acctype, result)
    };
    result
}

val IC_IVAU : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function IC_IVAU val_name = {
    if PSTATE.EL == EL0 & ELUsingAArch32(PSTATE.EL) then {
        UndefinedFault()
    };
    let iswrite : bool(false) = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, AccType_DC, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), AccType_DC, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_IVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_IVAC val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    iswrite : bool = undefined : bool;
    iswrite = true;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        iswrite = true;
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        iswrite = true;
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    if HasS2Translation() & [HCR_EL2[0]] == 0b1 then ();
    return()
}

val DC_IGDVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_IGDVAC val_name = {
    DC_IVAC(val_name);
    DC_IGVAC(val_name);
    return()
}

val DC_CVAU : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CVAU val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    let iswrite : bool(false) = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_CVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CVAC val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    let iswrite : bool(false) = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_CVAP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CVAP val_name = {
    DC_CVAC(val_name)
}

val DC_CGDVAP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGDVAP val_name = {
    DC_CVAP(val_name);
    DC_CGVAP(val_name);
    return()
}

val DC_CGDVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGDVAC val_name = {
    DC_CVAC(val_name);
    DC_CGVAC(val_name);
    return()
}

val DC_CIVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CIVAC val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    let iswrite : bool(false) = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 8);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_CIGDVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CIGDVAC val_name = {
    DC_CIVAC(val_name);
    DC_CIGVAC(val_name);
    return()
}

val AArch64_AutoGen_SysOpsWrite : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AutoGen_SysOpsWrite (el, op0, op1, CRn, op2, CRm, read, val_name) = {
    if op0 == 0b01 then {
        if CRn == 0x8 then {
            if op1 == 0b100 then {
                if op2 == 0b001 then {
                    if CRm == 0x0 then {
                        TLBI_IPAS2E1IS(ZeroExtend(val_name));
                        return()
                    } else {
                        if CRm == 0x1 then {
                            TLBI_VAE2OS(ZeroExtend(val_name));
                            return()
                        } else {
                            if CRm == 0x2 then {
                                TLBI_RVAE2IS(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x5 then {
                                    TLBI_RVAE2OS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x4 then {
                                        TLBI_IPAS2E1(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x6 then {
                                            TLBI_RVAE2(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBI_VAE2(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBI_VAE2IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b101 then {
                        if CRm == 0x0 then {
                            TLBI_IPAS2LE1IS(ZeroExtend(val_name));
                            return()
                        } else {
                            if CRm == 0x1 then {
                                TLBI_VALE2OS(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x2 then {
                                    TLBI_RVALE2IS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x5 then {
                                        TLBI_RVALE2OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x4 then {
                                            TLBI_IPAS2LE1(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x6 then {
                                                TLBI_RVALE2(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x7 then {
                                                    TLBI_VALE2(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0x3 then {
                                                        TLBI_VALE2IS(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x4 then {
                            if op2 == 0b010 then {
                                TLBI_RIPAS2E1(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b000 then {
                                    TLBI_IPAS2E1OS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b011 then {
                                        TLBI_RIPAS2E1OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b111 then {
                                            TLBI_RIPAS2LE1OS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b100 then {
                                                TLBI_IPAS2LE1OS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b110 then {
                                                    TLBI_RIPAS2LE1(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b110 then {
                                if CRm == 0x0 then {
                                    TLBI_RIPAS2LE1IS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x1 then {
                                        TLBI_VMALLS12E1OS();
                                        return()
                                    } else {
                                        if CRm == 0x7 then {
                                            TLBI_VMALLS12E1();
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                TLBI_VMALLS12E1IS();
                                                return()
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if CRm == 0x1 then {
                                        TLBI_ALLE2OS();
                                        return()
                                    } else {
                                        if CRm == 0x7 then {
                                            TLBI_ALLE2();
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                TLBI_ALLE2IS();
                                                return()
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b100 then {
                                        if CRm == 0x1 then {
                                            TLBI_ALLE1OS();
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBI_ALLE1();
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBI_ALLE1IS();
                                                    return()
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRm == 0x0 then {
                                                TLBI_RIPAS2E1IS(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b000 then {
                    if CRm == 0x1 then {
                        if op2 == 0b010 then {
                            TLBI_ASIDE1OS(ZeroExtend(val_name));
                            return()
                        } else {
                            if op2 == 0b101 then {
                                TLBI_VALE1OS(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b000 then {
                                    TLBI_VMALLE1OS();
                                    return()
                                } else {
                                    if op2 == 0b011 then {
                                        TLBI_VAAE1OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b111 then {
                                            TLBI_VAALE1OS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b001 then {
                                                TLBI_VAE1OS(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x3 then {
                            if op2 == 0b010 then {
                                TLBI_ASIDE1IS(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b000 then {
                                    TLBI_VMALLE1IS();
                                    return()
                                } else {
                                    if op2 == 0b101 then {
                                        TLBI_VALE1IS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b011 then {
                                            TLBI_VAAE1IS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b111 then {
                                                TLBI_VAALE1IS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    TLBI_VAE1IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x7 then {
                                if op2 == 0b010 then {
                                    TLBI_ASIDE1(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b000 then {
                                        TLBI_VMALLE1();
                                        return()
                                    } else {
                                        if op2 == 0b101 then {
                                            TLBI_VALE1(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b011 then {
                                                TLBI_VAAE1(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b111 then {
                                                    TLBI_VAALE1(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b001 then {
                                                        TLBI_VAE1(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if op2 == 0b101 then {
                                        TLBI_RVALE1IS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b011 then {
                                            TLBI_RVAAE1IS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b111 then {
                                                TLBI_RVAALE1IS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    TLBI_RVAE1IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x6 then {
                                        if op2 == 0b101 then {
                                            TLBI_RVALE1(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b011 then {
                                                TLBI_RVAAE1(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b111 then {
                                                    TLBI_RVAALE1(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b001 then {
                                                        TLBI_RVAE1(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if op2 == 0b101 then {
                                                TLBI_RVALE1OS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b011 then {
                                                    TLBI_RVAAE1OS(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b111 then {
                                                        TLBI_RVAALE1OS(ZeroExtend(val_name));
                                                        return()
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            TLBI_RVAE1OS(ZeroExtend(val_name));
                                                            return()
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b110 then {
                        if op2 == 0b001 then {
                            if CRm == 0x1 then {
                                TLBI_VAE3OS(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x2 then {
                                    TLBI_RVAE3IS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x5 then {
                                        TLBI_RVAE3OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x6 then {
                                            TLBI_RVAE3(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBI_VAE3(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBI_VAE3IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b101 then {
                                if CRm == 0x1 then {
                                    TLBI_VALE3OS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x2 then {
                                        TLBI_RVALE3IS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x5 then {
                                            TLBI_RVALE3OS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x6 then {
                                                TLBI_RVALE3(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x7 then {
                                                    TLBI_VALE3(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0x3 then {
                                                        TLBI_VALE3IS(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if CRm == 0x1 then {
                                        TLBI_ALLE3OS();
                                        return()
                                    } else {
                                        if CRm == 0x7 then {
                                            TLBI_ALLE3();
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                TLBI_ALLE3IS();
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRn == 0x7 then {
                if op1 == 0b000 then {
                    if CRm == 0x6 then {
                        if op2 == 0b010 then {
                            DC_ISW(ZeroExtend(val_name));
                            return()
                        } else {
                            if op2 == 0b101 then {
                                DC_IGDVAC(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b011 then {
                                    DC_IGVAC(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b100 then {
                                        DC_IGSW(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b001 then {
                                            DC_IVAC(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b110 then {
                                                DC_IGDSW(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b000 then {
                            if CRm == 0x8 then {
                                AT_S1E1R(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x5 then {
                                    IC_IALLU();
                                    return()
                                } else {
                                    if CRm == 0x1 then {
                                        IC_IALLUIS();
                                        return()
                                    } else {
                                        if CRm == 0x9 then {
                                            AT_S1E1RP(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRm == 0x8 then {
                                    AT_S1E0R(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0xA then {
                                        DC_CSW(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0xE then {
                                            DC_CISW(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xE then {
                                    if op2 == 0b100 then {
                                        DC_CIGSW(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b110 then {
                                            DC_CIGDSW(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                } else {
                                    if CRm == 0xA then {
                                        if op2 == 0b100 then {
                                            DC_CGSW(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b110 then {
                                                DC_CGDSW(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    } else {
                                        if CRm == 0x8 then {
                                            if op2 == 0b011 then {
                                                AT_S1E0W(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    AT_S1E1W(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if CRm == 0x9 then {
                                                    AT_S1E1WP(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if op2 == 0b001 then {
                            if CRm == 0xE then {
                                DC_CIVAC(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0xA then {
                                    DC_CVAC(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0xD then {
                                        DC_CVADP(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x5 then {
                                            IC_IVAU(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x4 then {
                                                DC_ZVA(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0xB then {
                                                    DC_CVAU(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0xC then {
                                                        DC_CVAP(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRm == 0xD then {
                                    DC_CGVADP();
                                    return()
                                } else {
                                    if CRm == 0xA then {
                                        DC_CGVAC(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x4 then {
                                            DC_GVA(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0xE then {
                                                DC_CIGVAC(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0xC then {
                                                    DC_CGVAP(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRm == 0xD then {
                                        DC_CGDVADP();
                                        return()
                                    } else {
                                        if CRm == 0xA then {
                                            DC_CGDVAC(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                DVP_RCTX(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0xE then {
                                                    DC_CIGDVAC(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0xC then {
                                                        DC_CGDVAP(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b100 then {
                                        if CRm == 0x4 then {
                                            DC_GZVA(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                CFP_RCTX(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRm == 0x3 then {
                                                CPP_RCTX(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x8 then {
                            if op1 == 0b100 then {
                                if op2 == 0b000 then {
                                    AT_S1E2R(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b101 then {
                                        AT_S12E1W(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b111 then {
                                            AT_S12E0W(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b100 then {
                                                AT_S12E1R(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    AT_S1E2W(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b110 then {
                                                        AT_S12E0R(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b110 then {
                                    if op2 == 0b000 then {
                                        AT_S1E3R(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b001 then {
                                            AT_S1E3W(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

val AArch64_SysInstr : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SysInstr (op0, op1, crn, crm, op2, val_name) = {
    AArch64_AutoGen_SysOpsWrite(PSTATE.EL, __GetSlice_int(2, op0, 0), __GetSlice_int(3, op1, 0), __GetSlice_int(4, crn, 0), __GetSlice_int(3, op2, 0), __GetSlice_int(4, crm, 0), 0b0, val_name)
}

val system_sysops : forall ('has_result : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  ('t >= 0 & 't <= 31 | not('has_result)) & ('t >= 0 & 't <= 31 | not(not('has_result))).
  (bool('has_result), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_sysops (has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if has_result then {
        X(t) = AArch64_SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2)
    } else {
        AArch64_SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X(t))
    }
}

val system_sysops_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_sysops_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    AArch64_CheckSystemAccess(0b01, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 : {'n, 'n == 1. int('n)} = 1;
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let has_result : bool = L == 0b1;
    __PostDecode();
    system_sysops(has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

val AArch32_aget_MemSingle : forall 'size ('wasaligned : Bool),
  'size in {1, 2, 4, 8, 16}.
  (bits(32), int('size), AccType, bool('wasaligned)) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch32_aget_MemSingle (address, size, acctype, wasaligned) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    assert(address == Align(address, size));
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    value_name : bits(8 * 'size) = undefined : bits('size * 8);
    let iswrite : bool(false) = false;
    let memaddrdesc = AArch32_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch32_Abort(address, memaddrdesc.fault)
    };
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    if HaveMTEExt() then {
        if AccessIsTagChecked(ZeroExtend(address, 64), acctype) then {
            let ptag : vector(4, dec, bit) = TransformTag(ZeroExtend(address, 64));
            if ~(CheckTag(memaddrdesc, ptag, iswrite)) then {
                TagCheckFail(ZeroExtend(address, 64), iswrite)
            }
        }
    };
    let value_name = _Mem(memaddrdesc, size, accdesc);
    value_name
}

overload MemSingle = {AArch32_aget_MemSingle}

val AArch32_CheckPCAlignment : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_CheckPCAlignment () = {
    let pc : bits(32) = ThisInstrAddr();
    acctype : AccType = undefined : AccType;
    iswrite : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    vaddress : bits(32) = undefined : bits(32);
    if CurrentInstrSet() == InstrSet_A32 & [pc[1]] == 0b1 | [pc[0]] == 0b1 then {
        if AArch32_GeneralExceptionsToAArch64() then {
            AArch64_PCAlignmentFault()
        };
        vaddress = pc;
        acctype = AccType_IFETCH;
        iswrite = false;
        secondstage = false;
        AArch32_Abort(vaddress, AArch32_AlignmentFault(acctype, iswrite, secondstage))
    }
}

val __fetchA32 : unit -> bits(32) effect {escape, rmem, rreg, undef, wmem, wreg}

function __fetchA32 () = {
    CheckSoftwareStep();
    AArch32_CheckPCAlignment();
    let a32 : vector(8 * 4, dec, bit) = MemSingle(slice(_PC, 0, 32), 4, AccType_IFETCH, true);
    AArch32_CheckIllegalState();
    a32
}
